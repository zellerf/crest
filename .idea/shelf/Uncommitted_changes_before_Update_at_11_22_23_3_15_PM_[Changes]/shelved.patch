Index: subprojects/packagefiles/tblite/tblite_patch.patch
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/subprojects/packagefiles/tblite/tblite_patch.patch b/subprojects/packagefiles/tblite/tblite_patch.patch
deleted file mode 100644
--- a/subprojects/packagefiles/tblite/tblite_patch.patch	(revision c187847ae6d075f7d7cc8a216cb890316e9d8e81)
+++ /dev/null	(revision c187847ae6d075f7d7cc8a216cb890316e9d8e81)
@@ -1,22 +0,0 @@
-diff --git a/meson.build b/meson.build
-index 9384afd..e4b73bb 100644
---- a/meson.build
-+++ b/meson.build
-@@ -57,7 +57,7 @@ tblite_dep = declare_dependency(
- )
- 
- # Add executable targets
--subdir('app')
-+#subdir('app')
- 
- # Package the license files
- tblite_lic = files(
-@@ -121,7 +121,7 @@ if install
- endif
- 
- # add the testsuite
--subdir('test')
-+#subdir('test')
- 
- if get_option('python')
-   subdir('python/tblite')
Index: src/calculator/turbom_sc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!> module turbom_sc\n!> A module containing routines for\n!> system calls to the code that uses Turbomole-like in & output conventions\n!> TODO: for actual turbomole calculations the input files must be copied (cefine)\n\n!=========================================================================================!\nmodule turbom_sc\n  use iso_fortran_env,only:wp => real64\n  use strucrd\n  use calc_type\n  use iomod,only:makedir,directory_exist,remove,command,checkprog_silent\n  use gradreader_module,only:rd_grad_tm\n  implicit none\n  !>--- private module variables and parameters\n  private\n  integer,parameter :: nf = 6\n  character(len=*),parameter :: oldfiles(nf) = [&\n          & 'energy','ceh.charges','output','.data', &\n          & 'NOT_CONVERGED','gp3restart' ]\n  character(len=*),parameter :: ridft = 'ridft' !> Turbomoles 'ridft'\n  character(len=*),parameter :: xyzn = 'coord'  !> input coords must be in coord\n  character(len=*),parameter :: ef = 'energy'   !> energy will be read from file energy\n  character(len=*),parameter :: gf = 'gradient' !> gradient will be read from file gradient\n\n  public :: turbom_engrad\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n  subroutine turbom_engrad(mol,calc,energy,grad,iostatus)\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    integer :: i,j,k,l,ich,och,io\n    logical :: ex\n\n    iostatus = 0\n\n    !>--- setup system call information\n    !$omp critical\n    call turbom_setup(mol,calc)\n    !$omp end critical\n\n    !>--- do the systemcall\n    call initsignal()\n    call command(calc%systemcall,iostatus)\n    if (iostatus /= 0) return\n\n    !>--- read energy and gradient\n    !$omp critical\n    call rd_turbom_engrad(mol,calc,energy,grad,iostatus)\n    !$omp end critical\n    if (iostatus /= 0) return\n\n    !>--- read WBOs?\n    !!$omp critical\n    !call rd_turbom_wbo(mol,calc,iostatus)\n    !!$omp end critical\n    !if (iostatus /= 0) return\n\n    return\n  end subroutine turbom_engrad\n\n!========================================================================================!\n  subroutine turbom_setup(mol,calc)\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    integer :: l\n    character(len=:),allocatable :: fname\n    character(len=:),allocatable :: cpath\n    character(len=10) :: num\n    integer :: i,j,k,ich,och,io\n    logical :: ex\n\n    call initsignal()\n\n    !>--- set default binary if not present\n    if (.not.allocated(calc%binary)) then\n      calc%binary = ridft\n    end if\n\n    !>--- check for the calculation space\n    if (allocated(calc%calcspace)) then\n      ex = directory_exist(calc%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(calc%calcspace))\n      end if\n      cpath = calc%calcspace\n    else\n      cpath = ''\n    end if\n    !>--- cleanup old files\n    do i = 1,nf\n      call remove(trim(cpath)//sep//trim(oldfiles(i)))\n    end do\n    deallocate (cpath)\n\n    !>--- construct path information and write coord file\n    if (.not.allocated(calc%calcfile)) then\n      if (allocated(calc%calcspace)) then\n        l = len_trim(calc%calcspace)\n        fname = trim(calc%calcspace)\n        if (calc%calcspace(l:l) == sep) then\n          fname = trim(fname)//xyzn\n        else\n          fname = trim(fname)//sep//xyzn\n        end if\n      else\n        fname = xyzn\n      end if\n      calc%calcfile = fname\n    else\n      fname = calc%calcfile\n    end if\n    call mol%write(fname) !> should write a \"coord\" file, must be called for each SP\n    deallocate (fname)\n\n    !>--- write charge and uhf files\n    if (calc%chrg /= 0) then\n      call touch_chrg_tm(calc,calc%chrg)\n    end if\n    if (calc%uhf /= 0) then\n      call touch_uhf_tm(calc,calc%uhf)\n    endif\n\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n    !>--- if the systemcall was already set up, return\n    if (allocated(calc%systemcall)) return\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n\n    !>--- construct path information for sys-call\n    if (allocated(calc%calcspace)) then\n      calc%systemcall = 'cd '//calc%calcspace//' &&'\n      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%binary)\n    else\n      calc%systemcall = trim(calc%binary)\n    end if\n\n    !>--- check if the binary exists\n    call checkprog_silent(trim(calc%binary),.true.,io)\n    if(io .ne. 0) error stop\n\n    !>--- add other call information\n    calc%systemcall = trim(calc%systemcall)//' '//xyzn\n    !>--- user-set flags\n    if (allocated(calc%other)) then\n      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%other)\n    end if\n\n    !>--- add printout information\n    calc%systemcall = trim(calc%systemcall)//' '//'> output'\n    calc%systemcall = trim(calc%systemcall)//dev0\n\n    return\n  end subroutine turbom_setup\n\n!========================================================================================!\n  subroutine rd_turbom_engrad(mol,calc,energy,grad,iostatus)\n!*****************************************************\n!* subroutine rd_turbom_engrad\n!* read the energy and Cartesian gradient from file\n!* Turbomole-style format is used for this\n!*****************************************************\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n    integer :: n,c\n    real(wp) :: dum\n    character(len=128) :: atmp\n\n    integer :: i,j,k,ich,och,io\n    logical :: ex\n\n    call initsignal()\n\n    iostatus = 0\n    energy = 0.0_wp\n    grad = 0.0_wp\n\n!>--- read the energy file in TM format\n    if (.not.allocated(calc%efile)) then\n      if (allocated(calc%calcspace)) then\n        calc%efile = trim(calc%calcspace)//sep//ef\n      else\n        calc%efile = ef\n      end if\n    end if\n\n    inquire (file=calc%efile,exist=ex)\n    if (.not.ex) then\n      iostatus = 1\n      return\n    end if\n    open (newunit=ich,file=calc%efile)\n    call rd_energy_tm(ich,energy,iostatus)\n    close (ich)\n\n!>--- sometimes we don't want to calculate and read gradients for expensive calculations\n!>--- where we are only interested in the total energy. Hence, reading it can be skipped\n    if (calc%rdgrad) then\n\n      if (.not.allocated(calc%gradfile)) then\n        if (allocated(calc%calcspace)) then\n          calc%gradfile = trim(calc%calcspace)//sep//gf\n        else\n          calc%gradfile = gf\n        end if\n      end if\n\n      inquire (file=calc%gradfile,exist=ex)\n      if (.not.ex) then\n        iostatus = 1\n        return\n      end if\n\n      open (newunit=ich,file=calc%gradfile)\n      call rd_grad_tm(ich,mol%nat,energy,grad,iostatus)\n      close (ich)\n    end if\n\n    return\n  end subroutine rd_turbom_engrad\n\n!========================================================================================!\n!  subroutine rd_turbom_wbo(mol,calc,iostatus)\n!    implicit none\n!    type(coord) :: mol\n!    type(calculation_settings) :: calc\n!    integer,intent(out) :: iostatus\n!\n!    real(wp) :: dum\n!    character(len=:),allocatable :: wbofile\n!    character(len=128) :: atmp\n!\n!    integer :: i,j,k,l,ich,och,io\n!    logical :: ex\n!    call initsignal()\n!\n!    iostatus = 0\n!\n!    if (calc%rdwbo) then\n!      if (allocated(calc%calcspace)) then\n!        wbofile = trim(calc%calcspace)//sep//'wbo'\n!      else\n!        wbofile = 'wbo'\n!      end if\n!    else\n!      return\n!    end if\n!\n!    inquire (file=wbofile,exist=ex)\n!    if (.not.ex) then\n!      iostatus = 1\n!      return\n!    end if\n!\n!    if (allocated(calc%wbo)) deallocate (calc%wbo)\n!    allocate (calc%wbo(mol%nat,mol%nat),source=0.0_wp)\n!\n!    open (newunit=ich,file=wbofile)\n!    do\n!      read (ich,'(a)',iostat=io) atmp\n!      if (io < 0) exit\n!      read (atmp,*) i,j,dum\n!      calc%wbo(i,j) = dum\n!      calc%wbo(j,i) = dum\n!    end do\n!    close (ich)\n!\n!  end subroutine rd_turbom_wbo\n\n!========================================================================================!\n  subroutine touch_chrg_tm(calc,chrg)\n    implicit none\n    type(calculation_settings) :: calc\n    integer,intent(in) :: chrg\n    character(len=:),allocatable :: fname\n    integer :: ich\n    if (allocated(calc%calcspace)) then\n      fname = trim(calc%calcspace)//sep//'.CHRG'\n    else\n      fname = '.CHRG'\n    end if\n    open (newunit=ich,file=fname)\n    write (ich,*) chrg\n    close (ich)\n    deallocate (fname)\n  end subroutine touch_chrg_tm\n\n  subroutine touch_uhf_tm(calc,uhf)\n    implicit none\n    type(calculation_settings) :: calc\n    integer,intent(in) :: uhf\n    character(len=:),allocatable :: fname\n    integer :: ich\n    if (allocated(calc%calcspace)) then\n      fname = trim(calc%calcspace)//sep//'.UHF'\n    else\n      fname = '.UHF'\n    end if\n    open (newunit=ich,file=fname)\n    write (ich,*) uhf\n    close (ich)\n    deallocate (fname)\n  end subroutine touch_uhf_tm\n\n  subroutine rd_energy_tm(ich,energy,iostat)\n!*******************************************\n!* read the 'energy' file\n!* The most current energy should be the \n!* second entry in the second-to-last line\n!*******************************************\n     implicit none\n     integer,intent(in) :: ich\n     real(wp),intent(out) :: energy\n     integer,intent(out) :: iostat\n     integer :: i,j,nlines,io\n     character(len=126) :: line,oldline\n     real(wp) :: dum(2)\n     energy = 0.0_wp\n     iostat = 1\n     nlines = 0\n     do\n       read (ich,'(a)',iostat=io) line\n       if(io < 0 ) exit !> EOF exit\n       if(index(line,'$end').ne.0)then\n         read(oldline,*) j,energy,dum(1:2)\n         iostat = 0\n       endif\n       oldline = line\n     enddo \n  end subroutine rd_energy_tm\n \n!========================================================================================!\n!========================================================================================!\nend module turbom_sc\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/turbom_sc.f90 b/src/calculator/turbom_sc.f90
--- a/src/calculator/turbom_sc.f90	(revision c187847ae6d075f7d7cc8a216cb890316e9d8e81)
+++ b/src/calculator/turbom_sc.f90	(date 1698936767496)
@@ -33,9 +33,9 @@
   !>--- private module variables and parameters
   private
   integer,parameter :: nf = 6
-  character(len=*),parameter :: oldfiles(nf) = [&
-          & 'energy','ceh.charges','output','.data', &
-          & 'NOT_CONVERGED','gp3restart' ]
+!  character(len=13),parameter :: oldfiles(nf) = [&
+!          & 'energy       ','ceh.charges  ','output       ','.data        ', &
+!          & 'NOT_CONVERGED ','gp3restart   ' ]
   character(len=*),parameter :: ridft = 'ridft' !> Turbomoles 'ridft'
   character(len=*),parameter :: xyzn = 'coord'  !> input coords must be in coord
   character(len=*),parameter :: ef = 'energy'   !> energy will be read from file energy
@@ -119,9 +119,9 @@
       cpath = ''
     end if
     !>--- cleanup old files
-    do i = 1,nf
-      call remove(trim(cpath)//sep//trim(oldfiles(i)))
-    end do
+  !  do i = 1,nf
+  !    call remove(trim(cpath)//sep//trim(oldfiles(i)))
+  !  end do
     deallocate (cpath)
 
     !>--- construct path information and write coord file
Index: src/calculator/api_engrad.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!> module api_engrad\n!> a collection of engrad calls for different APIs\n!> this builds the communication between CRESTs\n!> \"calculation_settings\" and the respective API setups\n\nmodule api_engrad\n\n  use iso_fortran_env,only:wp => real64,stdout => output_unit\n  use strucrd\n  use calc_type\n  use iomod,only:makedir,directory_exist,remove\n  !> API modules\n  use api_helpers\n  use tblite_api\n  use gfn0_api\n  use gfnff_api\n  use xhcff_api\n  implicit none\n  !--- private module variables and parameters\n  private\n\n  public :: tblite_engrad\n  public :: gfn0_engrad,gfn0occ_engrad\n  public :: gfnff_engrad\n  public :: xhcff_engrad\n\n!=========================================================================================!\n!=========================================================================================!\ncontains    !> MODULE PROCEDURES START HERE\n!=========================================================================================!\n!=========================================================================================!\n\n  subroutine tblite_engrad(mol,calc,energy,grad,iostatus)\n!******************************************************\n!* Interface singlepoint call between CREST and tblite\n!******************************************************\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    character(len=:),allocatable :: cpath\n    logical :: loadnew,pr\n\n    integer :: i,j,k,l,ich,och,io\n    logical :: ex\n    iostatus = 0\n    pr = .false.\n\n!>--- setup system call information\n    !$omp critical\n    call tblite_init(calc,loadnew)\n!>--- tblite printout handling\n    call api_handle_output(calc,'tblite.out',mol,pr)\n    if(pr)then\n       !> tblite uses its context (ctx)( type, rather than calc%prch\n       calc%tblite%ctx%unit = calc%prch\n       calc%tblite%ctx%verbosity = 1 \n    else\n       calc%tblite%ctx%verbosity = 0\n    endif\n\n!>-- populate parameters and wavefunction\n    if (loadnew) then\n      call tblite_setup(mol,calc%chrg,calc%uhf,calc%tblitelvl,calc%etemp, &\n      &    calc%tblite%ctx,calc%tblite%wfn,calc%tblite%calc)\n      call tblite_addsettings(calc%tblite%calc,calc%maxscc,calc%rdwbo,calc%saveint)\n      call tblite_add_solv(mol,calc%chrg,calc%uhf, &\n      &    calc%tblite%ctx,calc%tblite%wfn,calc%tblite%calc, &\n      &    calc%solvmodel,calc%solvent)\n    end if\n    !$omp end critical\n\n!>--- do the engrad call\n    call initsignal()\n    call tblite_singlepoint(mol,calc%chrg,calc%uhf,calc%accuracy, &\n    & calc%tblite%ctx,calc%tblite%wfn,calc%tblite%calc, &\n    & energy,grad,calc%tblite%res,iostatus)\n    if (iostatus /= 0) return\n    call api_print_e_grd(pr,calc%tblite%ctx%unit,mol,energy,grad)\n\n!>--- postprocessing, getting other data\n    !$omp critical\n    call tblite_wbos(calc,mol,iostatus)\n    !$omp end critical\n\n    return\n  end subroutine tblite_engrad\n\n!========================================================================================!\n\n  subroutine gfn0_engrad(mol,calc,g0calc,energy,grad,iostatus)\n!************************************************\n!* Interface singlepoint call between CREST and \n!* the GFN0 engrad standard implementation\n!************************************************\n    implicit none\n    !> INPUT\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    !> OUTPUT\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n    !> LOCAL\n    type(gfn0_results) :: res\n    character(len=:),allocatable :: cpath\n    logical :: loadnew\n    logical :: pr\n\n    integer :: i,j,k,l,ich,och,io\n    logical :: ex\n    iostatus = 0\n    pr = .false.\n!>--- setup system call information\n    !$omp critical\n    call gfn0_init(calc,g0calc,loadnew)\n!>--- printout handling\n    call api_handle_output(calc,'gfn0.out',mol,pr)\n!>-- populate parameters and wavefunction\n    if (loadnew) then\n      call gfn0_setup(mol,calc%chrg,calc%uhf,g0calc)\n      call gfn0_init2(mol,calc,g0calc)\n    end if\n    call gfn0_init3(mol,calc,g0calc)\n    !$omp end critical\n\n!>--- do the engrad call\n    call initsignal()\n    call gfn0_sp(mol,calc%chrg,calc%uhf,g0calc,energy,grad,iostatus,res)\n    if (iostatus /= 0) return\n    if (pr) then\n      call gfn0_print(calc%prch,g0calc,res)\n      call api_print_e_grd(pr,calc%prch,mol,energy,grad)\n    end if\n\n!>--- postprocessing, getting other data\n    !$omp critical\n    call gfn0_wbos(calc,calc%g0calc,mol,iostatus)\n    !$omp end critical\n\n    return\n  end subroutine gfn0_engrad\n\n!========================================================================================!\n\n  subroutine gfn0occ_engrad(mol,calc,g0calc,energy,grad,iostatus)\n!************************************************\n!* Interface singlepoint call between CREST and \n!* the GFN0 multi-occupation implementation \n!************************************************\n    implicit none\n    !> INPUT\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    !> OUTPUT\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(:,:)\n    integer,intent(out) :: iostatus\n    !> LOCAL\n    type(gfn0_results) :: res\n    character(len=:),allocatable :: cpath\n    logical :: loadnew,pr\n    integer :: i,j,k,l,ich,och,io\n    logical :: ex\n    iostatus = 0\n    pr = .false.\n!>--- setup system call information\n    !$omp critical\n    call gfn0occ_init(calc,g0calc,loadnew)\n!>--- printout handling\n    call api_handle_output(calc,'gfn0.out',mol,pr)\n!>--- populate parameters and wavefunction\n    if (loadnew) then\n      call gfn0_setup(mol,calc%chrg,calc%uhf,g0calc)\n      call gfn0occ_init2(mol,calc,g0calc)\n    end if\n    call gfn0occ_init3(mol,calc,g0calc)\n    !$omp end critical\n\n!>--- do the engrad call\n    call initsignal()\n    call gfn0_sp_occ(mol,calc%chrg,calc%uhf,calc%occ,g0calc, &\n    &    energy,grad,iostatus,res)\n    if (iostatus /= 0) return\n    if (pr) then\n      call gfn0_print(calc%prch,g0calc,res)\n      call api_print_e_grd(pr,calc%prch,mol,energy,grad)\n    end if\n\n!>--- postprocessing, getting other data\n    !$omp critical\n    call gfn0_wbos(calc,g0calc,mol,iostatus)\n    !$omp end critical\n\n    return\n  end subroutine gfn0occ_engrad\n\n!========================================================================================!\n\n  subroutine gfnff_engrad(mol,calc,energy,grad,iostatus)\n!******************************************************************\n!* Interface singlepoint call between CREST and GFN-FF force field\n!******************************************************************\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    character(len=:),allocatable :: cpath\n    logical :: loadnew,pr\n    integer :: i,j,k,l,ich,och,io\n    logical :: ex\n    iostatus = 0\n    pr = .false.\n!>--- setup system call information\n    !$omp critical\n    call gfnff_init(calc,loadnew)\n!>--- printout handling\n    call api_handle_output(calc,'gfnff.out',mol,pr) \n\n!>--- populate parameters and neighbourlists\n    if (loadnew) then\n      call gfnff_api_setup(mol,calc%chrg,calc%ff_dat,iostatus,pr,calc%prch)\n    end if\n    !$omp end critical\n    if (iostatus /= 0) return\n\n!>--- do the engrad call\n    call initsignal()\n    call gfnff_sp(mol,calc%ff_dat,energy,grad,iostatus)\n    if (iostatus /= 0) return\n\n!>--- printout\n    if (pr) then\n      call gfnff_printout(calc%prch,calc%ff_dat)\n      call api_print_e_grd(pr,calc%prch,mol,energy,grad)\n    end if\n\n!>--- postprocessing, getting other data\n    !$omp critical\n    call gfnff_wbos(calc,mol,iostatus)\n    !$omp end critical\n\n    return\n  end subroutine gfnff_engrad\n\n!========================================================================================!\n\n  subroutine xhcff_engrad(mol,calc,energy,grad,iostatus)\n!***************************************************************\n!* Interface singlepoint call between CREST and XHC force field\n!***************************************************************\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    character(len=:),allocatable :: cpath\n    logical :: loadnew,pr\n    integer :: i,j,k,l,ich,och,io\n    logical :: ex\n    iostatus = 0\n    pr = .false.\n!>--- setup system call information\n    !$omp critical\n    call xhcff_initcheck(calc,loadnew)\n!>--- printout handling\n    call api_handle_output(calc,'xhcff.out',mol,pr)\n!>--- populate parameters\n    if (loadnew) then\n      !> call xhcff with verbosity turned off\n      call xhcff_setup(mol,calc%xhcff,calc%extpressure,calc%ngrid,calc%proberad, &\n      &                calc%vdwset,pr,calc%prch,iostatus)\n    end if\n    !$omp end critical\n    if (iostatus /= 0) return\n\n!>--- do the engrad call\n    call initsignal()\n    call xhcff_sp(mol,calc%xhcff,energy,grad,iostatus)\n    if (iostatus /= 0) return\n\n!>--- printout\n    if (pr) then\n      !> the xhcff_sp call includes the printout within xhcff-lib\n      call api_print_e_grd(pr,calc%prch,mol,energy,grad)\n    end if\n\n!>--- postprocessing, getting other data\n\n    return\n  end subroutine xhcff_engrad\n\n!========================================================================================!\n!========================================================================================!\nend module api_engrad\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/api_engrad.f90 b/src/calculator/api_engrad.f90
--- a/src/calculator/api_engrad.f90	(revision c187847ae6d075f7d7cc8a216cb890316e9d8e81)
+++ b/src/calculator/api_engrad.f90	(date 1700231989335)
@@ -296,7 +296,10 @@
     !$omp critical
     call xhcff_initcheck(calc,loadnew)
 !>--- printout handling
-    call api_handle_output(calc,'xhcff.out',mol,pr)
+    inquire (unit=calc%prch,opened=ex)
+    if(.not. ex) then
+      call api_handle_output(calc,'xhcff.out',mol,pr)
+    end if
 !>--- populate parameters
     if (loadnew) then
       !> call xhcff with verbosity turned off
Index: src/algos/singlepoint.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> Implementation of a singlepoint calculation\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\nsubroutine crest_singlepoint(env,tim)\n!********************************************************************\n!* Standalone runtype for a singlepoint calculation\n!*\n!* Input/Output:\n!*  env  -  crest's systemdata object\n!*  tim  -  timer object\n!********************************************************************\n  use crest_parameters\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use gradreader_module, only: write_engrad\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(timer),intent(inout)      :: tim\n  type(coord) :: mol,molnew\n  integer :: i,j,k,l,io,ich\n  logical :: pr,wr\n  character(len=80) :: atmp\n!========================================================================================!\n  type(calcdata) :: calc\n  real(wp) :: accuracy,etemp\n\n  real(wp) :: energy\n  real(wp),allocatable :: grad(:,:)\n\n  character(len=*),parameter :: partial = '∂E/∂'\n!========================================================================================!\n  write (stdout,*)\n  !call system('figlet singlepoint')\n  write (stdout,*) \"     _             _                  _       _   \"\n  write (stdout,*) \" ___(_)_ __   __ _| | ___ _ __   ___ (_)_ __ | |_ \"\n  write (stdout,*) \"/ __| | '_ \\ / _` | |/ _ \\ '_ \\ / _ \\| | '_ \\| __|\"\n  write (stdout,*) \"\\__ \\ | | | | (_| | |  __/ |_) | (_) | | | | | |_ \"\n  write (stdout,*) \"|___/_|_| |_|\\__, |_|\\___| .__/ \\___/|_|_| |_|\\__|\"\n  write (stdout,*) \"             |___/       |_|                      \"\n  write (stdout,*)\n!========================================================================================!\n  call ompset_max(env%threads)\n  call ompprint_intern()\n  call tim%start(14,'Singlepoint calculation')\n!========================================================================================!\n  call env%ref%to(mol)\n  write (stdout,*)\n  write (stdout,*) 'Input structure:'\n  call mol%append(stdout)\n  write (stdout,*)\n!========================================================================================!\n\n  write (stdout,'(a)') repeat('-',80)\n  write (stdout,'(a)')\n\n  allocate (grad(3,mol%nat),source=0.0_wp)\n  calc = env%calc\n\n!>--- print some info about the calculation\n  call calc%info(stdout)\n\n!>--- and then start it\n  write (stdout,'(a)') repeat('-',80)\n  write (stdout,'(a)',advance='no') '> Performing singlepoint calculations ... '\n  flush (stdout)\n  call engrad(mol,calc,energy,grad,io)\n  call tim%stop(14)\n  write (stdout,*) 'done.'\n  write (atmp,'(a)') '> Total wall time for calculations'\n  call tim%write_timing(stdout,14,trim(atmp),.true.)\n  write (stdout,'(a)') repeat('-',80)\n  if (io /= 0) then\n    write (stdout,*)\n    write (stdout,*) 'WARNING: Calculation exited with error!'\n    return\n  end if\n\n!>--- print out the results\n  if (any(calc%calcs(:)%rdwbo)) then\n    write (stdout,*)\n    write (stdout,*) 'Connectivity information (bond order):'\n    do k = 1,calc%ncalculations\n      if (calc%calcs(k)%rdwbo) then\n        write (stdout,'(\"> \",a,i0)') 'Calculation level ',k\n        write (stdout,'(a12,a12,a10)') 'Atom A','Atom B','BO(A-B)'\n        do i = 1,mol%nat\n          do j = 1,i-1\n            if (calc%calcs(k)%wbo(i,j) > 0.0002_wp) then\n              write (stdout,*) i,j,calc%calcs(k)%wbo(i,j)\n            end if\n          end do\n        end do\n      end if\n    end do\n    write (stdout,*)\n    write (stdout,'(a)') repeat('-',80)\n  else\n    write (stdout,*)\n  end if\n\n  if(all(calc%calcs(:)%rdgrad == .false.))then\n    write (stdout,'(a)') '> No gradients calculated'\n  else \n  write (stdout,'(a)') '> Final molecular gradient ( Eh/a0 ):'\n  write (stdout,'(13x,a,13x,a,13x,a)') partial//'x',partial//'y',partial//'z'\n  do i = 1,mol%nat\n    write (stdout,'(3f18.8)') grad(1:3,i)\n  end do\n  write (stdout,'(a,f18.8,a)') '> Gradient norm:',norm2(grad),' Eh/a0'\n  endif\n\n  if (calc%ncalculations > 1) then\n    write (stdout,*)\n    write (stdout,'(a)') '> Individual energies and gradient norms:'\n    do k = 1,calc%ncalculations\n      write (stdout,'(1x,a,i3,2f18.8)') 'calculation ',k,calc%etmp(k),norm2(calc%grdtmp(:,:,k))\n    end do\n    if (calc%nconstraints > 0) then\n      write (stdout,'(1x,a)') '(+ constraints contribution)'\n    end if\n  end if\n\n  write (stdout,*)\n  write (stdout,'(a)') repeat('=',40)\n  write (stdout,'(1x,a,f20.10,a)') 'TOTAL ENERGY ',energy,' Eh'\n  write (stdout,'(1x,a,f20.10,a)') 'GRADIENT NORM',norm2(grad),' Eh/a0'\n  write (stdout,'(a)') repeat('=',40)\n\n  write(stdout,'(1x,a)') 'Writing crest.engrad ...' \n  call write_engrad('crest.engrad',energy,grad)\n\n  if(env%testnumgrad)then\n    call numgrad(mol,calc,grad)\n  endif \n\n  deallocate (grad)\n!========================================================================================!\n  return\nend subroutine crest_singlepoint\n\n!========================================================================================!\n!========================================================================================!\n\nsubroutine crest_xtbsp(env,xtblevel,molin)\n!********************************************************************\n!* Replacement for the legacy xtbsp routine, makes use of gfn0 or tblite.\n!* The purpose of this routine is usually to generate WBOs\n!*\n!* Input/Output:\n!*  env      - crest's systemdata object\n!*  xtblevel - quick selection of calc. level\n!*  molin    - molecule data\n!********************************************************************\n  use crest_parameters \n  use crest_data\n  use crest_calculator\n  use strucrd\n  use wiberg_mayer,only:write_wbo\n  implicit none\n  !> INPUT\n  type(systemdata) :: env\n  integer,intent(in),optional :: xtblevel\n  type(coord),intent(in),optional :: molin\n  !> LOCAL\n  integer :: lv,io\n  type(calcdata) :: tmpcalc\n  type(calculation_settings) :: cal\n  type(coord) :: mol\n  real(wp) :: energy\n  real(wp),allocatable :: grad(:,:)\n\n  !>--- transfer settings from env to tmpcalc\n  call env2calc(env,tmpcalc,molin)\n\n  tmpcalc%calcs(1)%rdwbo = .true. !> obtain WBOs\n  if (present(xtblevel)) then\n    select case (xtblevel) !> no default\n    case (0)\n      tmpcalc%calcs(1)%id = jobtype%gfn0\n    case (1)\n      tmpcalc%calcs(1)%id = jobtype%tblite\n      tmpcalc%calcs(1)%tblitelvl = 1\n    case (2)\n      tmpcalc%calcs(1)%id = jobtype%tblite\n      tmpcalc%calcs(1)%tblitelvl = 2\n    end select\n  end if\n  if (present(molin)) then\n    mol = molin\n  else\n    call mol%open('coord')\n  end if\n  allocate (grad(3,mol%nat),source=0.0_wp)\n\n  call engrad(mol,tmpcalc,energy,grad,io)\n  if (io .ne. 0) then\n    error stop 'crest_xtbsp failed'\n  end if\n\n  !>--- write wbo file\n  if (tmpcalc%calcs(1)%rdwbo) then\n    call write_wbo(tmpcalc%calcs(1)%wbo,0.002_wp)\n\n  end if\n\n  deallocate (grad)\n  call tmpcalc%reset()\n  call mol%deallocate()\nend subroutine crest_xtbsp\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/singlepoint.f90 b/src/algos/singlepoint.f90
--- a/src/algos/singlepoint.f90	(revision c187847ae6d075f7d7cc8a216cb890316e9d8e81)
+++ b/src/algos/singlepoint.f90	(date 1698937298404)
@@ -120,7 +120,7 @@
     write (stdout,*)
   end if
 
-  if(all(calc%calcs(:)%rdgrad == .false.))then
+  if(all(calc%calcs(:)%rdgrad .eqv. .false.))then
     write (stdout,'(a)') '> No gradients calculated'
   else 
   write (stdout,'(a)') '> Final molecular gradient ( Eh/a0 ):'
Index: src/algos/dynamics.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nsubroutine crest_moleculardynamics(env,tim)\n  use crest_parameters\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use dynamics_module\n  use shake_module\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(timer),intent(inout)      :: tim\n  type(coord) :: mol,molnew\n  integer :: i,j,k,l,io,ich\n  logical :: pr,wr\n!========================================================================================!\n  type(calcdata) :: calc\n  type(mddata) :: mddat\n  type(shakedata) :: shk\n\n  real(wp) :: energy,gnorm\n  real(wp),allocatable :: grad(:,:)\n\n  character(len=80) :: atmp\n  character(len=*),parameter :: trjf='crest_dynamics.trj'\n!========================================================================================!\n  write(stdout,*)\n  !call system('figlet dynamics')\n  write(stdout,*) \"      _                             _           \" \n  write(stdout,*) \"   __| |_   _ _ __   __ _ _ __ ___ (_) ___ ___  \"\n  write(stdout,*) \"  / _` | | | | '_ \\ / _` | '_ ` _ \\| |/ __/ __| \"\n  write(stdout,*) \" | (_| | |_| | | | | (_| | | | | | | | (__\\__ \\ \"\n  write(stdout,*) \"  \\__,_|\\__, |_| |_|\\__,_|_| |_| |_|_|\\___|___/ \"\n  write(stdout,*) \"        |___/                                   \"\n  write(stdout,*)\n!========================================================================================!\n  call tim%start(14,'Molecular dynamics (MD)')\n  call env%ref%to(mol)\n  write (stdout,*)\n  write (stdout,*) 'Input structure:'\n  call mol%append(stdout)\n  write (stdout,*)\n!========================================================================================!\n\n  !>--- parallelization settings\n  !call ompautoset(env%threads,7,env%omp,env%MAXRUN,1)\n  call ompprint_intern()\n\n  pr = .true.\n  !>--- default settings from env\n  call env_to_mddat(env)\n  mddat = env%mddat\n  calc = env%calc\n  !>--- check if we have any MD & calculation settings allocated\n  if (.not. mddat%requested) then\n    write (stdout,*) 'MD requested, but no MD settings present.'\n    return\n  else if (calc%ncalculations < 0) then\n    write (stdout,*) 'MD requested, but no calculation settings present.'\n    return\n  end if\n\n  !>--- print calculation info\n  call calc%info( stdout )\n\n  !>--- init SHAKE? --> we need connectivity info\n  if (mddat%shake) then\n    calc%calcs(1)%rdwbo = .true.\n    allocate (grad(3,mol%nat),source=0.0_wp)\n    call engrad(mol,calc,energy,grad,io)\n    deallocate (grad)\n    calc%calcs(1)%rdwbo = .false.\n    call move_alloc(calc%calcs(1)%wbo,mddat%shk%wbo)\n    !> moved to within the MD call\n    !call init_shake(mol%nat,mol%at,mol%xyz,mddat%shk,pr)\n    !mddat%nshake = mddat%shk%ncons\n  end if\n\n  !>--- complete real-time settings to steps\n  mddat%trajectoryfile = trjf\n\n  !>--- run the MD\n  call dynamics(mol,mddat,calc,pr,io)\n\n  if (io == 0) then\n    write (stdout,*) 'MD run completed successfully'\n    write (stdout,*) 'Trajectory written to ',trjf\n  else\n    write (stdout,*) 'MD run terminated with error'\n  end if\n!========================================================================================!\n  call tim%stop(14)\n  return\nend subroutine crest_moleculardynamics\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/dynamics.f90 b/src/algos/dynamics.f90
--- a/src/algos/dynamics.f90	(revision c187847ae6d075f7d7cc8a216cb890316e9d8e81)
+++ b/src/algos/dynamics.f90	(date 1699355839770)
@@ -51,6 +51,11 @@
   write(stdout,*) "        |___/                                   "
   write(stdout,*)
 !========================================================================================!
+
+  !> parallelization fix
+  call ompset_max(env%threads)
+  call ompprint_intern()
+
   call tim%start(14,'Molecular dynamics (MD)')
   call env%ref%to(mol)
   write (stdout,*)
Index: src/algos/crossing.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!========================================================================================!\n!> subroutine crest_crossing\n!> Read in an ensemble file and optimize all structures\n!> perform a crossing of z-matrices to generate new structures\n!> The procedure is loosely inspired by genetic algorithms\n!>------------------------------------------------------\nsubroutine crest_crossing(env,maxgen,fname,maxpairs)\n  use crest_parameters,only:wp,stdout,bohr,autokcal\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use optimize_module\n  implicit none\n  !> INPUT\n  type(systemdata),intent(inout) :: env\n  integer,intent(in)             :: maxgen\n  character(len=*),intent(in),optional   :: fname\n  real(wp),intent(in),optional :: maxpairs\n  !> LOCAL\n  integer :: i,j,k,l,io,ich,c\n  logical :: pr,wr,ex\n!========================================================================================!\n  real(wp) :: rthr,ewin,cthr\n\n  character(len=:),allocatable :: ensnam\n  integer :: nat,nall,nalltmp,maxgen2\n  real(wp),allocatable :: eread(:),erel(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  integer,allocatable  :: at(:)\n  real(wp) :: percent,maxtmp\n!========================================================================================!\n!>--- check for the ensemble file\n  if (present(fname)) then\n    ensnam = trim(fname)\n  else\n    ensnam = env%ensemblename\n  end if\n  inquire (file=ensnam,exist=ex)\n  if (.not.ex) then\n    write (stdout,*) 'no ensemble file found by crest_crossing()'\n    return\n  end if\n\n!>---- read the input ensemble\n  call rdensembleparam(ensnam,nat,nall)\n  if (nall .lt. 1) return\n  allocate (xyz(3,nat,nall),at(nat),eread(nall))\n  call rdensemble(ensnam,nat,nall,at,xyz,eread)\n  if (nall .lt. 2) then\n    write (stdout,*) 'Not enough structures to perform GC!'\n    return\n  end if\n\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n!>--- Important: crest_crossing requires coordinates in Bohrs\n  xyz = xyz/bohr\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n\n!>--- set OMP parallelization, use max number of threads\n  call ompautoset(env%threads,4,env%omp,env%MAXRUN,0) \n\n!========================================================================================!\n!>--- thresholds\n  ewin = env%ewin           !> energy window\n  rthr = env%rthr*2.0d0     !> standard RMSD threshold\n  cthr = 0.3d0              !> CN clash threshold\n  if(present(maxpairs))then !> dynamically adjust ewin in order to fit maxpairs\n    allocate(erel(nall))\n    call etoerel(nall,eread,erel,autokcal)\n    nalltmp = count( erel(:) < ewin)\n    maxtmp = (float(nalltmp)*(float(nalltmp)-1.0_wp))/2.0_wp\n    if( maxtmp > maxpairs)then\n      do while (maxtmp > maxpairs)\n        ewin = ewin - 0.01_wp\n        nalltmp = count( erel(:) < ewin)\n        maxtmp = (float(nalltmp)*(float(nalltmp)-1.0_wp))/2.0_wp\n      enddo\n    endif\n    deallocate(erel)\n  endif\n!========================================================================================!\n  !>--- printout header\n  write (stdout,*)\n  write (stdout,'(5x,''========================================'')')\n  write (stdout,'(5x,''|        Structure Crossing (GC)       |'')')\n  write (stdout,'(5x,''========================================'')')\n  write (stdout,*)\n  call ompprint_intern\n  write (stdout,'(a,a)')  'input  file name : ',trim(ensnam)\n  write (stdout,'(a,i8)') 'number of atoms                :',nat\n  write (stdout,'(a,i8)') 'number of points on xyz files  :',nall\n  if(present(maxpairs).and.(ewin.ne.env%ewin))then\n  write (stdout,'(a,es8.1)') 'max. # of parent structures    :',maxpairs\n  write (stdout,'(a,f8.2)') 'adjusted energy window  /kcal  :',ewin\n  else\n  write (stdout,'(a,f8.2)') 'conformer energy window  /kcal :',ewin\n  endif\n  write (stdout,'(a,f8.4)') 'CN per atom difference cut-off :',cthr\n  write (stdout,'(a,2f8.4)') 'RMSD threshold (Ang, Bohr)     :',rthr,rthr/bohr\n  write (stdout,'(a,1x,i8)') 'max. # of generated structures :',maxgen\n\n  maxgen2 = maxgen\n  call crossing(nat,nall,at,xyz,eread,ewin,rthr,cthr,maxgen2)\n\n\n  deallocate (eread,at,xyz)\n!========================================================================================!\n  return\nend subroutine crest_crossing\n\n!========================================================================================!\n!========================================================================================!\nsubroutine crossing(nat,nall,at,xyz,er,ewin,rthr,cthr,maxgen)\n  use crest_parameters\n  use ls_rmsd\n  use strucrd\n  use miscdata, only: rcov\n  implicit none\n  !> INPUT\n  integer,intent(in)  :: nat,nall           !> number of atoms, number of structures\n  integer,intent(in)  :: at(nat)            !> atomic numbers\n  real(wp),intent(inout) :: xyz(3,nat,nall) !> cartesian coordinates in Bohr(!!!) for ensemble\n  real(wp),intent(in) :: er(nall)           !> energies in Eh for each structure\n  integer,intent(inout) :: maxgen           !> max. number of generated structures\n  real(wp),intent(in) :: ewin               !> energy window\n  real(wp),intent(in) :: rthr               !> rmsd threshold in Ang\n  real(wp),intent(in) :: cthr               !> CN clash threshold\n  !> LOCAL\n  logical :: pr\n  real(sp),allocatable :: zmat(:,:,:),zref(:,:) !> zmat in single precision\n  integer,allocatable  :: na(:),nb(:),nc(:)\n  real(wp),allocatable :: cdum(:,:),zdum(:,:),xyzref(:,:)\n  real(wp),allocatable :: xyzgen(:,:,:),rms(:)\n  real(wp),allocatable :: erel(:)\n  real(wp),allocatable :: cnref(:)\n  real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:),ydum(:)  !> rmsd dummy stuff\n  integer,allocatable  :: ind(:)\n  real(wp) :: rthrbohr,rthrbohr100,rthrzmat,emin,rmsdavg,rval,rval2\n  real(wp) :: nmaxref,ncount,ncheck,ncheckstep\n  integer :: ierr,ntaken,ident,rcount,maxgen2\n  integer :: i,j,m,k,nwin,minpos\n  character(len=80) :: atmp\n  integer :: dumpio\n  logical :: fail,rmsdcheck,stop_crossing,huge_number\n  integer :: sdselect !> this is a function\n\n  pr = .true.\n  rmsdcheck = .true.\n\n  !>--- molecule storage\n  allocate (cdum(3,nat),zdum(3,nat),source=0.0_wp)\n  allocate (xyzref(3,nat),source=0.0_wp)\n  allocate (zmat(3,nat,nall),zref(3,nat),source=0.0_sp) !> zmat in single precision\n  allocate (na(nat),nb(nat),nc(nat),source=0)\n  allocate (gdum(3,3),Udum(3,3),xdum(3),ydum(3))\n\n  !>--- parameter setup\n  rthrbohr = rthr/bohr  !> Ang to Bohr\n  rthrbohr100 = rthrbohr/100.0_wp\n  allocate (erel(nall),cnref(nat),source=0.0_wp)\n  ! call setrcov(rcov)\n  call etoerel(nall,er,erel,autokcal)\n  nwin = count((erel(:) < ewin),1)\n  minpos = minloc(erel,1)\n  if (pr) write (stdout,*) '# in E window',nwin\n  nmaxref = (float(nwin)*(float(nwin)-1.0_wp))/2.0_wp\n\n  !>--- lowest conformer to provide reference values\n  xyzref(1:3,1:nat) = xyz(1:3,1:nat,minpos)  !> reference Cartesians\n  call ycoord(nat,rcov,at,xyzref,cnref,100.0d0) !> refernce CNs\n  call XYZINT(xyzref,nat,na,nb,nc,1.0d0,zdum)   !> z-mat connectivity\n  zref(:,:) = real(zdum,sp)                    !> reference z-mat\n\n  !>--- convert to internal coordinates\n  !$OMP PARALLEL PRIVATE(i,zdum) &\n  !$OMP SHARED(nall,nat,na,nb,nc,xyz,zmat)\n  !$OMP DO\n  do i = 1,nall\n    call XYZGEO(xyz(:,:,i),nat,na,nb,nc,1.0d0,zdum)\n    zmat(:,:,i) = real(zdum(:,:),sp) !> zmat in single precision\n  end do\n  !$OMP END DO\n  !$OMP END PARALLEL\n\n  !>--- generation loop setup\n  ierr = 0          !> discarded\n  rmsdavg = 0.0_wp     !> avg. rmsd of generated structures\n  rcount = 0          !> counting for avg\n  ident = 0          !> counting of discarded identical\n  ntaken = 0          !> counting of selected structures\n  maxgen2 = maxgen*2   !> check double the amount of structures needed\n  ncount = 0.0_wp      !> continous counter\n  ncheck = 0.1_wp     !> checkpoint for printout\n  ncheckstep = 0.25_wp !> steps for checkpoint printout\n  stop_crossing = .false. !> parameter for early termination\n  huge_number = .false.\n  if(nmaxref > 10*maxgen2)then\n    huge_number = .true.\n    maxgen2 = maxgen*5\n  endif\n  allocate (xyzgen(3,nat,maxgen2),rms(maxgen2),source=0.0_wp)\n  \n\n!$OMP PARALLEL PRIVATE(i,j,k,m, zdum,cdum, rval,rval2, fail) &\n!$OMP PRIVATE(Udum,xdum,ydum,gdum) &\n!$OMP SHARED(erel,ewin,nat,at,zref,zmat,na,nb,nc,rcov,cnref ) &\n!$OMP SHARED(cthr,rthrbohr,rthrbohr100,rms,xyzgen,maxgen,maxgen2) &\n!$OMP SHARED(ncount,nmaxref,ncheck,ncheckstep) &\n!$OMP SHARED(ierr,rcount,ident,rmsdavg,ntaken,rmsdcheck,stop_crossing,huge_number )\n!$OMP DO\n  do i = 1,nall\n    if (erel(i) > ewin) cycle\n    do j = 1,i-1\n      if(stop_crossing) cycle !> since we must not jump out of an OMP loop, use this workaround\n      if (erel(j) > ewin) cycle\n      ncount = ncount+1.0_wp\n      !>-- new structure generation\n      do m = 1,nat\n        !>-- new internal coords\n        do k = 1,3\n          zdum(k,m) = real(zref(k,m)+zmat(k,m,j)-zmat(k,m,i),wp)\n        end do\n        !>-- prevent linear bends\n        if (pi-zdum(2,m) .lt. 0.001_wp) zdum(2,m) = pi-0.005_wp\n        if (zdum(2,m) .lt. 0.001_wp) zdum(2,m) = 0.005_wp\n      end do\n      call GMETRY(nat,zdum,cdum,na,nb,nc,fail)\n      !>--- checks\n      if (fail) then\n        !$omp atomic\n        ierr = ierr+1\n        cycle\n      end if\n      call ycoord2(nat,rcov,at,cdum,cnref,100.d0,cthr,fail) !> CN clashes\n      if (fail) then\n        !$omp atomic\n        ierr = ierr+1\n        cycle\n      end if\n      call rmsd(nat,cdum,xyzref,0,Udum,xdum,ydum,rval,.false.,gdum)\n      !call poor_mans_rmsd(nat,xyzref,cdum,rval)\n      if (rval <= rthrbohr) then\n        !$omp atomic\n        ierr = ierr+1\n        cycle\n      else\n        !$omp atomic\n        rcount = rcount+1\n        !$omp atomic\n        rmsdavg = rmsdavg+rval\n      end if\n      !$omp critical\n      if (ntaken < 1) then\n        ntaken = ntaken+1\n        xyzgen(:,:,ntaken) = cdum\n        rms(ntaken) = rval\n      else\n        !> check if we have the generated structure already\n        fail = .false.\n        do m = 1,ntaken\n          !> check only those with a similar rmsd to the reference\n          if (abs(rms(m)-rval) < rthrbohr100 ) then\n            if (rmsdcheck) then !> variant 1: Cartesian RMSDs\n              call rmsd(nat,cdum,xyzgen(:,:,m),0,Udum,xdum,ydum,rval2,.false.,gdum)\n              if (rval2 < rthrbohr) then\n                ident = ident+1\n                fail = .true.\n                exit\n              end if\n            else !> variant 2: crude approximation, discard it\n              ident = ident+1\n              fail = .true.\n              exit\n            end if\n          end if\n        end do\n        if (fail) then\n          continue\n        else\n          if (ntaken < maxgen2) then\n            ntaken = ntaken+1\n            xyzgen(:,:,ntaken) = cdum\n            rms(ntaken) = rval\n          elseif(huge_number) then\n            stop_crossing = .true.\n          else\n            k = sdselect(ntaken,rms,rval)\n            if (k > 0) then\n              xyzgen(:,:,k) = cdum\n              rms(k) = rval\n            end if\n          end if\n        end if\n      end if\n      !$omp end critical\n    end do\n    !>-- checkpoint printout\n    !$omp critical\n    if(huge_number)then\n    if (pr .and.((float(ntaken)/float(maxgen2)) >= ncheck).and. .not.stop_crossing) then\n      ncheck = ncheck+ncheckstep\n      if (ncheck > 1.0_wp) ncheck = 1.0_wp\n      write (stdout,'(f6.1,\" % done\")') (float(ntaken)/float(maxgen2))*100.0_wp\n    end if\n    else\n    if (pr .and.((ncount/nmaxref) >= ncheck)) then\n      ncheck = ncheck+ncheckstep\n      if (ncheck > 1.0_wp) ncheck = 1.0_wp\n      write (stdout,'(f6.1,\" % done\")') (ncount/nmaxref)*100.0_wp\n    end if\n    endif\n    !$omp end critical\n  end do\n!$OMP END DO\n!$OMP END PARALLEL\n  if(pr.and.(ntaken > 0)) write (stdout,'(\" finished.\")')\n  rmsdavg = rmsdavg/float(rcount)\n\n  if (pr) then\n    if (ntaken > 0) then\n      write (stdout,'(1x,a,f12.5)') 'average rmsd w.r.t input     :',rmsdavg\n      write (stdout,'(1x,a,i12)') 'number of clash discarded    :',ierr\n      write (stdout,'(1x,a,i12)') 'removed identical structures :',ident\n    else\n      write (stdout,'(1x,a)') 'no new structures generated'\n    end if\n  end if\n\n  if (ntaken > 0) then\n    !>--- determin order for dumping\n    rmsdavg = sum(rms(1:ntaken))/float(ntaken)\n    allocate (ind(ntaken),source=0)\n    do i = 1,ntaken\n      ind(i) = i\n      rms(i) = -(rms(i)-rmsdavg)**2\n    end do\n    call qsort(rms(1:ntaken),1,ntaken,ind)\n    maxgen = min(maxgen,ntaken)\n    !>--- dump the new structures to file\n    !xyzgen = xyzgen*bohr !> to Angström\n    open (newunit=dumpio,file='confcross.xyz')\n    do i = 1,maxgen\n      k = ind(i)\n      xyzgen(:,:,k) = xyzgen(:,:,k)*bohr !> to Angström\n      write (atmp,'(1x,f12.6,1x,a)') rms(i),'!GC'\n      call wrxyz(dumpio,nat,at,xyzgen(:,:,k),trim(atmp))\n    end do\n    close (dumpio)\n    if (pr) then\n      write (stdout,'(/,1x,i0,1x,a,/)') maxgen,'structures written to confcross.xyz'\n    end if\n  end if\n\n  !>--- cleanup\n  if (allocated(ind)) deallocate (ind)\n  if (allocated(ydum)) deallocate (ydum)\n  if (allocated(xdum)) deallocate (xdum)\n  if (allocated(Udum)) deallocate (Udum)\n  if (allocated(gdum)) deallocate (gdum)\n  if (allocated(zmat)) deallocate (zmat)\n  if (allocated(zdum)) deallocate (zdum)\n  if (allocated(zref)) deallocate (zref)\n  if (allocated(xyzref)) deallocate (xyzref)\n  if (allocated(na)) deallocate (na)\n  if (allocated(nb)) deallocate (nb)\n  if (allocated(nc)) deallocate (nc)\n  if (allocated(cnref)) deallocate (cnref)\n  if (allocated(erel)) deallocate (erel)\n  !if (allocated(rcov)) deallocate (rcov)\n  if (allocated(cdum)) deallocate (cdum)\n  if (allocated(xyzgen)) deallocate (xyzgen)\n\nend subroutine crossing\n\n!========================================================================================!\n  function sdselect(n,rms,rval) result(pos)\n    use crest_parameters\n!> calculates SD of rms()\n!> and checks which entry to replace by rval in order to\n!> maximise the SD. returns this entry's number (or zero)\n    implicit none\n    integer :: pos\n    integer,intent(in)  :: n\n    real(wp),intent(in) :: rms(n)\n    real(wp),intent(in) :: rval\n    real(wp) :: avg,sdref,sdtmp\n    integer :: i,j\n\n    pos = 0\n    avg = sum(rms)\n    avg = avg/float(n)\n    sdref = sum((rms(:)-avg)**2)\n    sdref = sqrt(sdref/float(n))\n\n    do i = 1,n\n      avg = sum(rms)-rms(i)+rval\n      avg = avg/float(n)\n      sdtmp = sum((rms(:)-avg)**2)\n      sdtmp = sdtmp-(rms(i)-avg)**2\n      sdtmp = sdtmp+(rval-avg)**2\n      sdtmp = sqrt(sdtmp/float(n))\n      if (sdtmp > sdref) then\n        sdref = sdtmp\n        pos = i\n      end if\n    end do\n  end function sdselect\n!========================================================================================!\n\nsubroutine poor_mans_rmsd(nat,xyz_A,xyz_B,rmsd)\n  use crest_parameters\n  implicit none\n  integer,intent(in) :: nat\n  real(wp),intent(in) :: xyz_A(3,nat)\n  real(wp),intent(in) :: xyz_B(3,nat)\n  real(wp),intent(out) :: rmsd\n  integer :: i,j,k,l\n  real(wp) :: dum\n  rmsd = 0.0_wp\n  do i=1,nat\n     dum = sum((xyz_A(1:3,i)-xyz_B(1:3,i))**2.0_wp)\n     dum = dum/float(nat)  \n     rmsd = rmsd + dum\n  enddo\n  rmsd = sqrt(rmsd) \n\nend subroutine poor_mans_rmsd\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/crossing.f90 b/src/algos/crossing.f90
--- a/src/algos/crossing.f90	(revision c187847ae6d075f7d7cc8a216cb890316e9d8e81)
+++ b/src/algos/crossing.f90	(date 1698937429400)
@@ -222,7 +222,7 @@
 
 !$OMP PARALLEL PRIVATE(i,j,k,m, zdum,cdum, rval,rval2, fail) &
 !$OMP PRIVATE(Udum,xdum,ydum,gdum) &
-!$OMP SHARED(erel,ewin,nat,at,zref,zmat,na,nb,nc,rcov,cnref ) &
+!$OMP SHARED(erel,ewin,nat,at,zref,zmat,na,nb,nc,cnref ) &
 !$OMP SHARED(cthr,rthrbohr,rthrbohr100,rms,xyzgen,maxgen,maxgen2) &
 !$OMP SHARED(ncount,nmaxref,ncheck,ncheckstep) &
 !$OMP SHARED(ierr,rcount,ident,rmsdavg,ntaken,rmsdcheck,stop_crossing,huge_number )
