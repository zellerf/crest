Index: src/ccegen.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2020 Philipp Pracht, Stefan Grimme\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=========================================================================================!\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!\n!=========================================================================================!\n!===============================================================================!\n!\n!  This is the CCEGEN routine, used for clustering a conformational ensemble\n!  and determine representative structures for the molecule.\n!\n!  A principal component analysis (PCA) is performed, and the generated data\n!  is clustered.\n!\n!\n!  On Input:   pr - printout boolean\n!              fname - name of the ensemble file\n!\n!==============================================================================!\nsubroutine CCEGEN(env,pr,fname)\n      use crest_parameters, idp => dp \n      use crest_data\n      use zdata\n      use strucrd\n      implicit none\n      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n      type(timer) :: ctimer\n      logical,intent(in)   :: pr\n      character(len=*),intent(in) :: fname\n      type(zmolecule) :: zmol\n      type(zequal) :: groups\n      type(zequal) :: subgroups\n      integer,allocatable :: inc(:)\n      logical :: heavyonly\n      integer :: i,j,k,l,ich,c\n      real(wp) :: dum,dum2\n      type(ensemble) :: zens\n\n      character(len=:),allocatable :: measuretype\n\n      !>--- SVD params\n      integer :: ntaken\n      integer :: nallnew\n      real(wp),allocatable :: xyznew(:,:,:)\n      !integer,allocatable  :: atnew(:)\n      real(wp),allocatable :: measure(:,:) !this is what is passed to the SVD\n      integer :: mn,mm                     !--> measure(mn,mm)\n      real(wp),allocatable :: pc(:)        !the principal components\n      real(wp),allocatable :: pcvec(:,:)   !the principal component eigenvectors\n      real(wp),allocatable :: pcdum(:,:)  \n      integer :: nbnd,ndied\n      integer,allocatable :: diedat(:,:)   !atoms spanning relevant dihedral angles\n      real(wp),allocatable :: diedr(:)\n      real(wp) :: pcsum\n      real(wp) :: pcthr\n      real(wp) :: pcmin\n      integer :: pccap\n      integer :: npc\n      real(wp),allocatable :: geo(:,:)\n      integer,allocatable :: na(:),nb(:),nc(:)\n\n      !>--- CLUSTERING params\n      character(len=:),allocatable :: clusteralgo\n      integer :: nclust                    !number of clusters\n      integer :: nclustiter                !iterator for nclust\n      integer :: nclustmin,nclustmax                   \n      integer,allocatable :: member(:)     !track cluster correspondence\n      real(ap),allocatable :: p(:),q(:)\n      real(sp),allocatable :: dist(:)\n      real(ap),allocatable :: centroid(:,:)\n      integer(idp) :: ndist,klong\n      integer(idp) :: lina !this is a function\n      real(ap) :: eucdist !this is a function\n      real(wp) :: DBI,pSF,SSRSST,SSRSSTthr\n      real(wp) :: csthr\n      integer :: ncb,ancb\n      real(wp),allocatable :: eclust(:)\n      integer,allocatable :: clustbest(:),ind(:)\n      real(wp),allocatable :: statistics(:,:)\n      logical,allocatable :: extrema(:,:)\n      logical :: autolimit\n      real(wp) :: fraclimit\n\n      !>--- printout and params\n      real(wp) :: emin,erel\n      real(wp),parameter :: kcal = 627.5095d0\n      !real(wp),parameter :: pi =  3.14159265358979D0\n      real(wp),parameter :: rad = 180.0d0/pi\n\n\n       call ctimer%init(20)\n       if(pr)then\n       call largehead('Principal Component Analysis (PCA) and Clustering')\n       write(*,'(1x,a,a)') 'Input file: ',trim(fname)\n       endif\n\n!=========================================================!\n! set threads\n!=========================================================!\n       call cregen_setthreads(stdout,env,pr)\n\n!=========================================================!\n! Prepare a coordinate ensemble for the clustering\n!=========================================================!      \n   !>--- 0. Set defaults, read ensemble\n       call zens%open(fname) !read in the ensemble\n       if(zens%nall<1)then\n          error stop \"Ensemble is empty! must stop\"\n       else if(zens%nall==1)then\n           if(pr)then\n             write(*,*) 'Only one structure in ensemble!'\n             write(*,*) 'Write structure to ',clusterfile,' and skip PCA parts'\n           endif    \n           open(newunit=ich,file=clusterfile)\n           dum = zens%er(1)\n           call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,1),dum)\n           close(ich)\n           call zens%deallocate()\n           return\n       endif     \n\n       heavyonly = .true.\n       !measuretype = 'dihedral'\n       measuretype = env%pcmeasure\n       clusteralgo='kmeans'\n       !pcthr = 0.85d0  !PCs must add up to this amount of \"representability\"\n       pcthr = env%pcthr\n       pcmin = env%pcmin\n       !csthr = 0.80d0  !threshold for SSR/SST to select a suitable cluster count\n       csthr = env%csthr\n       !pccap = 100   !a cap for the number of principal components used in the clustering\n       pccap = env%pccap\n       autolimit = .true. !if the ensemble is very large, take only a fraction to speed up things\n                          !(only for predefined clustersizes with \"-cluster N\" )\n       fraclimit = 0.25d0 !if autolimit=true, 1/4 of the ensemble is taken\n\n   !>--- 1. topology for reference strucuture\n      if(env%wbotopo)then\n         env%wbofile='wbo'\n      else   \n         env%wbofile='none given' \n      endif\n      zens%xyz = zens%xyz/bohr  !ANG to Bohr for topo\n      call simpletopo(zens%nat,zens%at,zens%xyz,zmol,pr,.false.,env%wbofile)\n      zens%xyz = zens%xyz*bohr  !Bohr to ANG\n      allocate(inc(zmol%nat), source = 0)\n\n!===========================================================!\n if(measuretype.ne.'dihedral')then\n!===========================================================!\n   !>--- 2. read nuclear equivalencies\n      if(pr)then\n        write(*,*)\n        call smallhead('READING NUCLEAR EQUIVALENCIES')\n      endif\n      call readequals('anmr_nucinfo',zmol,groups)  \n      if(pr)then\n        call groups%prsum(6) !--- print summary to screen\n        write(*,'(1x,a)') 'Unlisted nuclei (groups) are unique.'\n      endif\n\n   !>--- 3. distribute groups into subgroups basedon topology\n      if(pr)then\n        write(*,*)\n        call smallhead('ANALYZING EQUIVALENCIES')\n      endif\n      call distsubgr(zmol,groups,subgroups,inc,pr)\n\n\n   !>--- 4. Equivalent atoms must be excluded in clustering to reduce noise\n      if(pr)then\n        write(*,*)\n        call smallhead('DETERMINE ATOMS TO INCLUDE IN PCA')\n      endif\n      call excludeFromRMSD(zmol,inc)\n      if(sum(inc)==0)then\n          if(pr)then\n          write(*,*) 'WARNING: No atoms included in PCA'\n          write(*,*) 'Including more atoms ...'\n          endif\n          inc=1\n          !-- for this exclude the equivalent atoms from anmr_nucinfo directly\n          do i=1,groups%ng\n             if(groups%grp(i)%nm > 1)then\n             write(*,*) groups%grp(i)%mem\n             do j=1,groups%grp(i)%nm \n                k=groups%grp(i)%mem(j)\n                inc(k) = 0\n             enddo\n             endif\n          enddo\n      endif\n      !>-- exclude user set atoms\n      if(env%pcaexclude)then\n         call excludeSelected(zmol,inc,env%atlist)\n      endif\n      !>-- exclude H atoms\n      if(heavyonly)then\n         call excludeLight(zmol,inc)\n      endif\n      if(pr)then\n          do i=1,zmol%nat\n            if(inc(i) == 1 )then\n              write(*,'(1x,a,a,i0,a,5x,a)') zmol%zat(i)%el,'(',i,')','taken'\n            endif\n          enddo\n      endif\n      ntaken = sum(inc)\n      !>--- if we have too few, include the heav atoms at least\n      if(ntaken <= 3)then\n          do i=1,zmol%nat\n            if(zmol%at(i) /= 1 )then\n                inc(i) = 1\n                if(pr) write(*,'(1x,a,a,i0,a,5x,a)') zmol%zat(i)%el,'(',i,')','taken'\n            endif\n          enddo\n      endif\n      ntaken = sum(inc)\n\n      call zmol%deallocate\n\n      !>-- for very large ensemble files limit the clustering\n      if(autolimit)then\n          if((env%nclust /= 0).and.(env%nclust*100 < zens%nall))then\n              dum = float(zens%nall) * fraclimit\n              dum2 = float(env%nclust)\n              nallnew = nint(max(dum,dum2))\n          else\n              nallnew = zens%nall\n          endif\n      else\n          nallnew = zens%nall\n      endif\n\n   !>--- 5. Transfer the relevant atoms to a new array   \n      allocate(xyznew(3,ntaken,nallnew))!,atnew(ntaken))\n      do i=1,nallnew\n         k = 0\n         do j=1,zens%nat\n            if(inc(j) == 1)then\n                k=k+1\n                xyznew(:,k,i) = zens%xyz(:,j,i)\n                !atnew(k) = zens%at(j)\n            endif    \n         enddo\n      enddo\n\n!===================================================!\n else !measuretype=='dihedral'\n!===================================================!\n\n      !-- for very large ensemble files limit the clustering\n      if(autolimit)then\n          if((env%nclust /= 0).and.(env%nclust*100 < zens%nall))then\n              dum = float(zens%nall) * fraclimit\n              dum2 = float(env%nclust)\n              nallnew = nint(max(dum,dum2))\n          else\n              nallnew = zens%nall\n          endif\n      else\n          nallnew = zens%nall\n      endif\n\n      inc = 1\n      ntaken = sum(inc)\n\n      call zmol%countbonds()\n      nbnd = zmol%nb\n      allocate(diedat(4,zmol%nb) , source=0)\n      call getdiederatoms(zmol,zmol%nat,inc,nbnd,diedat,ndied)\n      ntaken = ndied\n!==================================================!      \n endif\n!==================================================! \n\n!===================================================================================================!\n! do the SVD to get the principal components\n!===================================================================================================!\n      if(ntaken > 3)then !> all of this only makes sense if we have something to compare\n          call ctimer%start(1,'PCA')\n          if(pr)then\n              write(*,*)\n              call smallhead('PRINCIPAL COMPONENT ANALYSIS')\n          endif    \n          !mm = zens%nall  \n          mm = nallnew\n          select case( measuretype )\n           !==========================================================================!\n           case( 'cma','CMA','cmadist' )\n               if(pr)then\n                   write(*,'(1x,a)')'Using CMA DISTANCES as descriptors:'\n               endif\n           !>-- all structures should have been shifted to the CMA by CREGEN\n           !>   therefore assume the CMA is at (0,0,0).\n           !>   somewhat robust measure, but provides less information.\n             mn = min(ntaken,mm)\n             allocate(measure(mn,mm),pc(mn),pcvec(mm,mn))\n             do i=1,mm\n               do j=1,mn\n                  measure(j,i) = xyznew(1,j,i)**2 + &\n               &                 xyznew(2,j,i)**2 + &\n               &                 xyznew(3,j,i)**2       \n                  measure(j,i) = sqrt(measure(j,i))\n               enddo\n             enddo\n           !==========================================================================!   \n           case( 'cartesian','coords' )  \n               if(pr)then\n                   write(*,'(1x,a)')'Using CARTESIAN COORDINATES as descriptors:'\n               endif\n           !>-- all Cartesian components of the selected atoms\n           !>   REQUIRES PERFECT ALIGNMENT(!), hence not very robust\n             mn = min(ntaken*3,mm)\n             allocate(measure(mn,mm),pc(mn),pcvec(mm,mn))\n             do i=1,mm\n                l=0\n                do j=1,ntaken\n                  do k=1,3     \n                     l=l+1\n                     measure(j,l) = xyznew(k,j,i)\n                  enddo\n                enddo\n              enddo\n          !==========================================================================!    \n          case default !case( 'zmat','zmatrix' )\n              if(pr)then\n               write(*,'(1x,a)')'Using ZMATRIX as descriptors:'\n             endif\n           !>-- dihedral angles  \n             mn = ntaken - 3 !>--- first three dihedral angles are zero\n             mn = min(mm,mn) !>--- no more descriptors than structures for SVD!\n             if(mn < 1)then !> we need at least 2 dihedral angles, and therefore 5 descriptors\n                if(pr)then\n                    write(*,*) \"Not enough descriptors for PCA!\"\n                    return\n                endif\n             endif\n             allocate(measure(mn,mm),pc(mn),pcvec(mm,mn))\n             allocate(geo(3,ntaken), source = 0.0d0)\n             allocate(na(ntaken),nb(ntaken),nc(ntaken))\n             do i=1,mm\n               na = 0; nb = 0; nc = 0\n               geo=0.0d0\n               call xyzint(xyznew(1:3,1:ntaken,i),ntaken,na,nb,nc,rad,geo)\n               do j=1,mn\n                  k=j+3\n                  measure(j,i) = geo(3,k)\n               enddo\n             enddo\n             deallocate(nc,nb,na,geo)\n          !=========================================================================!   \n          case( 'dihedral' )   \n              mn = min(mm,ntaken) !>--- no more descriptors than structures for SVD!\n              allocate(measure(mn,mm),diedr(ndied))\n              if(pr)then\n                write(*,'(1x,a)') 'Using DIHEDRAL ANGLES as descriptors:' \n                do i=1,mn\n                   write(*,'(1x,a,4i6)') 'Atoms: ',diedat(1:4,i)\n                enddo\n                write(*,*)\n              endif   \n              do i=1,mm\n                call calc_dieders(zens%nat,zens%xyz(:,:,i),ndied,diedat,diedr)\n                do j=1,mn\n                !   if(i<5 .and. pr)then\n                !   write(*,'(1x,4i6,1x,f8.2)') diedat(1:4,j),diedr(j)\n                !   endif\n                   measure(j,i) = diedr(j)\n                enddo\n              enddo\n              if(allocated(diedat)) deallocate(diedat)\n              if(allocated(diedr)) deallocate(diedr)    \n              allocate(pc(mn),pcvec(mm,mn))\n      !=====================================================!       \n          end select\n      !=====================================================!    \n          if(pr)then\n              write(*,*)\n              write(*,'(1x,a,i0,a,i0,a)') 'Performing SVD for ', & \n        &          mm,' structures and ',mn,' props'\n          endif\n      !>--- do the SVD  ! MM must not be smaller than MN !\n          call SVD_to_PC(measure,mm,mn,pc,pcvec,.false.)\n!=========================================================================================!\n          call ctimer%stop(1)\n      else\n         write(*,*)'There are not enough descriptors for a PCA!'\n         write(*,*)'Taking all structures as representative and writing ',clusterfile\n         open(newunit=ich,file=clusterfile)\n         do i=1,zens%nall\n            dum = zens%er(i)\n            call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,i),dum)\n         enddo\n         close(ich)\n         return\n      endif\n!========================================================================================!\n      if(allocated(measure))deallocate(measure)\n      if(allocated(xyznew))deallocate(xyznew)\n      if(allocated(inc))deallocate(inc)\n\n      !>--- normalize PC eigenvalues\n      pcsum = sum(pc)\n      pc = pc / pcsum\n      !>--- get the contributing principal components\n      pcsum=0.0d0\n      npc = 0\n      do i=1,mn\n         if(pc(i) < pcmin) exit\n         pcsum = pcsum + pc(i)\n         npc = npc + 1\n         if(pcsum .ge. pcthr) exit\n      enddo\n      !npc = max(npc,2) !>-- at least 2 principal components should be used\n      npc = min(npc,pccap)\n      pcsum=0.0d0\n      do i=1,npc\n         pcsum = pcsum + pc(i)\n      enddo\n\n      if(pr)then\n        i = min(100,MM)  \n        k = min(npc,6)\n        write(*,*)\n        call smallhead('EIGENVECTORS AND NORMALIZED EIGENVALUES OF SVD ANALYIS')\n        call PRMAT(6,pcvec,i,k,'Eigenvectors of principal components')\n        write(*,'(1x,a,i0,a)')'NOTE: eigenvectors are only shown for the first ',i,' structures'\n        write(*,'(1x,a,i0,a)')'      and the first ',k,' contributing principal components.'       \n        write(*,*)\n\n        write(*,*) mn,'principal component eigenvalues (normalized)'\n        write(*,*) pc\n        !call PRMAT(6,pc,mn,1,'Principal components (eigenvalues)')\n        write(*,*)\n        write(*,'(1x,a,i0,a,f6.2,a)')  'The first ',npc,' components account for a total of ',100.d0*pcsum,'% of the'\n        write(*,'(1x,a)') 'ensembles unique structural features and are used for the clustering'  \n      endif\n\n      !>--- use some less memory and rearrange the eigenvectors (COLUMNS AND ROWS ARE SWAPPED)\n      !>    untaken PCs are not considered further\n      allocate(pcdum(npc,mm))\n      do i=1,mm\n         pcdum(1:npc,i) = pcvec(i,1:npc)\n      enddo\n      call move_alloc(pcdum,pcvec)  !>THIS CHANGES THE SHAPE OF pcvec (COLUMNS AND ROWS ARE SWAPPED)\n\n!=========================================================!\n! do the Clustering\n!=========================================================! \n\n      if(pr)then\n        write(*,*)\n        call smallhead('CLUSTERING ANALYSIS OF PRINCIPAL COMPONENTS')\n      endif\n\n      allocate(member(mm), source=0)\n\n      !>--- get Euclidean distances (packed matrix) between all structures\n      !> ndist = (mm*(mm+1))/2 ! overflows for large ensembles\n      ndist=mm\n      ndist=ndist*(mm+1)\n      ndist=ndist/2\n      allocate(dist(ndist), source = 0.0_sp)\n      allocate(p(npc),q(npc), source = 0.0_ap)\n\n      do i=1,mm\n         p(1:npc) = pcvec(1:npc,i)\n!$OMP PARALLEL PRIVATE ( j, klong, q, dum ) &\n!$OMP SHARED ( i, dist, npc, p, pcvec )\n!$OMP DO\n         do j=1,i\n            q(1:npc) = pcvec(1:npc,j)\n            dum = eucdist(npc,p,q)\n            klong = lina(i,j)\n            dist(klong) = real(dum, sp)\n         enddo\n!$OMP END DO\n!$OMP END PARALLEL         \n      enddo\n\n      !>-- NOTE\n      !>-- different clustering algorithms exist, but what is common\n      !>-- among them is, that no optimal number of clusters is known\n      !>-- at the beginning. The lower bound for the number of\n      !>-- clusters is the number of investigated PCs, the upper\n      !>-- bound is the number of structures\n      if(pr)then\n          select case(clusteralgo)\n            case( 'means','kmeans' )\n             write(*,'(1x,a)') 'Using a MEANS cluster algorithm.'\n          end select\n          write(*,'(1x,a)')'For a good review of cluster algorithms see'\n          write(*,'(1x,a)')'JCTC, 2007, 3, 2312 (doi.org/10.1021/ct700119m)'\n          write(*,*)\n          write(*,'(1x,a)') 'DBI = Davies-Bouldin index'\n          write(*,'(1x,a)') 'pSF = pseudo F-statistic'\n          write(*,'(1x,a)') 'SSR/SST = ratio of explained and unexplained variation'\n          write(*,*)\n          write(*,'(1x,a8,4x,a14,4x,a14,4x,a14)') 'Nclust','DBI','pSF','SSR/SST'\n          write(*,'(1x,a8,4x,a14,4x,a14,4x,a14)') '------','-------------','-------------','-------------'\n      endif\n\n!-----------------------------------------------------------------------!\n! Cluster evaluation settings\n!-----------------------------------------------------------------------!\n      if(env%maxcluster == 0 )then\n         !nclustmax=100  !some random default value\n         call clustleveval(env,nclustmax,csthr,SSRSSTthr) ! defaults\n         nclustmax=min(mm,nclustmax)\n         !SSRSSTthr=0.90  !exit if this value is reached  for SSR/SST\n      else  \n         nclustmax=max(2,env%maxcluster)  !no less than 2 clusters\n         nclustmax=min(mm,env%maxcluster) !there cannot be more clustes than structures.\n      endif\n      if(env%nclust == 0)then\n          nclustmin = 1\n      else\n      !>-- predefined number of clusters    \n          nclust =min(mm,env%nclust)\n          nclustmin = nclust\n          nclustmax = nclust   \n      endif\n\n      allocate(statistics(3,nclustmax) ,source =0.0d0)\n      CLUSTERSIZES : do nclustiter=nclustmin,nclustmax\n\n        !>-- regular case: test continuous cluster sizes\n        nclust = nclustiter\n        !>-- special case: test cluster sizes incrementally (good for large ensembles)\n        if( env%clustlev >= 10 )then\n            dum = float(mm)/float(nclustmax)\n            dum2= dum * float(nclustiter)\n            nclust = nint(dum2)\n        endif\n\n        allocate(centroid(npc,nclust), source = 0.0_ap)\n        centroid = 0.0_ap\n\n        select case(clusteralgo)\n          case( 'means','kmeans' )\n          call ctimer%start(2,'k-Means clustering')    \n          call kmeans(nclust,npc,mm,centroid,pcvec,ndist,dist,member)\n          call ctimer%stop(2)\n        end select\n\n        call ctimer%start(3,'statistics')\n        call cluststat(nclust,npc,mm,centroid,pcvec,member,DBI,pSF,SSRSST)\n        if(pr)then\n            write(*,'(1x,i8,4x,f14.6,4x,f14.6,4x,f14.6)')nclust,DBI,pSF,SSRSST\n        endif\n        call ctimer%stop(3)\n        deallocate(centroid)\n\n        statistics(1,nclust) = DBI\n        statistics(2,nclust) = pSF\n        statistics(3,nclust) = SSRSST\n\n        if(nclust==env%nclust) exit\n        if(SSRSST > SSRSSTthr) exit\n      enddo CLUSTERSIZES\n      if(allocated(centroid))deallocate(centroid)\n\n      write(*,*)\n      if(env%nclust == 0)then\n         if(pr)then \n         write(*,'(1x,a,i0,a)') 'Ensemble checked up to a partitioning into ',nclust,' clusters.'\n         write(*,'(1x,a)') 'Local MINIMA of the DBI indicate adequate cluster counts.'\n         write(*,'(1x,a)') 'Local MAXIMA of the pSF indicate adequate cluster counts.'\n         write(*,'(1x,a)') 'Higher SSR/SST vaules indicate more distinct clusters.'\n         write(*,'(1x,a)') 'Analyzing statistical values ...'\n         endif\n         k=nclust\n         allocate(extrema(2,k))\n         call ctimer%start(3,'statistics')\n         call statanal(k,nclustmax,statistics,extrema,pr)\n         if(pr)  call statwarning(fname)\n     !>-- determine a suggested cluster size (smallest suggested cluster with good SSR/SST)\n         do i=2,k    \n            if((extrema(1,i).or.extrema(2,i)).and.(statistics(3,i) > csthr))then\n                nclust=i\n                exit\n            endif\n         enddo\n         call ctimer%stop(3)\n         deallocate(extrema)\n         if(pr)then\n           write(*,*)\n           write(*,'(1x,a,f4.2,a,i0)') 'Suggested (SSR/SST >',csthr,') cluster count: ',nclust\n         endif\n     !>-- calculate the determined partition into clusters again for final file\n         allocate(centroid(npc,nclust), source = 0.0_ap)\n         select case(clusteralgo)\n          case( 'means','kmeans' )\n          call ctimer%start(2,'k-Means clustering')\n          call kmeans(nclust,npc,mm,centroid,pcvec,ndist,dist,member)\n          call ctimer%stop(2)\n         end select\n         deallocate(centroid)\n      else\n         if(pr)then \n         write(*,'(1x,a,i0,a)') 'Ensemble partitioning into ',nclust,' clsuters.'\n         endif\n      endif    \n      deallocate(statistics)    \n\n      deallocate(q,p,dist)\n      !>-- finally, assign a representative structure to each group (based on lowest energy)\n      !>-- and write the new ensemble file\n      call PCA_grpwrite(nclust,npc,mm,pcvec,member)\n\n      !ncb=maxval(member,1) !--total number of cluster\n      ncb = nclust\n      ancb = ncb           !>--actual number of clusters\n\n      if(ancb.le.1) return\n\n      if(pr)then\n          write(*,*)\n          write(*,'(1x,a)')'Representative structures'\n          write(*,'(1x,a6,1x,a6,3x,a6,1x,a16,1x,a16)')'Nr.','conf.','clust.','Etot/Eh','Erel/ kcal/mol'\n          write(*,'(1x,a6,1x,a6,3x,a6,1x,a16,1x,a16)')'---','-----','------','-------','--------------'\n      endif\n      allocate(eclust(ncb),source = 0.0d0)\n      allocate(clustbest(ncb), ind(ncb), source = 0)\n      do i=1,ncb\n          ind(i) = i\n          c = 0\n          do j=1,mm\n             if(member(j) == i)then\n                 c = c + 1\n                 if(zens%er(j)<eclust(i))then\n                     eclust(i) = zens%er(j)\n                     clustbest(i) = j\n                 endif\n             endif\n          enddo\n          !>-- if there are clusters without structures \n          if(c == 0 )then\n              clustbest(i) = -1\n              ancb = ancb - 1\n          endif\n      enddo\n      call qsort(eclust, 1, ncb, ind)\n      emin=minval(eclust,1)\n      open(newunit=ich, file=clusterfile)\n      do i=1,ncb\n        k=clustbest(ind(i))\n        if(k > 0)then\n         dum = zens%er(k)\n         call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,k),dum)\n         if(pr)then\n         erel= (dum - emin)*kcal\n         write(*,'(1x,i6,1x,i6,3x,i6,1x,f16.8,1x,f16.4)')i,k,member(k),dum,erel\n         endif\n        endif\n      enddo\n      close(ich)\n      if(pr)then\n         write(*,'(/,1x,a)')'(The \"clust.\" column refers to the cluster \"name\")'\n         write(*,*)\n         write(*,'(1x,a,a,a,i0,a)') 'File ',clusterfile,' written with ',ancb,' representative structures.'\n         if(ancb < ncb)then\n           write(*,'(1x,a,i0,a)') '(',ncb-ancb,' clusters discarded due to cluster merge)'\n         endif\n      endif\n      call zens%deallocate()\n\n      if(pr)then\n      write(*,*)    \n      !write(*,'(1x,a)') 'Timings:'    \n      !call eval_sub_timer(ctimer)\n      call ctimer%write(stdout, 'PCA/k-Means clustering')\n      endif\n      call ctimer%clear()\n      return\nend subroutine CCEGEN\n\n!=======================================================================================!\n! set clustering level defaults\n!=======================================================================================!\nsubroutine clustleveval(env,maxclust,csthr,SSRSSTthr)\n      use crest_parameters, idp => dp \n      use crest_data\n      implicit none\n      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n      integer :: clev\n      integer :: maxclust\n      real(wp) :: csthr\n      real(wp) :: SSRSSTthr\n\n      SSRSSTthr=0.90  !exit if this value is reached  for SSR/SST\n\n      clev = env%clustlev\n      if(env%clustlev >= 10)then  !for incremental modes\n          clev = env%clustlev -10\n      endif\n\n      select case( clev )\n         case( -1 ) !-- loose\n             maxclust=25\n             csthr=0.80d0\n         case( 1 )  !-- tight\n             maxclust=400\n             if(env%clustlev >= 10) maxclust=50\n             csthr=0.85d0\n         case( 2 )  !-- vtight\n             maxclust=400\n             if(env%clustlev >= 10) maxclust=100\n             csthr=0.9d0\n             SSRSSTthr=0.92d0    \n         case default !-- normal\n             maxclust=100\n             if(env%clustlev >= 10) maxclust=25\n             csthr=0.80d0\n      end select\n\n      return\nend subroutine clustleveval\n\n!=======================================================================================!\n! write a file with the 2 most contributing principal components of each structure\n! and the cluster to which the structure belongs\n!=======================================================================================!\nsubroutine PCA_grpwrite(nclust,npc,mm,pcvec,member)\n    use crest_parameters, idp => dp \n    implicit none\n    integer,intent(in) :: nclust  ! number of required centroids\n    integer,intent(in) :: npc,mm\n    real(wp),intent(in) :: pcvec(npc,mm)\n    integer,intent(in) :: member(mm)  ! membership for each structure\n    integer :: ich,i\n    open(newunit=ich,file='cluster.order')\n    write(ich,'(4x,i0,4x,i0,4x,i0)') mm,nclust,npc\n    if(npc>1)then\n    do i=1,mm\n       write(ich,'(i8,1x,f16.8,1x,f16.8,1x,i8)') i,pcvec(1,i),pcvec(2,i),member(i)\n    enddo\n    else\n    do i=1,mm\n       write(ich,'(i8,1x,f16.8,1x,i8)') i,pcvec(1,i),member(i)\n    enddo\n    endif\n    close(ich)\n    return\nend subroutine PCA_grpwrite\n\n!=======================================================================================!\n! Exclude light - exclude H atoms in the inc array\n!=======================================================================================!\nsubroutine excludeLight(zmol,inc)\n      use crest_parameters, idp => dp \n      use zdata\n      implicit none\n      type(zmolecule) :: zmol\n      integer :: inc(zmol%nat)\n      integer :: i\n      do i=1,zmol%nat\n         if(zmol%at(i) == 1 )then\n             inc(i) = 0\n         endif\n      enddo\n      return\nend subroutine excludeLight    \n\n!=======================================================================================!\n! Exclude Specified Atoms\n!=======================================================================================!\nsubroutine excludeSelected(zmol,inc,atlist)\n      use crest_parameters, idp => dp \n      use zdata\n      implicit none\n      type(zmolecule) :: zmol\n      integer :: inc(zmol%nat)\n      character(len=*) :: atlist   !a string containing atom numbers, needs parsing\n      integer :: i,ncon\n      integer,allocatable :: inc2(:)\n      allocate(inc2(zmol%nat),source=0)\n      call parse_atlist_new(atlist,ncon,zmol%nat,zmol%at,inc2)\n      do i=1,zmol%nat\n         if(inc2(i)==1)inc(i)=0\n      enddo\n      deallocate(inc2)\n      return\nend subroutine excludeSelected\n\n!=======================================================================================!\n! Perform a single value decomposition (SVD) and get the principal components\n! \n! X = U*sig*V^(T)\n!\n! The eigenvalues saved in sig are the principal components\n! The SVD only works if M >= N \n!\n!=======================================================================================!\nsubroutine svd_to_pc(measure,m,n,sig,U,pr)\n      use crest_parameters, idp => dp \n      implicit none\n      integer :: n,m\n      real(wp) :: measure(n,m)\n      real(wp) :: sig(n)\n      real(wp) :: U(m,n)\n      integer :: i,j,info,lwork\n      real(wp),allocatable :: mean(:),tmp(:)\n      integer, allocatable :: ind(:)\n      real(wp),allocatable :: X(:,:), V(:,:), work(:)\n      integer, allocatable :: iwork(:)\n      logical :: pr\n      if(pr)then\n       write(*,*)m,' mesaurements'\n       write(*,*)n,' props'\n      endif\n      allocate(mean(n),ind(m),tmp(m))\n      lwork=max(2*M+N,6*N+2*N*N)\n      allocate(X(m,n),V(n,n),iwork(m+3*n),work(lwork))\n      mean = 0.0d0\n      do i=1,m  \n         do j=1,n\n            mean(j)=mean(j)+measure(j,i)\n         enddo\n      enddo\n      mean = mean /float(m)\n      if(pr) write(*,*) mean\n      do i=1,m  \n         do j=1,n\n            X(i,j)=(mean(j)-measure(j,i))\n         enddo\n      enddo\n      if(pr)then\n         call PRMAT(6,X,m,n,'X')\n      endif\n!>--- LAPACKs' DGEJSV\n      call DGEJSV ( 'C' , 'U' , 'V' , 'N' , 'N' , 'N' , &\n     &              m,n,X,m,sig,U,m,V,n,                &\n     &              WORK, LWORK, IWORK, INFO )\n      if(pr)then\n        write(*,*) info\n        write(*,*) sig\n        call PRMAT(6,U**2,M,N,'U')\n        call PRMAT(6,V,N,N,'V')\n      endif\n      deallocate(work,iwork,V,X,tmp,ind,mean)\n      return\nend subroutine svd_to_pc\n\n!======================================================================!\n! calculate the Euclidian distance between two points p and q\n!======================================================================!\nfunction eucdist(ndim,p,q) result(dist)\n     use crest_parameters, idp => dp \n     implicit none\n     real(ap) :: dist\n     integer :: ndim\n     real(ap) :: p(ndim)\n     real(ap) :: q(ndim)\n     integer :: i\n     dist=0.0d0\n     do i=1,ndim\n        dist=dist + (q(i)-p(i))**2\n     enddo\n     dist=sqrt(dist)\n     return\nend function eucdist    \n\n!======================================================================!\n! K-means clustering algorithm\n!\n! determine a position of cluster centroids iteratively for a given\n! number of centroids.\n! \n!======================================================================!\nsubroutine kmeans(nclust,npc,mm,centroid,pcvec,ndist,dist,member)\n    use crest_parameters, idp => dp \n    implicit none\n    integer,intent(in) :: nclust  ! number of required centroids\n    integer,intent(in) :: npc,mm\n    real(wp),intent(in) :: pcvec(npc,mm)\n    integer(idp),intent(in) :: ndist\n    real(sp),intent(in)   :: dist(ndist)\n    integer,intent(inout) :: member(mm)  ! membership for each structure\n    real(ap),intent(inout):: centroid(npc,nclust)\n    integer,allocatable :: refmember(:)\n\n    if(nclust.le.1)return !no singular clusters!\n\n    allocate(refmember(mm), source = 0)\n\n    !>-- determine seeds for the centroids (i.e., initial positions)\n    call  kmeans_seeds(nclust,npc,mm,centroid,pcvec,ndist,dist)\n\n    do\n    !>-- determine cluster membership for all structures \n    !>   (by shortest Euc. distance to the respective centroid)\n       member = 0 !reset\n       call kmeans_assign(nclust,npc,mm,centroid,pcvec,member)\n\n    !>-- check if memberships changed w.r.t. previous memberships\n       if(all(member==refmember))then\n           exit\n       else\n           refmember = member\n       endif    \n    !>-- update centroids if necessary\n       call kmeans_recenter(nclust,npc,mm,centroid,pcvec,member)\n    enddo\n\n    deallocate(refmember)\n    return\nend subroutine kmeans   \n!===================================================================!\n! determine cluster seeds for the K-means algo\n!===================================================================!\nsubroutine kmeans_seeds(nclust,npc,mm,centroid,pcvec,ndist,dist)\n    use crest_parameters, idp => dp \n    implicit none\n    integer :: nclust,npc,mm\n    real(ap) :: centroid(npc,nclust)\n    real(wp) :: pcvec(npc,mm)\n    integer(idp) :: ndist\n    real(sp) :: dist(ndist)\n    real(sp) :: ddum\n    integer(idp) :: k,kiter\n    integer :: i,j,l,c\n    real(wp) :: distsum,maxdistsum\n    real(ap) :: eucdist !this is a function\n    real(ap),allocatable :: p(:),q(:)\n    integer,allocatable :: taken(:)\n\n    !>--- first two centroids are located at the most apart points\n    !>    in the PC space\n    !k = maxloc(dist,1)\n    ddum=0.0_sp\n    do kiter=1,ndist\n       if(dist(kiter) > ddum)then\n          k=kiter\n       endif\n    enddo\n    call revlin(k,j,i) !> reverse of the lin function, get indices i and j\n\n    centroid(1:npc,1) = pcvec(1:npc,i)\n    centroid(1:npc,2) = pcvec(1:npc,j)\n\n    if(nclust.le.2)return !>-- if we only need two centroids, return\n\n    !>-- If more centroids are needed, search for one point which has the maximal sum of\n    !>-- the distances between the already determined centroids and itself. \n    allocate(p(npc),q(npc),taken(nclust))\n    taken=0\n    taken(1) = i\n    taken(2) = j\n    do i=3,nclust\n       maxdistsum = 0.0d0\n       c = 0\n!$OMP PARALLEL PRIVATE ( l, q, p, j, distsum ) &\n!$OMP SHARED ( i, centroid, npc, mm, maxdistsum, pcvec, c, taken ) \n!$OMP DO\n       do j=1,mm\n         distsum = 0.0d0\n         p(1:npc) = pcvec(1:npc,j)\n         do l=1,i-1\n            q(1:npc) = centroid(1:npc,l)\n            distsum = distsum + eucdist(npc,p,q)\n         enddo\n         !$OMP CRITICAL\n         if(.not. any(taken==j))then\n         if(distsum .gt. maxdistsum)then\n             maxdistsum = distsum\n             c = j\n             taken(i) = c\n         endif\n         endif\n         !$OMP END CRITICAL\n       enddo\n!$OMP END DO\n!$OMP END PARALLEL\n       if(c==0)then\n        exit\n       else\n        centroid(1:npc,i) = pcvec(1:npc,c)\n       endif\n    enddo   \n\n    deallocate(taken,q,p)\n\n    return\nend subroutine kmeans_seeds    \n!===================================================================!\n! assign structures as members to a centroid\n!===================================================================!\nsubroutine kmeans_assign(nclust,npc,mm,centroid,pcvec,member)\n    use crest_parameters, idp => dp \n    implicit none\n    integer :: nclust,npc,mm\n    real(ap) :: centroid(npc,nclust)\n    real(wp) :: pcvec(npc,mm)\n    integer :: member(mm)\n    real(ap) :: eucdist  !this is a function\n    integer :: i,j,c\n    real(ap),allocatable :: centdist(:)\n    real(ap),allocatable :: p(:),q(:)\n\n    allocate(centdist(nclust), source = 0.0_ap)\n    allocate(p(npc),q(npc))\n!$OMP PARALLEL PRIVATE ( i, j, p, q, c, centdist ) &\n!$OMP SHARED ( mm, nclust, member, centroid, npc, pcvec ) \n!$OMP DO\n    do i=1,mm\n       p(1:npc) = pcvec(1:npc,i)\n       do j=1,nclust\n          q(1:npc) = centroid(1:npc,j)\n          centdist(j) = eucdist(npc,p,q)\n       enddo\n       c = minloc(centdist,1)\n       member(i) = c\n    enddo  \n!$OMP END DO\n!$OMP END PARALLEL    \n    deallocate(q,p)\n    deallocate(centdist)\n    return\nend subroutine kmeans_assign\n\n!===================================================================!\n! re-center centroids for given (sorted) structures\n!===================================================================!\nsubroutine kmeans_recenter(nclust,npc,mm,centroid,pcvec,member)\n    use crest_parameters, idp => dp \n    implicit none\n    integer :: nclust,npc,mm\n    real(ap) :: centroid(npc,nclust)\n    real(wp) :: pcvec(npc,mm)\n    integer :: member(mm)\n    integer :: i,j,c\n    real(ap),allocatable :: p(:),q(:)\n\n    allocate(p(npc),q(npc))\n    do i=1,nclust\n       c=0\n       p=0.0d0\n       do j=1,mm\n          if(member(j)==i)then\n              c=c+1\n              p(1:npc) = p(1:npc) + pcvec(1:npc,j)      \n          endif\n       enddo\n       if(c > 0)then\n         p=p/float(c)\n         centroid(1:npc,i) = p(1:npc)\n       else  \n         p=999.9d0  \n       endif\n    enddo   \n    deallocate(q,p)\n\n    return\nend subroutine kmeans_recenter\n\n!======================================================================!\n! calculate statistical values for the given cluster size\n! Values to compute:\n! DBI - the Davies-Bouldin index\n! pSF - the \"pseudo-F statistic\"\n! SSR/SST ratio\n!======================================================================!\nsubroutine cluststat(nclust,npc,mm,centroid,pcvec,member,DBI,pSF,SSRSST)\n    use crest_parameters, idp => dp \n    implicit none\n    integer,intent(in) :: nclust  ! number of required centroids\n    integer,intent(in) :: npc,mm\n    real(wp),intent(in) :: pcvec(npc,mm)\n    integer,intent(in) :: member(mm)  ! membership for each structure\n    real(ap),intent(in):: centroid(npc,nclust)\n    real(wp),intent(out) :: DBI,pSF,SSRSST\n    real(wp) :: SSE,SSR,SST\n    real(ap),allocatable :: p(:),q(:)\n    real(wp),allocatable :: compact(:)\n    real(wp),allocatable :: DBmat(:,:)\n    real(ap) :: eucdist !this is a function\n    real(wp) :: d,Rij,maxDB\n    integer :: i,c,k,c2\n    \n    DBI= 0.0d0\n    pSF = 0.0d0\n    SSRSST = 0.0d0\n\n    if(nclust<2)return\n\n    allocate(p(npc),q(npc))\n\n    !>-- Sum of squares error\n    SSE = 0.0d0\n    do c=1,nclust\n       p(1:npc) = centroid(1:npc,c)\n       do i=1,mm\n          if(member(i)==c)then\n              q(1:npc) = pcvec(1:npc,i)\n              d = eucdist(npc,p,q)\n              SSE = SSE + d**2\n          endif\n       enddo\n    enddo\n    SSE = SSE\n\n    !>-- Total sum of squares\n    SST = 0.0d0\n    p = 0.0d0\n    do c=1,nclust\n       p(1:npc) = p(1:npc) + centroid(1:npc,c)\n    enddo   \n    p = p/float(nclust)\n    do i=1,mm\n        q(1:npc) = pcvec(1:npc,i)\n        d = eucdist(npc,p,q)\n        SST = SST + d**2\n    enddo\n    SST = SST\n\n    !>-- Sum of squares regression\n    SSR = SST - SSE\n\n    !>-- SSR/SST ratio\n    SSRSST = SSR / SST\n\n    !>-- pseudo-F statistic\n    if(nclust>1)then\n      pSF = (SSR/(float(nclust)-1.0d0))\n      if(mm==nclust)then\n          pSF=0.0d0\n      else\n          pSF = pSF / (SSE/(float(mm) - float(nclust)))\n      endif\n    else\n      pSF = 0.0d0\n    endif  \n\n    !>-- Davies-Bouldin index (DBI)\n    allocate(compact(nclust),source=0.0d0) !cluster compactness\n    do c=1,nclust\n       p(1:npc) = centroid(1:npc,c)\n       k=0\n       do i=1,mm\n          if(member(i)==c)then\n              k = k + 1\n              q(1:npc) = pcvec(1:npc,i)\n              d = eucdist(npc,p,q)\n              compact(c) = compact(c) + d\n          endif\n       enddo\n       if(k > 0)then\n         compact(c) = compact(c) / float(k)\n       else\n         compact(c) = 0\n       endif  \n    enddo\n    allocate(DBmat(nclust,nclust), source = 0.0d0)\n    do c=1,nclust\n       p(1:npc) = centroid(1:npc,c)\n       do c2=1,nclust\n          if(c2==c) cycle\n          q(1:npc) = centroid(1:npc,c2)\n          d = eucdist(npc,p,q)\n          Rij = (compact(c)+compact(c2))/d\n          DBmat(c,c2) = Rij\n       enddo\n    enddo\n    do c=1,nclust\n       maxDB=maxval(DBmat(:,c),1)\n       DBI = DBI + maxDB\n    enddo  \n    DBI = DBI / float(nclust)\n    deallocate(DBmat)\n    deallocate(compact)\n\n    deallocate(q,p)\n    return\nend subroutine cluststat\n\n!==============================================================!\n! analyze the statistical values DBI and pSF to get the \n! respective extrema\n!==============================================================!\nsubroutine statanal(n,nmax,statistics,extrema,pr)\n    use crest_parameters\n    implicit none\n    integer :: n,nmax\n    real(wp) :: statistics(3,nmax)\n    logical,intent(inout) :: extrema(2,n)\n    logical :: pr\n    real(wp) :: last,next,current\n    integer :: i\n\n    extrema=.false.\n!>--- identify local extrema of the DBI and pSF\n    do i=2,n-1\n    !>-- DBI \n       last = statistics(1,i-1)\n       next = statistics(1,i+1)\n       current = statistics(1,i)\n       if((current<last) .and. (current<next))then\n          extrema(1,i) = .true.\n       endif\n    !>-- pSF\n       last = statistics(2,i-1)\n       next = statistics(2,i+1)\n       current = statistics(2,i)\n       if((current>last) .and. (current>next))then\n          extrema(2,i) = .true.\n       endif\n    enddo\n\n    if(pr)then\n        write(*,*)\n        write(*,'(1x,a,/)') 'Suggestions for cluster sizes:'\n        do i=1,n\n           if(extrema(1,i) .or. extrema(2,i))then\n               if(extrema(1,i) .and. extrema(2,i))then\n                  write(*,'(1x,i8,''*'',3x,a,f8.4)') i,'SSR/SST',statistics(3,i)\n               else\n                  write(*,'(1x,i8,4x,a,f8.4)') i,'SSR/SST',statistics(3,i)\n               endif\n           endif    \n        enddo\n        write(*,'(/,1x,a)') 'Cluster counts marked with a star (*) are reasonable'\n        write(*,'(1x,a)') 'suggestions according to BOTH the DBI and pSF.'\n    endif    \n\n    return\nend subroutine statanal    \n\n!==============================================================!\n! print a warning regarding the nature of the cluster partitioning\n!==============================================================!\nsubroutine statwarning(fname)\n    implicit none\n    character(len=*) :: fname\n    write(*,*)\n    write(*,'(1x,a)') '!---------------------------- NOTE ----------------------------!'\n    write(*,'(2x,a)') 'The partitioning of data (the ensemble) into clusters'\n    write(*,'(2x,a)') 'of similar characteristics (structures) is ARBITRARY'\n    write(*,'(2x,a)') 'and depends on many criteria (e.g. choice of PCs).'\n    write(*,'(2x,a)') 'The selected cluster count is the smallest reasonable'\n    write(*,'(2x,a)') 'number of clusters that can be formed according to'\n    write(*,'(2x,a)') 'the DBI and pSF values for the given data.'\n    write(*,*)\n    write(*,'(2x,a)') 'If other cluster sizes are desired, rerun CREST with'\n    write(*,'(2x,3a)') '\"crest --for ',trim(fname),' --cluster <number of clusters>\"'\n    write(*,*)\n    write(*,'(2x,a)') 'Other default evaluation settings can be chosen with the'\n    write(*,'(2x,a)') 'keywords \"loose\",\"normal\", and \"tight\" as <level> via'\n    write(*,'(2x,3a)') '\"crest --for ',trim(fname),' --cluster <level>\"'\n    write(*,'(1x,a)') '!--------------------------------------------------------------!'\nend subroutine statwarning\n\n\n!====================================================================!\nsubroutine getdiederatoms(zmol,nat,inc,nb,diedat,ndied)\n      use crest_parameters, idp => dp \n      use zdata\n      use strucrd\n      implicit none\n      type(zmolecule) :: zmol\n      integer :: nat\n      integer :: inc(nat) !contains 1 (=include) or 0 (=ignore)\n      integer :: nb\n      integer :: diedat(4,nb)\n      integer,intent(out) :: ndied\n      integer :: a,b,c,d\n      integer :: i,j,k\n\n      ndied = 0\n      do i=1,nb\n         a = zmol%bondpairs(1,i)\n         b = zmol%bondpairs(2,i)\n         if(inc(a)==0)cycle          !ignored by user?  \n         if(inc(b)==0)cycle          !ignored by user? \n         if(zmol%zat(a)%nei==1)cycle !terminal atom?\n         if(zmol%zat(b)%nei==1)cycle !terminal atom?\n         if(zmol%methyl(a))cycle !methyl C?\n         if(zmol%methyl(b))cycle !methyl C?\n         !>-- passed all checks, so let's get atoms\n         !>-- a neighbour for a\n         do j=1,zmol%zat(a)%nei\n            c = zmol%zat(a)%ngh(j)\n            if(c == b)then\n                cycle\n            else\n                exit\n            endif\n         enddo\n         !>-- a neighbour for b\n         do k=1,zmol%zat(b)%nei\n            d = zmol%zat(b)%ngh(k)\n            if( d == a)then\n                cycle\n            else\n                exit\n            endif\n         enddo\n         ndied = ndied + 1\n         !>the bond is between a and b\n         !>c is a neighbour of a, d is a neighbour of b\n         diedat(2,ndied) = a\n         diedat(3,ndied) = b\n         diedat(1,ndied) = c \n         diedat(4,ndied) = d\n      enddo\n\n      return\nend subroutine getdiederatoms\n\nsubroutine calc_dieders(nat,xyz,ndied,diedat,diedr)\n      use crest_parameters, idp => dp \n      use crest_data\n      use zdata\n      use strucrd\n      implicit none\n      integer :: nat,ndied\n      real(wp) :: xyz(3,nat)\n      integer :: diedat(4,ndied)\n      real(wp),intent(out) :: diedr(ndied)\n      integer :: i\n      integer :: a,b,c,d\n      real(wp) :: coords(3,4)\n      real(wp) :: angle\n      real(wp),parameter :: rad2degree = 57.29578_wp\n      real(wp),parameter :: tol = 5.0_wp !tolerance for almost 360 degree\n\n      diedr=0.0_wp\n      do i=1,ndied\n        a = diedat(2,i)\n        b = diedat(3,i)\n        c = diedat(1,i)\n        d = diedat(4,i)\n        coords(1:3,1) = xyz(1:3,c)\n        coords(1:3,2) = xyz(1:3,a)\n        coords(1:3,3) = xyz(1:3,b)\n        coords(1:3,4) = xyz(1:3,d)\n        call DIHED(coords,1,2,3,4,angle)\n        angle = abs(angle) * rad2degree\n        if( abs(angle-360.0_wp) < tol ) angle = 0.0_wp\n        diedr(i) = angle\n      enddo\n\n      return\nend subroutine calc_dieders\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ccegen.f90 b/src/ccegen.f90
--- a/src/ccegen.f90	
+++ b/src/ccegen.f90	
@@ -34,704 +34,702 @@
 !
 !==============================================================================!
 subroutine CCEGEN(env,pr,fname)
-      use crest_parameters, idp => dp 
-      use crest_data
-      use zdata
-      use strucrd
-      implicit none
-      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
-      type(timer) :: ctimer
-      logical,intent(in)   :: pr
-      character(len=*),intent(in) :: fname
-      type(zmolecule) :: zmol
-      type(zequal) :: groups
-      type(zequal) :: subgroups
-      integer,allocatable :: inc(:)
-      logical :: heavyonly
-      integer :: i,j,k,l,ich,c
-      real(wp) :: dum,dum2
-      type(ensemble) :: zens
+  use crest_parameters,idp => dp
+  use crest_data
+  use zdata
+  use strucrd
+  use utilities
+  implicit none
+  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
+  type(timer) :: ctimer
+  logical,intent(in)   :: pr
+  character(len=*),intent(in) :: fname
+  type(zmolecule) :: zmol
+  type(zequal) :: groups
+  type(zequal) :: subgroups
+  integer,allocatable :: inc(:)
+  logical :: heavyonly
+  integer :: i,j,k,l,ich,c
+  real(wp) :: dum,dum2
+  type(ensemble) :: zens
 
-      character(len=:),allocatable :: measuretype
+  character(len=:),allocatable :: measuretype
 
-      !>--- SVD params
-      integer :: ntaken
-      integer :: nallnew
-      real(wp),allocatable :: xyznew(:,:,:)
-      !integer,allocatable  :: atnew(:)
-      real(wp),allocatable :: measure(:,:) !this is what is passed to the SVD
-      integer :: mn,mm                     !--> measure(mn,mm)
-      real(wp),allocatable :: pc(:)        !the principal components
-      real(wp),allocatable :: pcvec(:,:)   !the principal component eigenvectors
-      real(wp),allocatable :: pcdum(:,:)  
-      integer :: nbnd,ndied
-      integer,allocatable :: diedat(:,:)   !atoms spanning relevant dihedral angles
-      real(wp),allocatable :: diedr(:)
-      real(wp) :: pcsum
-      real(wp) :: pcthr
-      real(wp) :: pcmin
-      integer :: pccap
-      integer :: npc
-      real(wp),allocatable :: geo(:,:)
-      integer,allocatable :: na(:),nb(:),nc(:)
+  !>--- SVD params
+  integer :: ntaken
+  integer :: nallnew
+  real(wp),allocatable :: xyznew(:,:,:)
+  !integer,allocatable  :: atnew(:)
+  real(wp),allocatable :: measure(:,:) !this is what is passed to the SVD
+  integer :: mn,mm                     !--> measure(mn,mm)
+  real(wp),allocatable :: pc(:)        !the principal components
+  real(wp),allocatable :: pcvec(:,:)   !the principal component eigenvectors
+  real(wp),allocatable :: pcdum(:,:)
+  integer :: nbnd,ndied
+  integer,allocatable :: diedat(:,:)   !atoms spanning relevant dihedral angles
+  real(wp),allocatable :: diedr(:)
+  real(wp) :: pcsum
+  real(wp) :: pcthr
+  real(wp) :: pcmin
+  integer :: pccap
+  integer :: npc
+  real(wp),allocatable :: geo(:,:)
+  integer,allocatable :: na(:),nb(:),nc(:)
 
-      !>--- CLUSTERING params
-      character(len=:),allocatable :: clusteralgo
-      integer :: nclust                    !number of clusters
-      integer :: nclustiter                !iterator for nclust
-      integer :: nclustmin,nclustmax                   
-      integer,allocatable :: member(:)     !track cluster correspondence
-      real(ap),allocatable :: p(:),q(:)
-      real(sp),allocatable :: dist(:)
-      real(ap),allocatable :: centroid(:,:)
-      integer(idp) :: ndist,klong
-      integer(idp) :: lina !this is a function
-      real(ap) :: eucdist !this is a function
-      real(wp) :: DBI,pSF,SSRSST,SSRSSTthr
-      real(wp) :: csthr
-      integer :: ncb,ancb
-      real(wp),allocatable :: eclust(:)
-      integer,allocatable :: clustbest(:),ind(:)
-      real(wp),allocatable :: statistics(:,:)
-      logical,allocatable :: extrema(:,:)
-      logical :: autolimit
-      real(wp) :: fraclimit
+  !>--- CLUSTERING params
+  character(len=:),allocatable :: clusteralgo
+  integer :: nclust                    !number of clusters
+  integer :: nclustiter                !iterator for nclust
+  integer :: nclustmin,nclustmax
+  integer,allocatable :: member(:)     !track cluster correspondence
+  real(ap),allocatable :: p(:),q(:)
+  real(sp),allocatable :: dist(:)
+  real(ap),allocatable :: centroid(:,:)
+  integer(idp) :: ndist,klong
+  real(ap) :: eucdist !this is a function
+  real(wp) :: DBI,pSF,SSRSST,SSRSSTthr
+  real(wp) :: csthr
+  integer :: ncb,ancb
+  real(wp),allocatable :: eclust(:)
+  integer,allocatable :: clustbest(:),ind(:)
+  real(wp),allocatable :: statistics(:,:)
+  logical,allocatable :: extrema(:,:)
+  logical :: autolimit
+  real(wp) :: fraclimit
 
-      !>--- printout and params
-      real(wp) :: emin,erel
-      real(wp),parameter :: kcal = 627.5095d0
-      !real(wp),parameter :: pi =  3.14159265358979D0
-      real(wp),parameter :: rad = 180.0d0/pi
+  !>--- printout and params
+  real(wp) :: emin,erel
+  real(wp),parameter :: kcal = 627.5095d0
+  !real(wp),parameter :: pi =  3.14159265358979D0
+  real(wp),parameter :: rad = 180.0d0/pi
 
-
-       call ctimer%init(20)
-       if(pr)then
-       call largehead('Principal Component Analysis (PCA) and Clustering')
-       write(*,'(1x,a,a)') 'Input file: ',trim(fname)
-       endif
+  call ctimer%init(20)
+  if (pr) then
+    call largehead('Principal Component Analysis (PCA) and Clustering')
+    write (*,'(1x,a,a)') 'Input file: ',trim(fname)
+  end if
 
 !=========================================================!
 ! set threads
 !=========================================================!
-       call cregen_setthreads(stdout,env,pr)
+  call cregen_setthreads(stdout,env,pr)
 
 !=========================================================!
 ! Prepare a coordinate ensemble for the clustering
-!=========================================================!      
-   !>--- 0. Set defaults, read ensemble
-       call zens%open(fname) !read in the ensemble
-       if(zens%nall<1)then
-          error stop "Ensemble is empty! must stop"
-       else if(zens%nall==1)then
-           if(pr)then
-             write(*,*) 'Only one structure in ensemble!'
-             write(*,*) 'Write structure to ',clusterfile,' and skip PCA parts'
-           endif    
-           open(newunit=ich,file=clusterfile)
-           dum = zens%er(1)
-           call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,1),dum)
-           close(ich)
-           call zens%deallocate()
-           return
-       endif     
+!=========================================================!
+  !>--- 0. Set defaults, read ensemble
+  call zens%open(fname) !read in the ensemble
+  if (zens%nall < 1) then
+    error stop "Ensemble is empty! must stop"
+  else if (zens%nall == 1) then
+    if (pr) then
+      write (*,*) 'Only one structure in ensemble!'
+      write (*,*) 'Write structure to ',clusterfile,' and skip PCA parts'
+    end if
+    open (newunit=ich,file=clusterfile)
+    dum = zens%er(1)
+    call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,1),dum)
+    close (ich)
+    call zens%deallocate()
+    return
+  end if
 
-       heavyonly = .true.
-       !measuretype = 'dihedral'
-       measuretype = env%pcmeasure
-       clusteralgo='kmeans'
-       !pcthr = 0.85d0  !PCs must add up to this amount of "representability"
-       pcthr = env%pcthr
-       pcmin = env%pcmin
-       !csthr = 0.80d0  !threshold for SSR/SST to select a suitable cluster count
-       csthr = env%csthr
-       !pccap = 100   !a cap for the number of principal components used in the clustering
-       pccap = env%pccap
-       autolimit = .true. !if the ensemble is very large, take only a fraction to speed up things
-                          !(only for predefined clustersizes with "-cluster N" )
-       fraclimit = 0.25d0 !if autolimit=true, 1/4 of the ensemble is taken
+  heavyonly = .true.
+  !measuretype = 'dihedral'
+  measuretype = env%pcmeasure
+  clusteralgo = 'kmeans'
+  !pcthr = 0.85d0  !PCs must add up to this amount of "representability"
+  pcthr = env%pcthr
+  pcmin = env%pcmin
+  !csthr = 0.80d0  !threshold for SSR/SST to select a suitable cluster count
+  csthr = env%csthr
+  !pccap = 100   !a cap for the number of principal components used in the clustering
+  pccap = env%pccap
+  autolimit = .true. !if the ensemble is very large, take only a fraction to speed up things
+  !(only for predefined clustersizes with "-cluster N" )
+  fraclimit = 0.25d0 !if autolimit=true, 1/4 of the ensemble is taken
 
-   !>--- 1. topology for reference strucuture
-      if(env%wbotopo)then
-         env%wbofile='wbo'
-      else   
-         env%wbofile='none given' 
-      endif
-      zens%xyz = zens%xyz/bohr  !ANG to Bohr for topo
-      call simpletopo(zens%nat,zens%at,zens%xyz,zmol,pr,.false.,env%wbofile)
-      zens%xyz = zens%xyz*bohr  !Bohr to ANG
-      allocate(inc(zmol%nat), source = 0)
+  !>--- 1. topology for reference strucuture
+  if (env%wbotopo) then
+    env%wbofile = 'wbo'
+  else
+    env%wbofile = 'none given'
+  end if
+  zens%xyz = zens%xyz/bohr  !ANG to Bohr for topo
+  call simpletopo(zens%nat,zens%at,zens%xyz,zmol,pr,.false.,env%wbofile)
+  zens%xyz = zens%xyz*bohr  !Bohr to ANG
+  allocate (inc(zmol%nat),source=0)
 
 !===========================================================!
- if(measuretype.ne.'dihedral')then
+  if (measuretype .ne. 'dihedral') then
 !===========================================================!
-   !>--- 2. read nuclear equivalencies
-      if(pr)then
-        write(*,*)
-        call smallhead('READING NUCLEAR EQUIVALENCIES')
-      endif
-      call readequals('anmr_nucinfo',zmol,groups)  
-      if(pr)then
-        call groups%prsum(6) !--- print summary to screen
-        write(*,'(1x,a)') 'Unlisted nuclei (groups) are unique.'
-      endif
+    !>--- 2. read nuclear equivalencies
+    if (pr) then
+      write (*,*)
+      call smallhead('READING NUCLEAR EQUIVALENCIES')
+    end if
+    call readequals('anmr_nucinfo',zmol,groups)
+    if (pr) then
+      call groups%prsum(6) !--- print summary to screen
+      write (*,'(1x,a)') 'Unlisted nuclei (groups) are unique.'
+    end if
 
-   !>--- 3. distribute groups into subgroups basedon topology
-      if(pr)then
-        write(*,*)
-        call smallhead('ANALYZING EQUIVALENCIES')
-      endif
-      call distsubgr(zmol,groups,subgroups,inc,pr)
+    !>--- 3. distribute groups into subgroups basedon topology
+    if (pr) then
+      write (*,*)
+      call smallhead('ANALYZING EQUIVALENCIES')
+    end if
+    call distsubgr(zmol,groups,subgroups,inc,pr)
 
-
-   !>--- 4. Equivalent atoms must be excluded in clustering to reduce noise
-      if(pr)then
-        write(*,*)
-        call smallhead('DETERMINE ATOMS TO INCLUDE IN PCA')
-      endif
-      call excludeFromRMSD(zmol,inc)
-      if(sum(inc)==0)then
-          if(pr)then
-          write(*,*) 'WARNING: No atoms included in PCA'
-          write(*,*) 'Including more atoms ...'
-          endif
-          inc=1
-          !-- for this exclude the equivalent atoms from anmr_nucinfo directly
-          do i=1,groups%ng
-             if(groups%grp(i)%nm > 1)then
-             write(*,*) groups%grp(i)%mem
-             do j=1,groups%grp(i)%nm 
-                k=groups%grp(i)%mem(j)
-                inc(k) = 0
-             enddo
-             endif
-          enddo
-      endif
-      !>-- exclude user set atoms
-      if(env%pcaexclude)then
-         call excludeSelected(zmol,inc,env%atlist)
-      endif
-      !>-- exclude H atoms
-      if(heavyonly)then
-         call excludeLight(zmol,inc)
-      endif
-      if(pr)then
-          do i=1,zmol%nat
-            if(inc(i) == 1 )then
-              write(*,'(1x,a,a,i0,a,5x,a)') zmol%zat(i)%el,'(',i,')','taken'
-            endif
-          enddo
-      endif
-      ntaken = sum(inc)
-      !>--- if we have too few, include the heav atoms at least
-      if(ntaken <= 3)then
-          do i=1,zmol%nat
-            if(zmol%at(i) /= 1 )then
-                inc(i) = 1
-                if(pr) write(*,'(1x,a,a,i0,a,5x,a)') zmol%zat(i)%el,'(',i,')','taken'
-            endif
-          enddo
-      endif
-      ntaken = sum(inc)
+    !>--- 4. Equivalent atoms must be excluded in clustering to reduce noise
+    if (pr) then
+      write (*,*)
+      call smallhead('DETERMINE ATOMS TO INCLUDE IN PCA')
+    end if
+    call excludeFromRMSD(zmol,inc)
+    if (sum(inc) == 0) then
+      if (pr) then
+        write (*,*) 'WARNING: No atoms included in PCA'
+        write (*,*) 'Including more atoms ...'
+      end if
+      inc = 1
+      !-- for this exclude the equivalent atoms from anmr_nucinfo directly
+      do i = 1,groups%ng
+        if (groups%grp(i)%nm > 1) then
+          write (*,*) groups%grp(i)%mem
+          do j = 1,groups%grp(i)%nm
+            k = groups%grp(i)%mem(j)
+            inc(k) = 0
+          end do
+        end if
+      end do
+    end if
+    !>-- exclude user set atoms
+    if (env%pcaexclude) then
+      call excludeSelected(zmol,inc,env%atlist)
+    end if
+    !>-- exclude H atoms
+    if (heavyonly) then
+      call excludeLight(zmol,inc)
+    end if
+    if (pr) then
+      do i = 1,zmol%nat
+        if (inc(i) == 1) then
+          write (*,'(1x,a,a,i0,a,5x,a)') zmol%zat(i)%el,'(',i,')','taken'
+        end if
+      end do
+    end if
+    ntaken = sum(inc)
+    !>--- if we have too few, include the heav atoms at least
+    if (ntaken <= 3) then
+      do i = 1,zmol%nat
+        if (zmol%at(i) /= 1) then
+          inc(i) = 1
+          if (pr) write (*,'(1x,a,a,i0,a,5x,a)') zmol%zat(i)%el,'(',i,')','taken'
+        end if
+      end do
+    end if
+    ntaken = sum(inc)
 
-      call zmol%deallocate
+    call zmol%deallocate
 
-      !>-- for very large ensemble files limit the clustering
-      if(autolimit)then
-          if((env%nclust /= 0).and.(env%nclust*100 < zens%nall))then
-              dum = float(zens%nall) * fraclimit
-              dum2 = float(env%nclust)
-              nallnew = nint(max(dum,dum2))
-          else
-              nallnew = zens%nall
-          endif
-      else
-          nallnew = zens%nall
-      endif
+    !>-- for very large ensemble files limit the clustering
+    if (autolimit) then
+      if ((env%nclust /= 0).and.(env%nclust*100 < zens%nall)) then
+        dum = float(zens%nall)*fraclimit
+        dum2 = float(env%nclust)
+        nallnew = nint(max(dum,dum2))
+      else
+        nallnew = zens%nall
+      end if
+    else
+      nallnew = zens%nall
+    end if
 
-   !>--- 5. Transfer the relevant atoms to a new array   
-      allocate(xyznew(3,ntaken,nallnew))!,atnew(ntaken))
-      do i=1,nallnew
-         k = 0
-         do j=1,zens%nat
-            if(inc(j) == 1)then
-                k=k+1
-                xyznew(:,k,i) = zens%xyz(:,j,i)
-                !atnew(k) = zens%at(j)
-            endif    
-         enddo
-      enddo
+    !>--- 5. Transfer the relevant atoms to a new array
+    allocate (xyznew(3,ntaken,nallnew))!,atnew(ntaken))
+    do i = 1,nallnew
+      k = 0
+      do j = 1,zens%nat
+        if (inc(j) == 1) then
+          k = k+1
+          xyznew(:,k,i) = zens%xyz(:,j,i)
+          !atnew(k) = zens%at(j)
+        end if
+      end do
+    end do
 
 !===================================================!
- else !measuretype=='dihedral'
+  else !measuretype=='dihedral'
 !===================================================!
 
-      !-- for very large ensemble files limit the clustering
-      if(autolimit)then
-          if((env%nclust /= 0).and.(env%nclust*100 < zens%nall))then
-              dum = float(zens%nall) * fraclimit
-              dum2 = float(env%nclust)
-              nallnew = nint(max(dum,dum2))
-          else
-              nallnew = zens%nall
-          endif
-      else
-          nallnew = zens%nall
-      endif
+    !-- for very large ensemble files limit the clustering
+    if (autolimit) then
+      if ((env%nclust /= 0).and.(env%nclust*100 < zens%nall)) then
+        dum = float(zens%nall)*fraclimit
+        dum2 = float(env%nclust)
+        nallnew = nint(max(dum,dum2))
+      else
+        nallnew = zens%nall
+      end if
+    else
+      nallnew = zens%nall
+    end if
 
-      inc = 1
-      ntaken = sum(inc)
+    inc = 1
+    ntaken = sum(inc)
 
-      call zmol%countbonds()
-      nbnd = zmol%nb
-      allocate(diedat(4,zmol%nb) , source=0)
-      call getdiederatoms(zmol,zmol%nat,inc,nbnd,diedat,ndied)
-      ntaken = ndied
-!==================================================!      
- endif
-!==================================================! 
+    call zmol%countbonds()
+    nbnd = zmol%nb
+    allocate (diedat(4,zmol%nb),source=0)
+    call getdiederatoms(zmol,zmol%nat,inc,nbnd,diedat,ndied)
+    ntaken = ndied
+!==================================================!
+  end if
+!==================================================!
 
 !===================================================================================================!
 ! do the SVD to get the principal components
 !===================================================================================================!
-      if(ntaken > 3)then !> all of this only makes sense if we have something to compare
-          call ctimer%start(1,'PCA')
-          if(pr)then
-              write(*,*)
-              call smallhead('PRINCIPAL COMPONENT ANALYSIS')
-          endif    
-          !mm = zens%nall  
-          mm = nallnew
-          select case( measuretype )
-           !==========================================================================!
-           case( 'cma','CMA','cmadist' )
-               if(pr)then
-                   write(*,'(1x,a)')'Using CMA DISTANCES as descriptors:'
-               endif
-           !>-- all structures should have been shifted to the CMA by CREGEN
-           !>   therefore assume the CMA is at (0,0,0).
-           !>   somewhat robust measure, but provides less information.
-             mn = min(ntaken,mm)
-             allocate(measure(mn,mm),pc(mn),pcvec(mm,mn))
-             do i=1,mm
-               do j=1,mn
-                  measure(j,i) = xyznew(1,j,i)**2 + &
-               &                 xyznew(2,j,i)**2 + &
-               &                 xyznew(3,j,i)**2       
-                  measure(j,i) = sqrt(measure(j,i))
-               enddo
-             enddo
-           !==========================================================================!   
-           case( 'cartesian','coords' )  
-               if(pr)then
-                   write(*,'(1x,a)')'Using CARTESIAN COORDINATES as descriptors:'
-               endif
-           !>-- all Cartesian components of the selected atoms
-           !>   REQUIRES PERFECT ALIGNMENT(!), hence not very robust
-             mn = min(ntaken*3,mm)
-             allocate(measure(mn,mm),pc(mn),pcvec(mm,mn))
-             do i=1,mm
-                l=0
-                do j=1,ntaken
-                  do k=1,3     
-                     l=l+1
-                     measure(j,l) = xyznew(k,j,i)
-                  enddo
-                enddo
-              enddo
-          !==========================================================================!    
-          case default !case( 'zmat','zmatrix' )
-              if(pr)then
-               write(*,'(1x,a)')'Using ZMATRIX as descriptors:'
-             endif
-           !>-- dihedral angles  
-             mn = ntaken - 3 !>--- first three dihedral angles are zero
-             mn = min(mm,mn) !>--- no more descriptors than structures for SVD!
-             if(mn < 1)then !> we need at least 2 dihedral angles, and therefore 5 descriptors
-                if(pr)then
-                    write(*,*) "Not enough descriptors for PCA!"
-                    return
-                endif
-             endif
-             allocate(measure(mn,mm),pc(mn),pcvec(mm,mn))
-             allocate(geo(3,ntaken), source = 0.0d0)
-             allocate(na(ntaken),nb(ntaken),nc(ntaken))
-             do i=1,mm
-               na = 0; nb = 0; nc = 0
-               geo=0.0d0
-               call xyzint(xyznew(1:3,1:ntaken,i),ntaken,na,nb,nc,rad,geo)
-               do j=1,mn
-                  k=j+3
-                  measure(j,i) = geo(3,k)
-               enddo
-             enddo
-             deallocate(nc,nb,na,geo)
-          !=========================================================================!   
-          case( 'dihedral' )   
-              mn = min(mm,ntaken) !>--- no more descriptors than structures for SVD!
-              allocate(measure(mn,mm),diedr(ndied))
-              if(pr)then
-                write(*,'(1x,a)') 'Using DIHEDRAL ANGLES as descriptors:' 
-                do i=1,mn
-                   write(*,'(1x,a,4i6)') 'Atoms: ',diedat(1:4,i)
-                enddo
-                write(*,*)
-              endif   
-              do i=1,mm
-                call calc_dieders(zens%nat,zens%xyz(:,:,i),ndied,diedat,diedr)
-                do j=1,mn
-                !   if(i<5 .and. pr)then
-                !   write(*,'(1x,4i6,1x,f8.2)') diedat(1:4,j),diedr(j)
-                !   endif
-                   measure(j,i) = diedr(j)
-                enddo
-              enddo
-              if(allocated(diedat)) deallocate(diedat)
-              if(allocated(diedr)) deallocate(diedr)    
-              allocate(pc(mn),pcvec(mm,mn))
-      !=====================================================!       
-          end select
-      !=====================================================!    
-          if(pr)then
-              write(*,*)
-              write(*,'(1x,a,i0,a,i0,a)') 'Performing SVD for ', & 
-        &          mm,' structures and ',mn,' props'
-          endif
-      !>--- do the SVD  ! MM must not be smaller than MN !
-          call SVD_to_PC(measure,mm,mn,pc,pcvec,.false.)
+  if (ntaken > 3) then !> all of this only makes sense if we have something to compare
+    call ctimer%start(1,'PCA')
+    if (pr) then
+      write (*,*)
+      call smallhead('PRINCIPAL COMPONENT ANALYSIS')
+    end if
+    !mm = zens%nall
+    mm = nallnew
+    select case (measuretype)
+      !==========================================================================!
+    case ('cma','CMA','cmadist')
+      if (pr) then
+        write (*,'(1x,a)') 'Using CMA DISTANCES as descriptors:'
+      end if
+      !>-- all structures should have been shifted to the CMA by CREGEN
+      !>   therefore assume the CMA is at (0,0,0).
+      !>   somewhat robust measure, but provides less information.
+      mn = min(ntaken,mm)
+      allocate (measure(mn,mm),pc(mn),pcvec(mm,mn))
+      do i = 1,mm
+        do j = 1,mn
+          measure(j,i) = xyznew(1,j,i)**2+ &
+       &                 xyznew(2,j,i)**2+ &
+       &                 xyznew(3,j,i)**2
+          measure(j,i) = sqrt(measure(j,i))
+        end do
+      end do
+      !==========================================================================!
+    case ('cartesian','coords')
+      if (pr) then
+        write (*,'(1x,a)') 'Using CARTESIAN COORDINATES as descriptors:'
+      end if
+      !>-- all Cartesian components of the selected atoms
+      !>   REQUIRES PERFECT ALIGNMENT(!), hence not very robust
+      mn = min(ntaken*3,mm)
+      allocate (measure(mn,mm),pc(mn),pcvec(mm,mn))
+      do i = 1,mm
+        l = 0
+        do j = 1,ntaken
+          do k = 1,3
+            l = l+1
+            measure(j,l) = xyznew(k,j,i)
+          end do
+        end do
+      end do
+      !==========================================================================!
+    case default !case( 'zmat','zmatrix' )
+      if (pr) then
+        write (*,'(1x,a)') 'Using ZMATRIX as descriptors:'
+      end if
+      !>-- dihedral angles
+      mn = ntaken-3 !>--- first three dihedral angles are zero
+      mn = min(mm,mn) !>--- no more descriptors than structures for SVD!
+      if (mn < 1) then !> we need at least 2 dihedral angles, and therefore 5 descriptors
+        if (pr) then
+          write (*,*) "Not enough descriptors for PCA!"
+          return
+        end if
+      end if
+      allocate (measure(mn,mm),pc(mn),pcvec(mm,mn))
+      allocate (geo(3,ntaken),source=0.0d0)
+      allocate (na(ntaken),nb(ntaken),nc(ntaken))
+      do i = 1,mm
+        na = 0; nb = 0; nc = 0
+        geo = 0.0d0
+        call xyzint(xyznew(1:3,1:ntaken,i),ntaken,na,nb,nc,rad,geo)
+        do j = 1,mn
+          k = j+3
+          measure(j,i) = geo(3,k)
+        end do
+      end do
+      deallocate (nc,nb,na,geo)
+      !=========================================================================!
+    case ('dihedral')
+      mn = min(mm,ntaken) !>--- no more descriptors than structures for SVD!
+      allocate (measure(mn,mm),diedr(ndied))
+      if (pr) then
+        write (*,'(1x,a)') 'Using DIHEDRAL ANGLES as descriptors:'
+        do i = 1,mn
+          write (*,'(1x,a,4i6)') 'Atoms: ',diedat(1:4,i)
+        end do
+        write (*,*)
+      end if
+      do i = 1,mm
+        call calc_dieders(zens%nat,zens%xyz(:,:,i),ndied,diedat,diedr)
+        do j = 1,mn
+          !   if(i<5 .and. pr)then
+          !   write(*,'(1x,4i6,1x,f8.2)') diedat(1:4,j),diedr(j)
+          !   endif
+          measure(j,i) = diedr(j)
+        end do
+      end do
+      if (allocated(diedat)) deallocate (diedat)
+      if (allocated(diedr)) deallocate (diedr)
+      allocate (pc(mn),pcvec(mm,mn))
+      !=====================================================!
+    end select
+    !=====================================================!
+    if (pr) then
+      write (*,*)
+      write (*,'(1x,a,i0,a,i0,a)') 'Performing SVD for ', &
+&          mm,' structures and ',mn,' props'
+    end if
+    !>--- do the SVD  ! MM must not be smaller than MN !
+    call SVD_to_PC(measure,mm,mn,pc,pcvec,.false.)
 !=========================================================================================!
-          call ctimer%stop(1)
-      else
-         write(*,*)'There are not enough descriptors for a PCA!'
-         write(*,*)'Taking all structures as representative and writing ',clusterfile
-         open(newunit=ich,file=clusterfile)
-         do i=1,zens%nall
-            dum = zens%er(i)
-            call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,i),dum)
-         enddo
-         close(ich)
-         return
-      endif
+    call ctimer%stop(1)
+  else
+    write (*,*) 'There are not enough descriptors for a PCA!'
+    write (*,*) 'Taking all structures as representative and writing ',clusterfile
+    open (newunit=ich,file=clusterfile)
+    do i = 1,zens%nall
+      dum = zens%er(i)
+      call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,i),dum)
+    end do
+    close (ich)
+    return
+  end if
 !========================================================================================!
-      if(allocated(measure))deallocate(measure)
-      if(allocated(xyznew))deallocate(xyznew)
-      if(allocated(inc))deallocate(inc)
+  if (allocated(measure)) deallocate (measure)
+  if (allocated(xyznew)) deallocate (xyznew)
+  if (allocated(inc)) deallocate (inc)
 
-      !>--- normalize PC eigenvalues
-      pcsum = sum(pc)
-      pc = pc / pcsum
-      !>--- get the contributing principal components
-      pcsum=0.0d0
-      npc = 0
-      do i=1,mn
-         if(pc(i) < pcmin) exit
-         pcsum = pcsum + pc(i)
-         npc = npc + 1
-         if(pcsum .ge. pcthr) exit
-      enddo
-      !npc = max(npc,2) !>-- at least 2 principal components should be used
-      npc = min(npc,pccap)
-      pcsum=0.0d0
-      do i=1,npc
-         pcsum = pcsum + pc(i)
-      enddo
+  !>--- normalize PC eigenvalues
+  pcsum = sum(pc)
+  pc = pc/pcsum
+  !>--- get the contributing principal components
+  pcsum = 0.0d0
+  npc = 0
+  do i = 1,mn
+    if (pc(i) < pcmin) exit
+    pcsum = pcsum+pc(i)
+    npc = npc+1
+    if (pcsum .ge. pcthr) exit
+  end do
+  !npc = max(npc,2) !>-- at least 2 principal components should be used
+  npc = min(npc,pccap)
+  pcsum = 0.0d0
+  do i = 1,npc
+    pcsum = pcsum+pc(i)
+  end do
 
-      if(pr)then
-        i = min(100,MM)  
-        k = min(npc,6)
-        write(*,*)
-        call smallhead('EIGENVECTORS AND NORMALIZED EIGENVALUES OF SVD ANALYIS')
-        call PRMAT(6,pcvec,i,k,'Eigenvectors of principal components')
-        write(*,'(1x,a,i0,a)')'NOTE: eigenvectors are only shown for the first ',i,' structures'
-        write(*,'(1x,a,i0,a)')'      and the first ',k,' contributing principal components.'       
-        write(*,*)
+  if (pr) then
+    i = min(100,MM)
+    k = min(npc,6)
+    write (*,*)
+    call smallhead('EIGENVECTORS AND NORMALIZED EIGENVALUES OF SVD ANALYIS')
+    call PRMAT(6,pcvec,i,k,'Eigenvectors of principal components')
+    write (*,'(1x,a,i0,a)') 'NOTE: eigenvectors are only shown for the first ',i,' structures'
+    write (*,'(1x,a,i0,a)') '      and the first ',k,' contributing principal components.'
+    write (*,*)
 
-        write(*,*) mn,'principal component eigenvalues (normalized)'
-        write(*,*) pc
-        !call PRMAT(6,pc,mn,1,'Principal components (eigenvalues)')
-        write(*,*)
-        write(*,'(1x,a,i0,a,f6.2,a)')  'The first ',npc,' components account for a total of ',100.d0*pcsum,'% of the'
-        write(*,'(1x,a)') 'ensembles unique structural features and are used for the clustering'  
-      endif
+    write (*,*) mn,'principal component eigenvalues (normalized)'
+    write (*,*) pc
+    !call PRMAT(6,pc,mn,1,'Principal components (eigenvalues)')
+    write (*,*)
+    write (*,'(1x,a,i0,a,f6.2,a)') 'The first ',npc,' components account for a total of ',100.d0*pcsum,'% of the'
+    write (*,'(1x,a)') 'ensembles unique structural features and are used for the clustering'
+  end if
 
-      !>--- use some less memory and rearrange the eigenvectors (COLUMNS AND ROWS ARE SWAPPED)
-      !>    untaken PCs are not considered further
-      allocate(pcdum(npc,mm))
-      do i=1,mm
-         pcdum(1:npc,i) = pcvec(i,1:npc)
-      enddo
-      call move_alloc(pcdum,pcvec)  !>THIS CHANGES THE SHAPE OF pcvec (COLUMNS AND ROWS ARE SWAPPED)
+  !>--- use some less memory and rearrange the eigenvectors (COLUMNS AND ROWS ARE SWAPPED)
+  !>    untaken PCs are not considered further
+  allocate (pcdum(npc,mm))
+  do i = 1,mm
+    pcdum(1:npc,i) = pcvec(i,1:npc)
+  end do
+  call move_alloc(pcdum,pcvec)  !>THIS CHANGES THE SHAPE OF pcvec (COLUMNS AND ROWS ARE SWAPPED)
 
 !=========================================================!
 ! do the Clustering
-!=========================================================! 
+!=========================================================!
 
-      if(pr)then
-        write(*,*)
-        call smallhead('CLUSTERING ANALYSIS OF PRINCIPAL COMPONENTS')
-      endif
+  if (pr) then
+    write (*,*)
+    call smallhead('CLUSTERING ANALYSIS OF PRINCIPAL COMPONENTS')
+  end if
 
-      allocate(member(mm), source=0)
+  allocate (member(mm),source=0)
 
-      !>--- get Euclidean distances (packed matrix) between all structures
-      !> ndist = (mm*(mm+1))/2 ! overflows for large ensembles
-      ndist=mm
-      ndist=ndist*(mm+1)
-      ndist=ndist/2
-      allocate(dist(ndist), source = 0.0_sp)
-      allocate(p(npc),q(npc), source = 0.0_ap)
+  !>--- get Euclidean distances (packed matrix) between all structures
+  !> ndist = (mm*(mm+1))/2 ! overflows for large ensembles
+  ndist = mm
+  ndist = ndist*(mm+1)
+  ndist = ndist/2
+  allocate (dist(ndist),source=0.0_sp)
+  allocate (p(npc),q(npc),source=0.0_ap)
 
-      do i=1,mm
-         p(1:npc) = pcvec(1:npc,i)
+  do i = 1,mm
+    p(1:npc) = pcvec(1:npc,i)
 !$OMP PARALLEL PRIVATE ( j, klong, q, dum ) &
 !$OMP SHARED ( i, dist, npc, p, pcvec )
 !$OMP DO
-         do j=1,i
-            q(1:npc) = pcvec(1:npc,j)
-            dum = eucdist(npc,p,q)
-            klong = lina(i,j)
-            dist(klong) = real(dum, sp)
-         enddo
+    do j = 1,i
+      q(1:npc) = pcvec(1:npc,j)
+      dum = eucdist(npc,p,q)
+      klong = lina(i,j)
+      dist(klong) = real(dum,sp)
+    end do
 !$OMP END DO
-!$OMP END PARALLEL         
-      enddo
+!$OMP END PARALLEL
+  end do
 
-      !>-- NOTE
-      !>-- different clustering algorithms exist, but what is common
-      !>-- among them is, that no optimal number of clusters is known
-      !>-- at the beginning. The lower bound for the number of
-      !>-- clusters is the number of investigated PCs, the upper
-      !>-- bound is the number of structures
-      if(pr)then
-          select case(clusteralgo)
-            case( 'means','kmeans' )
-             write(*,'(1x,a)') 'Using a MEANS cluster algorithm.'
-          end select
-          write(*,'(1x,a)')'For a good review of cluster algorithms see'
-          write(*,'(1x,a)')'JCTC, 2007, 3, 2312 (doi.org/10.1021/ct700119m)'
-          write(*,*)
-          write(*,'(1x,a)') 'DBI = Davies-Bouldin index'
-          write(*,'(1x,a)') 'pSF = pseudo F-statistic'
-          write(*,'(1x,a)') 'SSR/SST = ratio of explained and unexplained variation'
-          write(*,*)
-          write(*,'(1x,a8,4x,a14,4x,a14,4x,a14)') 'Nclust','DBI','pSF','SSR/SST'
-          write(*,'(1x,a8,4x,a14,4x,a14,4x,a14)') '------','-------------','-------------','-------------'
-      endif
+  !>-- NOTE
+  !>-- different clustering algorithms exist, but what is common
+  !>-- among them is, that no optimal number of clusters is known
+  !>-- at the beginning. The lower bound for the number of
+  !>-- clusters is the number of investigated PCs, the upper
+  !>-- bound is the number of structures
+  if (pr) then
+    select case (clusteralgo)
+    case ('means','kmeans')
+      write (*,'(1x,a)') 'Using a MEANS cluster algorithm.'
+    end select
+    write (*,'(1x,a)') 'For a good review of cluster algorithms see'
+    write (*,'(1x,a)') 'JCTC, 2007, 3, 2312 (doi.org/10.1021/ct700119m)'
+    write (*,*)
+    write (*,'(1x,a)') 'DBI = Davies-Bouldin index'
+    write (*,'(1x,a)') 'pSF = pseudo F-statistic'
+    write (*,'(1x,a)') 'SSR/SST = ratio of explained and unexplained variation'
+    write (*,*)
+    write (*,'(1x,a8,4x,a14,4x,a14,4x,a14)') 'Nclust','DBI','pSF','SSR/SST'
+    write (*,'(1x,a8,4x,a14,4x,a14,4x,a14)') '------','-------------','-------------','-------------'
+  end if
 
 !-----------------------------------------------------------------------!
 ! Cluster evaluation settings
 !-----------------------------------------------------------------------!
-      if(env%maxcluster == 0 )then
-         !nclustmax=100  !some random default value
-         call clustleveval(env,nclustmax,csthr,SSRSSTthr) ! defaults
-         nclustmax=min(mm,nclustmax)
-         !SSRSSTthr=0.90  !exit if this value is reached  for SSR/SST
-      else  
-         nclustmax=max(2,env%maxcluster)  !no less than 2 clusters
-         nclustmax=min(mm,env%maxcluster) !there cannot be more clustes than structures.
-      endif
-      if(env%nclust == 0)then
-          nclustmin = 1
-      else
-      !>-- predefined number of clusters    
-          nclust =min(mm,env%nclust)
-          nclustmin = nclust
-          nclustmax = nclust   
-      endif
+  if (env%maxcluster == 0) then
+    !nclustmax=100  !some random default value
+    call clustleveval(env,nclustmax,csthr,SSRSSTthr) ! defaults
+    nclustmax = min(mm,nclustmax)
+    !SSRSSTthr=0.90  !exit if this value is reached  for SSR/SST
+  else
+    nclustmax = max(2,env%maxcluster)  !no less than 2 clusters
+    nclustmax = min(mm,env%maxcluster) !there cannot be more clustes than structures.
+  end if
+  if (env%nclust == 0) then
+    nclustmin = 1
+  else
+    !>-- predefined number of clusters
+    nclust = min(mm,env%nclust)
+    nclustmin = nclust
+    nclustmax = nclust
+  end if
 
-      allocate(statistics(3,nclustmax) ,source =0.0d0)
-      CLUSTERSIZES : do nclustiter=nclustmin,nclustmax
+  allocate (statistics(3,nclustmax),source=0.0d0)
+  CLUSTERSIZES: do nclustiter = nclustmin,nclustmax
 
-        !>-- regular case: test continuous cluster sizes
-        nclust = nclustiter
-        !>-- special case: test cluster sizes incrementally (good for large ensembles)
-        if( env%clustlev >= 10 )then
-            dum = float(mm)/float(nclustmax)
-            dum2= dum * float(nclustiter)
-            nclust = nint(dum2)
-        endif
+    !>-- regular case: test continuous cluster sizes
+    nclust = nclustiter
+    !>-- special case: test cluster sizes incrementally (good for large ensembles)
+    if (env%clustlev >= 10) then
+      dum = float(mm)/float(nclustmax)
+      dum2 = dum*float(nclustiter)
+      nclust = nint(dum2)
+    end if
 
-        allocate(centroid(npc,nclust), source = 0.0_ap)
-        centroid = 0.0_ap
+    allocate (centroid(npc,nclust),source=0.0_ap)
+    centroid = 0.0_ap
 
-        select case(clusteralgo)
-          case( 'means','kmeans' )
-          call ctimer%start(2,'k-Means clustering')    
-          call kmeans(nclust,npc,mm,centroid,pcvec,ndist,dist,member)
-          call ctimer%stop(2)
-        end select
+    select case (clusteralgo)
+    case ('means','kmeans')
+      call ctimer%start(2,'k-Means clustering')
+      call kmeans(nclust,npc,mm,centroid,pcvec,ndist,dist,member)
+      call ctimer%stop(2)
+    end select
 
-        call ctimer%start(3,'statistics')
-        call cluststat(nclust,npc,mm,centroid,pcvec,member,DBI,pSF,SSRSST)
-        if(pr)then
-            write(*,'(1x,i8,4x,f14.6,4x,f14.6,4x,f14.6)')nclust,DBI,pSF,SSRSST
-        endif
-        call ctimer%stop(3)
-        deallocate(centroid)
+    call ctimer%start(3,'statistics')
+    call cluststat(nclust,npc,mm,centroid,pcvec,member,DBI,pSF,SSRSST)
+    if (pr) then
+      write (*,'(1x,i8,4x,f14.6,4x,f14.6,4x,f14.6)') nclust,DBI,pSF,SSRSST
+    end if
+    call ctimer%stop(3)
+    deallocate (centroid)
 
-        statistics(1,nclust) = DBI
-        statistics(2,nclust) = pSF
-        statistics(3,nclust) = SSRSST
+    statistics(1,nclust) = DBI
+    statistics(2,nclust) = pSF
+    statistics(3,nclust) = SSRSST
 
-        if(nclust==env%nclust) exit
-        if(SSRSST > SSRSSTthr) exit
-      enddo CLUSTERSIZES
-      if(allocated(centroid))deallocate(centroid)
+    if (nclust == env%nclust) exit
+    if (SSRSST > SSRSSTthr) exit
+  end do CLUSTERSIZES
+  if (allocated(centroid)) deallocate (centroid)
 
-      write(*,*)
-      if(env%nclust == 0)then
-         if(pr)then 
-         write(*,'(1x,a,i0,a)') 'Ensemble checked up to a partitioning into ',nclust,' clusters.'
-         write(*,'(1x,a)') 'Local MINIMA of the DBI indicate adequate cluster counts.'
-         write(*,'(1x,a)') 'Local MAXIMA of the pSF indicate adequate cluster counts.'
-         write(*,'(1x,a)') 'Higher SSR/SST vaules indicate more distinct clusters.'
-         write(*,'(1x,a)') 'Analyzing statistical values ...'
-         endif
-         k=nclust
-         allocate(extrema(2,k))
-         call ctimer%start(3,'statistics')
-         call statanal(k,nclustmax,statistics,extrema,pr)
-         if(pr)  call statwarning(fname)
-     !>-- determine a suggested cluster size (smallest suggested cluster with good SSR/SST)
-         do i=2,k    
-            if((extrema(1,i).or.extrema(2,i)).and.(statistics(3,i) > csthr))then
-                nclust=i
-                exit
-            endif
-         enddo
-         call ctimer%stop(3)
-         deallocate(extrema)
-         if(pr)then
-           write(*,*)
-           write(*,'(1x,a,f4.2,a,i0)') 'Suggested (SSR/SST >',csthr,') cluster count: ',nclust
-         endif
-     !>-- calculate the determined partition into clusters again for final file
-         allocate(centroid(npc,nclust), source = 0.0_ap)
-         select case(clusteralgo)
-          case( 'means','kmeans' )
-          call ctimer%start(2,'k-Means clustering')
-          call kmeans(nclust,npc,mm,centroid,pcvec,ndist,dist,member)
-          call ctimer%stop(2)
-         end select
-         deallocate(centroid)
-      else
-         if(pr)then 
-         write(*,'(1x,a,i0,a)') 'Ensemble partitioning into ',nclust,' clsuters.'
-         endif
-      endif    
-      deallocate(statistics)    
+  write (*,*)
+  if (env%nclust == 0) then
+    if (pr) then
+      write (*,'(1x,a,i0,a)') 'Ensemble checked up to a partitioning into ',nclust,' clusters.'
+      write (*,'(1x,a)') 'Local MINIMA of the DBI indicate adequate cluster counts.'
+      write (*,'(1x,a)') 'Local MAXIMA of the pSF indicate adequate cluster counts.'
+      write (*,'(1x,a)') 'Higher SSR/SST vaules indicate more distinct clusters.'
+      write (*,'(1x,a)') 'Analyzing statistical values ...'
+    end if
+    k = nclust
+    allocate (extrema(2,k))
+    call ctimer%start(3,'statistics')
+    call statanal(k,nclustmax,statistics,extrema,pr)
+    if (pr) call statwarning(fname)
+    !>-- determine a suggested cluster size (smallest suggested cluster with good SSR/SST)
+    do i = 2,k
+      if ((extrema(1,i).or.extrema(2,i)).and.(statistics(3,i) > csthr)) then
+        nclust = i
+        exit
+      end if
+    end do
+    call ctimer%stop(3)
+    deallocate (extrema)
+    if (pr) then
+      write (*,*)
+      write (*,'(1x,a,f4.2,a,i0)') 'Suggested (SSR/SST >',csthr,') cluster count: ',nclust
+    end if
+    !>-- calculate the determined partition into clusters again for final file
+    allocate (centroid(npc,nclust),source=0.0_ap)
+    select case (clusteralgo)
+    case ('means','kmeans')
+      call ctimer%start(2,'k-Means clustering')
+      call kmeans(nclust,npc,mm,centroid,pcvec,ndist,dist,member)
+      call ctimer%stop(2)
+    end select
+    deallocate (centroid)
+  else
+    if (pr) then
+      write (*,'(1x,a,i0,a)') 'Ensemble partitioning into ',nclust,' clsuters.'
+    end if
+  end if
+  deallocate (statistics)
 
-      deallocate(q,p,dist)
-      !>-- finally, assign a representative structure to each group (based on lowest energy)
-      !>-- and write the new ensemble file
-      call PCA_grpwrite(nclust,npc,mm,pcvec,member)
+  deallocate (q,p,dist)
+  !>-- finally, assign a representative structure to each group (based on lowest energy)
+  !>-- and write the new ensemble file
+  call PCA_grpwrite(nclust,npc,mm,pcvec,member)
 
-      !ncb=maxval(member,1) !--total number of cluster
-      ncb = nclust
-      ancb = ncb           !>--actual number of clusters
+  !ncb=maxval(member,1) !--total number of cluster
+  ncb = nclust
+  ancb = ncb           !>--actual number of clusters
 
-      if(ancb.le.1) return
+  if (ancb .le. 1) return
 
-      if(pr)then
-          write(*,*)
-          write(*,'(1x,a)')'Representative structures'
-          write(*,'(1x,a6,1x,a6,3x,a6,1x,a16,1x,a16)')'Nr.','conf.','clust.','Etot/Eh','Erel/ kcal/mol'
-          write(*,'(1x,a6,1x,a6,3x,a6,1x,a16,1x,a16)')'---','-----','------','-------','--------------'
-      endif
-      allocate(eclust(ncb),source = 0.0d0)
-      allocate(clustbest(ncb), ind(ncb), source = 0)
-      do i=1,ncb
-          ind(i) = i
-          c = 0
-          do j=1,mm
-             if(member(j) == i)then
-                 c = c + 1
-                 if(zens%er(j)<eclust(i))then
-                     eclust(i) = zens%er(j)
-                     clustbest(i) = j
-                 endif
-             endif
-          enddo
-          !>-- if there are clusters without structures 
-          if(c == 0 )then
-              clustbest(i) = -1
-              ancb = ancb - 1
-          endif
-      enddo
-      call qsort(eclust, 1, ncb, ind)
-      emin=minval(eclust,1)
-      open(newunit=ich, file=clusterfile)
-      do i=1,ncb
-        k=clustbest(ind(i))
-        if(k > 0)then
-         dum = zens%er(k)
-         call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,k),dum)
-         if(pr)then
-         erel= (dum - emin)*kcal
-         write(*,'(1x,i6,1x,i6,3x,i6,1x,f16.8,1x,f16.4)')i,k,member(k),dum,erel
-         endif
-        endif
-      enddo
-      close(ich)
-      if(pr)then
-         write(*,'(/,1x,a)')'(The "clust." column refers to the cluster "name")'
-         write(*,*)
-         write(*,'(1x,a,a,a,i0,a)') 'File ',clusterfile,' written with ',ancb,' representative structures.'
-         if(ancb < ncb)then
-           write(*,'(1x,a,i0,a)') '(',ncb-ancb,' clusters discarded due to cluster merge)'
-         endif
-      endif
-      call zens%deallocate()
+  if (pr) then
+    write (*,*)
+    write (*,'(1x,a)') 'Representative structures'
+    write (*,'(1x,a6,1x,a6,3x,a6,1x,a16,1x,a16)') 'Nr.','conf.','clust.','Etot/Eh','Erel/ kcal/mol'
+    write (*,'(1x,a6,1x,a6,3x,a6,1x,a16,1x,a16)') '---','-----','------','-------','--------------'
+  end if
+  allocate (eclust(ncb),source=0.0d0)
+  allocate (clustbest(ncb),ind(ncb),source=0)
+  do i = 1,ncb
+    ind(i) = i
+    c = 0
+    do j = 1,mm
+      if (member(j) == i) then
+        c = c+1
+        if (zens%er(j) < eclust(i)) then
+          eclust(i) = zens%er(j)
+          clustbest(i) = j
+        end if
+      end if
+    end do
+    !>-- if there are clusters without structures
+    if (c == 0) then
+      clustbest(i) = -1
+      ancb = ancb-1
+    end if
+  end do
+  call qsort(eclust,1,ncb,ind)
+  emin = minval(eclust,1)
+  open (newunit=ich,file=clusterfile)
+  do i = 1,ncb
+    k = clustbest(ind(i))
+    if (k > 0) then
+      dum = zens%er(k)
+      call wrxyz(ich,zens%nat,zens%at,zens%xyz(:,:,k),dum)
+      if (pr) then
+        erel = (dum-emin)*kcal
+        write (*,'(1x,i6,1x,i6,3x,i6,1x,f16.8,1x,f16.4)') i,k,member(k),dum,erel
+      end if
+    end if
+  end do
+  close (ich)
+  if (pr) then
+    write (*,'(/,1x,a)') '(The "clust." column refers to the cluster "name")'
+    write (*,*)
+    write (*,'(1x,a,a,a,i0,a)') 'File ',clusterfile,' written with ',ancb,' representative structures.'
+    if (ancb < ncb) then
+      write (*,'(1x,a,i0,a)') '(',ncb-ancb,' clusters discarded due to cluster merge)'
+    end if
+  end if
+  call zens%deallocate()
 
-      if(pr)then
-      write(*,*)    
-      !write(*,'(1x,a)') 'Timings:'    
-      !call eval_sub_timer(ctimer)
-      call ctimer%write(stdout, 'PCA/k-Means clustering')
-      endif
-      call ctimer%clear()
-      return
+  if (pr) then
+    write (*,*)
+    !write(*,'(1x,a)') 'Timings:'
+    !call eval_sub_timer(ctimer)
+    call ctimer%write(stdout,'PCA/k-Means clustering')
+  end if
+  call ctimer%clear()
+  return
 end subroutine CCEGEN
 
 !=======================================================================================!
 ! set clustering level defaults
 !=======================================================================================!
 subroutine clustleveval(env,maxclust,csthr,SSRSSTthr)
-      use crest_parameters, idp => dp 
-      use crest_data
-      implicit none
-      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
-      integer :: clev
-      integer :: maxclust
-      real(wp) :: csthr
-      real(wp) :: SSRSSTthr
+  use crest_parameters,idp => dp
+  use crest_data
+  implicit none
+  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
+  integer :: clev
+  integer :: maxclust
+  real(wp) :: csthr
+  real(wp) :: SSRSSTthr
 
-      SSRSSTthr=0.90  !exit if this value is reached  for SSR/SST
+  SSRSSTthr = 0.90  !exit if this value is reached  for SSR/SST
 
-      clev = env%clustlev
-      if(env%clustlev >= 10)then  !for incremental modes
-          clev = env%clustlev -10
-      endif
+  clev = env%clustlev
+  if (env%clustlev >= 10) then  !for incremental modes
+    clev = env%clustlev-10
+  end if
 
-      select case( clev )
-         case( -1 ) !-- loose
-             maxclust=25
-             csthr=0.80d0
-         case( 1 )  !-- tight
-             maxclust=400
-             if(env%clustlev >= 10) maxclust=50
-             csthr=0.85d0
-         case( 2 )  !-- vtight
-             maxclust=400
-             if(env%clustlev >= 10) maxclust=100
-             csthr=0.9d0
-             SSRSSTthr=0.92d0    
-         case default !-- normal
-             maxclust=100
-             if(env%clustlev >= 10) maxclust=25
-             csthr=0.80d0
-      end select
+  select case (clev)
+  case (-1) !-- loose
+    maxclust = 25
+    csthr = 0.80d0
+  case (1)  !-- tight
+    maxclust = 400
+    if (env%clustlev >= 10) maxclust = 50
+    csthr = 0.85d0
+  case (2)  !-- vtight
+    maxclust = 400
+    if (env%clustlev >= 10) maxclust = 100
+    csthr = 0.9d0
+    SSRSSTthr = 0.92d0
+  case default !-- normal
+    maxclust = 100
+    if (env%clustlev >= 10) maxclust = 25
+    csthr = 0.80d0
+  end select
 
-      return
+  return
 end subroutine clustleveval
 
 !=======================================================================================!
@@ -739,336 +737,337 @@
 ! and the cluster to which the structure belongs
 !=======================================================================================!
 subroutine PCA_grpwrite(nclust,npc,mm,pcvec,member)
-    use crest_parameters, idp => dp 
-    implicit none
-    integer,intent(in) :: nclust  ! number of required centroids
-    integer,intent(in) :: npc,mm
-    real(wp),intent(in) :: pcvec(npc,mm)
-    integer,intent(in) :: member(mm)  ! membership for each structure
-    integer :: ich,i
-    open(newunit=ich,file='cluster.order')
-    write(ich,'(4x,i0,4x,i0,4x,i0)') mm,nclust,npc
-    if(npc>1)then
-    do i=1,mm
-       write(ich,'(i8,1x,f16.8,1x,f16.8,1x,i8)') i,pcvec(1,i),pcvec(2,i),member(i)
-    enddo
-    else
-    do i=1,mm
-       write(ich,'(i8,1x,f16.8,1x,i8)') i,pcvec(1,i),member(i)
-    enddo
-    endif
-    close(ich)
-    return
+  use crest_parameters,idp => dp
+  implicit none
+  integer,intent(in) :: nclust  ! number of required centroids
+  integer,intent(in) :: npc,mm
+  real(wp),intent(in) :: pcvec(npc,mm)
+  integer,intent(in) :: member(mm)  ! membership for each structure
+  integer :: ich,i
+  open (newunit=ich,file='cluster.order')
+  write (ich,'(4x,i0,4x,i0,4x,i0)') mm,nclust,npc
+  if (npc > 1) then
+    do i = 1,mm
+      write (ich,'(i8,1x,f16.8,1x,f16.8,1x,i8)') i,pcvec(1,i),pcvec(2,i),member(i)
+    end do
+  else
+    do i = 1,mm
+      write (ich,'(i8,1x,f16.8,1x,i8)') i,pcvec(1,i),member(i)
+    end do
+  end if
+  close (ich)
+  return
 end subroutine PCA_grpwrite
 
 !=======================================================================================!
 ! Exclude light - exclude H atoms in the inc array
 !=======================================================================================!
 subroutine excludeLight(zmol,inc)
-      use crest_parameters, idp => dp 
-      use zdata
-      implicit none
-      type(zmolecule) :: zmol
-      integer :: inc(zmol%nat)
-      integer :: i
-      do i=1,zmol%nat
-         if(zmol%at(i) == 1 )then
-             inc(i) = 0
-         endif
-      enddo
-      return
-end subroutine excludeLight    
+  use crest_parameters,idp => dp
+  use zdata
+  implicit none
+  type(zmolecule) :: zmol
+  integer :: inc(zmol%nat)
+  integer :: i
+  do i = 1,zmol%nat
+    if (zmol%at(i) == 1) then
+      inc(i) = 0
+    end if
+  end do
+  return
+end subroutine excludeLight
 
 !=======================================================================================!
 ! Exclude Specified Atoms
 !=======================================================================================!
 subroutine excludeSelected(zmol,inc,atlist)
-      use crest_parameters, idp => dp 
-      use zdata
-      implicit none
-      type(zmolecule) :: zmol
-      integer :: inc(zmol%nat)
-      character(len=*) :: atlist   !a string containing atom numbers, needs parsing
-      integer :: i,ncon
-      integer,allocatable :: inc2(:)
-      allocate(inc2(zmol%nat),source=0)
-      call parse_atlist_new(atlist,ncon,zmol%nat,zmol%at,inc2)
-      do i=1,zmol%nat
-         if(inc2(i)==1)inc(i)=0
-      enddo
-      deallocate(inc2)
-      return
+  use crest_parameters,idp => dp
+  use zdata
+  implicit none
+  type(zmolecule) :: zmol
+  integer :: inc(zmol%nat)
+  character(len=*) :: atlist   !a string containing atom numbers, needs parsing
+  integer :: i,ncon
+  integer,allocatable :: inc2(:)
+  allocate (inc2(zmol%nat),source=0)
+  call parse_atlist_new(atlist,ncon,zmol%nat,zmol%at,inc2)
+  do i = 1,zmol%nat
+    if (inc2(i) == 1) inc(i) = 0
+  end do
+  deallocate (inc2)
+  return
 end subroutine excludeSelected
 
 !=======================================================================================!
 ! Perform a single value decomposition (SVD) and get the principal components
-! 
+!
 ! X = U*sig*V^(T)
 !
 ! The eigenvalues saved in sig are the principal components
-! The SVD only works if M >= N 
+! The SVD only works if M >= N
 !
 !=======================================================================================!
 subroutine svd_to_pc(measure,m,n,sig,U,pr)
-      use crest_parameters, idp => dp 
-      implicit none
-      integer :: n,m
-      real(wp) :: measure(n,m)
-      real(wp) :: sig(n)
-      real(wp) :: U(m,n)
-      integer :: i,j,info,lwork
-      real(wp),allocatable :: mean(:),tmp(:)
-      integer, allocatable :: ind(:)
-      real(wp),allocatable :: X(:,:), V(:,:), work(:)
-      integer, allocatable :: iwork(:)
-      logical :: pr
-      if(pr)then
-       write(*,*)m,' mesaurements'
-       write(*,*)n,' props'
-      endif
-      allocate(mean(n),ind(m),tmp(m))
-      lwork=max(2*M+N,6*N+2*N*N)
-      allocate(X(m,n),V(n,n),iwork(m+3*n),work(lwork))
-      mean = 0.0d0
-      do i=1,m  
-         do j=1,n
-            mean(j)=mean(j)+measure(j,i)
-         enddo
-      enddo
-      mean = mean /float(m)
-      if(pr) write(*,*) mean
-      do i=1,m  
-         do j=1,n
-            X(i,j)=(mean(j)-measure(j,i))
-         enddo
-      enddo
-      if(pr)then
-         call PRMAT(6,X,m,n,'X')
-      endif
+  use crest_parameters,idp => dp
+  implicit none
+  integer :: n,m
+  real(wp) :: measure(n,m)
+  real(wp) :: sig(n)
+  real(wp) :: U(m,n)
+  integer :: i,j,info,lwork
+  real(wp),allocatable :: mean(:),tmp(:)
+  integer,allocatable :: ind(:)
+  real(wp),allocatable :: X(:,:),V(:,:),work(:)
+  integer,allocatable :: iwork(:)
+  logical :: pr
+  if (pr) then
+    write (*,*) m,' mesaurements'
+    write (*,*) n,' props'
+  end if
+  allocate (mean(n),ind(m),tmp(m))
+  lwork = max(2*M+N,6*N+2*N*N)
+  allocate (X(m,n),V(n,n),iwork(m+3*n),work(lwork))
+  mean = 0.0d0
+  do i = 1,m
+    do j = 1,n
+      mean(j) = mean(j)+measure(j,i)
+    end do
+  end do
+  mean = mean/float(m)
+  if (pr) write (*,*) mean
+  do i = 1,m
+    do j = 1,n
+      X(i,j) = (mean(j)-measure(j,i))
+    end do
+  end do
+  if (pr) then
+    call PRMAT(6,X,m,n,'X')
+  end if
 !>--- LAPACKs' DGEJSV
-      call DGEJSV ( 'C' , 'U' , 'V' , 'N' , 'N' , 'N' , &
-     &              m,n,X,m,sig,U,m,V,n,                &
-     &              WORK, LWORK, IWORK, INFO )
-      if(pr)then
-        write(*,*) info
-        write(*,*) sig
-        call PRMAT(6,U**2,M,N,'U')
-        call PRMAT(6,V,N,N,'V')
-      endif
-      deallocate(work,iwork,V,X,tmp,ind,mean)
-      return
+  call DGEJSV('C','U','V','N','N','N', &
+ &              m,n,X,m,sig,U,m,V,n,                &
+ &              WORK,LWORK,IWORK,INFO)
+  if (pr) then
+    write (*,*) info
+    write (*,*) sig
+    call PRMAT(6,U**2,M,N,'U')
+    call PRMAT(6,V,N,N,'V')
+  end if
+  deallocate (work,iwork,V,X,tmp,ind,mean)
+  return
 end subroutine svd_to_pc
 
 !======================================================================!
 ! calculate the Euclidian distance between two points p and q
 !======================================================================!
 function eucdist(ndim,p,q) result(dist)
-     use crest_parameters, idp => dp 
-     implicit none
-     real(ap) :: dist
-     integer :: ndim
-     real(ap) :: p(ndim)
-     real(ap) :: q(ndim)
-     integer :: i
-     dist=0.0d0
-     do i=1,ndim
-        dist=dist + (q(i)-p(i))**2
-     enddo
-     dist=sqrt(dist)
-     return
-end function eucdist    
+  use crest_parameters,idp => dp
+  implicit none
+  real(ap) :: dist
+  integer :: ndim
+  real(ap) :: p(ndim)
+  real(ap) :: q(ndim)
+  integer :: i
+  dist = 0.0d0
+  do i = 1,ndim
+    dist = dist+(q(i)-p(i))**2
+  end do
+  dist = sqrt(dist)
+  return
+end function eucdist
 
 !======================================================================!
 ! K-means clustering algorithm
 !
 ! determine a position of cluster centroids iteratively for a given
 ! number of centroids.
-! 
+!
 !======================================================================!
 subroutine kmeans(nclust,npc,mm,centroid,pcvec,ndist,dist,member)
-    use crest_parameters, idp => dp 
-    implicit none
-    integer,intent(in) :: nclust  ! number of required centroids
-    integer,intent(in) :: npc,mm
-    real(wp),intent(in) :: pcvec(npc,mm)
-    integer(idp),intent(in) :: ndist
-    real(sp),intent(in)   :: dist(ndist)
-    integer,intent(inout) :: member(mm)  ! membership for each structure
-    real(ap),intent(inout):: centroid(npc,nclust)
-    integer,allocatable :: refmember(:)
+  use crest_parameters,idp => dp
+  implicit none
+  integer,intent(in) :: nclust  ! number of required centroids
+  integer,intent(in) :: npc,mm
+  real(wp),intent(in) :: pcvec(npc,mm)
+  integer(idp),intent(in) :: ndist
+  real(sp),intent(in)   :: dist(ndist)
+  integer,intent(inout) :: member(mm)  ! membership for each structure
+  real(ap),intent(inout):: centroid(npc,nclust)
+  integer,allocatable :: refmember(:)
 
-    if(nclust.le.1)return !no singular clusters!
+  if (nclust .le. 1) return !no singular clusters!
 
-    allocate(refmember(mm), source = 0)
+  allocate (refmember(mm),source=0)
 
-    !>-- determine seeds for the centroids (i.e., initial positions)
-    call  kmeans_seeds(nclust,npc,mm,centroid,pcvec,ndist,dist)
+  !>-- determine seeds for the centroids (i.e., initial positions)
+  call kmeans_seeds(nclust,npc,mm,centroid,pcvec,ndist,dist)
 
-    do
-    !>-- determine cluster membership for all structures 
+  do
+    !>-- determine cluster membership for all structures
     !>   (by shortest Euc. distance to the respective centroid)
-       member = 0 !reset
-       call kmeans_assign(nclust,npc,mm,centroid,pcvec,member)
+    member = 0 !reset
+    call kmeans_assign(nclust,npc,mm,centroid,pcvec,member)
 
     !>-- check if memberships changed w.r.t. previous memberships
-       if(all(member==refmember))then
-           exit
-       else
-           refmember = member
-       endif    
+    if (all(member == refmember)) then
+      exit
+    else
+      refmember = member
+    end if
     !>-- update centroids if necessary
-       call kmeans_recenter(nclust,npc,mm,centroid,pcvec,member)
-    enddo
+    call kmeans_recenter(nclust,npc,mm,centroid,pcvec,member)
+  end do
 
-    deallocate(refmember)
-    return
-end subroutine kmeans   
+  deallocate (refmember)
+  return
+end subroutine kmeans
 !===================================================================!
 ! determine cluster seeds for the K-means algo
 !===================================================================!
 subroutine kmeans_seeds(nclust,npc,mm,centroid,pcvec,ndist,dist)
-    use crest_parameters, idp => dp 
-    implicit none
-    integer :: nclust,npc,mm
-    real(ap) :: centroid(npc,nclust)
-    real(wp) :: pcvec(npc,mm)
-    integer(idp) :: ndist
-    real(sp) :: dist(ndist)
-    real(sp) :: ddum
-    integer(idp) :: k,kiter
-    integer :: i,j,l,c
-    real(wp) :: distsum,maxdistsum
-    real(ap) :: eucdist !this is a function
-    real(ap),allocatable :: p(:),q(:)
-    integer,allocatable :: taken(:)
+  use crest_parameters,idp => dp
+  use utilities
+  implicit none
+  integer :: nclust,npc,mm
+  real(ap) :: centroid(npc,nclust)
+  real(wp) :: pcvec(npc,mm)
+  integer(idp) :: ndist
+  real(sp) :: dist(ndist)
+  real(sp) :: ddum
+  integer(idp) :: k,kiter
+  integer :: i,j,l,c
+  real(wp) :: distsum,maxdistsum
+  real(ap) :: eucdist !this is a function
+  real(ap),allocatable :: p(:),q(:)
+  integer,allocatable :: taken(:)
 
-    !>--- first two centroids are located at the most apart points
-    !>    in the PC space
-    !k = maxloc(dist,1)
-    ddum=0.0_sp
-    do kiter=1,ndist
-       if(dist(kiter) > ddum)then
-          k=kiter
-       endif
-    enddo
-    call revlin(k,j,i) !> reverse of the lin function, get indices i and j
+  !>--- first two centroids are located at the most apart points
+  !>    in the PC space
+  !k = maxloc(dist,1)
+  ddum = 0.0_sp
+  do kiter = 1,ndist
+    if (dist(kiter) > ddum) then
+      k = kiter
+    end if
+  end do
+  call revlin(k,j,i) !> reverse of the lin function, get indices i and j
 
-    centroid(1:npc,1) = pcvec(1:npc,i)
-    centroid(1:npc,2) = pcvec(1:npc,j)
+  centroid(1:npc,1) = pcvec(1:npc,i)
+  centroid(1:npc,2) = pcvec(1:npc,j)
 
-    if(nclust.le.2)return !>-- if we only need two centroids, return
+  if (nclust .le. 2) return !>-- if we only need two centroids, return
 
-    !>-- If more centroids are needed, search for one point which has the maximal sum of
-    !>-- the distances between the already determined centroids and itself. 
-    allocate(p(npc),q(npc),taken(nclust))
-    taken=0
-    taken(1) = i
-    taken(2) = j
-    do i=3,nclust
-       maxdistsum = 0.0d0
-       c = 0
+  !>-- If more centroids are needed, search for one point which has the maximal sum of
+  !>-- the distances between the already determined centroids and itself.
+  allocate (p(npc),q(npc),taken(nclust))
+  taken = 0
+  taken(1) = i
+  taken(2) = j
+  do i = 3,nclust
+    maxdistsum = 0.0d0
+    c = 0
 !$OMP PARALLEL PRIVATE ( l, q, p, j, distsum ) &
-!$OMP SHARED ( i, centroid, npc, mm, maxdistsum, pcvec, c, taken ) 
+!$OMP SHARED ( i, centroid, npc, mm, maxdistsum, pcvec, c, taken )
 !$OMP DO
-       do j=1,mm
-         distsum = 0.0d0
-         p(1:npc) = pcvec(1:npc,j)
-         do l=1,i-1
-            q(1:npc) = centroid(1:npc,l)
-            distsum = distsum + eucdist(npc,p,q)
-         enddo
-         !$OMP CRITICAL
-         if(.not. any(taken==j))then
-         if(distsum .gt. maxdistsum)then
-             maxdistsum = distsum
-             c = j
-             taken(i) = c
-         endif
-         endif
-         !$OMP END CRITICAL
-       enddo
+    do j = 1,mm
+      distsum = 0.0d0
+      p(1:npc) = pcvec(1:npc,j)
+      do l = 1,i-1
+        q(1:npc) = centroid(1:npc,l)
+        distsum = distsum+eucdist(npc,p,q)
+      end do
+      !$OMP CRITICAL
+      if (.not.any(taken == j)) then
+        if (distsum .gt. maxdistsum) then
+          maxdistsum = distsum
+          c = j
+          taken(i) = c
+        end if
+      end if
+      !$OMP END CRITICAL
+    end do
 !$OMP END DO
 !$OMP END PARALLEL
-       if(c==0)then
-        exit
-       else
-        centroid(1:npc,i) = pcvec(1:npc,c)
-       endif
-    enddo   
+    if (c == 0) then
+      exit
+    else
+      centroid(1:npc,i) = pcvec(1:npc,c)
+    end if
+  end do
 
-    deallocate(taken,q,p)
+  deallocate (taken,q,p)
 
-    return
-end subroutine kmeans_seeds    
+  return
+end subroutine kmeans_seeds
 !===================================================================!
 ! assign structures as members to a centroid
 !===================================================================!
 subroutine kmeans_assign(nclust,npc,mm,centroid,pcvec,member)
-    use crest_parameters, idp => dp 
-    implicit none
-    integer :: nclust,npc,mm
-    real(ap) :: centroid(npc,nclust)
-    real(wp) :: pcvec(npc,mm)
-    integer :: member(mm)
-    real(ap) :: eucdist  !this is a function
-    integer :: i,j,c
-    real(ap),allocatable :: centdist(:)
-    real(ap),allocatable :: p(:),q(:)
+  use crest_parameters,idp => dp
+  implicit none
+  integer :: nclust,npc,mm
+  real(ap) :: centroid(npc,nclust)
+  real(wp) :: pcvec(npc,mm)
+  integer :: member(mm)
+  real(ap) :: eucdist  !this is a function
+  integer :: i,j,c
+  real(ap),allocatable :: centdist(:)
+  real(ap),allocatable :: p(:),q(:)
 
-    allocate(centdist(nclust), source = 0.0_ap)
-    allocate(p(npc),q(npc))
+  allocate (centdist(nclust),source=0.0_ap)
+  allocate (p(npc),q(npc))
 !$OMP PARALLEL PRIVATE ( i, j, p, q, c, centdist ) &
-!$OMP SHARED ( mm, nclust, member, centroid, npc, pcvec ) 
+!$OMP SHARED ( mm, nclust, member, centroid, npc, pcvec )
 !$OMP DO
-    do i=1,mm
-       p(1:npc) = pcvec(1:npc,i)
-       do j=1,nclust
-          q(1:npc) = centroid(1:npc,j)
-          centdist(j) = eucdist(npc,p,q)
-       enddo
-       c = minloc(centdist,1)
-       member(i) = c
-    enddo  
+  do i = 1,mm
+    p(1:npc) = pcvec(1:npc,i)
+    do j = 1,nclust
+      q(1:npc) = centroid(1:npc,j)
+      centdist(j) = eucdist(npc,p,q)
+    end do
+    c = minloc(centdist,1)
+    member(i) = c
+  end do
 !$OMP END DO
-!$OMP END PARALLEL    
-    deallocate(q,p)
-    deallocate(centdist)
-    return
+!$OMP END PARALLEL
+  deallocate (q,p)
+  deallocate (centdist)
+  return
 end subroutine kmeans_assign
 
 !===================================================================!
 ! re-center centroids for given (sorted) structures
 !===================================================================!
 subroutine kmeans_recenter(nclust,npc,mm,centroid,pcvec,member)
-    use crest_parameters, idp => dp 
-    implicit none
-    integer :: nclust,npc,mm
-    real(ap) :: centroid(npc,nclust)
-    real(wp) :: pcvec(npc,mm)
-    integer :: member(mm)
-    integer :: i,j,c
-    real(ap),allocatable :: p(:),q(:)
+  use crest_parameters,idp => dp
+  implicit none
+  integer :: nclust,npc,mm
+  real(ap) :: centroid(npc,nclust)
+  real(wp) :: pcvec(npc,mm)
+  integer :: member(mm)
+  integer :: i,j,c
+  real(ap),allocatable :: p(:),q(:)
 
-    allocate(p(npc),q(npc))
-    do i=1,nclust
-       c=0
-       p=0.0d0
-       do j=1,mm
-          if(member(j)==i)then
-              c=c+1
-              p(1:npc) = p(1:npc) + pcvec(1:npc,j)      
-          endif
-       enddo
-       if(c > 0)then
-         p=p/float(c)
-         centroid(1:npc,i) = p(1:npc)
-       else  
-         p=999.9d0  
-       endif
-    enddo   
-    deallocate(q,p)
+  allocate (p(npc),q(npc))
+  do i = 1,nclust
+    c = 0
+    p = 0.0d0
+    do j = 1,mm
+      if (member(j) == i) then
+        c = c+1
+        p(1:npc) = p(1:npc)+pcvec(1:npc,j)
+      end if
+    end do
+    if (c > 0) then
+      p = p/float(c)
+      centroid(1:npc,i) = p(1:npc)
+    else
+      p = 999.9d0
+    end if
+  end do
+  deallocate (q,p)
 
-    return
+  return
 end subroutine kmeans_recenter
 
 !======================================================================!
@@ -1079,284 +1078,283 @@
 ! SSR/SST ratio
 !======================================================================!
 subroutine cluststat(nclust,npc,mm,centroid,pcvec,member,DBI,pSF,SSRSST)
-    use crest_parameters, idp => dp 
-    implicit none
-    integer,intent(in) :: nclust  ! number of required centroids
-    integer,intent(in) :: npc,mm
-    real(wp),intent(in) :: pcvec(npc,mm)
-    integer,intent(in) :: member(mm)  ! membership for each structure
-    real(ap),intent(in):: centroid(npc,nclust)
-    real(wp),intent(out) :: DBI,pSF,SSRSST
-    real(wp) :: SSE,SSR,SST
-    real(ap),allocatable :: p(:),q(:)
-    real(wp),allocatable :: compact(:)
-    real(wp),allocatable :: DBmat(:,:)
-    real(ap) :: eucdist !this is a function
-    real(wp) :: d,Rij,maxDB
-    integer :: i,c,k,c2
-    
-    DBI= 0.0d0
-    pSF = 0.0d0
-    SSRSST = 0.0d0
+  use crest_parameters,idp => dp
+  implicit none
+  integer,intent(in) :: nclust  ! number of required centroids
+  integer,intent(in) :: npc,mm
+  real(wp),intent(in) :: pcvec(npc,mm)
+  integer,intent(in) :: member(mm)  ! membership for each structure
+  real(ap),intent(in):: centroid(npc,nclust)
+  real(wp),intent(out) :: DBI,pSF,SSRSST
+  real(wp) :: SSE,SSR,SST
+  real(ap),allocatable :: p(:),q(:)
+  real(wp),allocatable :: compact(:)
+  real(wp),allocatable :: DBmat(:,:)
+  real(ap) :: eucdist !this is a function
+  real(wp) :: d,Rij,maxDB
+  integer :: i,c,k,c2
+
+  DBI = 0.0d0
+  pSF = 0.0d0
+  SSRSST = 0.0d0
 
-    if(nclust<2)return
+  if (nclust < 2) return
 
-    allocate(p(npc),q(npc))
+  allocate (p(npc),q(npc))
 
-    !>-- Sum of squares error
-    SSE = 0.0d0
-    do c=1,nclust
-       p(1:npc) = centroid(1:npc,c)
-       do i=1,mm
-          if(member(i)==c)then
-              q(1:npc) = pcvec(1:npc,i)
-              d = eucdist(npc,p,q)
-              SSE = SSE + d**2
-          endif
-       enddo
-    enddo
-    SSE = SSE
+  !>-- Sum of squares error
+  SSE = 0.0d0
+  do c = 1,nclust
+    p(1:npc) = centroid(1:npc,c)
+    do i = 1,mm
+      if (member(i) == c) then
+        q(1:npc) = pcvec(1:npc,i)
+        d = eucdist(npc,p,q)
+        SSE = SSE+d**2
+      end if
+    end do
+  end do
+  SSE = SSE
 
-    !>-- Total sum of squares
-    SST = 0.0d0
-    p = 0.0d0
-    do c=1,nclust
-       p(1:npc) = p(1:npc) + centroid(1:npc,c)
-    enddo   
-    p = p/float(nclust)
-    do i=1,mm
-        q(1:npc) = pcvec(1:npc,i)
-        d = eucdist(npc,p,q)
-        SST = SST + d**2
-    enddo
-    SST = SST
+  !>-- Total sum of squares
+  SST = 0.0d0
+  p = 0.0d0
+  do c = 1,nclust
+    p(1:npc) = p(1:npc)+centroid(1:npc,c)
+  end do
+  p = p/float(nclust)
+  do i = 1,mm
+    q(1:npc) = pcvec(1:npc,i)
+    d = eucdist(npc,p,q)
+    SST = SST+d**2
+  end do
+  SST = SST
 
-    !>-- Sum of squares regression
-    SSR = SST - SSE
+  !>-- Sum of squares regression
+  SSR = SST-SSE
 
-    !>-- SSR/SST ratio
-    SSRSST = SSR / SST
+  !>-- SSR/SST ratio
+  SSRSST = SSR/SST
 
-    !>-- pseudo-F statistic
-    if(nclust>1)then
-      pSF = (SSR/(float(nclust)-1.0d0))
-      if(mm==nclust)then
-          pSF=0.0d0
-      else
-          pSF = pSF / (SSE/(float(mm) - float(nclust)))
-      endif
-    else
-      pSF = 0.0d0
-    endif  
+  !>-- pseudo-F statistic
+  if (nclust > 1) then
+    pSF = (SSR/(float(nclust)-1.0d0))
+    if (mm == nclust) then
+      pSF = 0.0d0
+    else
+      pSF = pSF/(SSE/(float(mm)-float(nclust)))
+    end if
+  else
+    pSF = 0.0d0
+  end if
 
-    !>-- Davies-Bouldin index (DBI)
-    allocate(compact(nclust),source=0.0d0) !cluster compactness
-    do c=1,nclust
-       p(1:npc) = centroid(1:npc,c)
-       k=0
-       do i=1,mm
-          if(member(i)==c)then
-              k = k + 1
-              q(1:npc) = pcvec(1:npc,i)
-              d = eucdist(npc,p,q)
-              compact(c) = compact(c) + d
-          endif
-       enddo
-       if(k > 0)then
-         compact(c) = compact(c) / float(k)
-       else
-         compact(c) = 0
-       endif  
-    enddo
-    allocate(DBmat(nclust,nclust), source = 0.0d0)
-    do c=1,nclust
-       p(1:npc) = centroid(1:npc,c)
-       do c2=1,nclust
-          if(c2==c) cycle
-          q(1:npc) = centroid(1:npc,c2)
-          d = eucdist(npc,p,q)
-          Rij = (compact(c)+compact(c2))/d
-          DBmat(c,c2) = Rij
-       enddo
-    enddo
-    do c=1,nclust
-       maxDB=maxval(DBmat(:,c),1)
-       DBI = DBI + maxDB
-    enddo  
-    DBI = DBI / float(nclust)
-    deallocate(DBmat)
-    deallocate(compact)
+  !>-- Davies-Bouldin index (DBI)
+  allocate (compact(nclust),source=0.0d0) !cluster compactness
+  do c = 1,nclust
+    p(1:npc) = centroid(1:npc,c)
+    k = 0
+    do i = 1,mm
+      if (member(i) == c) then
+        k = k+1
+        q(1:npc) = pcvec(1:npc,i)
+        d = eucdist(npc,p,q)
+        compact(c) = compact(c)+d
+      end if
+    end do
+    if (k > 0) then
+      compact(c) = compact(c)/float(k)
+    else
+      compact(c) = 0
+    end if
+  end do
+  allocate (DBmat(nclust,nclust),source=0.0d0)
+  do c = 1,nclust
+    p(1:npc) = centroid(1:npc,c)
+    do c2 = 1,nclust
+      if (c2 == c) cycle
+      q(1:npc) = centroid(1:npc,c2)
+      d = eucdist(npc,p,q)
+      Rij = (compact(c)+compact(c2))/d
+      DBmat(c,c2) = Rij
+    end do
+  end do
+  do c = 1,nclust
+    maxDB = maxval(DBmat(:,c),1)
+    DBI = DBI+maxDB
+  end do
+  DBI = DBI/float(nclust)
+  deallocate (DBmat)
+  deallocate (compact)
 
-    deallocate(q,p)
-    return
+  deallocate (q,p)
+  return
 end subroutine cluststat
 
 !==============================================================!
-! analyze the statistical values DBI and pSF to get the 
+! analyze the statistical values DBI and pSF to get the
 ! respective extrema
 !==============================================================!
 subroutine statanal(n,nmax,statistics,extrema,pr)
-    use crest_parameters
-    implicit none
-    integer :: n,nmax
-    real(wp) :: statistics(3,nmax)
-    logical,intent(inout) :: extrema(2,n)
-    logical :: pr
-    real(wp) :: last,next,current
-    integer :: i
+  use crest_parameters
+  implicit none
+  integer :: n,nmax
+  real(wp) :: statistics(3,nmax)
+  logical,intent(inout) :: extrema(2,n)
+  logical :: pr
+  real(wp) :: last,next,current
+  integer :: i
 
-    extrema=.false.
+  extrema = .false.
 !>--- identify local extrema of the DBI and pSF
-    do i=2,n-1
-    !>-- DBI 
-       last = statistics(1,i-1)
-       next = statistics(1,i+1)
-       current = statistics(1,i)
-       if((current<last) .and. (current<next))then
-          extrema(1,i) = .true.
-       endif
+  do i = 2,n-1
+    !>-- DBI
+    last = statistics(1,i-1)
+    next = statistics(1,i+1)
+    current = statistics(1,i)
+    if ((current < last).and.(current < next)) then
+      extrema(1,i) = .true.
+    end if
     !>-- pSF
-       last = statistics(2,i-1)
-       next = statistics(2,i+1)
-       current = statistics(2,i)
-       if((current>last) .and. (current>next))then
-          extrema(2,i) = .true.
-       endif
-    enddo
+    last = statistics(2,i-1)
+    next = statistics(2,i+1)
+    current = statistics(2,i)
+    if ((current > last).and.(current > next)) then
+      extrema(2,i) = .true.
+    end if
+  end do
 
-    if(pr)then
-        write(*,*)
-        write(*,'(1x,a,/)') 'Suggestions for cluster sizes:'
-        do i=1,n
-           if(extrema(1,i) .or. extrema(2,i))then
-               if(extrema(1,i) .and. extrema(2,i))then
-                  write(*,'(1x,i8,''*'',3x,a,f8.4)') i,'SSR/SST',statistics(3,i)
-               else
-                  write(*,'(1x,i8,4x,a,f8.4)') i,'SSR/SST',statistics(3,i)
-               endif
-           endif    
-        enddo
-        write(*,'(/,1x,a)') 'Cluster counts marked with a star (*) are reasonable'
-        write(*,'(1x,a)') 'suggestions according to BOTH the DBI and pSF.'
-    endif    
+  if (pr) then
+    write (*,*)
+    write (*,'(1x,a,/)') 'Suggestions for cluster sizes:'
+    do i = 1,n
+      if (extrema(1,i).or.extrema(2,i)) then
+        if (extrema(1,i).and.extrema(2,i)) then
+          write (*,'(1x,i8,''*'',3x,a,f8.4)') i,'SSR/SST',statistics(3,i)
+        else
+          write (*,'(1x,i8,4x,a,f8.4)') i,'SSR/SST',statistics(3,i)
+        end if
+      end if
+    end do
+    write (*,'(/,1x,a)') 'Cluster counts marked with a star (*) are reasonable'
+    write (*,'(1x,a)') 'suggestions according to BOTH the DBI and pSF.'
+  end if
 
-    return
-end subroutine statanal    
+  return
+end subroutine statanal
 
 !==============================================================!
 ! print a warning regarding the nature of the cluster partitioning
 !==============================================================!
 subroutine statwarning(fname)
-    implicit none
-    character(len=*) :: fname
-    write(*,*)
-    write(*,'(1x,a)') '!---------------------------- NOTE ----------------------------!'
-    write(*,'(2x,a)') 'The partitioning of data (the ensemble) into clusters'
-    write(*,'(2x,a)') 'of similar characteristics (structures) is ARBITRARY'
-    write(*,'(2x,a)') 'and depends on many criteria (e.g. choice of PCs).'
-    write(*,'(2x,a)') 'The selected cluster count is the smallest reasonable'
-    write(*,'(2x,a)') 'number of clusters that can be formed according to'
-    write(*,'(2x,a)') 'the DBI and pSF values for the given data.'
-    write(*,*)
-    write(*,'(2x,a)') 'If other cluster sizes are desired, rerun CREST with'
-    write(*,'(2x,3a)') '"crest --for ',trim(fname),' --cluster <number of clusters>"'
-    write(*,*)
-    write(*,'(2x,a)') 'Other default evaluation settings can be chosen with the'
-    write(*,'(2x,a)') 'keywords "loose","normal", and "tight" as <level> via'
-    write(*,'(2x,3a)') '"crest --for ',trim(fname),' --cluster <level>"'
-    write(*,'(1x,a)') '!--------------------------------------------------------------!'
+  implicit none
+  character(len=*) :: fname
+  write (*,*)
+  write (*,'(1x,a)') '!---------------------------- NOTE ----------------------------!'
+  write (*,'(2x,a)') 'The partitioning of data (the ensemble) into clusters'
+  write (*,'(2x,a)') 'of similar characteristics (structures) is ARBITRARY'
+  write (*,'(2x,a)') 'and depends on many criteria (e.g. choice of PCs).'
+  write (*,'(2x,a)') 'The selected cluster count is the smallest reasonable'
+  write (*,'(2x,a)') 'number of clusters that can be formed according to'
+  write (*,'(2x,a)') 'the DBI and pSF values for the given data.'
+  write (*,*)
+  write (*,'(2x,a)') 'If other cluster sizes are desired, rerun CREST with'
+  write (*,'(2x,3a)') '"crest --for ',trim(fname),' --cluster <number of clusters>"'
+  write (*,*)
+  write (*,'(2x,a)') 'Other default evaluation settings can be chosen with the'
+  write (*,'(2x,a)') 'keywords "loose","normal", and "tight" as <level> via'
+  write (*,'(2x,3a)') '"crest --for ',trim(fname),' --cluster <level>"'
+  write (*,'(1x,a)') '!--------------------------------------------------------------!'
 end subroutine statwarning
 
-
 !====================================================================!
 subroutine getdiederatoms(zmol,nat,inc,nb,diedat,ndied)
-      use crest_parameters, idp => dp 
-      use zdata
-      use strucrd
-      implicit none
-      type(zmolecule) :: zmol
-      integer :: nat
-      integer :: inc(nat) !contains 1 (=include) or 0 (=ignore)
-      integer :: nb
-      integer :: diedat(4,nb)
-      integer,intent(out) :: ndied
-      integer :: a,b,c,d
-      integer :: i,j,k
+  use crest_parameters,idp => dp
+  use zdata
+  use strucrd
+  implicit none
+  type(zmolecule) :: zmol
+  integer :: nat
+  integer :: inc(nat) !contains 1 (=include) or 0 (=ignore)
+  integer :: nb
+  integer :: diedat(4,nb)
+  integer,intent(out) :: ndied
+  integer :: a,b,c,d
+  integer :: i,j,k
 
-      ndied = 0
-      do i=1,nb
-         a = zmol%bondpairs(1,i)
-         b = zmol%bondpairs(2,i)
-         if(inc(a)==0)cycle          !ignored by user?  
-         if(inc(b)==0)cycle          !ignored by user? 
-         if(zmol%zat(a)%nei==1)cycle !terminal atom?
-         if(zmol%zat(b)%nei==1)cycle !terminal atom?
-         if(zmol%methyl(a))cycle !methyl C?
-         if(zmol%methyl(b))cycle !methyl C?
-         !>-- passed all checks, so let's get atoms
-         !>-- a neighbour for a
-         do j=1,zmol%zat(a)%nei
-            c = zmol%zat(a)%ngh(j)
-            if(c == b)then
-                cycle
-            else
-                exit
-            endif
-         enddo
-         !>-- a neighbour for b
-         do k=1,zmol%zat(b)%nei
-            d = zmol%zat(b)%ngh(k)
-            if( d == a)then
-                cycle
-            else
-                exit
-            endif
-         enddo
-         ndied = ndied + 1
-         !>the bond is between a and b
-         !>c is a neighbour of a, d is a neighbour of b
-         diedat(2,ndied) = a
-         diedat(3,ndied) = b
-         diedat(1,ndied) = c 
-         diedat(4,ndied) = d
-      enddo
+  ndied = 0
+  do i = 1,nb
+    a = zmol%bondpairs(1,i)
+    b = zmol%bondpairs(2,i)
+    if (inc(a) == 0) cycle          !ignored by user?
+    if (inc(b) == 0) cycle          !ignored by user?
+    if (zmol%zat(a)%nei == 1) cycle !terminal atom?
+    if (zmol%zat(b)%nei == 1) cycle !terminal atom?
+    if (zmol%methyl(a)) cycle !methyl C?
+    if (zmol%methyl(b)) cycle !methyl C?
+    !>-- passed all checks, so let's get atoms
+    !>-- a neighbour for a
+    do j = 1,zmol%zat(a)%nei
+      c = zmol%zat(a)%ngh(j)
+      if (c == b) then
+        cycle
+      else
+        exit
+      end if
+    end do
+    !>-- a neighbour for b
+    do k = 1,zmol%zat(b)%nei
+      d = zmol%zat(b)%ngh(k)
+      if (d == a) then
+        cycle
+      else
+        exit
+      end if
+    end do
+    ndied = ndied+1
+    !>the bond is between a and b
+    !>c is a neighbour of a, d is a neighbour of b
+    diedat(2,ndied) = a
+    diedat(3,ndied) = b
+    diedat(1,ndied) = c
+    diedat(4,ndied) = d
+  end do
 
-      return
+  return
 end subroutine getdiederatoms
 
 subroutine calc_dieders(nat,xyz,ndied,diedat,diedr)
-      use crest_parameters, idp => dp 
-      use crest_data
-      use zdata
-      use strucrd
-      implicit none
-      integer :: nat,ndied
-      real(wp) :: xyz(3,nat)
-      integer :: diedat(4,ndied)
-      real(wp),intent(out) :: diedr(ndied)
-      integer :: i
-      integer :: a,b,c,d
-      real(wp) :: coords(3,4)
-      real(wp) :: angle
-      real(wp),parameter :: rad2degree = 57.29578_wp
-      real(wp),parameter :: tol = 5.0_wp !tolerance for almost 360 degree
+  use crest_parameters,idp => dp
+  use crest_data
+  use zdata
+  use strucrd
+  implicit none
+  integer :: nat,ndied
+  real(wp) :: xyz(3,nat)
+  integer :: diedat(4,ndied)
+  real(wp),intent(out) :: diedr(ndied)
+  integer :: i
+  integer :: a,b,c,d
+  real(wp) :: coords(3,4)
+  real(wp) :: angle
+  real(wp),parameter :: rad2degree = 57.29578_wp
+  real(wp),parameter :: tol = 5.0_wp !tolerance for almost 360 degree
 
-      diedr=0.0_wp
-      do i=1,ndied
-        a = diedat(2,i)
-        b = diedat(3,i)
-        c = diedat(1,i)
-        d = diedat(4,i)
-        coords(1:3,1) = xyz(1:3,c)
-        coords(1:3,2) = xyz(1:3,a)
-        coords(1:3,3) = xyz(1:3,b)
-        coords(1:3,4) = xyz(1:3,d)
-        call DIHED(coords,1,2,3,4,angle)
-        angle = abs(angle) * rad2degree
-        if( abs(angle-360.0_wp) < tol ) angle = 0.0_wp
-        diedr(i) = angle
-      enddo
+  diedr = 0.0_wp
+  do i = 1,ndied
+    a = diedat(2,i)
+    b = diedat(3,i)
+    c = diedat(1,i)
+    d = diedat(4,i)
+    coords(1:3,1) = xyz(1:3,c)
+    coords(1:3,2) = xyz(1:3,a)
+    coords(1:3,3) = xyz(1:3,b)
+    coords(1:3,4) = xyz(1:3,d)
+    call DIHED(coords,1,2,3,4,angle)
+    angle = abs(angle)*rad2degree
+    if (abs(angle-360.0_wp) < tol) angle = 0.0_wp
+    diedr(i) = angle
+  end do
 
-      return
+  return
 end subroutine calc_dieders
 
Index: src/classes.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!================================================================================!\n! THIS MODULE CONTAINS THE MAIN AND GLOBAL DATA STORAGE OF CREST\n!================================================================================!\n\nmodule crest_data\n   use iso_fortran_env, wp => real64, dp => int64\n   use crest_calculator,only:calcdata\n   use dynamics_module, only:mddata\n   use strucrd, only:coord\n   use crest_type_timer, only:timer\n   implicit none\n\n   public :: systemdata\n   public :: timer   !> RE-EXPORT from crest_type_timer\n   public :: protobj\n   public :: constra\n   public :: optlevflag,optlevnum,optlevmap_alt\n\n   !> basename for the CRE files\n   character(len=14),parameter,public :: crefile = 'crest_rotamers'              \n   !> basename for the conformer file\n   character(len=20),parameter,public :: conformerfile = 'crest_conformers.xyz'  \n   !> basename for the conformer file\n   character(len=16),parameter,public :: conformerfilebase = 'crest_conformers'  \n   !> basename for the conformer file\n   character(len=19),parameter,public :: clusterfile='crest_clustered.xyz'       \n   !> basename for the cluster file\n   character(len=*),parameter,public :: ensemblefile='crest_ensemble.xyz'\n   !> basename for the log file\n   character(len=*),parameter,public :: ensembleelog='ensemble_energies.log'\n   !> basename for the mecp file\n   character(len=*),parameter,public :: mecpensemble='crest_mecp_search.xyz'\n\n\n\n   logical,public :: gui = .false.\n\n\n!============================================================================!\n! runtype variables\n!============================================================================!\n!>---- runtypes (variables for crest%crestver)\n   integer,parameter,public :: crest_none     = 0\n   integer,parameter,public :: crest_mfmdgc   = 1    \n   integer,parameter,public :: crest_imtd     = 2\n   integer,parameter,public :: crest_imtd2    = 22\n   integer,parameter,public :: crest_mdopt    = 3\n   integer,parameter,public :: crest_mdopt2   = 33\n   integer,parameter,public :: crest_screen   = 4\n   integer,parameter,public :: crest_nano     = 7\n   integer,parameter,public :: crest_compr    = 77\n   integer,parameter,public :: crest_msreac   = 9\n   integer,parameter,public :: crest_pka      = 14\n   integer,parameter,public :: crest_solv     = 15\n!>> runtypes with IDs between use non-legacy routines  <<!\n   integer,parameter,public :: crest_sp         = 264\n   integer,parameter,public :: crest_optimize   = 265\n   integer,parameter,public :: crest_moldyn     = 266\n   integer,parameter,public :: crest_s1         = 267\n   integer,parameter,public :: crest_mecp       = 268\n   integer,parameter,public :: crest_numhessian = 269\n   integer,parameter,public :: crest_scanning   = 270\n   integer,parameter,public :: crest_rigcon     = 271\n!>> <<! \n   integer,parameter,public :: crest_test       = 456\n\n!>---- tools (variables for env%properties)\n   integer,parameter,public :: p_none         =  0\n   integer,parameter,public :: p_cregen       = -1\n   integer,parameter,public :: p_compare      = -2\n   integer,parameter,public :: p_protonate    = -3\n   integer,parameter,public :: p_deprotonate  = -4\n   integer,parameter,public :: p_tautomerize  = -5\n   integer,parameter,public :: p_tautomerize2 = -555\n   integer,parameter,public :: p_isomerize    = -92\n   integer,parameter,public :: p_reactorset   = -312\n   integer,parameter,public :: p_CREentropy   = -45   \n   integer,parameter,public :: p_rrhoaverage  = -4450\n   integer,parameter,public :: p_cluster      = -70\n   integer,parameter,public :: p_propcalc     = -666\n   integer,parameter,public :: p_acidbase     = -788\n   integer,parameter,public :: p_ligand       = -355\n   integer,parameter,public :: p_gesc1        = -9224\n   integer,parameter,public :: p_gesc2        = -9225\n   integer,parameter,public :: p_thermo       = -3654\n   integer,parameter,public :: p_useonly      = -227\n   integer,parameter,public :: p_qcg          = 37\n\n!===========================================================================!\n\n   private\n\n!========================================================================================!\n\n   type :: constra\n      integer :: ndim\n      logical :: used\n      logical :: NCI\n      logical :: ggrid = .false.\n      character(len=:),allocatable :: gbsagrid\n      character(len=128),allocatable :: sett(:)\n      character(len=128),allocatable :: buff(:)\n      character(len=128),allocatable :: pots(:)\n   !--- data of bondlength constraints\n      logical :: cbonds_global = .false.\n      logical :: cbonds_md     = .false.\n      integer :: n_cbonds = 0\n      character(len=128),allocatable :: cbonds(:)\n   !--- data of nano-reactor\n      logical :: ureactor = .false.\n      integer :: nrctrl = 0\n      character(len=128),allocatable :: rctrl(:)\n   !--- dispersion scaling (>xtb 6.4.0)\n      logical :: dispscal_md     = .false.\n      logical :: dispscal_global = .false.\n      real(wp) :: dscal = 1.0_wp\n   !--- RMSD corrected GFN/DFT hypersurface:  gESC method\n      character(len=:),allocatable :: rmsdpotfile\n      logical :: usermsdpot = .false.   \n      logical :: gesc_heavy = .false.\n    contains\n      procedure :: allocate => allocate_constraints\n      procedure :: deallocate => deallocate_constraints\n   end type constra\n\n!========================================================================================!\n\n   type :: protobj\n      integer :: nfrag\n      integer :: newchrg\n      integer :: iter\n      real(wp) :: popthr\n      real(wp) :: ewin\n      integer :: swchrg        !switch element charge\n      integer :: swat          !switch element element\n      logical :: swelem        !switch element to add to lmo lp pair?\n      logical :: allowFrag\n      logical :: threshsort    !use ewin threshold\n      logical :: protdeprot    !currently unused!\n      logical :: deprotprot    !(tautomerize) do first deprotonation and then protonation\n\n      logical :: strictPDT = .false.  ! strict mode (i.e. bond constraints) for (de)protonation,tautomerization\n      logical :: fixPDT    = .false.  ! extension to the strict mode, fix heavy atom positions\n      logical :: ABcorrection = .false.\n\n      integer,allocatable :: atmap(:)\n\n      !--- ligandtool\n      integer :: centeratom = 0\n      integer :: ligand     = 0\n      logical :: isatom = .false.\n      character(len=:),allocatable :: infile\n      character(len=:),allocatable :: newligand\n\n      !--- pka\n      integer :: h_acidic = 0  !which h atom to remove in pka script\n      integer :: pka_mode = 0  !what to do in the pka calc.\n      character(len=:),allocatable :: pka_baseinp  !if a base file is read in instead\n      character(len=:),allocatable :: pka_acidensemble  !\n      character(len=:),allocatable :: pka_baseensemble  !\n      logical :: rdCFER =.false.\n      character(len=:),allocatable :: cferfile\n\n      integer :: divers = 1    !number of structures red from given ensemble for extended taut. mode\n      logical :: alldivers = .false.  !use all structures of given ensemble for extended taut mode\n      logical,allocatable :: blacklist(:) !a blacklist of atoms to disallow deprotonation from\n   end type protobj\n\n!========================================================================================!\n\n   !--- ENTROPY mode setting object\n   type :: entropyMTD\n      integer :: nMDs           ! number of static MTDs\n      integer :: nBias          ! number of Bias structures\n      real(wp) :: nbiasgrow =1.2d0\n      integer :: iter = 4       ! number of iterations\n      integer :: iterlast = 1   ! document how many iterations were done\n      integer :: nconflast = 0  ! number of conformers in last iteraton\n      real(wp) :: lenfac        ! length factor of each static MTD\n      real(wp) :: temperature\n      real(wp) :: kpush = 0.0005d0  ! kpush per atom !SG\n      real(wp),allocatable :: klist(:)\n      integer :: nklist = 1\n      integer :: maxfallback = 10\n      real(wp) :: alpha = 1.0d0     ! exponent\n      real(wp) :: confthr =  -0.01d0  ! stop iterations if we get less than this fraction of new conformers\n      real(wp) :: sconvthr = -0.01d0 ! stop iterations based on estimated entroy change\n      integer  :: rmax = 5          ! max ring size to exclude from bias\n      integer :: katoms             ! number of atoms in bias\n      \n      real(wp) :: mtdramp = 0.03_wp\n      real(wp) :: sapprox\n      real(wp) :: sapproxlast\n      character(len=:),allocatable :: atomlist   \n      logical,allocatable :: atomlist2(:)\n      real(wp) :: trange(3)\n      integer :: nt = 0\n      real(wp),allocatable ::  cpoft(:)  !Cp(T)\n      real(wp),allocatable ::  soft(:)   !S(T)\n      real(wp),allocatable :: hoft(:)    !H(T)-H(0) \n      !-- reference structure for BHESS\n      logical :: bhess =.true.\n      character(len=:),allocatable :: fromfile\n      integer :: nat\n      integer,allocatable :: at(:)\n      real(wp),allocatable :: xyz(:,:)\n   end type entropyMTD\n\n!========================================================================================!\n\n   type :: thermodata\n      real(wp) :: ithr  = -50.0_wp  !imaginary mode inversion (in xtb -20.0)\n      real(wp) :: fscal = 1.0_wp    !frequency scaling\n      real(wp) :: sthr  =  25.0_wp  !rot/vib interpol threshold (in xtb 50.0)\n      real(wp) :: trange(3)         \n      integer  :: ntemps\n      real(wp),allocatable :: temps(:)\n      real(wp) :: ptot = 0.9d0    ! population sthreshold\n      integer  :: pcap = 50000    ! limit number of structures\n      logical :: avbhess = .false.  !use bhess in the msRRHO average calc. for all structures (expensive!)\n      logical :: constrhess = .false. !apply constraints in rrhoav?\n      logical :: printpop = .false. !print a file with populations at different T\n    contains\n      procedure :: get_temps => thermo_get_temps\n      procedure :: read_temps => thermo_read_temps\n   end type thermodata\n\n!========================================================================================!\n\n   type :: refdata\n       integer :: nat\n       integer,allocatable :: at(:)\n       real(wp),allocatable :: xyz(:,:)\n       integer :: ichrg = 0\n       integer :: uhf = 0\n       integer :: ntopo\n       integer,allocatable :: topo(:)\n       real(wp),allocatable :: charges(:)\n       real(wp),allocatable :: wbo(:,:)\n    contains\n      procedure :: rdcharges => read_charges\n      procedure :: to => ref_to_mol\n   end type refdata\n\n!========================================================================================!  \n\n   type :: systemdata\n    !--- GENERAL data\n      integer :: crestver     ! Runtype-variable\n      integer :: runver            ! additional runtype-variable\n      integer :: properties        ! additional stuff before or after the confsearch\n      integer :: properties2       ! backup variable\n      integer,allocatable :: pqueue(:) !property job queue\n      integer :: npq = 0           ! number of jobs in priority queue  \n\n      real(wp) :: level            ! increase/decrease factor of #modes in V1\n      real(wp) :: thresholds(8)    ! CREGEN thresholds\n      real(wp) :: ewin             ! Energy window (6 kcal default) \n      real(wp) :: ethr             ! dE between conformers (0.05 kcal default)\n      real(wp) :: ethrpurge        ! dE between conformers (purgemode, 0.2 kcal default)\n      real(wp) :: couthr           ! CREGEN coulomb energy threshold\n      real(wp) :: rthr\n      real(wp) :: bthr\n      real(wp) :: bthr2            ! alternative BTHR (relative value BTHR threshold)\n      real(wp) :: bthrmax          ! max BTHR due to anisotropy \n      real(wp) :: bthrshift        ! erf-shift of BTHR\n      real(wp) :: athr\n      real(wp) :: pthr\n      real(wp) :: pthrsum\n      real(wp) :: tboltz\n      logical  :: cgf(6)           ! collection of CREGEN options\n\n      real(wp) :: mdtemps(10)      ! different temperatures for the QMDFF-MDs in V1\n      real(wp) :: mdtime           ! MD length (V1&2)\n      real(wp) :: elowest          ! Energy of the lowest conformer\n      real(wp) :: eprivious        ! Energy of the priviously lowest conformer\n      real(wp) :: gcmax            ! Max. number of structures for GC\n      real(wp) :: gcmaxparent = 1.2d7 ! Max. number of parent pairs for GC\n\n      integer :: icount            ! Mode counter in V1\n      integer :: mdmode            ! MD mode in V1 xtb-MD or QMDFF\n      integer :: nmodes            ! number of NMs to follow (V1)\n      integer :: temps             ! number of MDs in V1, and NORMMDs in V2\n      integer :: snapshots         ! number of snapshots from MD (V1)\n      integer :: Maxrestart        ! max number of restarts in V1 and V3\n      integer :: nreset = 0        ! tracker of algo-iterations\n      integer :: nrotammds         ! Number of additional normal MDs in V2\n      integer :: maxcompare        ! maximal number of (lowest) conformers to compare when using \"-compare\"\n      integer :: tsplit            ! number of time splitting for entropy S(t=inf) extrapolation\n\n      integer  :: nat               !number of atoms    \n      integer  :: chrg              !molecular charge\n      integer  :: uhf               ! nα - nβ electrons\n      integer  :: MAXRUN            !number of parallel xtb jobs\n      integer  :: omp               !OMP/MKL_NUM_THREADS\n      integer  :: Threads           !Total number of threads (=omp*MAXRUN)\n      integer  :: rednat            !reduced Nat, if atom list is given\n      real(wp) :: optlev\n      real(wp) :: forceconst        !forceconstant (mainly for gff iMTD-GC)\n\n      real(wp) :: dummypercent\n\n\n    !--- various names and flags\n      character(len=128) :: ensemblename      !ensemble input name for SCREEN,MDOPT and CREGEN\n      character(len=128) :: ensemblename2     !another ensemble input name\n      character(len=128) :: fixfile\n      character(len=512) :: constraints       !name of the constraint file\n      character(len=20)  :: solvent !the solvent\n      character(len=:),allocatable :: solv !the entrie gbsa flag including solvent\n      character(len=20)  :: gfnver  !GFN version\n      character(len=20)  :: gfnver2 !GFN version (multilevel)\n      character(len=20)  :: lmover  !GFN version for LMO computation in xtb_lmo subroutine\n      character(len=512) :: ProgName!name of the executable, and enough space for a specified path\n      character(len=512) :: ProgIFF !name of xtbiff for QCG-mode\n      character(len=512) :: scratchdir !path to the scratch directory\n      character(len=1)   :: seperator !file-path seperator \n      character(len=20)  :: devnull  !/dev/null or NUL\n      character(len=:),allocatable :: inputcoords, inputcoords_solv, inputcoords_solu\n      character(len=:),allocatable :: wbofile\n      character(len=:),allocatable :: atlist\n      character(len=:),allocatable :: chargesfilename\n      \n     !--- METADYN data\n      real(wp) :: hmass\n      real(wp) :: mdtemp\n      real(wp) :: nmdtemp\n      real(wp) :: mdstep\n      real(wp) :: mdlenfac\n      real(wp) :: tmtd\n      real(wp) :: flexi\n      integer  :: shake\n      integer  :: mddumpxyz\n      integer  :: mdskip\n      integer  :: mddump\n      integer  :: maxopt\n      real(wp) :: hlowopt\n      real(wp) :: microopt\n      real(wp) :: s6opt\n\n      integer :: nmetadyn\n      real(wp),allocatable :: metadfac(:)\n      real(wp),allocatable :: metadexp(:)\n      integer,allocatable  :: metadlist(:)\n      \n      \n      character(len=:),allocatable :: mtdstaticfile\n      integer :: nstatic\n\n      integer,allocatable  :: includeRMSD(:)\n      logical,allocatable  :: excludeTOPO(:)\n\n    !--- property data objects\n      type(protobj) :: ptb\n      type(protobj) :: ptb_solvent\n      type(protobj) :: ptb_solute\n\n\n    !--- saved constraints\n      type(constra) :: cts\n\n    !--- NCI mode data\n      real(wp) :: potscal\n    \n    !--- Nanoreactor data\n      real(wp) :: rdens     !reactor density      \n      real(wp) :: tempfermi = 6000.0d0 !logfermi temperature\n\n    !--- Entropy static MTDs object\n      type(entropyMTD) :: eMTD  \n      real(wp) :: XH3 = 0\n      real(wp) :: kappa = 1.5_wp   !> vM-kernel discretization\n\n    !--- thermo data\n      type(thermodata) :: thermo  \n\n    !--- reference structure data (the input structure)\n      type(refdata) :: ref\n      type(refdata) :: qcg_solvent\n      type(refdata) :: qcg_solute\n      \n    !--- QCG data\n      integer           :: qcg_runtype = 0      !Default is grow, 1= ensemble & opt, 2= e_solv, 3= g_solv\n      integer           :: nsolv = 0            !Number of solventmolecules\n      integer           :: nqcgclust = 0        !Number of cluster to be taken\n      integer           :: max_solv = 0         !Maximal number of solvents added, if none is given\n      integer           :: ensemble_method = -1 !Default -1 for qcgmtd, 0= crest, 1= standard MD, 2= MTD\n      character(len=20) :: ensemble_opt         !Method for ensemble optimization in qcg mode\n      character(len=20) :: freqver              !Method for frequency computation in qcg mode\n      real(wp)          :: freq_scal            !Frequency scaling factor\n      character(len=:),allocatable :: solu_file, solv_file !solute  and solvent input file\n      character(len=5) :: docking_qcg_flag = '--qcg'\n\n    !--- clustering data\n      integer :: maxcluster = 0  ! maximum number of clusters to be generated\n      integer :: nclust  = 0     ! fixed number of clusters (unly used if !=0)\n      integer :: pccap  = 100    ! maximum number of principal components used for clustering\n      real(wp) :: pcthr = 0.85d0\n      real(wp) :: pcmin = 0.05d0  \n      real(wp) :: csthr = 0.80d0\n      character(len=:),allocatable :: pcmeasure\n      integer :: clustlev = 0    ! clustering level\n\n    !--- additional structure generation settings\n      logical :: doOHflip = .true.\n      integer :: maxflip = 1000  \n\n    !--- external RMSD bias to optimizations\n      character(len=:),allocatable :: biasfile\n      real(wp) :: rthr2 = 0.3_wp    ! Discard all structures with a bias smaller than this\n      real(wp) :: kshift = 3.0_wp   ! Shift of the k_i (in kcal/mol)  \n      integer :: kshiftnum = 4      ! try 5 different kshift (if not specified otherwise\n      real(wp) :: gescoptlev = 2.0_wp \n\n    !--- DFT driver arguments [DEPRECATED]\n      character(len=:),allocatable :: dftrcfile !i.e. ~/.dftrc\n      integer :: dftprog      !TM=1,ORCA=2\n      character(len=:),allocatable :: dftsetup   !,i.e. \"cefine -func [...]\"\n      character(len=:),allocatable :: dftsetup2  !,i.e. \"cefine -func [...]\" before aoforce\n      character(len=:),allocatable :: dftcall    !,i.e. \"ridft [...]\"\n      character(len=:),allocatable :: dftoptlev  !optimization level for dft\n      character(len=:),allocatable :: dftmasspar !dft mass scaling parameters\n      integer :: dftruntype   !OPT=1,SP=2,FREQ=3,autoIR=4\n      logical :: resetsetup = .false.\n      logical :: hardcutDFT = .false.  !use hard cut-off criteria for aoforce consideration\n      logical :: dftmasscal = .false.\n      real(wp) :: harcutpthr = 0.5_wp  !take no less than 50% population of ensemble\n      integer  :: hardcutnst = 5       !take no more than 5 structures\n\n\n   !================================================!\n   !>--- Calculation settings for newer implementations (version >= 3.0)\n      type(calcdata) :: calc\n      type(mddata)   :: mddat\n   !>--- rigidconf data   \n      integer :: rigidconf_algo = 0\n      integer :: rigidconf_toposource = 0\n   !================================================! \n\n   !--- general logical data\n      logical :: allrot = .true.   ! use all rotational constants for check instead of mean?\n      logical :: altopt = .false.\n      logical :: autothreads       ! automatically determine threads\n      logical :: autozsort         ! do the ZSORT in the beginning ?\n      logical :: allowrestart = .true. !allow restart in crest algos?\n      logical :: better            ! found a better conformer and restart in V1\n      logical :: cff               ! CFF used in QCG-energy calculation\n      logical :: cluster = .false. ! perform a clustering analysis        \n      logical :: checktopo = .true.  !perform topolgy check in CREGEN\n      logical :: checkiso  = .false. !perform E/Z isomerization check in CREGEN\n      logical :: chargesfile = .false. !use a given charges file for gfnff\n      logical :: compareens        ! try to correlate 2 given Ensemble files\n      logical :: confgo            ! perform only the CREGEN routine ?\n      logical :: constrain_solu    ! constrain the solute\n      logical :: doNMR             ! determine NMR equivalencies in CREGEN ?\n      logical :: dryrun =.false.   ! dryrun to print settings\n      logical :: ENSO              ! some options for usage of CREST within ENSO\n      logical :: ens_const = .false. ! constrain solute also in Ensemble generation\n      logical :: entropic =.false. ! entropy mode\n      logical :: entropymd = .false. ! entropy mode static mtds\n      logical :: esort = .false.   ! legacy option in old cregen\n      logical :: ext               ! external\n      logical :: extLFER =.false.  ! read in external LFER parameters\n      logical :: fullcre = .false. ! calculate exact rotamer degeneracies\n      logical :: gbsa              ! use gbsa\n      logical :: gcmultiopt        ! 2 level optimization for GC in V2\n      logical :: heavyrmsd = .false. !use only heavy atoms for RMSD in CREGEN?\n      logical :: inplaceMode = .true. ! in-place mode: optimization dirs are created \"on-the-fly\"\n      logical :: iterativeV2       ! iterative version of V2 (= V3)\n      logical :: iru               ! re-use previously found conformers as bias in iterative approach\n      logical :: keepModef         ! keep MODEF* dirs in V1 ?\n      logical :: keepScratch = .false. ! keep scratch directory or delete it?\n      logical :: legacy = .true.   ! switch between the original system call routines of crest and newer, e.g. tblite implementations\n      logical :: metadynset        ! is the number of MTDs already set (V2) ?\n      logical :: methautocorr      ! try to automatically include Methyl equivalencies in CREGEN ?\n      logical :: multilevelopt     ! perform the multileveloptimization\n      logical :: newcregen = .false. ! use the CREGEN rewrite\n      logical :: NCI               ! NCI special usage\n      logical :: niceprint         ! make a nice progress-bar printout\n      logical :: noconst=.false.   ! no constrain of solute during QCG Growth\n      logical :: onlyZsort         ! do only the ZSORT routine ?\n      logical :: optpurge = .false. !MDOPT purge application\n      logical :: outputsdf = .false. ! write output ensemble as sdf?\n      logical :: pcaexclude = .false. ! exclude user set atoms from PCA?\n      logical :: pclean            ! cleanup option for property mode\n      logical :: performCross      ! perform the GC in V1/V2 ?\n      logical :: performMD         ! perform the MD in V1 ?\n      logical :: performModef      ! perform the MF in V1 ? \n      logical :: performMTD        ! perform the MTD in V2 ?\n      logical :: preactormtd       ! prepare reactor mtd?\n      logical :: preactorpot       ! prepare reactor logfermi?\n      logical :: preopt            ! do a GFNn-xTB pre-optimization of the geometry?\n      logical :: presp =.false.    ! do a Sp calculation before starting a job?\n      logical :: printscoords      ! write scoord.* files in CREGEN ?\n      logical :: QCG               ! QCG special usage\n      logical :: qcg_flag = .false. ! QCG-parsing logical, only true, if qcg exclusive flags used\n      logical :: qcg_restart = .false. ! QCG, only true, if results from previous run are found\n      logical :: nopreopt = .false. ! Switch off preoptimization for QCG\n      logical :: quick             ! quick-run option (mainly for testing)\n      logical :: readbias = .false. ! read MTD parameters from file\n      logical :: reftopo = .true.    !use a reference topology from the given input structure\n      logical :: relax =.false.    ! was the --relax function used for protonation site search?\n      logical :: restartopt        ! restart in the second step of the multilevel opt (V2) ?\n      logical :: reweight=.false.  ! reweight structures on the fly after optimizations (i.e. do SPs)?\n      logical :: riso=.false.      ! take only isomers in reactor mode\n      logical :: rotamermds        ! do additional MDs after second  multilevel OPT step in V2 ?\n      logical :: sameRandomNumber =.false. !QCG related, choose same random number for iff\n      logical :: scallen           ! scale the automatically determined MD length by some factor?\n      logical :: scratch           ! use scratch directory\n      logical :: setgcmax = .false.! adjust the maxmimum number of structures taken into account for GC?\n      logical :: sdfformat = .false. ! was the SDF format used as input file?\n      logical :: slow              ! slowmode (counterpart to quick mode)\n      logical :: solv_md = .false. !switches on QCG-ensemblerun instead of CFF\n      logical :: staticmtd = .false. ! do a static MTD instead of normal MDs\n      logical :: subRMSD           ! include only the selected substructure into the CREGEN RMSD\n      logical :: superquick        ! very crude quick-run option\n      logical :: threadssetmanual  ! are #CPUs set with the '-T' flag ? \n      logical :: trackorigin       ! track the origin of a conformation?\n      logical :: use_xtbiff = .false. !use xtbiff for QCG?\n      logical :: user_enslvl = .false. !true if user set qcg enslvl\n      logical :: user_temp = .false. !true if user set the MD temp\n      logical :: user_mdtime = .false. ! true if mdtime set by user\n      logical :: user_mdstep = .false. ! true if mdstep is set by user\n      logical :: user_nclust = .false. ! true if number of cluster is set by user (only QCG)\n      logical :: user_dumxyz =.false. !true if dumpxyz is set by user\n      logical :: user_wscal =.false. !true if wscal is set by user\n      logical :: useqmdff          ! use QMDFF in V2?\n      logical :: water = .false.   ! true if water is used as solvent (only QCG)\n      logical :: wallsetup = .false. ! set up a wall potential?\n      logical :: wbotopo =.false.  ! set up topo with WBOs   \n\n    contains\n      procedure :: allocate => allocate_metadyn\n      procedure :: deallocate => deallocate_metadyn\n      procedure :: addjob => add_to_pqueue\n      procedure :: checkhy => pqueue_hybrid\n      procedure :: rmhy    => pqueue_removehybrid\n      procedure :: wrtCHRG => wrtCHRG\n   end type systemdata\n\n!========================================================================================!\n\n!   type :: timer\n!     integer :: times = 0\n!     integer(dp):: rate\n!     integer(dp),allocatable :: t(:,:)\n!     character(len=32),allocatable :: names(:)\n!    contains\n!     procedure :: init  => init_timer\n!     procedure :: clear => clear_timer\n!     procedure :: start => start_timer\n!     procedure :: stop  => stop_timer\n!   end type timer\n\n!========================================================================================!\n!========================================================================================!\ncontains  !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\nsubroutine allocate_metadyn(self,n)\n   implicit none\n   class(systemdata) :: self\n   integer,intent(in)  :: n\n   self%nmetadyn = n\n   if(.not.allocated( self%metadfac ))then\n       allocate( self%metadfac(n),  source = 0.0_wp )\n   endif\n   if(.not.allocated( self%metadexp ))then\n       allocate( self%metadexp(n),  source = 0.0_wp )\n   endif\n   if(.not.allocated( self%metadlist ))then\n       allocate( self%metadlist(n), source = 0 )\n   endif\n   return\nend subroutine allocate_metadyn\n!========================================================================================!\nsubroutine deallocate_metadyn(self)\n   implicit none\n   class(systemdata) :: self\n   if (allocated( self%metadfac )) deallocate( self%metadfac )\n   if (allocated( self%metadexp )) deallocate( self%metadexp )\n   if (allocated( self%metadlist )) deallocate( self%metadlist )\nend subroutine deallocate_metadyn\n!========================================================================================!\nsubroutine allocate_constraints(self,n)\n   implicit none\n   class(constra) :: self\n   integer,intent(in)  :: n\n   self%ndim      = n\n   allocate( self%sett(n))\n   allocate( self%buff(n))\n   self%sett = ''\n   self%buff = ''\nend subroutine allocate_constraints\n!========================================================================================!\nsubroutine deallocate_constraints(self)\n   implicit none\n   class(constra) :: self\n   if (allocated( self%sett)) deallocate( self%sett )\n   if (allocated( self%buff )) deallocate( self%buff )\nend subroutine deallocate_constraints\n!========================================================================================!\n!subroutine init_timer(self,n)\n!   implicit none\n!   class(timer) :: self\n!   integer,intent(in)  :: n\n!   integer(dp) :: dummy\n!   self%times      = n\n!   call system_clock ( dummy, self%rate )\n!   allocate( self%t(n,3),  source = 0_dp )\n!   allocate( self%names(n))\n!   self%names = ''\n!end subroutine init_timer\n!!========================================================================================!\n!subroutine clear_timer(self)\n!   implicit none\n!   class(timer) :: self\n!   deallocate( self%t )\n!   deallocate( self%names )\n!end subroutine clear_timer\n!!========================================================================================!\n!subroutine start_timer(self,n,inp)\n!   implicit none\n!   class(timer) :: self\n!   integer,intent(in)  :: n\n!   character(len=*) :: inp\n!   integer(dp) :: dummy\n!   self%names(n) = inp\n!   call system_clock ( self%t(n,1) , dummy )\n!end subroutine start_timer\n!!========================================================================================!\n!subroutine stop_timer(self,n)\n!   implicit none\n!   class(timer) :: self\n!   integer,intent(in)  :: n\n!   integer(dp) :: dummy\n!   call system_clock ( self%t(n,2) , dummy )\n!   self%t(n,3)=self%t(n,3) + (self%t(n,2)-self%t(n,1))\n!end subroutine stop_timer\n!----------------------------------------------------------------------------------------------------\n!----------------------------------------------------------------------------------------------------\nsubroutine add_to_pqueue(self,pjob)\n   implicit none\n   class(systemdata) :: self\n   integer :: pjob\n   integer :: idum\n   integer,allocatable :: qdum(:)\n   idum = self%npq\n   self%npq = self%npq + 1 !add a job to the queue\n   if(.not.allocated(self%pqueue))then   \n       allocate(self%pqueue(1))\n       self%pqueue(1) = pjob\n   else\n       allocate(qdum(self%npq))\n       qdum(1:idum) = self%pqueue(1:idum)\n       qdum(self%npq) = pjob\n       call move_alloc(qdum,self%pqueue)\n   endif\n   return\nend subroutine add_to_pqueue\n\n!========================================================================================!\n!> check the queue for requested hybrid reoptimization (e.g. '-gfn2@gff')\n!> and sort it accordingly\nsubroutine pqueue_hybrid(self)\n   implicit none\n   class(systemdata) :: self\n   integer :: i,pjob,n,k\n   integer,allocatable :: qdum(:)\n   n=self%npq\n   if(self%npq .gt. 1)then\n       if(any(self%pqueue.ge.50 .and. self%pqueue.lt.60))then\n           allocate(qdum(n), source = 0)\n           do i=1,n\n             pjob=self%pqueue(i)\n             if(pjob.ge.50 .and. pjob.lt.60)then\n                qdum(1)=pjob \n            endif \n           enddo\n           k=2\n           do i=1,n\n             pjob=self%pqueue(i)\n             if(pjob==0)cycle\n             if(pjob.lt.50 .or. pjob.ge.60)then\n               qdum(k)=pjob  \n               k=k+1\n             endif\n           enddo\n           call move_alloc(qdum,self%pqueue)\n       endif\n   endif\n   return\nend subroutine pqueue_hybrid\n\nsubroutine pqueue_removehybrid(self)\n   implicit none\n   class(systemdata) :: self\n   integer :: i,pjob,n\n   n=self%npq\n   if(self%npq .gt. 1)then\n           do i=1,n\n             pjob=self%pqueue(i)\n             if(pjob.ge.50 .and. pjob.lt.60)then\n                self%pqueue(i) = 0\n                self%npq = self%npq- 1\n            endif\n           enddo\n   endif\n   return\nend subroutine pqueue_removehybrid\n\n!========================================================================================!\n!> write a .CHRG (and .UHF) file in the specified dir, but only if it is needed\nsubroutine wrtCHRG(self,dir)\n    implicit none\n    class(systemdata) :: self\n    character(len=*) :: dir    \n    character(len=:),allocatable :: path\n    integer :: ich,k,i\n    k = len_trim(dir)\n    if(self%chrg.ne.0)then\n       if(k>0)then \n       path=trim(dir)//'/'//'.CHRG'\n       else\n       path='.CHRG'\n       endif    \n       open(newunit=ich,file=path)\n       write(ich,*) self%chrg\n       if(self%QCG) then\n          write(ich,*) self%chrg\n          write(ich,*) '0'\n      end if\n       close(ich)\n    endif    \n    if(self%UHF.ne.0)then\n       if(k>0)then\n       path=trim(dir)//'/'//'.UHF'\n       else\n       path='.UHF'\n       endif    \n       open(newunit=ich,file=path)\n       write(ich,*) self%uhf\n       if(self%QCG) then\n          write(ich,*) self%uhf\n          write(ich,*) '0'\n       end if\n      close(ich)\n    endif  \n    if(self%chargesfile .and. allocated(self%ref%charges))then\n       if(k>0)then \n       path=trim(dir)//'/'//'charges'\n       else\n       path='charges'\n       endif\n       open(newunit=ich,file=path)\n       do i=1,self%ref%nat\n       write(ich,'(1x,f16.8)') self%ref%charges(i)\n       enddo\n       close(ich)\n    endif\n    return\nend subroutine wrtCHRG \n\n!========================================================================================!\n!> read atomic charges from a file (one line per atom)\nsubroutine read_charges(self,chargesfilename,totchrg)\n    implicit none\n    class(refdata) :: self\n    character(len=*) :: chargesfilename\n    integer :: ich,io,i\n    real(wp) :: dum,tot\n    integer :: totchrg\n    if(allocated(self%charges))deallocate(self%charges)\n    if(self%nat>0)then\n        allocate(self%charges(self%nat),source=0.0_wp)\n        open(newunit=ich,file=chargesfilename)\n        do i=1,self%nat\n         read(ich,*,iostat=io) dum\n         if(io==0)then\n           self%charges(i) = dum\n         endif\n        enddo\n        close(io)\n    endif\n    tot=0.0_wp\n    do i=1,self%nat\n      tot=tot+self%charges(i)\n    enddo\n    totchrg = nint(tot)\n    return\nend subroutine read_charges\n\nsubroutine ref_to_mol(self,mol)\n    implicit none\n    class(refdata) :: self\n    type(coord) :: mol\n    mol%nat = self%nat\n    mol%at  = self%at\n    mol%xyz = self%xyz\n    mol%chrg = self%ichrg\n    mol%uhf  = self%uhf\n    return\nend subroutine ref_to_mol\n\n\n!========================================================================================!\nfunction optlevflag(optlev) result(flag)\n    implicit none\n    real(wp),intent(in) :: optlev\n    character(len=:),allocatable :: flag\n    flag=''\n    if(optlev <= 3.0d0) flag='extreme'\n    if(optlev <= 2.0d0) flag='very tight'\n    if(optlev <= 1.0d0) flag='tight'\n    if(optlev <= 0.0d0) flag='normal'\n    if(optlev <= -1.0d0) flag='loose'\n    if(optlev <= -2.0d0) flag='very loose'\n    if(optlev <= -3.0d0) flag='crude'\n    return\nend function optlevflag\n\nfunction optlevnum(flag) result(optlev)\n    implicit none\n    real(wp) :: optlev\n    character(len=*):: flag\n    optlev = 0.0_wp\n    if(index(flag,'crude'    ).ne.0) optlev=-3.0d0\n    if(index(flag,'loose'    ).ne.0) optlev=-1.0d0\n    if(index(flag,'vloose'   ).ne.0) optlev=-2.0d0\n    if(index(flag,'sloppy'   ).ne.0) optlev=-2.0d0\n    if(index(flag,'normal'   ).ne.0) optlev=0.0d0\n    if(index(flag,'tight'    ).ne.0) optlev=1.0d0\n    if(index(flag,'verytight').ne.0) optlev=2.0d0\n    if(index(flag,'vtight'   ).ne.0) optlev=2.0d0\n    if(index(flag,'2'        ).ne.0) optlev=2.0d0\n    if(index(flag,'1'        ).ne.0) optlev=1.0d0\n    if(index(flag,'0'        ).ne.0) optlev=0.0d0\n    if(index(flag,'-3'       ).ne.0) optlev=-3.0d0\n    if(index(flag,'-2'       ).ne.0) optlev=-2.0d0\n    if(index(flag,'-1'       ).ne.0) optlev=-1.0d0\n    return\nend function optlevnum\n\nfunction optlevmap_alt(optin) result(optout)\n!> a mapping from env%optlev to integer\n!> that is used in the multilevel_oloop selection\n   implicit none\n   integer :: optout\n   real(wp),intent(in) :: optin\n   integer :: k\n   integer,parameter :: omap(7) = [ 1, 2, 3, 4, 5, 6, 6]\n   k = nint(optin) + 4\n   optout = omap(k)\nend function optlevmap_alt\n\n!========================================================================================!\n\nsubroutine thermo_get_temps(self)\n   implicit none\n   class(thermodata) :: self\n   integer :: i,nt\n   real(wp) :: dum1\n   if(allocated(self%temps))then\n       deallocate(self%temps)\n   endif\n   dum1 = (self%trange(2)-self%trange(1))\n   nt  = nint( dum1/self%trange(3)) + 1\n   if(nt < 1) nt=1\n   self%ntemps=nt\n   allocate(self%temps(nt))\n   dum1 = self%trange(1)\n   do i=1,nt\n      self%temps(i)=dum1\n      dum1 = dum1 +self%trange(3)\n   enddo\n   return\nend subroutine thermo_get_temps\n\nsubroutine thermo_read_temps(self,fname)\n   implicit none\n   class(thermodata) :: self\n   character(len=*) :: fname    \n   integer :: i,nt,io,ich\n   real(wp) :: dum1\n   character(80) :: atmp\n   write(*,*) 'reading from ',trim(fname)\n   if(allocated(self%temps))then\n       deallocate(self%temps)\n   endif\n   open(newunit=ich,file=fname)\n   nt=0\n   do\n      read(ich,'(a)',iostat=io) atmp\n      if(io < 0) exit  !EOF\n      read(atmp,*,iostat=io) dum1\n      if(io == 0)then\n          nt=nt+1\n      endif    \n   enddo\n   self%ntemps=nt\n   write(*,*) nt,' temperatures'\n   allocate(self%temps(nt))\n   rewind ich\n   i = 0\n   do\n      read(ich,'(a)',iostat=io) atmp\n      if(io < 0) exit  !EOF\n      read(atmp,*,iostat=io) dum1\n      if(io == 0)then\n        i=i+1\n        self%temps(i)=dum1\n      endif\n   enddo\n   close(ich)\n   write(*,*) self%ntemps\n   write(*,*) self%temps\n   return\nend subroutine thermo_read_temps\n\n!========================================================================================!\nend module crest_data\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/classes.f90 b/src/classes.f90
--- a/src/classes.f90	
+++ b/src/classes.f90	
@@ -22,920 +22,934 @@
 !================================================================================!
 
 module crest_data
-   use iso_fortran_env, wp => real64, dp => int64
-   use crest_calculator,only:calcdata
-   use dynamics_module, only:mddata
-   use strucrd, only:coord
-   use crest_type_timer, only:timer
-   implicit none
+  use iso_fortran_env,wp => real64,dp => int64
+  use crest_calculator,only:calcdata
+  use dynamics_module,only:mddata
+  use strucrd,only:coord
+  use crest_type_timer,only:timer
+  use lwoniom_module, only: lwoniom_input
+  implicit none
 
-   public :: systemdata
-   public :: timer   !> RE-EXPORT from crest_type_timer
-   public :: protobj
-   public :: constra
-   public :: optlevflag,optlevnum,optlevmap_alt
+  public :: systemdata
+  public :: timer   !> RE-EXPORT from crest_type_timer
+  public :: protobj
+  public :: constra
+  public :: optlevflag,optlevnum,optlevmap_alt
+  public :: optlev_to_multilev
 
-   !> basename for the CRE files
-   character(len=14),parameter,public :: crefile = 'crest_rotamers'              
-   !> basename for the conformer file
-   character(len=20),parameter,public :: conformerfile = 'crest_conformers.xyz'  
-   !> basename for the conformer file
-   character(len=16),parameter,public :: conformerfilebase = 'crest_conformers'  
-   !> basename for the conformer file
-   character(len=19),parameter,public :: clusterfile='crest_clustered.xyz'       
-   !> basename for the cluster file
-   character(len=*),parameter,public :: ensemblefile='crest_ensemble.xyz'
-   !> basename for the log file
-   character(len=*),parameter,public :: ensembleelog='ensemble_energies.log'
-   !> basename for the mecp file
-   character(len=*),parameter,public :: mecpensemble='crest_mecp_search.xyz'
+  !> basename for the CRE files
+  character(len=14),parameter,public :: crefile = 'crest_rotamers'
+  !> basename for the conformer file
+  character(len=20),parameter,public :: conformerfile = 'crest_conformers.xyz'
+  !> basename for the conformer file
+  character(len=16),parameter,public :: conformerfilebase = 'crest_conformers'
+  !> basename for the conformer file
+  character(len=19),parameter,public :: clusterfile = 'crest_clustered.xyz'
+  !> basename for the cluster file
+  character(len=*),parameter,public :: ensemblefile = 'crest_ensemble.xyz'
+  !> basename for the log file
+  character(len=*),parameter,public :: ensembleelog = 'ensemble_energies.log'
+  !> basename for the mecp file
+  character(len=*),parameter,public :: mecpensemble = 'crest_mecp_search.xyz'
 
-
-
-   logical,public :: gui = .false.
+  logical,public :: gui = .false.
 
-
 !============================================================================!
 ! runtype variables
 !============================================================================!
+!&<
 !>---- runtypes (variables for crest%crestver)
-   integer,parameter,public :: crest_none     = 0
-   integer,parameter,public :: crest_mfmdgc   = 1    
-   integer,parameter,public :: crest_imtd     = 2
-   integer,parameter,public :: crest_imtd2    = 22
-   integer,parameter,public :: crest_mdopt    = 3
-   integer,parameter,public :: crest_mdopt2   = 33
-   integer,parameter,public :: crest_screen   = 4
-   integer,parameter,public :: crest_nano     = 7
-   integer,parameter,public :: crest_compr    = 77
-   integer,parameter,public :: crest_msreac   = 9
-   integer,parameter,public :: crest_pka      = 14
-   integer,parameter,public :: crest_solv     = 15
+  integer,parameter,public :: crest_none     = 0
+  integer,parameter,public :: crest_mfmdgc   = 1
+  integer,parameter,public :: crest_imtd     = 2
+  integer,parameter,public :: crest_imtd2    = 22
+  integer,parameter,public :: crest_mdopt    = 3
+  integer,parameter,public :: crest_mdopt2   = 33
+  integer,parameter,public :: crest_screen   = 4
+  integer,parameter,public :: crest_nano     = 7
+  integer,parameter,public :: crest_compr    = 77
+  integer,parameter,public :: crest_msreac   = 9
+  integer,parameter,public :: crest_pka      = 14
+  integer,parameter,public :: crest_solv     = 15
 !>> runtypes with IDs between use non-legacy routines  <<!
-   integer,parameter,public :: crest_sp         = 264
-   integer,parameter,public :: crest_optimize   = 265
-   integer,parameter,public :: crest_moldyn     = 266
-   integer,parameter,public :: crest_s1         = 267
-   integer,parameter,public :: crest_mecp       = 268
-   integer,parameter,public :: crest_numhessian = 269
-   integer,parameter,public :: crest_scanning   = 270
-   integer,parameter,public :: crest_rigcon     = 271
-!>> <<! 
-   integer,parameter,public :: crest_test       = 456
+  integer,parameter,public :: crest_sp         = 264
+  integer,parameter,public :: crest_optimize   = 265
+  integer,parameter,public :: crest_moldyn     = 266
+  integer,parameter,public :: crest_s1         = 267
+  integer,parameter,public :: crest_mecp       = 268
+  integer,parameter,public :: crest_numhessian = 269
+  integer,parameter,public :: crest_scanning   = 270
+  integer,parameter,public :: crest_rigcon     = 271
+!>> <<!
+  integer,parameter,public :: crest_test       = 456
 
 !>---- tools (variables for env%properties)
-   integer,parameter,public :: p_none         =  0
-   integer,parameter,public :: p_cregen       = -1
-   integer,parameter,public :: p_compare      = -2
-   integer,parameter,public :: p_protonate    = -3
-   integer,parameter,public :: p_deprotonate  = -4
-   integer,parameter,public :: p_tautomerize  = -5
-   integer,parameter,public :: p_tautomerize2 = -555
-   integer,parameter,public :: p_isomerize    = -92
-   integer,parameter,public :: p_reactorset   = -312
-   integer,parameter,public :: p_CREentropy   = -45   
-   integer,parameter,public :: p_rrhoaverage  = -4450
-   integer,parameter,public :: p_cluster      = -70
-   integer,parameter,public :: p_propcalc     = -666
-   integer,parameter,public :: p_acidbase     = -788
-   integer,parameter,public :: p_ligand       = -355
-   integer,parameter,public :: p_gesc1        = -9224
-   integer,parameter,public :: p_gesc2        = -9225
-   integer,parameter,public :: p_thermo       = -3654
-   integer,parameter,public :: p_useonly      = -227
-   integer,parameter,public :: p_qcg          = 37
+  integer,parameter,public :: p_none         =  0
+  integer,parameter,public :: p_cregen       = -1
+  integer,parameter,public :: p_compare      = -2
+  integer,parameter,public :: p_protonate    = -3
+  integer,parameter,public :: p_deprotonate  = -4
+  integer,parameter,public :: p_tautomerize  = -5
+  integer,parameter,public :: p_zsort        = -6
+  integer,parameter,public :: p_tautomerize2 = -555
+  integer,parameter,public :: p_isomerize    = -92
+  integer,parameter,public :: p_reactorset   = -312
+  integer,parameter,public :: p_CREentropy   = -45
+  integer,parameter,public :: p_rrhoaverage  = -4450
+  integer,parameter,public :: p_cluster      = -70
+  integer,parameter,public :: p_propcalc     = -666
+  integer,parameter,public :: p_acidbase     = -788
+  integer,parameter,public :: p_ligand       = -355
+  integer,parameter,public :: p_gesc1        = -9224
+  integer,parameter,public :: p_gesc2        = -9225
+  integer,parameter,public :: p_thermo       = -3654
+  integer,parameter,public :: p_useonly      = -227
+  integer,parameter,public :: p_qcg          = 37
 
-!===========================================================================!
+!>--- refinement levels (typically after multilevel opt.)
+  type ,private:: refine_type
+    integer :: non         = 0
+    integer :: singlepoint = 1
+    integer :: correction  = 2
+    integer :: geoopt      = 3
+    integer :: ConfSolv    = 4
+  end type refine_type
+  type(refine_type), parameter,public :: refine = refine_type()
+
+!&>
+
+!========================================================================================!
+!========================================================================================!
 
-   private
+  private
 
+!========================================================================================!
 !========================================================================================!
 
-   type :: constra
-      integer :: ndim
-      logical :: used
-      logical :: NCI
-      logical :: ggrid = .false.
-      character(len=:),allocatable :: gbsagrid
-      character(len=128),allocatable :: sett(:)
-      character(len=128),allocatable :: buff(:)
-      character(len=128),allocatable :: pots(:)
-   !--- data of bondlength constraints
-      logical :: cbonds_global = .false.
-      logical :: cbonds_md     = .false.
-      integer :: n_cbonds = 0
-      character(len=128),allocatable :: cbonds(:)
-   !--- data of nano-reactor
-      logical :: ureactor = .false.
-      integer :: nrctrl = 0
-      character(len=128),allocatable :: rctrl(:)
-   !--- dispersion scaling (>xtb 6.4.0)
-      logical :: dispscal_md     = .false.
-      logical :: dispscal_global = .false.
-      real(wp) :: dscal = 1.0_wp
-   !--- RMSD corrected GFN/DFT hypersurface:  gESC method
-      character(len=:),allocatable :: rmsdpotfile
-      logical :: usermsdpot = .false.   
-      logical :: gesc_heavy = .false.
-    contains
-      procedure :: allocate => allocate_constraints
-      procedure :: deallocate => deallocate_constraints
-   end type constra
+  type :: constra
+    integer :: ndim
+    logical :: used
+    logical :: NCI
+    logical :: ggrid = .false.
+    character(len=:),allocatable :: gbsagrid
+    character(len=128),allocatable :: sett(:)
+    character(len=128),allocatable :: buff(:)
+    character(len=128),allocatable :: pots(:)
+    !--- data of bondlength constraints
+    logical :: cbonds_global = .false.
+    logical :: cbonds_md = .false.
+    integer :: n_cbonds = 0
+    character(len=128),allocatable :: cbonds(:)
+    !--- data of nano-reactor
+    logical :: ureactor = .false.
+    integer :: nrctrl = 0
+    character(len=128),allocatable :: rctrl(:)
+    !--- dispersion scaling (>xtb 6.4.0)
+    logical :: dispscal_md = .false.
+    logical :: dispscal_global = .false.
+    real(wp) :: dscal = 1.0_wp
+    !--- RMSD corrected GFN/DFT hypersurface:  gESC method
+    character(len=:),allocatable :: rmsdpotfile
+    logical :: usermsdpot = .false.
+    logical :: gesc_heavy = .false.
+  contains
+    procedure :: allocate => allocate_constraints
+    procedure :: deallocate => deallocate_constraints
+  end type constra
 
 !========================================================================================!
 
-   type :: protobj
-      integer :: nfrag
-      integer :: newchrg
-      integer :: iter
-      real(wp) :: popthr
-      real(wp) :: ewin
-      integer :: swchrg        !switch element charge
-      integer :: swat          !switch element element
-      logical :: swelem        !switch element to add to lmo lp pair?
-      logical :: allowFrag
-      logical :: threshsort    !use ewin threshold
-      logical :: protdeprot    !currently unused!
-      logical :: deprotprot    !(tautomerize) do first deprotonation and then protonation
+  type :: protobj
+    integer :: nfrag
+    integer :: newchrg
+    integer :: iter
+    real(wp) :: popthr
+    real(wp) :: ewin
+    integer :: swchrg        !switch element charge
+    integer :: swat          !switch element element
+    logical :: swelem        !switch element to add to lmo lp pair?
+    logical :: allowFrag
+    logical :: threshsort    !use ewin threshold
+    logical :: protdeprot    !currently unused!
+    logical :: deprotprot    !(tautomerize) do first deprotonation and then protonation
 
-      logical :: strictPDT = .false.  ! strict mode (i.e. bond constraints) for (de)protonation,tautomerization
-      logical :: fixPDT    = .false.  ! extension to the strict mode, fix heavy atom positions
-      logical :: ABcorrection = .false.
+    logical :: strictPDT = .false.  ! strict mode (i.e. bond constraints) for (de)protonation,tautomerization
+    logical :: fixPDT = .false.  ! extension to the strict mode, fix heavy atom positions
+    logical :: ABcorrection = .false.
 
-      integer,allocatable :: atmap(:)
+    integer,allocatable :: atmap(:)
 
-      !--- ligandtool
-      integer :: centeratom = 0
-      integer :: ligand     = 0
-      logical :: isatom = .false.
-      character(len=:),allocatable :: infile
-      character(len=:),allocatable :: newligand
+    !--- ligandtool
+    integer :: centeratom = 0
+    integer :: ligand = 0
+    logical :: isatom = .false.
+    character(len=:),allocatable :: infile
+    character(len=:),allocatable :: newligand
 
-      !--- pka
-      integer :: h_acidic = 0  !which h atom to remove in pka script
-      integer :: pka_mode = 0  !what to do in the pka calc.
-      character(len=:),allocatable :: pka_baseinp  !if a base file is read in instead
-      character(len=:),allocatable :: pka_acidensemble  !
-      character(len=:),allocatable :: pka_baseensemble  !
-      logical :: rdCFER =.false.
-      character(len=:),allocatable :: cferfile
+    !--- pka
+    integer :: h_acidic = 0  !which h atom to remove in pka script
+    integer :: pka_mode = 0  !what to do in the pka calc.
+    character(len=:),allocatable :: pka_baseinp  !if a base file is read in instead
+    character(len=:),allocatable :: pka_acidensemble  !
+    character(len=:),allocatable :: pka_baseensemble  !
+    logical :: rdCFER = .false.
+    character(len=:),allocatable :: cferfile
 
-      integer :: divers = 1    !number of structures red from given ensemble for extended taut. mode
-      logical :: alldivers = .false.  !use all structures of given ensemble for extended taut mode
-      logical,allocatable :: blacklist(:) !a blacklist of atoms to disallow deprotonation from
-   end type protobj
+    integer :: divers = 1    !number of structures read from given ensemble for extended taut. mode
+    logical :: alldivers = .false.  !use all structures of given ensemble for extended taut mode
+    logical,allocatable :: blacklist(:) !a blacklist of atoms to disallow deprotonation from
+  end type protobj
 
 !========================================================================================!
 
-   !--- ENTROPY mode setting object
-   type :: entropyMTD
-      integer :: nMDs           ! number of static MTDs
-      integer :: nBias          ! number of Bias structures
-      real(wp) :: nbiasgrow =1.2d0
-      integer :: iter = 4       ! number of iterations
-      integer :: iterlast = 1   ! document how many iterations were done
-      integer :: nconflast = 0  ! number of conformers in last iteraton
-      real(wp) :: lenfac        ! length factor of each static MTD
-      real(wp) :: temperature
-      real(wp) :: kpush = 0.0005d0  ! kpush per atom !SG
-      real(wp),allocatable :: klist(:)
-      integer :: nklist = 1
-      integer :: maxfallback = 10
-      real(wp) :: alpha = 1.0d0     ! exponent
-      real(wp) :: confthr =  -0.01d0  ! stop iterations if we get less than this fraction of new conformers
-      real(wp) :: sconvthr = -0.01d0 ! stop iterations based on estimated entroy change
-      integer  :: rmax = 5          ! max ring size to exclude from bias
-      integer :: katoms             ! number of atoms in bias
-      
-      real(wp) :: mtdramp = 0.03_wp
-      real(wp) :: sapprox
-      real(wp) :: sapproxlast
-      character(len=:),allocatable :: atomlist   
-      logical,allocatable :: atomlist2(:)
-      real(wp) :: trange(3)
-      integer :: nt = 0
-      real(wp),allocatable ::  cpoft(:)  !Cp(T)
-      real(wp),allocatable ::  soft(:)   !S(T)
-      real(wp),allocatable :: hoft(:)    !H(T)-H(0) 
-      !-- reference structure for BHESS
-      logical :: bhess =.true.
-      character(len=:),allocatable :: fromfile
-      integer :: nat
-      integer,allocatable :: at(:)
-      real(wp),allocatable :: xyz(:,:)
-   end type entropyMTD
+!>--- ENTROPY mode setting object
+  type :: entropyMTD
+    integer :: nMDs           ! number of static MTDs
+    integer :: nBias          ! number of Bias structures
+    real(wp) :: nbiasgrow = 1.2d0
+    integer :: iter = 4       ! number of iterations
+    integer :: iterlast = 1   ! document how many iterations were done
+    integer :: nconflast = 0  ! number of conformers in last iteraton
+    real(wp) :: lenfac        ! length factor of each static MTD
+    real(wp) :: temperature
+    real(wp) :: kpush = 0.0005d0  ! kpush per atom !SG
+    real(wp),allocatable :: klist(:)
+    integer :: nklist = 1
+    integer :: maxfallback = 10
+    real(wp) :: alpha = 1.0d0     ! exponent
+    real(wp) :: confthr = -0.01d0  ! stop iterations if we get less than this fraction of new conformers
+    real(wp) :: sconvthr = -0.01d0 ! stop iterations based on estimated entroy change
+    integer  :: rmax = 5          ! max ring size to exclude from bias
+    integer :: katoms             ! number of atoms in bias
+
+    real(wp) :: mtdramp = 0.03_wp
+    real(wp) :: sapprox
+    real(wp) :: sapproxlast
+    character(len=:),allocatable :: atomlist
+    logical,allocatable :: atomlist2(:)
+    real(wp) :: trange(3)
+    integer :: nt = 0
+    real(wp),allocatable ::  cpoft(:)  !Cp(T)
+    real(wp),allocatable ::  soft(:)   !S(T)
+    real(wp),allocatable :: hoft(:)    !H(T)-H(0)
+    !-- reference structure for BHESS
+    logical :: bhess = .true.
+    character(len=:),allocatable :: fromfile
+    integer :: nat
+    integer,allocatable :: at(:)
+    real(wp),allocatable :: xyz(:,:)
+  end type entropyMTD
 
 !========================================================================================!
-
-   type :: thermodata
-      real(wp) :: ithr  = -50.0_wp  !imaginary mode inversion (in xtb -20.0)
-      real(wp) :: fscal = 1.0_wp    !frequency scaling
-      real(wp) :: sthr  =  25.0_wp  !rot/vib interpol threshold (in xtb 50.0)
-      real(wp) :: trange(3)         
-      integer  :: ntemps
-      real(wp),allocatable :: temps(:)
-      real(wp) :: ptot = 0.9d0    ! population sthreshold
-      integer  :: pcap = 50000    ! limit number of structures
-      logical :: avbhess = .false.  !use bhess in the msRRHO average calc. for all structures (expensive!)
-      logical :: constrhess = .false. !apply constraints in rrhoav?
-      logical :: printpop = .false. !print a file with populations at different T
-    contains
-      procedure :: get_temps => thermo_get_temps
-      procedure :: read_temps => thermo_read_temps
-   end type thermodata
+!>--- thermodynamics evaluation data
+  type :: thermodata
+    real(wp) :: ithr = -50.0_wp  !> imaginary mode inversion (in xtb -20.0)
+    real(wp) :: fscal = 1.0_wp   !> frequency scaling
+    real(wp) :: sthr = 25.0_wp   !> rot/vib interpol threshold (in xtb 50.0)
+    real(wp) :: trange(3)
+    integer  :: ntemps
+    real(wp),allocatable :: temps(:)
+    real(wp) :: ptot = 0.9d0       !> population sthreshold
+    integer  :: pcap = 50000       !> limit number of structures
+    logical :: avbhess = .false.   !> use bhess in the msRRHO average calc. for all structures (expensive!)
+    logical :: constrhess = .false. !> apply constraints in rrhoav?
+    logical :: printpop   = .false. !> print a file with populations at different T
+  contains
+    procedure :: get_temps => thermo_get_temps
+    procedure :: read_temps => thermo_read_temps
+  end type thermodata
 
 !========================================================================================!
-
-   type :: refdata
-       integer :: nat
-       integer,allocatable :: at(:)
-       real(wp),allocatable :: xyz(:,:)
-       integer :: ichrg = 0
-       integer :: uhf = 0
-       integer :: ntopo
-       integer,allocatable :: topo(:)
-       real(wp),allocatable :: charges(:)
-       real(wp),allocatable :: wbo(:,:)
-    contains
-      procedure :: rdcharges => read_charges
-      procedure :: to => ref_to_mol
-   end type refdata
+!>--- storage of the reference (input structure)
+  type :: refdata
+    integer :: nat
+    integer,allocatable :: at(:)
+    real(wp),allocatable :: xyz(:,:)
+    integer :: ichrg = 0
+    integer :: uhf = 0
+    integer :: ntopo
+    integer,allocatable :: topo(:)
+    real(wp),allocatable :: charges(:)
+    real(wp),allocatable :: wbo(:,:)
+  contains
+    procedure :: rdcharges => read_charges
+    procedure :: to => ref_to_mol
+  end type refdata
 
-!========================================================================================!  
-
-   type :: systemdata
-    !--- GENERAL data
-      integer :: crestver     ! Runtype-variable
-      integer :: runver            ! additional runtype-variable
-      integer :: properties        ! additional stuff before or after the confsearch
-      integer :: properties2       ! backup variable
-      integer,allocatable :: pqueue(:) !property job queue
-      integer :: npq = 0           ! number of jobs in priority queue  
+!========================================================================================!
+!========================================================================================!
+!>--- GENERAL data
+  type :: systemdata
+    integer :: crestver          !> Runtype-variable
+    integer :: runver            !> additional runtype-variable
+    integer :: properties        !> additional stuff before or after the confsearch
+    integer :: properties2       !> backup variable
+    integer,allocatable :: pqueue(:) !> property job queue
+    integer :: npq = 0           !> number of jobs in priority queue
 
-      real(wp) :: level            ! increase/decrease factor of #modes in V1
-      real(wp) :: thresholds(8)    ! CREGEN thresholds
-      real(wp) :: ewin             ! Energy window (6 kcal default) 
-      real(wp) :: ethr             ! dE between conformers (0.05 kcal default)
-      real(wp) :: ethrpurge        ! dE between conformers (purgemode, 0.2 kcal default)
-      real(wp) :: couthr           ! CREGEN coulomb energy threshold
-      real(wp) :: rthr
-      real(wp) :: bthr
-      real(wp) :: bthr2            ! alternative BTHR (relative value BTHR threshold)
-      real(wp) :: bthrmax          ! max BTHR due to anisotropy 
-      real(wp) :: bthrshift        ! erf-shift of BTHR
-      real(wp) :: athr
-      real(wp) :: pthr
-      real(wp) :: pthrsum
-      real(wp) :: tboltz
-      logical  :: cgf(6)           ! collection of CREGEN options
+    real(wp) :: level            !> increase/decrease factor of #modes in V1
+    real(wp) :: thresholds(8)    !> CREGEN thresholds
+    real(wp) :: ewin             !> Energy window (6 kcal default)
+    real(wp) :: ethr             !> dE between conformers (0.05 kcal default)
+    real(wp) :: ethrpurge        !> dE between conformers (purgemode, 0.2 kcal default)
+    real(wp) :: couthr           !> CREGEN coulomb energy threshold
+    real(wp) :: rthr
+    real(wp) :: bthr
+    real(wp) :: bthr2            !> alternative BTHR (relative value BTHR threshold)
+    real(wp) :: bthrmax          !> max BTHR due to anisotropy
+    real(wp) :: bthrshift        !> erf-shift of BTHR
+    real(wp) :: athr
+    real(wp) :: pthr
+    real(wp) :: pthrsum
+    real(wp) :: tboltz
+    logical  :: cgf(6)           !> collection of CREGEN options
 
-      real(wp) :: mdtemps(10)      ! different temperatures for the QMDFF-MDs in V1
-      real(wp) :: mdtime           ! MD length (V1&2)
-      real(wp) :: elowest          ! Energy of the lowest conformer
-      real(wp) :: eprivious        ! Energy of the priviously lowest conformer
-      real(wp) :: gcmax            ! Max. number of structures for GC
-      real(wp) :: gcmaxparent = 1.2d7 ! Max. number of parent pairs for GC
+    real(wp) :: mdtemps(10)      !> different temperatures for the QMDFF-MDs in V1
+    real(wp) :: mdtime           !> MD length (V1&2)
+    real(wp) :: elowest          !> Energy of the lowest conformer
+    real(wp) :: eprivious        !> Energy of the priviously lowest conformer
+    real(wp) :: gcmax            !> Max. number of structures for GC
+    real(wp) :: gcmaxparent = 1.2d7 !> Max. number of parent pairs for GC
 
-      integer :: icount            ! Mode counter in V1
-      integer :: mdmode            ! MD mode in V1 xtb-MD or QMDFF
-      integer :: nmodes            ! number of NMs to follow (V1)
-      integer :: temps             ! number of MDs in V1, and NORMMDs in V2
-      integer :: snapshots         ! number of snapshots from MD (V1)
-      integer :: Maxrestart        ! max number of restarts in V1 and V3
-      integer :: nreset = 0        ! tracker of algo-iterations
-      integer :: nrotammds         ! Number of additional normal MDs in V2
-      integer :: maxcompare        ! maximal number of (lowest) conformers to compare when using "-compare"
-      integer :: tsplit            ! number of time splitting for entropy S(t=inf) extrapolation
+    integer :: icount            !> Mode counter in V1
+    integer :: mdmode            !> MD mode in V1 xtb-MD or QMDFF
+    integer :: nmodes            !> number of NMs to follow (V1)
+    integer :: temps             !> number of MDs in V1, and NORMMDs in V2
+    integer :: snapshots         !> number of snapshots from MD (V1)
+    integer :: Maxrestart        !> max number of restarts in V1 and V3
+    integer :: nreset = 0        !> tracker of algo-iterations
+    integer :: nrotammds         !> Number of additional normal MDs in V2
+    integer :: maxcompare        !> maximal number of (lowest) conformers to compare in -compare
+    integer :: tsplit            !> number of time splitting for entropy S(t=inf) extrapolation
 
-      integer  :: nat               !number of atoms    
-      integer  :: chrg              !molecular charge
-      integer  :: uhf               ! nα - nβ electrons
-      integer  :: MAXRUN            !number of parallel xtb jobs
-      integer  :: omp               !OMP/MKL_NUM_THREADS
-      integer  :: Threads           !Total number of threads (=omp*MAXRUN)
-      integer  :: rednat            !reduced Nat, if atom list is given
-      real(wp) :: optlev
-      real(wp) :: forceconst        !forceconstant (mainly for gff iMTD-GC)
+    integer  :: nat              !> number of atoms
+    integer  :: chrg             !> molecular charge
+    integer  :: uhf              !>  nα - nβ electrons
+    integer  :: MAXRUN           !> number of parallel xtb jobs
+    integer  :: omp              !> OMP/MKL_NUM_THREADS
+    integer  :: Threads          !> Total number of threads (=omp*MAXRUN)
+    integer  :: rednat           !> reduced Nat, if atom list is given
+    real(wp) :: optlev
+    real(wp) :: forceconst       !> forceconstant (mainly for gff iMTD-GC)
 
-      real(wp) :: dummypercent
+    real(wp) :: dummypercent
 
-
-    !--- various names and flags
-      character(len=128) :: ensemblename      !ensemble input name for SCREEN,MDOPT and CREGEN
-      character(len=128) :: ensemblename2     !another ensemble input name
-      character(len=128) :: fixfile
-      character(len=512) :: constraints       !name of the constraint file
-      character(len=20)  :: solvent !the solvent
-      character(len=:),allocatable :: solv !the entrie gbsa flag including solvent
-      character(len=20)  :: gfnver  !GFN version
-      character(len=20)  :: gfnver2 !GFN version (multilevel)
-      character(len=20)  :: lmover  !GFN version for LMO computation in xtb_lmo subroutine
-      character(len=512) :: ProgName!name of the executable, and enough space for a specified path
-      character(len=512) :: ProgIFF !name of xtbiff for QCG-mode
-      character(len=512) :: scratchdir !path to the scratch directory
-      character(len=1)   :: seperator !file-path seperator 
-      character(len=20)  :: devnull  !/dev/null or NUL
-      character(len=:),allocatable :: inputcoords, inputcoords_solv, inputcoords_solu
-      character(len=:),allocatable :: wbofile
-      character(len=:),allocatable :: atlist
-      character(len=:),allocatable :: chargesfilename
-      
-     !--- METADYN data
-      real(wp) :: hmass
-      real(wp) :: mdtemp
-      real(wp) :: nmdtemp
-      real(wp) :: mdstep
-      real(wp) :: mdlenfac
-      real(wp) :: tmtd
-      real(wp) :: flexi
-      integer  :: shake
-      integer  :: mddumpxyz
-      integer  :: mdskip
-      integer  :: mddump
-      integer  :: maxopt
-      real(wp) :: hlowopt
-      real(wp) :: microopt
-      real(wp) :: s6opt
+    !>--- various names and flags
+    character(len=128) :: ensemblename   !> ensemble input name for SCREEN,MDOPT and CREGEN
+    character(len=128) :: ensemblename2  !> another ensemble input name
+    character(len=128) :: fixfile
+    character(len=512) :: constraints    !> name of the constraint file
+    character(len=20)  :: solvent        !> the solvent
+    character(len=:),allocatable :: solv !> the entrie gbsa flag including solvent
+    character(len=20)  :: gfnver         !> GFN version
+    character(len=20)  :: gfnver2        !> GFN version (multilevel)
+    character(len=20)  :: lmover         !> GFN version for LMO computation in xtb_lmo subroutine
+    character(len=512) :: ProgName       !> name of the xtb executable (+ path)
+    character(len=512) :: ProgIFF        !> name of xtbiff for QCG-mode
+    character(len=512) :: homedir        !> original directory from which calculation was started
+    character(len=512) :: scratchdir     !> path to the scratch directory
+    character(len=:),allocatable :: cmd
+    character(len=:),allocatable :: inputcoords,inputcoords_solv,inputcoords_solu
+    character(len=:),allocatable :: wbofile
+    character(len=:),allocatable :: atlist
+    character(len=:),allocatable :: chargesfilename
+
+    !>--- METADYN data
+    real(wp) :: hmass
+    real(wp) :: mdtemp
+    real(wp) :: nmdtemp
+    real(wp) :: mdstep
+    real(wp) :: mdlenfac
+    real(wp) :: tmtd
+    real(wp) :: flexi
+    integer  :: shake
+    integer  :: mddumpxyz
+    integer  :: mdskip
+    integer  :: mddump
+    integer  :: maxopt
+    real(wp) :: hlowopt
+    real(wp) :: microopt
+    real(wp) :: s6opt
 
-      integer :: nmetadyn
-      real(wp),allocatable :: metadfac(:)
-      real(wp),allocatable :: metadexp(:)
-      integer,allocatable  :: metadlist(:)
-      
-      
-      character(len=:),allocatable :: mtdstaticfile
-      integer :: nstatic
+    integer :: nmetadyn
+    real(wp),allocatable :: metadfac(:)
+    real(wp),allocatable :: metadexp(:)
+    integer,allocatable  :: metadlist(:)
+    real(wp) :: mtd_kscal = 1.0_wp !> globally scale kpush for all metadynamics
+
+    character(len=:),allocatable :: mtdstaticfile
+    integer :: nstatic
 
-      integer,allocatable  :: includeRMSD(:)
-      logical,allocatable  :: excludeTOPO(:)
+    integer,allocatable  :: includeRMSD(:)
+    logical,allocatable  :: excludeTOPO(:)
 
-    !--- property data objects
-      type(protobj) :: ptb
-      type(protobj) :: ptb_solvent
-      type(protobj) :: ptb_solute
+    !>--- property data objects
+    type(protobj) :: ptb
+    type(protobj) :: ptb_solvent
+    type(protobj) :: ptb_solute
 
-
-    !--- saved constraints
-      type(constra) :: cts
+    !>--- saved constraints
+    type(constra) :: cts
 
-    !--- NCI mode data
-      real(wp) :: potscal
-    
-    !--- Nanoreactor data
-      real(wp) :: rdens     !reactor density      
-      real(wp) :: tempfermi = 6000.0d0 !logfermi temperature
+    !>--- NCI mode data
+    real(wp) :: potscal
+
+    !>--- Nanoreactor data
+    real(wp) :: rdens     !reactor density
+    real(wp) :: tempfermi = 6000.0d0 !logfermi temperature
 
-    !--- Entropy static MTDs object
-      type(entropyMTD) :: eMTD  
-      real(wp) :: XH3 = 0
-      real(wp) :: kappa = 1.5_wp   !> vM-kernel discretization
+    !>--- Entropy static MTDs object
+    type(entropyMTD) :: eMTD
+    real(wp) :: XH3 = 0
+    real(wp) :: kappa = 1.5_wp   !> vM-kernel discretization
 
-    !--- thermo data
-      type(thermodata) :: thermo  
+    !>--- thermo data
+    type(thermodata) :: thermo
 
-    !--- reference structure data (the input structure)
-      type(refdata) :: ref
-      type(refdata) :: qcg_solvent
-      type(refdata) :: qcg_solute
-      
-    !--- QCG data
-      integer           :: qcg_runtype = 0      !Default is grow, 1= ensemble & opt, 2= e_solv, 3= g_solv
-      integer           :: nsolv = 0            !Number of solventmolecules
-      integer           :: nqcgclust = 0        !Number of cluster to be taken
-      integer           :: max_solv = 0         !Maximal number of solvents added, if none is given
-      integer           :: ensemble_method = -1 !Default -1 for qcgmtd, 0= crest, 1= standard MD, 2= MTD
-      character(len=20) :: ensemble_opt         !Method for ensemble optimization in qcg mode
-      character(len=20) :: freqver              !Method for frequency computation in qcg mode
-      real(wp)          :: freq_scal            !Frequency scaling factor
-      character(len=:),allocatable :: solu_file, solv_file !solute  and solvent input file
-      character(len=5) :: docking_qcg_flag = '--qcg'
+    !>--- reference structure data (the input structure)
+    type(refdata) :: ref
+    type(refdata) :: qcg_solvent
+    type(refdata) :: qcg_solute
+
+    !>--- QCG data
+    integer           :: qcg_runtype = 0      !> Default is grow, 1= ensemble & opt, 2= e_solv, 3= g_solv
+    integer           :: nsolv = 0            !> Number of solventmolecules
+    integer           :: nqcgclust = 0        !> Number of cluster to be taken
+    integer           :: max_solv = 0         !> Maximal number of solvents added, if none is given
+    integer           :: ensemble_method = -1 !> Default -1 for qcgmtd, 0= crest, 1= standard MD, 2= MTD
+    character(len=:), allocatable :: directed_file !name of the directed list
+    character(len=64), allocatable :: directed_list(:,:) !How many solvents at which atom to add
+    integer, allocatable :: directed_number(:) !Numbers of solvents added per defined atom
+    character(len=20) :: ensemble_opt         !> Method for ensemble optimization in qcg mode
+    character(len=20) :: freqver              !> Method for frequency computation in qcg mode
+    real(wp)          :: freq_scal            !> Frequency scaling factor
+    character(len=:),allocatable :: solu_file,solv_file !> solute  and solvent input file
+    character(len=5) :: docking_qcg_flag = '--qcg'
 
-    !--- clustering data
-      integer :: maxcluster = 0  ! maximum number of clusters to be generated
-      integer :: nclust  = 0     ! fixed number of clusters (unly used if !=0)
-      integer :: pccap  = 100    ! maximum number of principal components used for clustering
-      real(wp) :: pcthr = 0.85d0
-      real(wp) :: pcmin = 0.05d0  
-      real(wp) :: csthr = 0.80d0
-      character(len=:),allocatable :: pcmeasure
-      integer :: clustlev = 0    ! clustering level
+    !>--- clustering data
+    integer :: maxcluster = 0  !> maximum number of clusters to be generated
+    integer :: nclust = 0      !> fixed number of clusters (unly used if !=0)
+    integer :: pccap = 100     !> maximum number of principal components used for clustering
+    real(wp) :: pcthr = 0.85d0
+    real(wp) :: pcmin = 0.05d0
+    real(wp) :: csthr = 0.80d0
+    character(len=:),allocatable :: pcmeasure
+    integer :: clustlev = 0    !> clustering level
 
-    !--- additional structure generation settings
-      logical :: doOHflip = .true.
-      integer :: maxflip = 1000  
+    !>--- additional structure generation settings
+    logical :: doOHflip = .true.
+    integer :: maxflip = 1000
 
-    !--- external RMSD bias to optimizations
-      character(len=:),allocatable :: biasfile
-      real(wp) :: rthr2 = 0.3_wp    ! Discard all structures with a bias smaller than this
-      real(wp) :: kshift = 3.0_wp   ! Shift of the k_i (in kcal/mol)  
-      integer :: kshiftnum = 4      ! try 5 different kshift (if not specified otherwise
-      real(wp) :: gescoptlev = 2.0_wp 
+    !>--- external RMSD bias to optimizations
+    character(len=:),allocatable :: biasfile
+    real(wp) :: rthr2 = 0.3_wp    !>  Discard all structures with a bias smaller than this
+    real(wp) :: kshift = 3.0_wp   !>  Shift of the k_i (in kcal/mol)
+    integer :: kshiftnum = 4      !>  try 5 different kshift (if not specified otherwise
+    real(wp) :: gescoptlev = 2.0_wp
 
-    !--- DFT driver arguments [DEPRECATED]
-      character(len=:),allocatable :: dftrcfile !i.e. ~/.dftrc
-      integer :: dftprog      !TM=1,ORCA=2
-      character(len=:),allocatable :: dftsetup   !,i.e. "cefine -func [...]"
-      character(len=:),allocatable :: dftsetup2  !,i.e. "cefine -func [...]" before aoforce
-      character(len=:),allocatable :: dftcall    !,i.e. "ridft [...]"
-      character(len=:),allocatable :: dftoptlev  !optimization level for dft
-      character(len=:),allocatable :: dftmasspar !dft mass scaling parameters
-      integer :: dftruntype   !OPT=1,SP=2,FREQ=3,autoIR=4
-      logical :: resetsetup = .false.
-      logical :: hardcutDFT = .false.  !use hard cut-off criteria for aoforce consideration
-      logical :: dftmasscal = .false.
-      real(wp) :: harcutpthr = 0.5_wp  !take no less than 50% population of ensemble
-      integer  :: hardcutnst = 5       !take no more than 5 structures
+    !>--- DFT driver arguments [DEPRECATED]
+    character(len=:),allocatable :: dftrcfile !i.e. ~/.dftrc
+    logical :: hardcutDFT = .false.  !use hard cut-off criteria for aoforce consideration
+    real(wp) :: harcutpthr = 0.5_wp  !take no less than 50% population of ensemble
+    integer  :: hardcutnst = 5       !take no more than 5 structures
 
-
-   !================================================!
-   !>--- Calculation settings for newer implementations (version >= 3.0)
-      type(calcdata) :: calc
-      type(mddata)   :: mddat
-   !>--- rigidconf data   
-      integer :: rigidconf_algo = 0
-      integer :: rigidconf_toposource = 0
-   !================================================! 
+    !================================================!
+    !>--- Calculation settings for newer implementations (version >= 3.0)
+    type(calcdata) :: calc
+    type(mddata)   :: mddat
+    !>--- rigidconf data
+    integer :: rigidconf_algo = 0
+    integer :: rigidconf_toposource = 0
+    character(len=:),allocatable :: rigidconf_userfile
+    !>--- refinement queue
+    integer,allocatable :: refine_queue(:)
+    !>--- lwONIOM input
+    character(len=:),allocatable    :: ONIOM_toml
+    type(lwoniom_input),allocatable :: ONIOM_input
+    !================================================!
 
-   !--- general logical data
-      logical :: allrot = .true.   ! use all rotational constants for check instead of mean?
-      logical :: altopt = .false.
-      logical :: autothreads       ! automatically determine threads
-      logical :: autozsort         ! do the ZSORT in the beginning ?
-      logical :: allowrestart = .true. !allow restart in crest algos?
-      logical :: better            ! found a better conformer and restart in V1
-      logical :: cff               ! CFF used in QCG-energy calculation
-      logical :: cluster = .false. ! perform a clustering analysis        
-      logical :: checktopo = .true.  !perform topolgy check in CREGEN
-      logical :: checkiso  = .false. !perform E/Z isomerization check in CREGEN
-      logical :: chargesfile = .false. !use a given charges file for gfnff
-      logical :: compareens        ! try to correlate 2 given Ensemble files
-      logical :: confgo            ! perform only the CREGEN routine ?
-      logical :: constrain_solu    ! constrain the solute
-      logical :: doNMR             ! determine NMR equivalencies in CREGEN ?
-      logical :: dryrun =.false.   ! dryrun to print settings
-      logical :: ENSO              ! some options for usage of CREST within ENSO
-      logical :: ens_const = .false. ! constrain solute also in Ensemble generation
-      logical :: entropic =.false. ! entropy mode
-      logical :: entropymd = .false. ! entropy mode static mtds
-      logical :: esort = .false.   ! legacy option in old cregen
-      logical :: ext               ! external
-      logical :: extLFER =.false.  ! read in external LFER parameters
-      logical :: fullcre = .false. ! calculate exact rotamer degeneracies
-      logical :: gbsa              ! use gbsa
-      logical :: gcmultiopt        ! 2 level optimization for GC in V2
-      logical :: heavyrmsd = .false. !use only heavy atoms for RMSD in CREGEN?
-      logical :: inplaceMode = .true. ! in-place mode: optimization dirs are created "on-the-fly"
-      logical :: iterativeV2       ! iterative version of V2 (= V3)
-      logical :: iru               ! re-use previously found conformers as bias in iterative approach
-      logical :: keepModef         ! keep MODEF* dirs in V1 ?
-      logical :: keepScratch = .false. ! keep scratch directory or delete it?
-      logical :: legacy = .true.   ! switch between the original system call routines of crest and newer, e.g. tblite implementations
-      logical :: metadynset        ! is the number of MTDs already set (V2) ?
-      logical :: methautocorr      ! try to automatically include Methyl equivalencies in CREGEN ?
-      logical :: multilevelopt     ! perform the multileveloptimization
-      logical :: newcregen = .false. ! use the CREGEN rewrite
-      logical :: NCI               ! NCI special usage
-      logical :: niceprint         ! make a nice progress-bar printout
-      logical :: noconst=.false.   ! no constrain of solute during QCG Growth
-      logical :: onlyZsort         ! do only the ZSORT routine ?
-      logical :: optpurge = .false. !MDOPT purge application
-      logical :: outputsdf = .false. ! write output ensemble as sdf?
-      logical :: pcaexclude = .false. ! exclude user set atoms from PCA?
-      logical :: pclean            ! cleanup option for property mode
-      logical :: performCross      ! perform the GC in V1/V2 ?
-      logical :: performMD         ! perform the MD in V1 ?
-      logical :: performModef      ! perform the MF in V1 ? 
-      logical :: performMTD        ! perform the MTD in V2 ?
-      logical :: preactormtd       ! prepare reactor mtd?
-      logical :: preactorpot       ! prepare reactor logfermi?
-      logical :: preopt            ! do a GFNn-xTB pre-optimization of the geometry?
-      logical :: presp =.false.    ! do a Sp calculation before starting a job?
-      logical :: printscoords      ! write scoord.* files in CREGEN ?
-      logical :: QCG               ! QCG special usage
-      logical :: qcg_flag = .false. ! QCG-parsing logical, only true, if qcg exclusive flags used
-      logical :: qcg_restart = .false. ! QCG, only true, if results from previous run are found
-      logical :: nopreopt = .false. ! Switch off preoptimization for QCG
-      logical :: quick             ! quick-run option (mainly for testing)
-      logical :: readbias = .false. ! read MTD parameters from file
-      logical :: reftopo = .true.    !use a reference topology from the given input structure
-      logical :: relax =.false.    ! was the --relax function used for protonation site search?
-      logical :: restartopt        ! restart in the second step of the multilevel opt (V2) ?
-      logical :: reweight=.false.  ! reweight structures on the fly after optimizations (i.e. do SPs)?
-      logical :: riso=.false.      ! take only isomers in reactor mode
-      logical :: rotamermds        ! do additional MDs after second  multilevel OPT step in V2 ?
-      logical :: sameRandomNumber =.false. !QCG related, choose same random number for iff
-      logical :: scallen           ! scale the automatically determined MD length by some factor?
-      logical :: scratch           ! use scratch directory
-      logical :: setgcmax = .false.! adjust the maxmimum number of structures taken into account for GC?
-      logical :: sdfformat = .false. ! was the SDF format used as input file?
-      logical :: slow              ! slowmode (counterpart to quick mode)
-      logical :: solv_md = .false. !switches on QCG-ensemblerun instead of CFF
-      logical :: staticmtd = .false. ! do a static MTD instead of normal MDs
-      logical :: subRMSD           ! include only the selected substructure into the CREGEN RMSD
-      logical :: superquick        ! very crude quick-run option
-      logical :: threadssetmanual  ! are #CPUs set with the '-T' flag ? 
-      logical :: trackorigin       ! track the origin of a conformation?
-      logical :: use_xtbiff = .false. !use xtbiff for QCG?
-      logical :: user_enslvl = .false. !true if user set qcg enslvl
-      logical :: user_temp = .false. !true if user set the MD temp
-      logical :: user_mdtime = .false. ! true if mdtime set by user
-      logical :: user_mdstep = .false. ! true if mdstep is set by user
-      logical :: user_nclust = .false. ! true if number of cluster is set by user (only QCG)
-      logical :: user_dumxyz =.false. !true if dumpxyz is set by user
-      logical :: user_wscal =.false. !true if wscal is set by user
-      logical :: useqmdff          ! use QMDFF in V2?
-      logical :: water = .false.   ! true if water is used as solvent (only QCG)
-      logical :: wallsetup = .false. ! set up a wall potential?
-      logical :: wbotopo =.false.  ! set up topo with WBOs   
+    !>--- general logical data
+    logical :: allrot = .true.       !> use all rotational constants for check instead of mean?
+    logical :: altopt = .false.
+    logical :: autothreads           !> automatically determine threads
+    logical :: autozsort             !> do the ZSORT in the beginning ?
+    logical :: allowrestart = .true. !> allow restart in crest algos?
+    logical :: better                !> found a better conformer and restart in V1
+    logical :: cff                   !> CFF used in QCG-energy calculation
+    logical :: cluster = .false.     !> perform a clustering analysis
+    logical :: checktopo = .true.    !> perform topolgy check in CREGEN
+    logical :: checkiso = .false.    !> perform E/Z isomerization check in CREGEN
+    logical :: chargesfile = .false. !> use a given charges file for gfnff
+    logical :: compareens            !> try to correlate 2 given Ensemble files
+    logical :: confgo                !> perform only the CREGEN routine ?
+    logical :: constrain_solu        !> constrain the solute
+    logical :: doNMR                 !> determine NMR equivalencies in CREGEN ?
+    logical :: dryrun = .false.      !> dryrun to print settings
+    logical :: ENSO                  !> some options for usage of CREST within ENSO
+    logical :: ens_const = .false.   !> constrain solute also in Ensemble generation
+    logical :: entropic = .false.    !> entropy mode
+    logical :: entropymd = .false.   !> entropy mode static mtds
+    logical :: esort = .false.       !> legacy option in old cregen
+    logical :: ext                   !> external
+    logical :: extLFER = .false.     !> read in external LFER parameters
+    logical :: FINAL_GFN2_OPT = .false.
+    logical :: fullcre = .false.     !> calculate exact rotamer degeneracies
+    logical :: gbsa                  !> use gbsa
+    logical :: gcmultiopt            !> 2 level optimization for GC in V2
+    logical :: heavyrmsd = .false.   !> use only heavy atoms for RMSD in CREGEN?
+    logical :: inplaceMode = .true.  !> in-place mode: optimization dirs are created "on-the-fly"
+    logical :: iterativeV2           !> iterative version of V2 (= V3)
+    logical :: iru                   !> re-use previously found conformers as bias in iterative approach
+    logical :: keepModef             !> keep MODEF* dirs in V1 ?
+    logical :: keepScratch = .false. !> keep scratch directory or delete it?
+    logical :: legacy = .false.       !> switch between the original system call routines of crest and newer, e.g. tblite implementations
+    logical :: metadynset            !> is the number of MTDs already set (V2) ?
+    logical :: methautocorr          !> try to automatically include Methyl equivalencies in CREGEN ?
+    logical :: multilevelopt         !> perform the multileveloptimization
+    logical :: newcregen = .false.   !> use the CREGEN rewrite
+    logical :: NCI                   !> NCI special usage
+    logical :: niceprint             !> make a nice progress-bar printout
+    logical :: noconst = .false.     !> no constrain of solute during QCG Growth
+    logical :: onlyZsort             !> do only the ZSORT routine ?
+    logical :: optpurge = .false.    !> MDOPT purge application
+    logical :: outputsdf = .false.   !> write output ensemble as sdf?
+    logical :: pcaexclude = .false.  !> exclude user set atoms from PCA?
+    logical :: pclean                !> cleanup option for property mode
+    logical :: performCross          !> perform the GC in V1/V2 ?
+    logical :: performMD             !> perform the MD in V1 ?
+    logical :: performModef          !> perform the MF in V1 ?
+    logical :: performMTD            !> perform the MTD in V2 ?
+    logical :: preactormtd           !> prepare reactor mtd?
+    logical :: preactorpot           !> prepare reactor logfermi?
+    logical :: preopt                !> do a GFNn-xTB pre-optimization of the geometry?
+    logical :: presp = .false.       !> do a Sp calculation before starting a job?
+    logical :: printscoords          !> write scoord.* files in CREGEN ?
+    logical :: QCG                   !> QCG special usage
+    logical :: qcg_flag = .false.    !> QCG-parsing logical, only true, if qcg exclusive flags used
+    logical :: qcg_restart = .false. !> QCG, only true, if results from previous run are found
+    logical :: nopreopt = .false.    !> Switch off preoptimization for QCG
+    logical :: quick                 !> quick-run option (mainly for testing)
+    logical :: readbias = .false.    !> read MTD parameters from file
+    logical :: reftopo = .true.      !> use a reference topology from the given input structure
+    logical :: relax = .false.       !> was the --relax function used for protonation site search?
+    logical :: restartopt            !> restart in the second step of the multilevel opt (V2) ?
+    logical :: reweight = .false.    !> reweight structures on the fly after optimizations (i.e. do SPs)?
+    logical :: riso = .false.        !> take only isomers in reactor mode
+    logical :: rotamermds            !> do additional MDs after second  multilevel OPT step in V2 ?
+    logical :: sameRandomNumber = .false. !> QCG related, choose same random number for iff
+    logical :: scallen               !> scale the automatically determined MD length by some factor?
+    logical :: scratch               !> use scratch directory
+    logical :: setgcmax = .false.    !> adjust the maxmimum number of structures taken into account for GC?
+    logical :: sdfformat = .false.   !> was the SDF format used as input file?
+    logical :: slow                  !> slowmode (counterpart to quick mode)
+    logical :: solv_md = .false.     !> switches on QCG-ensemblerun instead of CFF
+    logical :: staticmtd = .false.   !> do a static MTD instead of normal MDs
+    logical :: subRMSD               !> include only the selected substructure into the CREGEN RMSD
+    logical :: superquick            !> very crude quick-run option
+    logical :: threadssetmanual      !> are #CPUs set with the '-T' flag ?
+    logical :: trackorigin           !> track the origin of a conformation?
+    logical :: testnumgrad = .false. !> test numerical gradient in singlepoint
+    logical :: use_xtbiff = .false.  !> use xtbiff for QCG?
+    logical :: user_enslvl = .false. !> true if user set qcg enslvl
+    logical :: user_temp = .false.   !> true if user set the MD temp
+    logical :: user_mdtime = .false. !> true if mdtime set by user
+    logical :: user_mdstep = .false. !> true if mdstep is set by user
+    logical :: user_nclust = .false. !> true if number of cluster is set by user (only QCG)
+    logical :: user_dumxyz = .false. !> true if dumpxyz is set by user
+    logical :: user_wscal = .false.  !> true if wscal is set by user
+    logical :: useqmdff              !> use QMDFF in V2?
+    logical :: water = .false.       !> true if water is used as solvent (only QCG)
+    logical :: wallsetup = .false.   !> set up a wall potential?
+    logical :: wbotopo = .false.     !> set up topo with WBOs
 
-    contains
-      procedure :: allocate => allocate_metadyn
-      procedure :: deallocate => deallocate_metadyn
-      procedure :: addjob => add_to_pqueue
-      procedure :: checkhy => pqueue_hybrid
-      procedure :: rmhy    => pqueue_removehybrid
-      procedure :: wrtCHRG => wrtCHRG
-   end type systemdata
+  contains
+    procedure :: allocate => allocate_metadyn
+    procedure :: deallocate => deallocate_metadyn
+    procedure :: addjob => add_to_pqueue
+    procedure :: checkhy => pqueue_hybrid
+    procedure :: rmhy => pqueue_removehybrid
+    procedure :: addrefine => add_to_refinequeue
+    procedure :: wrtCHRG => wrtCHRG
+  end type systemdata
 
-!========================================================================================!
-
-!   type :: timer
-!     integer :: times = 0
-!     integer(dp):: rate
-!     integer(dp),allocatable :: t(:,:)
-!     character(len=32),allocatable :: names(:)
-!    contains
-!     procedure :: init  => init_timer
-!     procedure :: clear => clear_timer
-!     procedure :: start => start_timer
-!     procedure :: stop  => stop_timer
-!   end type timer
-
 !========================================================================================!
 !========================================================================================!
 contains  !> MODULE PROCEDURES START HERE
 !========================================================================================!
 !========================================================================================!
 
-subroutine allocate_metadyn(self,n)
-   implicit none
-   class(systemdata) :: self
-   integer,intent(in)  :: n
-   self%nmetadyn = n
-   if(.not.allocated( self%metadfac ))then
-       allocate( self%metadfac(n),  source = 0.0_wp )
-   endif
-   if(.not.allocated( self%metadexp ))then
-       allocate( self%metadexp(n),  source = 0.0_wp )
-   endif
-   if(.not.allocated( self%metadlist ))then
-       allocate( self%metadlist(n), source = 0 )
-   endif
-   return
-end subroutine allocate_metadyn
+  subroutine allocate_metadyn(self,n)
+    implicit none
+    class(systemdata) :: self
+    integer,intent(in)  :: n
+    self%nmetadyn = n
+    if (.not.allocated(self%metadfac)) then
+      allocate (self%metadfac(n),source=0.0_wp)
+    end if
+    if (.not.allocated(self%metadexp)) then
+      allocate (self%metadexp(n),source=0.0_wp)
+    end if
+    if (.not.allocated(self%metadlist)) then
+      allocate (self%metadlist(n),source=0)
+    end if
+    return
+  end subroutine allocate_metadyn
 !========================================================================================!
-subroutine deallocate_metadyn(self)
-   implicit none
-   class(systemdata) :: self
-   if (allocated( self%metadfac )) deallocate( self%metadfac )
-   if (allocated( self%metadexp )) deallocate( self%metadexp )
-   if (allocated( self%metadlist )) deallocate( self%metadlist )
-end subroutine deallocate_metadyn
+  subroutine deallocate_metadyn(self)
+    implicit none
+    class(systemdata) :: self
+    if (allocated(self%metadfac)) deallocate (self%metadfac)
+    if (allocated(self%metadexp)) deallocate (self%metadexp)
+    if (allocated(self%metadlist)) deallocate (self%metadlist)
+  end subroutine deallocate_metadyn
 !========================================================================================!
-subroutine allocate_constraints(self,n)
-   implicit none
-   class(constra) :: self
-   integer,intent(in)  :: n
-   self%ndim      = n
-   allocate( self%sett(n))
-   allocate( self%buff(n))
-   self%sett = ''
-   self%buff = ''
-end subroutine allocate_constraints
+  subroutine allocate_constraints(self,n)
+    implicit none
+    class(constra) :: self
+    integer,intent(in)  :: n
+    self%ndim = n
+    allocate (self%sett(n))
+    allocate (self%buff(n))
+    self%sett = ''
+    self%buff = ''
+  end subroutine allocate_constraints
 !========================================================================================!
-subroutine deallocate_constraints(self)
-   implicit none
-   class(constra) :: self
-   if (allocated( self%sett)) deallocate( self%sett )
-   if (allocated( self%buff )) deallocate( self%buff )
-end subroutine deallocate_constraints
+  subroutine deallocate_constraints(self)
+    implicit none
+    class(constra) :: self
+    if (allocated(self%sett)) deallocate (self%sett)
+    if (allocated(self%buff)) deallocate (self%buff)
+  end subroutine deallocate_constraints
+
 !========================================================================================!
-!subroutine init_timer(self,n)
-!   implicit none
-!   class(timer) :: self
-!   integer,intent(in)  :: n
-!   integer(dp) :: dummy
-!   self%times      = n
-!   call system_clock ( dummy, self%rate )
-!   allocate( self%t(n,3),  source = 0_dp )
-!   allocate( self%names(n))
-!   self%names = ''
-!end subroutine init_timer
-!!========================================================================================!
-!subroutine clear_timer(self)
-!   implicit none
-!   class(timer) :: self
-!   deallocate( self%t )
-!   deallocate( self%names )
-!end subroutine clear_timer
-!!========================================================================================!
-!subroutine start_timer(self,n,inp)
-!   implicit none
-!   class(timer) :: self
-!   integer,intent(in)  :: n
-!   character(len=*) :: inp
-!   integer(dp) :: dummy
-!   self%names(n) = inp
-!   call system_clock ( self%t(n,1) , dummy )
-!end subroutine start_timer
-!!========================================================================================!
-!subroutine stop_timer(self,n)
-!   implicit none
-!   class(timer) :: self
-!   integer,intent(in)  :: n
-!   integer(dp) :: dummy
-!   call system_clock ( self%t(n,2) , dummy )
-!   self%t(n,3)=self%t(n,3) + (self%t(n,2)-self%t(n,1))
-!end subroutine stop_timer
-!----------------------------------------------------------------------------------------------------
-!----------------------------------------------------------------------------------------------------
-subroutine add_to_pqueue(self,pjob)
-   implicit none
-   class(systemdata) :: self
-   integer :: pjob
-   integer :: idum
-   integer,allocatable :: qdum(:)
-   idum = self%npq
-   self%npq = self%npq + 1 !add a job to the queue
-   if(.not.allocated(self%pqueue))then   
-       allocate(self%pqueue(1))
-       self%pqueue(1) = pjob
-   else
-       allocate(qdum(self%npq))
-       qdum(1:idum) = self%pqueue(1:idum)
-       qdum(self%npq) = pjob
-       call move_alloc(qdum,self%pqueue)
-   endif
-   return
-end subroutine add_to_pqueue
+!========================================================================================!
+
+  subroutine add_to_pqueue(self,pjob)
+    implicit none
+    class(systemdata) :: self
+    integer :: pjob
+    integer :: idum
+    integer,allocatable :: qdum(:)
+    idum = self%npq
+    self%npq = self%npq+1 !add a job to the queue
+    if (.not.allocated(self%pqueue)) then
+      allocate (self%pqueue(1))
+      self%pqueue(1) = pjob
+    else
+      allocate (qdum(self%npq))
+      qdum(1:idum) = self%pqueue(1:idum)
+      qdum(self%npq) = pjob
+      call move_alloc(qdum,self%pqueue)
+    end if
+    return
+  end subroutine add_to_pqueue
 
-!========================================================================================!
+  subroutine pqueue_hybrid(self)
 !> check the queue for requested hybrid reoptimization (e.g. '-gfn2@gff')
 !> and sort it accordingly
-subroutine pqueue_hybrid(self)
-   implicit none
-   class(systemdata) :: self
-   integer :: i,pjob,n,k
-   integer,allocatable :: qdum(:)
-   n=self%npq
-   if(self%npq .gt. 1)then
-       if(any(self%pqueue.ge.50 .and. self%pqueue.lt.60))then
-           allocate(qdum(n), source = 0)
-           do i=1,n
-             pjob=self%pqueue(i)
-             if(pjob.ge.50 .and. pjob.lt.60)then
-                qdum(1)=pjob 
-            endif 
-           enddo
-           k=2
-           do i=1,n
-             pjob=self%pqueue(i)
-             if(pjob==0)cycle
-             if(pjob.lt.50 .or. pjob.ge.60)then
-               qdum(k)=pjob  
-               k=k+1
-             endif
-           enddo
-           call move_alloc(qdum,self%pqueue)
-       endif
-   endif
-   return
-end subroutine pqueue_hybrid
+    implicit none
+    class(systemdata) :: self
+    integer :: i,pjob,n,k
+    integer,allocatable :: qdum(:)
+    n = self%npq
+    if (self%npq .gt. 1) then
+      if (any(self%pqueue .ge. 50.and.self%pqueue .lt. 60)) then
+        allocate (qdum(n),source=0)
+        do i = 1,n
+          pjob = self%pqueue(i)
+          if (pjob .ge. 50.and.pjob .lt. 60) then
+            qdum(1) = pjob
+          end if
+        end do
+        k = 2
+        do i = 1,n
+          pjob = self%pqueue(i)
+          if (pjob == 0) cycle
+          if (pjob .lt. 50.or.pjob .ge. 60) then
+            qdum(k) = pjob
+            k = k+1
+          end if
+        end do
+        call move_alloc(qdum,self%pqueue)
+      end if
+    end if
+    return
+  end subroutine pqueue_hybrid
 
-subroutine pqueue_removehybrid(self)
-   implicit none
-   class(systemdata) :: self
-   integer :: i,pjob,n
-   n=self%npq
-   if(self%npq .gt. 1)then
-           do i=1,n
-             pjob=self%pqueue(i)
-             if(pjob.ge.50 .and. pjob.lt.60)then
-                self%pqueue(i) = 0
-                self%npq = self%npq- 1
-            endif
-           enddo
-   endif
-   return
-end subroutine pqueue_removehybrid
+  subroutine pqueue_removehybrid(self)
+    implicit none
+    class(systemdata) :: self
+    integer :: i,pjob,n
+    n = self%npq
+    if (self%npq .gt. 1) then
+      do i = 1,n
+        pjob = self%pqueue(i)
+        if (pjob .ge. 50.and.pjob .lt. 60) then
+          self%pqueue(i) = 0
+          self%npq = self%npq-1
+        end if
+      end do
+    end if
+    return
+  end subroutine pqueue_removehybrid
 
+
+  subroutine add_to_refinequeue(self,refinetype)
+    implicit none
+    class(systemdata) :: self
+    integer :: refinetype
+    integer :: idum
+    integer,allocatable :: qdum(:)
+    if( refinetype <= 0 ) return
+    if (.not.allocated(self%refine_queue)) then
+      allocate (self%refine_queue(1))
+      self%refine_queue(1) = refinetype
+    else
+      idum = size(self%refine_queue,1)
+      allocate (qdum(idum+1))
+      qdum(1:idum) = self%refine_queue(1:idum)
+      qdum(idum+1) = refinetype
+      call move_alloc(qdum,self%pqueue)
+    end if
+    return
+  end subroutine add_to_refinequeue
+
+!========================================================================================!
 !========================================================================================!
 !> write a .CHRG (and .UHF) file in the specified dir, but only if it is needed
-subroutine wrtCHRG(self,dir)
+  subroutine wrtCHRG(self,dir)
     implicit none
     class(systemdata) :: self
-    character(len=*) :: dir    
+    character(len=*) :: dir
     character(len=:),allocatable :: path
     integer :: ich,k,i
     k = len_trim(dir)
-    if(self%chrg.ne.0)then
-       if(k>0)then 
-       path=trim(dir)//'/'//'.CHRG'
-       else
-       path='.CHRG'
-       endif    
-       open(newunit=ich,file=path)
-       write(ich,*) self%chrg
-       if(self%QCG) then
-          write(ich,*) self%chrg
-          write(ich,*) '0'
+    if (self%chrg .ne. 0) then
+      if (k > 0) then
+        path = trim(dir)//'/'//'.CHRG'
+      else
+        path = '.CHRG'
+      end if
+      open (newunit=ich,file=path)
+      write (ich,*) self%chrg
+      if (self%QCG) then
+        write (ich,*) self%chrg
+        write (ich,*) '0'
       end if
-       close(ich)
-    endif    
-    if(self%UHF.ne.0)then
-       if(k>0)then
-       path=trim(dir)//'/'//'.UHF'
-       else
-       path='.UHF'
-       endif    
-       open(newunit=ich,file=path)
-       write(ich,*) self%uhf
-       if(self%QCG) then
-          write(ich,*) self%uhf
-          write(ich,*) '0'
-       end if
-      close(ich)
-    endif  
-    if(self%chargesfile .and. allocated(self%ref%charges))then
-       if(k>0)then 
-       path=trim(dir)//'/'//'charges'
-       else
-       path='charges'
-       endif
-       open(newunit=ich,file=path)
-       do i=1,self%ref%nat
-       write(ich,'(1x,f16.8)') self%ref%charges(i)
-       enddo
-       close(ich)
-    endif
+      close (ich)
+    end if
+    if (self%UHF .ne. 0) then
+      if (k > 0) then
+        path = trim(dir)//'/'//'.UHF'
+      else
+        path = '.UHF'
+      end if
+      open (newunit=ich,file=path)
+      write (ich,*) self%uhf
+      if (self%QCG) then
+        write (ich,*) self%uhf
+        write (ich,*) '0'
+      end if
+      close (ich)
+    end if
+    if (self%chargesfile.and.allocated(self%ref%charges)) then
+      if (k > 0) then
+        path = trim(dir)//'/'//'charges'
+      else
+        path = 'charges'
+      end if
+      open (newunit=ich,file=path)
+      do i = 1,self%ref%nat
+        write (ich,'(1x,f16.8)') self%ref%charges(i)
+      end do
+      close (ich)
+    end if
     return
-end subroutine wrtCHRG 
+  end subroutine wrtCHRG
 
 !========================================================================================!
 !> read atomic charges from a file (one line per atom)
-subroutine read_charges(self,chargesfilename,totchrg)
+  subroutine read_charges(self,chargesfilename,totchrg)
     implicit none
     class(refdata) :: self
     character(len=*) :: chargesfilename
     integer :: ich,io,i
     real(wp) :: dum,tot
     integer :: totchrg
-    if(allocated(self%charges))deallocate(self%charges)
-    if(self%nat>0)then
-        allocate(self%charges(self%nat),source=0.0_wp)
-        open(newunit=ich,file=chargesfilename)
-        do i=1,self%nat
-         read(ich,*,iostat=io) dum
-         if(io==0)then
-           self%charges(i) = dum
-         endif
-        enddo
-        close(io)
-    endif
-    tot=0.0_wp
-    do i=1,self%nat
-      tot=tot+self%charges(i)
-    enddo
+    if (allocated(self%charges)) deallocate (self%charges)
+    if (self%nat > 0) then
+      allocate (self%charges(self%nat),source=0.0_wp)
+      open (newunit=ich,file=chargesfilename)
+      do i = 1,self%nat
+        read (ich,*,iostat=io) dum
+        if (io == 0) then
+          self%charges(i) = dum
+        end if
+      end do
+      close (io)
+    end if
+    tot = 0.0_wp
+    do i = 1,self%nat
+      tot = tot+self%charges(i)
+    end do
     totchrg = nint(tot)
     return
-end subroutine read_charges
+  end subroutine read_charges
 
-subroutine ref_to_mol(self,mol)
+  subroutine ref_to_mol(self,mol)
     implicit none
     class(refdata) :: self
     type(coord) :: mol
     mol%nat = self%nat
-    mol%at  = self%at
+    mol%at = self%at
     mol%xyz = self%xyz
     mol%chrg = self%ichrg
-    mol%uhf  = self%uhf
+    mol%uhf = self%uhf
     return
-end subroutine ref_to_mol
+  end subroutine ref_to_mol
 
-
 !========================================================================================!
-function optlevflag(optlev) result(flag)
+!========================================================================================!
+
+  function optlevflag(optlev) result(flag)
     implicit none
     real(wp),intent(in) :: optlev
     character(len=:),allocatable :: flag
-    flag=''
-    if(optlev <= 3.0d0) flag='extreme'
-    if(optlev <= 2.0d0) flag='very tight'
-    if(optlev <= 1.0d0) flag='tight'
-    if(optlev <= 0.0d0) flag='normal'
-    if(optlev <= -1.0d0) flag='loose'
-    if(optlev <= -2.0d0) flag='very loose'
-    if(optlev <= -3.0d0) flag='crude'
+    flag = ''
+    if (optlev <= 3.0d0) flag = 'extreme'
+    if (optlev <= 2.0d0) flag = 'very tight'
+    if (optlev <= 1.0d0) flag = 'tight'
+    if (optlev <= 0.0d0) flag = 'normal'
+    if (optlev <= -1.0d0) flag = 'loose'
+    if (optlev <= -2.0d0) flag = 'very loose'
+    if (optlev <= -3.0d0) flag = 'crude'
+    if (optlev <= -4.0d0) flag = 'lax'
     return
-end function optlevflag
+  end function optlevflag
 
-function optlevnum(flag) result(optlev)
+  function optlevnum(flag) result(optlev)
     implicit none
     real(wp) :: optlev
     character(len=*):: flag
     optlev = 0.0_wp
-    if(index(flag,'crude'    ).ne.0) optlev=-3.0d0
-    if(index(flag,'loose'    ).ne.0) optlev=-1.0d0
-    if(index(flag,'vloose'   ).ne.0) optlev=-2.0d0
-    if(index(flag,'sloppy'   ).ne.0) optlev=-2.0d0
-    if(index(flag,'normal'   ).ne.0) optlev=0.0d0
-    if(index(flag,'tight'    ).ne.0) optlev=1.0d0
-    if(index(flag,'verytight').ne.0) optlev=2.0d0
-    if(index(flag,'vtight'   ).ne.0) optlev=2.0d0
-    if(index(flag,'2'        ).ne.0) optlev=2.0d0
-    if(index(flag,'1'        ).ne.0) optlev=1.0d0
-    if(index(flag,'0'        ).ne.0) optlev=0.0d0
-    if(index(flag,'-3'       ).ne.0) optlev=-3.0d0
-    if(index(flag,'-2'       ).ne.0) optlev=-2.0d0
-    if(index(flag,'-1'       ).ne.0) optlev=-1.0d0
+    if (index(flag,'crude') .ne. 0) optlev = -3.0d0
+    if (index(flag,'loose') .ne. 0) optlev = -1.0d0
+    if (index(flag,'vloose') .ne. 0) optlev = -2.0d0
+    if (index(flag,'sloppy') .ne. 0) optlev = -2.0d0
+    if (index(flag,'normal') .ne. 0) optlev = 0.0d0
+    if (index(flag,'tight') .ne. 0) optlev = 1.0d0
+    if (index(flag,'verytight') .ne. 0) optlev = 2.0d0
+    if (index(flag,'vtight') .ne. 0) optlev = 2.0d0
+    if (index(flag,'2') .ne. 0) optlev = 2.0d0
+    if (index(flag,'1') .ne. 0) optlev = 1.0d0
+    if (index(flag,'0') .ne. 0) optlev = 0.0d0
+    if (index(flag,'-3') .ne. 0) optlev = -3.0d0
+    if (index(flag,'-2') .ne. 0) optlev = -2.0d0
+    if (index(flag,'-1') .ne. 0) optlev = -1.0d0
     return
-end function optlevnum
+  end function optlevnum
 
-function optlevmap_alt(optin) result(optout)
+  function optlevmap_alt(optin) result(optout)
 !> a mapping from env%optlev to integer
 !> that is used in the multilevel_oloop selection
-   implicit none
-   integer :: optout
-   real(wp),intent(in) :: optin
-   integer :: k
-   integer,parameter :: omap(7) = [ 1, 2, 3, 4, 5, 6, 6]
-   k = nint(optin) + 4
-   optout = omap(k)
-end function optlevmap_alt
+    implicit none
+    integer :: optout
+    real(wp),intent(in) :: optin
+    integer :: k
+    integer,parameter :: omap(7) = [1,2,3,4,5,6,6]
+    k = nint(optin)+4
+    optout = omap(k)
+  end function optlevmap_alt
 
+  subroutine optlev_to_multilev(optlev,multilev)
+    implicit none
+    real(wp),intent(in) :: optlev
+    logical,intent(out) :: multilev(6)
+    integer :: j
+    if (optlev <= 3.0d0)then !> "extreme" thresholds
+      multilev(:) = .false.
+      multilev(6) = .true.
+      multilev(4) = .true.
+      multilev(1) = .true.
+    endif
+    j = optlevmap_alt(optlev)
+    j = max(j-1, 1)  !> j is reduced by one
+    if (optlev <= 2.0d0)then  !> "normal" to "vtight"
+     multilev(:) = .false.
+     multilev(1) = .true.
+     multilev(j) = .true.
+    endif
+    if (optlev <= -1.0d0)then !> "loose" to "crude"
+     multilev(:) = .false.
+     multilev(j) = .true.
+    endif
+  end subroutine optlev_to_multilev
+
+!========================================================================================!
 !========================================================================================!
 
-subroutine thermo_get_temps(self)
-   implicit none
-   class(thermodata) :: self
-   integer :: i,nt
-   real(wp) :: dum1
-   if(allocated(self%temps))then
-       deallocate(self%temps)
-   endif
-   dum1 = (self%trange(2)-self%trange(1))
-   nt  = nint( dum1/self%trange(3)) + 1
-   if(nt < 1) nt=1
-   self%ntemps=nt
-   allocate(self%temps(nt))
-   dum1 = self%trange(1)
-   do i=1,nt
-      self%temps(i)=dum1
-      dum1 = dum1 +self%trange(3)
-   enddo
-   return
-end subroutine thermo_get_temps
+  subroutine thermo_get_temps(self)
+    implicit none
+    class(thermodata) :: self
+    integer :: i,nt
+    real(wp) :: dum1
+    if (allocated(self%temps)) then
+      deallocate (self%temps)
+    end if
+    dum1 = (self%trange(2)-self%trange(1))
+    nt = nint(dum1/self%trange(3))+1
+    if (nt < 1) nt = 1
+    self%ntemps = nt
+    allocate (self%temps(nt))
+    dum1 = self%trange(1)
+    do i = 1,nt
+      self%temps(i) = dum1
+      dum1 = dum1+self%trange(3)
+    end do
+    return
+  end subroutine thermo_get_temps
 
-subroutine thermo_read_temps(self,fname)
-   implicit none
-   class(thermodata) :: self
-   character(len=*) :: fname    
-   integer :: i,nt,io,ich
-   real(wp) :: dum1
-   character(80) :: atmp
-   write(*,*) 'reading from ',trim(fname)
-   if(allocated(self%temps))then
-       deallocate(self%temps)
-   endif
-   open(newunit=ich,file=fname)
-   nt=0
-   do
-      read(ich,'(a)',iostat=io) atmp
-      if(io < 0) exit  !EOF
-      read(atmp,*,iostat=io) dum1
-      if(io == 0)then
-          nt=nt+1
-      endif    
-   enddo
-   self%ntemps=nt
-   write(*,*) nt,' temperatures'
-   allocate(self%temps(nt))
-   rewind ich
-   i = 0
-   do
-      read(ich,'(a)',iostat=io) atmp
-      if(io < 0) exit  !EOF
-      read(atmp,*,iostat=io) dum1
-      if(io == 0)then
-        i=i+1
-        self%temps(i)=dum1
-      endif
-   enddo
-   close(ich)
-   write(*,*) self%ntemps
-   write(*,*) self%temps
-   return
-end subroutine thermo_read_temps
+  subroutine thermo_read_temps(self,fname)
+    implicit none
+    class(thermodata) :: self
+    character(len=*) :: fname
+    integer :: i,nt,io,ich
+    real(wp) :: dum1
+    character(80) :: atmp
+    write (*,*) 'reading from ',trim(fname)
+    if (allocated(self%temps)) then
+      deallocate (self%temps)
+    end if
+    open (newunit=ich,file=fname)
+    nt = 0
+    do
+      read (ich,'(a)',iostat=io) atmp
+      if (io < 0) exit  !EOF
+      read (atmp,*,iostat=io) dum1
+      if (io == 0) then
+        nt = nt+1
+      end if
+    end do
+    self%ntemps = nt
+    write (*,*) nt,' temperatures'
+    allocate (self%temps(nt))
+    rewind ich
+    i = 0
+    do
+      read (ich,'(a)',iostat=io) atmp
+      if (io < 0) exit  !EOF
+      read (atmp,*,iostat=io) dum1
+      if (io == 0) then
+        i = i+1
+        self%temps(i) = dum1
+      end if
+    end do
+    close (ich)
+    write (*,*) self%ntemps
+    write (*,*) self%temps
+    return
+  end subroutine thermo_read_temps
 
+!========================================================================================!
 !========================================================================================!
 end module crest_data
Index: .gitmodules
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[submodule \"subprojects/gfn0\"]\n\tpath = subprojects/gfn0\n\turl = https://github.com/pprcht/gfn0.git\n    branch = main\n[submodule \"subprojects/toml-f\"]\n\tpath = subprojects/toml-f\n\turl = https://github.com/toml-f/toml-f.git\n    branch = main\n[submodule \"subprojects/gfnff\"]\n\tpath = subprojects/gfnff\n\turl = https://github.com/pprcht/gfnff\n    branch = master \n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitmodules b/.gitmodules
--- a/.gitmodules	
+++ b/.gitmodules	
@@ -8,5 +8,8 @@
     branch = main
 [submodule "subprojects/gfnff"]
 	path = subprojects/gfnff
-	url = https://github.com/pprcht/gfnff
+	url = https://github.com/pprcht/gfnff.git
     branch = master 
+[submodule "subprojects/tblite"]
+	path = subprojects/tblite
+	url = https://github.com/tblite/tblite.git
Index: src/neighbor.f
===================================================================
diff --git a/src/neighbor.f b/src/neighbor.f
deleted file mode 100644
--- a/src/neighbor.f	
+++ /dev/null	
@@ -1,321 +0,0 @@
-!================================================================================!
-! This file is part of crest.
-!
-! Copyright (C) 2017 Stefan Grimme
-!
-! crest is free software: you can redistribute it and/or modify it under
-! the terms of the GNU Lesser General Public License as published by
-! the Free Software Foundation, either version 3 of the License, or
-! (at your option) any later version.
-!
-! crest is distributed in the hope that it will be useful,
-! but WITHOUT ANY WARRANTY; without even the implied warranty of
-! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-! GNU Lesser General Public License for more details.
-!
-! You should have received a copy of the GNU Lesser General Public License
-! along with crest.  If not, see <https://www.gnu.org/licenses/>.
-!================================================================================!
-
-c determine ring and ringsize from neighbor list
-c SG 2017, for QMDFF
-      subroutine getring(n,nbin,a0,c,iring)
-      implicit none
-      integer n,nbin(20,n),a0,iring,i,nb(20,0:n)
-      integer    i1,i2,i3,i4,i5,i6,i7,i8,i9,i10
-      integer n0,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10
-      integer    a1,a2,a3,a4,a5,a6,a7,a8,a9,a10
-      integer c(10)
-      logical chk
- 
-      if(n.le.2) return
-
-      nb(:,1:n)=nbin(:,:)
-      do i=1,n
-         if(nb(20,i).eq.1)nb(20,i)=0
-      enddo
-
-      iring =0
-      c     =0
-
-      n0=nb(20,a0)
-
-      do i1=1,n0
-         a1=nb(i1,a0)
-         if(a1.eq.a0) cycle
-         n1=nb(20,a1)
-         do i2=1,n1
-            a2=nb(i2,a1)
-            if(a2.eq.a1) cycle
-            n2=nb(20,a2)
-            do i3=1,n2
-               a3=nb(i3,a2)
-               n3=nb(20,a3)
-               if(a3.eq.a2) cycle
-               c(1)=a1
-               c(2)=a2
-               c(3)=a3
-               if(a3.eq.a0.and.chk(n,3,c))then
-               iring=3
-               goto 99
-               endif
-               do i4=1,n3
-                  a4=nb(i4,a3)
-                  n4=nb(20,a4)
-                  if(a4.eq.a3) cycle
-                  c(4)=a4
-                  if(a4.eq.a0.and.chk(n,4,c))then
-                     iring=4
-                     goto 99
-                  endif
-                  do i5=1,n4
-                     a5=nb(i5,a4)
-                     n5=nb(20,a5)
-                     if(a5.eq.a4) cycle
-                     c(5)=a5
-                     if(a5.eq.a0.and.chk(n,5,c))then
-                        iring=5
-                        goto 99
-                     endif
-                     do i6=1,n5
-                        a6=nb(i6,a5)
-                        n6=nb(20,a6)
-                        if(a6.eq.a5) cycle
-                        c(6)=a6
-                        if(a6.eq.a0.and.chk(n,6,c))then
-                           iring=6
-                           goto 99
-                        endif
-                        do i7=1,n6
-                           a7=nb(i7,a6)
-                           n7=nb(20,a7)
-                           if(a7.eq.a6) cycle
-                           c(7)=a7
-                           if(a7.eq.a0.and.chk(n,7,c))then
-                              iring=7
-                              goto 99
-                           endif
-                           do i8=1,n7
-                              a8=nb(i8,a7)
-                              n8=nb(20,a8)
-                              if(a8.eq.a7) cycle
-                              c(8)=a8
-                              if(a8.eq.a0.and.chk(n,8,c))then
-                                 iring=8
-                                 goto 99
-                              endif
-                              do i9=1,n8
-                                 a9=nb(i9,a8)
-                                 n9=nb(20,a9)
-                                 if(a9.eq.a8) cycle
-                                 c(9)=a9
-                                 if(a9.eq.a0.and.chk(n,9,c))then
-                                    iring=9
-                                    goto 99
-                                 endif
-                                 do i10=1,n9
-                                    a10=nb(i10,a9)
-                                    n10=nb(20,a10)
-                                    if(a10.eq.a9) cycle
-                                    c(10)=a10
-                                    if(a10.eq.a0.and.chk(n,10,c))then
-                                       iring=10
-                                       goto 99
-                                    endif
-                                 enddo
-                              enddo
-                           enddo
-                        enddo
-                     enddo
-                  enddo
-               enddo
-            enddo
-         enddo
-      enddo
-
-      return
-
- 99   continue
-c     write(*,*) 'atom ',a0,'ring found',c(1:iring)
-c     call isort(iring,c)
-      return
-
-      end
-
-      logical function chk(nn,n,c)
-      implicit none
-      integer n,idum(0:nn),nn,c(10),i,j
-      chk=.true.
-      idum=0
-      do i=1,n
-         idum(c(i))=idum(c(i))+1
-      enddo
-      j=0
-      do i=1,nn
-         if(idum(i).eq.1) j=j+1
-      enddo
-      if(j.ne.n) chk=.false.
-      end
-
-
-      logical function samering(n,i,j,c,s)
-      implicit none
-      integer n,i,j,c(10,n),s(n)
-      integer m,k
-
-      samering=.false.
-      if(s(i).eq.0   ) return
-      if(s(i).ne.s(j)) return
-
-      m=0
-      do k=1,s(i)
-         m=m+c(k,i)-c(k,j)
-      enddo
-      if(m.eq.0) then
-         samering=.true.
-         return
-      endif
-      
-      do k=1,s(i)
-         if(c(k,i).eq.j)then
-            samering=.true.
-            return
-         endif
-      enddo
-      do k=1,s(j)
-         if(c(k,j).eq.i)then
-            samering=.true.
-            return
-         endif
-      enddo
-
-      end
-
-      subroutine neighborh(natoms,at,xyz,nb)
-      implicit none  
-      integer at(natoms),natoms,nb(20,natoms)
-      real*8  xyz(3,natoms)
-
-      logical da
-      integer iat,i,j,k,nn
-      real*8 rad(94)
-      real*8 dx,dy,dz,r,rco,r2,f
-      data rad/
-     . 0.80628308, 1.15903197, 3.02356173, 2.36845659, 1.94011865,
-     . 1.88972601, 1.78894056, 1.58736983, 1.61256616, 1.68815527,
-     . 3.52748848, 3.14954334, 2.84718717, 2.62041997, 2.77159820,
-     . 2.57002732, 2.49443835, 2.41884923, 4.43455700, 3.88023730,
-     . 3.35111422, 3.07395437, 3.04875805, 2.77159820, 2.69600923,
-     . 2.62041997, 2.51963467, 2.49443835, 2.54483100, 2.74640188,
-     . 2.82199085, 2.74640188, 2.89757982, 2.77159820, 2.87238349,
-     . 2.94797246, 4.76210950, 4.20778980, 3.70386304, 3.50229216,
-     . 3.32591790, 3.12434702, 2.89757982, 2.84718717, 2.84718717,
-     . 2.72120556, 2.89757982, 3.09915070, 3.22513231, 3.17473967,
-     . 3.17473967, 3.09915070, 3.32591790, 3.30072128, 5.26603625,
-     . 4.43455700, 4.08180818, 3.70386304, 3.98102289, 3.95582657,
-     . 3.93062995, 3.90543362, 3.80464833, 3.82984466, 3.80464833,
-     . 3.77945201, 3.75425569, 3.75425569, 3.72905937, 3.85504098,
-     . 3.67866672, 3.45189952, 3.30072128, 3.09915070, 2.97316878,
-     . 2.92277614, 2.79679452, 2.82199085, 2.84718717, 3.32591790,
-     . 3.27552496, 3.27552496, 3.42670319, 3.30072128, 3.47709584,
-     . 3.57788113, 5.06446567, 4.56053862, 4.20778980, 3.98102289,
-     . 3.82984466, 3.85504098, 3.88023730, 3.90543362 /
-
-      nb=0
-      nn=min(natoms,2)-1
-
-      do i=1,natoms
-      f=1.0
-      k=0
- 100  do iat=1,natoms
-         da=.false.
-         do j=1,k
-            if(nb(j,i).eq.iat)da=.true.
-         enddo
-         if(iat.ne.i.and.(.not.da))then
-            dx=xyz(1,iat)-xyz(1,i)
-            dy=xyz(2,iat)-xyz(2,i)
-            dz=xyz(3,iat)-xyz(3,i)
-            r2=dx*dx+dy*dy+dz*dz 
-            r=sqrt(r2)
-            rco=rad(at(i))+rad(at(iat))
-c critical step            
-            if(r.lt.f*rco.and.k.lt.19)then
-               k=k+1
-               nb(k,i)=iat
-            endif
-         endif
-      enddo
-      if(k.lt.1.and.f.lt.1.5)then
-         f=f*1.1
-         goto 100
-      endif
-      nb(20,i)=k
-      enddo
-
-      end
-
-      subroutine neighdist(natoms,at,xyz,nb,dist)
-      implicit none  
-      integer at(natoms),natoms,nb(200,natoms)
-      real*8  xyz(3,natoms),dist(natoms,natoms)
-
-      logical da
-      integer iat,i,j,k,nn
-      real*8 rad(94)
-      real*8 dx,dy,dz,r,rco,r2,f
-      data rad/
-     . 0.80628308, 1.15903197, 3.02356173, 2.36845659, 1.94011865,
-     . 1.88972601, 1.78894056, 1.58736983, 1.61256616, 1.68815527,
-     . 3.52748848, 3.14954334, 2.84718717, 2.62041997, 2.77159820,
-     . 2.57002732, 2.49443835, 2.41884923, 4.43455700, 3.88023730,
-     . 3.35111422, 3.07395437, 3.04875805, 2.77159820, 2.69600923,
-     . 2.62041997, 2.51963467, 2.49443835, 2.54483100, 2.74640188,
-     . 2.82199085, 2.74640188, 2.89757982, 2.77159820, 2.87238349,
-     . 2.94797246, 4.76210950, 4.20778980, 3.70386304, 3.50229216,
-     . 3.32591790, 3.12434702, 2.89757982, 2.84718717, 2.84718717,
-     . 2.72120556, 2.89757982, 3.09915070, 3.22513231, 3.17473967,
-     . 3.17473967, 3.09915070, 3.32591790, 3.30072128, 5.26603625,
-     . 4.43455700, 4.08180818, 3.70386304, 3.98102289, 3.95582657,
-     . 3.93062995, 3.90543362, 3.80464833, 3.82984466, 3.80464833,
-     . 3.77945201, 3.75425569, 3.75425569, 3.72905937, 3.85504098,
-     . 3.67866672, 3.45189952, 3.30072128, 3.09915070, 2.97316878,
-     . 2.92277614, 2.79679452, 2.82199085, 2.84718717, 3.32591790,
-     . 3.27552496, 3.27552496, 3.42670319, 3.30072128, 3.47709584,
-     . 3.57788113, 5.06446567, 4.56053862, 4.20778980, 3.98102289,
-     . 3.82984466, 3.85504098, 3.88023730, 3.90543362 /
-
-      nb=0
-      nn=min(natoms,2)-1
-
-      do i=1,natoms
-      f=1.0
-      k=0
- 100  do iat=1,natoms
-         da=.false.
-         do j=1,k
-            if(nb(j,i).eq.iat)da=.true.
-         enddo
-         dx=xyz(1,iat)-xyz(1,i)
-         dy=xyz(2,iat)-xyz(2,i)
-         dz=xyz(3,iat)-xyz(3,i)
-         r2=dx*dx+dy*dy+dz*dz 
-         r=sqrt(r2)
-         dist(iat,i)=r
-         if(iat.ne.i.and.(.not.da))then
-            rco=rad(at(i))+rad(at(iat))
-c critical step            
-            if(r.lt.f*rco.and.k.lt.199)then
-               k=k+1
-               nb(k,i)=iat
-            endif
-         endif
-      enddo
-      if(k.lt.1.and.f.lt.1.5)then
-         f=f*1.1
-         goto 100
-      endif
-      nb(200,i)=k
-      enddo
-
-      end
Index: subprojects/packagefiles/tblite/tblite_patch.patch
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/subprojects/packagefiles/tblite/tblite_patch.patch b/subprojects/packagefiles/tblite/tblite_patch.patch
deleted file mode 100644
--- a/subprojects/packagefiles/tblite/tblite_patch.patch	
+++ /dev/null	
@@ -1,37 +0,0 @@
-diff --git a/meson.build b/meson.build
-index 9384afd..e4b73bb 100644
---- a/meson.build
-+++ b/meson.build
-@@ -57,7 +57,7 @@ tblite_dep = declare_dependency(
- )
- 
- # Add executable targets
--subdir('app')
-+#subdir('app')
- 
- # Package the license files
- tblite_lic = files(
-@@ -121,7 +121,7 @@ if install
- endif
- 
- # add the testsuite
--subdir('test')
-+#subdir('test')
- 
- if get_option('python')
-   subdir('python/tblite')
-diff --git a/src/tblite/param/serde.f90 b/src/tblite/param/serde.f90
-index 9855640..4dbe3ff 100644
---- a/src/tblite/param/serde.f90
-+++ b/src/tblite/param/serde.f90
-@@ -156,7 +156,7 @@ subroutine dump_to_unit(self, unit, error)
-    type(toml_serializer) :: ser
- 
-    table = toml_table()
--   ser = toml_serializer(unit)
-+   ser = toml_serializer()
- 
-    call self%dump(table, error)
-
--
-+
Index: config/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/modules\")\nset(CMAKE_MODULE_PATH \"${CMAKE_MODULE_PATH}\" PARENT_SCOPE)\ninstall(\n  DIRECTORY\n  \"${CMAKE_CURRENT_SOURCE_DIR}/modules/\"\n  DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\"\n)\n\nset(\n  module-dir\n  \"${PROJECT_NAME}/${CMAKE_Fortran_COMPILER_ID}-${CMAKE_Fortran_COMPILER_VERSION}\"\n)\nset(module-dir \"${module-dir}\" PARENT_SCOPE)\n\n\n# Set build type as CMake does not provide defaults\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(\n    CMAKE_BUILD_TYPE \"RelWithDebInfo\"\n    CACHE STRING \"Build type to be used.\"\n    FORCE\n  )\n  message(\n    STATUS\n    \"Setting build type to '${CMAKE_BUILD_TYPE}' as none was specified.\"\n  )\nendif()\n\n\n### Options and defaults\n\ninclude(\"${CMAKE_CURRENT_SOURCE_DIR}/modules/crest-utils.cmake\")\nset(fortran_minimal_versions \"GNU;7.5\" \"Intel;19.0\")\ncheck_minimal_compiler_version(\"Fortran\" \"${fortran_minimal_versions}\")\n\noption(WITH_OpenMP \"Enable support for shared memory parallelisation with OpenMP\" TRUE)\n\noption(WITH_TBLITE \"Enable build with the lightweight tight-binding library\" FALSE)\n\noption(WITH_TOMLF \"Enable build with toml-f support\" TRUE)\n\noption(WITH_GFN0 \"Enable build with GFN0-xTB support\" TRUE)\n\noption(WITH_GFNFF \"Enable build with GFN-FF support\" TRUE)\n\noption(WITH_XHCFF \"Enable build with XHCFF support\" FALSE)\n\n\nif(NOT DEFINED \"${PROJECT_NAME}-dependency-method\")\n  set(\n    \"${PROJECT_NAME}-dependency-method\"\n    \"subproject\" \"cmake\" \"pkgconf\" \"fetch\"\n  )\nendif()\n\n#\n# Compiler settings\n#\nif(CMAKE_Fortran_COMPILER_ID MATCHES \"GNU\")\n#  set(dialect \"-fdefault-real-8 -fdefault-double-8 -ffree-line-length-none -fbacktrace\")\n  set(dialect \"-g -O0 -fbacktrace -ffree-line-length-none -fbacktrace\")\n  set(bounds \"-fbounds-check\")\nendif()\nif(CMAKE_Fortran_COMPILER_ID MATCHES \"Intel\")\n#  set(dialect \"-axAVX2 -r8 -traceback\")\n  set(dialect \"-g -O2 -r8 -align array64byte -traceback\") \n  set(bounds \"-check bounds\")\nendif()\nif(CMAKE_Fortran_COMPILER_ID MATCHES \"PGI\")\n  set(dialect \"-Mbackslash -Mallocatable=03 -r8 -traceback\")\nendif()\nset(CMAKE_Fortran_FLAGS_DEBUG \"${CMAKE_Fortran_FLAGS_DEBUG} ${bounds}\" PARENT_SCOPE)\nset(CMAKE_Fortran_FLAGS \"${CMAKE_Fortran_FLAGS} ${dialect}\" PARENT_SCOPE)\n\n\n#\n# Populate crest_metadata.fh\n#\nset(version ${PROJECT_VERSION}${SOVERSION})\nexecute_process(COMMAND git show -s --format=%h\n  RESULT_VARIABLE git_return\n  OUTPUT_VARIABLE commit\n  OUTPUT_STRIP_TRAILING_WHITESPACE\n)\nif(git_return)\n  set(commit \"unknown-commit\")\nendif()\nstring(TIMESTAMP date \"%a, %d %B %H:%M:%S, %m/%d/%Y\")\nset(author $ENV{USERNAME})\nexecute_process(COMMAND hostname OUTPUT_VARIABLE HOSTNAME OUTPUT_STRIP_TRAILING_WHITESPACE)\nset(origin ${HOSTNAME})\nset(fcid ${CMAKE_Fortran_COMPILER_ID})\nset(fcver ${CMAKE_Fortran_COMPILER_VERSION})\nset(ccid ${CMAKE_C_COMPILER_ID})\nset(ccver ${CMAKE_C_COMPILER_VERSION})\nset(bsystem \"cmake ${CMAKE_VERSION}\")\nset(tomlfvar \"${WITH_TOMLF}\")#string(TOLOWER \"${MY_BOOL}\" ${WITH_TOMLF}))\nset(gfn0var \"${WITH_GFN0}\")\nset(gfnffvar \"${WITH_GFNFF}\")\nset(tblitevar \"${WITH_TBLITE}\")\nset(xhcffvar \"${WITH_XHCFF}\")\n\nconfigure_file(\n  \"${PROJECT_SOURCE_DIR}/assets/template/metadata.f90\"\n  \"${PROJECT_BINARY_DIR}/crest_metadata.fh\"\n  @ONLY\n)\n# gfortran needs the file at another place...\nconfigure_file(\n  \"${PROJECT_SOURCE_DIR}/assets/template/metadata.f90\"\n  \"${PROJECT_BINARY_DIR}/include/crest_metadata.fh\"\n  @ONLY\n)\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config/CMakeLists.txt b/config/CMakeLists.txt
--- a/config/CMakeLists.txt	
+++ b/config/CMakeLists.txt	
@@ -51,7 +51,7 @@
 
 option(WITH_OpenMP "Enable support for shared memory parallelisation with OpenMP" TRUE)
 
-option(WITH_TBLITE "Enable build with the lightweight tight-binding library" FALSE)
+option(WITH_TBLITE "Enable build with the lightweight tight-binding library" TRUE)
 
 option(WITH_TOMLF "Enable build with toml-f support" TRUE)
 
@@ -61,6 +61,7 @@
 
 option(WITH_XHCFF "Enable build with XHCFF support" FALSE)
 
+option(WITH_LWONIOM "Enable build with lwONIOM support" FALSE)
 
 if(NOT DEFINED "${PROJECT_NAME}-dependency-method")
   set(
@@ -115,6 +116,7 @@
 set(gfnffvar "${WITH_GFNFF}")
 set(tblitevar "${WITH_TBLITE}")
 set(xhcffvar "${WITH_XHCFF}")
+set(lwoniomvar "${WITH_LWONIOM}")
 
 configure_file(
   "${PROJECT_SOURCE_DIR}/assets/template/metadata.f90"
Index: config/meson.build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nfc = meson.get_compiler('fortran')\ncc = meson.get_compiler('c')\nfc_id = fc.get_id()\ncc_id = cc.get_id()\n\nif fc.get_id() != cc.get_id()\n  warning('FC and CC are not from the same vendor')\nendif\n\n## ========================================= ##\n## Compiler specific default arguments\n## ========================================= ##  \nif fc_id == 'gcc'\n  add_project_arguments(\n    '-ffree-line-length-none',\n    '-fbacktrace',\n    '-Wno-maybe-uninitialized',\n    '-Wno-uninitialized',\n    '-Wno-unused-variable',\n    '-Wno-unused-dummy-argument',\n    '-Wno-unused-function',\n    language: 'fortran',\n  )\nelif fc_id == 'intel'\n  add_project_link_arguments(\n    '-Wl,--allow-multiple-definition',\n    language: 'fortran',\n  )\n  add_project_arguments(\n    '-traceback',\n    language: 'fortran',\n  )\n  add_project_arguments(\n    '-DLINUX',\n    language: 'c',\n  )\nelif fc_id == 'pgi' or fc_id == 'nvidia_hpc'\n  add_project_arguments(\n    '-Mbackslash',\n    '-Mallocatable=03',\n    '-traceback',\n    language: 'fortran',\n  )\nelif fc_id == 'flang'\n  add_project_arguments(\n    '-Mbackslash',\n    '-Mallocatable=03',\n    language: 'fortran',\n  )\nendif\n\nadd_project_arguments('-D_Float128=__float128', language: 'c')\n\n\n## ========================================= ##\n## build type option arguments\n## ========================================= ## \nif ( get_option('default_library') == 'static')\n  message('Static linking selected')\n  add_project_link_arguments('-static', language: 'fortran')\n  add_project_link_arguments('-static', language: 'c') # icc will do linking\nendif\n\n\n## ========================================= ##\n## OpenMP\n## ========================================= ##\nif get_option('openmp')\n  omp_dep = dependency('openmp', required: fc.get_id() != 'intel')\n  if not omp_dep.found()\n    omp_dep = declare_dependency(\n      compile_args: '-qopenmp',\n      link_args: '-fopenmp',\n    )\n  endif\n  exe_deps += omp_dep\nendif\n\n## ======================================== ##\n## Linear Algebra Libraries\n## ======================================== ##\nla_backend = get_option('la_backend')\nmessage('Linear algebra backend: '+get_option('la_backend'))\nif la_backend == 'mkl' or la_backend == 'mkl-static'\n  add_project_arguments('-DWITH_MKL', language: 'fortran')\n  if la_backend == 'mkl-static'\n    add_project_link_arguments('-static', language: 'fortran')\n    add_project_link_arguments('-static', language: 'c') # icc will do linking\n  endif\n\n  if get_option('default_library') == 'shared'\n    mkl_rt_dep = cc.find_library('mkl_rt', required: true)\n    exe_deps += mkl_rt_dep\n  else\n    if fc.get_id() == 'gcc'\n      libmkl_exe = [cc.find_library('mkl_gf_lp64')]\n      if get_option('openmp')\n        libmkl_exe += cc.find_library('mkl_gnu_thread')\n      endif\n    elif fc.get_id() == 'intel' or fc.get_id() == 'intel-cl'\n      libmkl_exe = [cc.find_library('mkl_intel_lp64')]\n      if get_option('openmp')\n        libmkl_exe += cc.find_library('mkl_intel_thread')\n      endif\n    elif fc.get_id() == 'pgi' or fc.get_id() == 'nvidia_hpc'\n      libmkl_exe = [cc.find_library('mkl_intel_lp64')]\n      if get_option('openmp')\n        libmkl_exe += cc.find_library('mkl_pgi_thread')\n      endif\n    endif\n    if not get_option('openmp')\n      libmkl_exe += cc.find_library('mkl_sequential')\n    endif\n    libmkl_exe += cc.find_library('mkl_core')\n    exe_deps += libmkl_exe\n  endif\n\nelif la_backend == 'mkl-rt'\n  add_project_arguments('-DWITH_MKL', language: 'fortran')\n\n  mkl_rt_dep = fc.find_library('mkl_rt', required: true)\n  if fc.get_id() == 'intel'\n    exe_deps += fc.find_library('ifcore')\n  endif\n\n  exe_deps += mkl_rt_dep\n\nelif la_backend == 'openblas'\n  # search for OpenBLAS\n  blas_dep = dependency('openblas', required: false)\n  if not blas_dep.found()\n    blas_dep = fc.find_library('openblas', required: true)\n  endif\n  exe_deps += blas_dep\n  # some OpenBLAS versions can provide lapack, check if we can find dsygvd\n  openblas_provides_lapack = fc.links(\n    'external dsygvd; call dsygvd(); end',\n    dependencies: blas_dep,\n  )\n  # otherwise we fall back to LAPACK\n  if not openblas_provides_lapack\n    lapack_dep = dependency('lapack', required: false)\n    if not lapack_dep.found()\n      lapack_dep = fc.find_library('lapack', required: true)\n    endif\n    exe_deps += lapack_dep\n  endif\n\nelif la_backend == 'custom'\n  foreach lib: get_option('custom_libraries')\n    exe_deps += fc.find_library(lib)\n  endforeach\n\nelse\n  # Find BLAS (usually netlib, but in conda also OpenBLAS/MKL)\n  blas_dep = dependency('blas', required: false)\n  if not blas_dep.found()\n    blas_dep = fc.find_library('blas', required: true)\n  endif\n  exe_deps += blas_dep\n  # Find LAPACK (usually netlib, but in conda also MKL)\n  lapack_dep = dependency('lapack', required: false)\n  if not lapack_dep.found()\n    lapack_dep = fc.find_library('lapack', required: true)\n  endif\n  exe_deps += lapack_dep\nendif\n\n\n## ========================================= ##\n## External subprojects\n## ========================================= ##  \n\n# GFN1-xTB and GFN2-xTB via TBLITE\nif get_option('WITH_TBLITE')\n add_project_arguments('-DWITH_TBLITE', language: 'fortran')\n tblite_dep = dependency(\n   'tblite',\n   version: '>=0.2',\n   fallback: ['tblite', 'tblite_dep'],\n   default_options: ['default_library=static', 'api=false'],\n )\n exe_deps += tblite_dep\nendif\n\n# TOML-F\nif get_option('WITH_TOMLF')\n add_project_arguments('-DWITH_TOMLF', language: 'fortran')\n tomlf_dep = dependency(\n   'toml-f',\n   version: '>=0.2.0',\n   fallback: ['toml-f', 'tomlf_dep'],\n   default_options: ['default_library=static'],\n )\n exe_deps += tomlf_dep\nendif\n\n# GFN0-xTB\nif get_option('WITH_GFN0')\n add_project_arguments('-DWITH_GFN0', language: 'fortran')\n gfn0_dep = dependency(\n   'gfn0',\n#   version: '>=0.2',\n   fallback: ['gfn0', 'gfn0_dep'],\n   default_options: ['default_library=static','with_gbsa=true'],\n )\n exe_deps += gfn0_dep\nendif\n\n# GFN-FF\nif get_option('WITH_GFNFF')\n add_project_arguments('-DWITH_GFNFF', language: 'fortran')\n gfnff_dep = dependency(\n   'gfnff',\n   fallback: ['gfnff', 'gfnff_dep'],\n   default_options: ['default_library=static','with_gbsa=true'],\n )\n exe_deps += gfnff_dep\nendif\n\n\n# XHCFF\nif get_option('WITH_XHCFF')\n add_project_arguments('-DWITH_XHCFF', language: 'fortran')\n xhcff_dep = dependency(\n   'xhcff',\n   fallback: ['xhcff', 'xhcfflib_dep'],\n   default_options: ['default_library=static'],\n )\n exe_deps += xhcff_dep\nendif\n\n\n## ========================================= ##\n## populate the data for crest_metadata.fh\n## ========================================= ##  \ncommit = 'unknown commit'\ngit = find_program('git', required: false)\nif git.found()\n  git_commit = run_command(git, 'show', '-s', '--format=%h',check:true)\n  if git_commit.returncode() == 0\n    commit = git_commit.stdout().strip()\n  endif\nendif\n# create configuration data\nconfig = configuration_data({\n  'name': meson.project_name(),\n  'version': meson.project_version(),\n  'description': 'Conformer Rotamer Ensemble Sampling Tool',\n  'commit': commit,\n  'date': run_command('date',check:true).stdout().     strip(),\n  'author': run_command('id','-u','-n', check:true).stdout().strip(),\n  'origin': run_command('hostname', check:true).stdout().strip(),\n  'fcid': fc.get_id(),\n  'fcver': fc.version(),\n  'ccid': cc.get_id(),\n  'ccver': cc.version(),\n  'bsystem': 'meson '+meson.version(),\n  'tomlfvar': get_option('WITH_TOMLF'),\n  'gfn0var': get_option('WITH_GFN0'),\n  'gfnffvar': get_option('WITH_GFNFF'), \n  'tblitevar': get_option('WITH_TBLITE'),\n  'xhcffvar': get_option('WITH_XHCFF'),\n})\n#message(get_option('WITH_TOMLF'))\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config/meson.build b/config/meson.build
--- a/config/meson.build	
+++ b/config/meson.build	
@@ -42,6 +42,10 @@
     '-Wl,--allow-multiple-definition',
     language: 'fortran',
   )
+  add_global_link_arguments(
+    '-Wl,--allow-multiple-definition',
+    language: 'fortran',
+  )
   add_project_arguments(
     '-traceback',
     language: 'fortran',
@@ -247,6 +251,18 @@
 endif
 
 
+# lwONIOM
+if get_option('WITH_LWONIOM')
+ add_project_arguments('-DWITH_LWONIOM', language: 'fortran')
+ lwoniom_dep = dependency(
+   'lwoniom',
+   fallback: ['lwoniom', 'lwoniom_dep'],
+   default_options: ['default_library=static'],
+ )
+ exe_deps += lwoniom_dep
+endif
+
+
 ## ========================================= ##
 ## populate the data for crest_metadata.fh
 ## ========================================= ##  
@@ -277,6 +293,7 @@
   'gfnffvar': get_option('WITH_GFNFF'), 
   'tblitevar': get_option('WITH_TBLITE'),
   'xhcffvar': get_option('WITH_XHCFF'),
+  'lwoniomvar': get_option('WITH_LWONIOM'),
 })
 #message(get_option('WITH_TOMLF'))
 
Index: subprojects/lwoniom.wrap
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/subprojects/lwoniom.wrap b/subprojects/lwoniom.wrap
new file mode 100644
--- /dev/null	
+++ b/subprojects/lwoniom.wrap	
@@ -0,0 +1,4 @@
+[wrap-git]
+directory = lwoniom
+url = https://github.com/pprcht/lwoniom
+revision = head
Index: src/parsing/parse_xtbinput.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/parse_xtbinput.f90 b/src/parsing/parse_xtbinput.f90
new file mode 100644
--- /dev/null	
+++ b/src/parsing/parse_xtbinput.f90	
@@ -0,0 +1,859 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!> This is the fallback reader for xtb input files.
+!> Defining constrains in this format is a bit easier than with toml
+!> Furthermore, it should provide some higher degree of compatibility
+!> between CREST and xTB.
+!> The xtb-style keywords in CREST are limited to geometrical constraints
+!> These are files that can be read with the --cinp option
+
+module parse_xtbinput
+  use crest_parameters
+  use crest_data
+  use parse_datastruct
+  use parse_keyvalue
+  use parse_block
+  use parse_datastruct
+  use filemod
+  use iomod
+  use strucrd
+  use wall_setup
+  use constraints,only:constraint
+  implicit none
+  private
+  !logical,parameter,private :: debug = .true.
+  logical,parameter,private :: debug = .false.
+
+  public :: parse_xtbinputfile
+  interface parse_xtbinputfile
+    module procedure :: parse_xtb_inputfile
+    module procedure :: parse_xtb_input_fallback
+  end interface parse_xtbinputfile
+
+!========================================================================================!
+!========================================================================================!
+contains  !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
+
+  subroutine parse_xtb_inputfile(env,fname)
+!*********************************************
+!* Routine for parsing the input file fname
+!* and storing information in env
+!*********************************************
+    implicit none
+    type(systemdata) :: env
+    character(len=*) :: fname
+
+    type(root_object) :: dict
+    type(datablock) :: blk
+    logical :: ex
+    character(len=:),allocatable :: hdr
+    integer :: i,j,k,l
+
+    inquire (file=fname,exist=ex)
+    if (.not.ex) return
+
+    call parse_xtb_input_fallback(fname,dict)
+    !call dict%print()
+
+    write (stdout,'(a,a,a)') 'Parsing xtb-type input file ',trim(fname), &
+    & ' to set up calculators ...'
+    !> iterate through the blocks and save the necessary information
+    do i = 1,dict%nblk
+      blk = dict%blk_list(i)
+      hdr = trim(blk%header)
+      select case (hdr)
+      case ('constrain')
+        call get_xtb_constraint_block(env,blk)
+      case ('wall')
+        call get_xtb_wall_block(env,blk)
+      case ('fix')
+        call get_xtb_fix_block(env,blk)
+      case ('metadyn')
+        call get_xtb_metadyn_block(env,blk)
+      case default
+        write (stdout,'(a,a,a)') 'xtb-style input block: "$',trim(hdr),'" not defined for CREST'
+      end select
+    end do
+
+    if (debug) stop
+  end subroutine parse_xtb_inputfile
+
+!========================================================================================!
+
+  subroutine get_xtb_constraint_block(env,blk)
+!********************************************************************
+!* This is the fallback reader for xtb input files to set up a dict
+!********************************************************************
+    implicit none
+    type(systemdata),intent(inout) :: env
+    type(filetype) :: file
+    integer :: i,j,k,io
+    type(keyvalue) :: kv
+    type(datablock),intent(in) :: blk
+    real(wp) :: force_constant,dist,angl
+    real(wp) :: rdum
+    type(coord) :: mol
+    type(coord) :: molref
+    logical :: useref
+    logical,allocatable :: pairwise(:)
+    logical,allocatable :: atlist(:)
+    integer :: i1,i2,i3,i4,atm1,atm2
+    real(wp) :: dum1,dum2,dum3,dum4
+    type(constraint) :: cons
+    type(constraint),allocatable :: conslist(:)
+
+    useref = .false.
+!>--- a default xtb force constant (in Eh), must be read first, if present
+    force_constant = 0.05
+    do i = 1,blk%nkv
+      kv = blk%kv_list(i)
+      select case (kv%key)
+
+      case ('force constant')
+        read (kv%rawvalue,*,iostat=io) rdum
+        if (io == 0) then
+          if (debug) write (stdout,'(a,a,a)') 'read force constant: ',to_str(rdum),' Eh'
+          force_constant = rdum
+        end if
+
+      case ('reference')
+        !> a reference geometry (must be the same molecule as the input)
+        call molref%open(kv%rawvalue)
+        if (any(mol%at(:) .ne. molref%at(:))) then
+          write (stdout,'(a,/,a)') '**ERROR** while reading xtb-style input:',&
+          & '  Geometry provided as "reference=" appears not to be the same molecule as CREST input!'
+          error stop
+        end if
+        useref = .true.
+        if (debug) write (stdout,'(a,a,a)') '> Using reference geometry "',kv%rawvalue,'"'
+
+      end select
+    end do
+
+!>--- get reference input geometry
+    call env%ref%to(mol)
+
+!>--- then the common constraints: distance, angle, dihedral
+    do i = 1,blk%nkv
+      kv = blk%kv_list(i)
+      select case (kv%key)
+      case ('force constant','reference')
+        !> already read above
+
+      case ('distance','bond')
+        if (kv%na .eq. 3) then
+          read (kv%value_rawa(1),*,iostat=io) i1
+          if (io == 0) read (kv%value_rawa(2),*,iostat=io) i2
+          if (io == 0) then
+            if (trim(kv%value_rawa(3)) .eq. 'auto') then
+              if (useref) then
+                dist = molref%dist(i1,i2)
+              else
+                dist = mol%dist(i1,i2)
+              end if
+            else
+              read (kv%value_rawa(3),*) dist
+              dist = dist*aatoau
+            end if
+            call cons%deallocate()
+            call cons%bondconstraint(i1,i2,dist,force_constant)
+            if (debug) call cons%print(stdout)
+            call env%calc%add(cons)
+          end if
+        end if
+
+      case ('angle')
+        if (kv%na .eq. 4) then
+          read (kv%value_rawa(1),*,iostat=io) i1
+          if (io == 0) read (kv%value_rawa(2),*,iostat=io) i2
+          if (io == 0) read (kv%value_rawa(3),*,iostat=io) i3
+          if (io == 0) then
+            if (trim(kv%value_rawa(4)) .eq. 'auto') then
+              if (useref) then
+                angl = molref%angle(i1,i2,i3)*radtodeg
+              else
+                angl = mol%angle(i1,i2,i3)*radtodeg
+              end if
+            else
+              read (kv%value_rawa(4),*) angl
+            end if
+            call cons%deallocate()
+            call cons%angleconstraint(i1,i2,i3,angl,force_constant)
+            if (debug) call cons%print(stdout)
+            call env%calc%add(cons)
+          end if
+        end if
+
+      case ('dihedral')
+        if (kv%na .eq. 5) then
+          read (kv%value_rawa(1),*,iostat=io) i1
+          if (io == 0) read (kv%value_rawa(2),*,iostat=io) i2
+          if (io == 0) read (kv%value_rawa(3),*,iostat=io) i3
+          if (io == 0) read (kv%value_rawa(4),*,iostat=io) i4
+          if (io == 0) then
+            if (trim(kv%value_rawa(5)) .eq. 'auto') then
+              if (useref) then
+                angl = molref%dihedral(i1,i2,i3,i4)*radtodeg
+              else
+                angl = mol%dihedral(i1,i2,i3,i4)*radtodeg
+              end if
+            else
+              read (kv%value_rawa(5),*) angl
+            end if
+            call cons%deallocate()
+            call cons%dihedralconstraint(i1,i2,i3,i4,angl,force_constant)
+            if (debug) call cons%print(stdout)
+            call env%calc%add(cons)
+          end if
+        end if
+
+      case ('bondrange')
+        read (kv%value_rawa(1),*,iostat=io) atm1
+        if (io == 0) read (kv%value_rawa(2),*,iostat=io) atm2
+        if (io == 0) read (kv%value_rawa(3),*,iostat=io) dum1
+        if(io==0)then
+        dum1 = dum1*aatoau
+        dum1 = max(0.0_wp,dum1) !> can't be negative
+        select case (kv%na)
+        case (3)
+          dum2 = huge(dum2)/3.0_wp !> some huge value
+          call cons%bondrangeconstraint(atm1,atm2,dum1,dum2)
+        case (4)
+          if (io == 0) read (kv%value_rawa(4),*,iostat=io) dum2
+          dum2 = dum2*aatoau
+          call cons%bondrangeconstraint(atm1,atm2,dum1,dum2)
+        case (5)
+          if (io == 0) read (kv%value_rawa(5),*,iostat=io) dum3
+          call cons%bondrangeconstraint(atm1,atm2,dum1,dum2,beta=dum3)
+        case (6)
+          if (io == 0) read (kv%value_rawa(6),*,iostat=io) dum4 
+          call cons%bondrangeconstraint(atm1,atm2,dum1,dum2,beta=dum3,T=dum4)
+        case default
+          error stop '**ERROR** wrong number of arguments in bondrange constraint'
+        end select
+        call env%calc%add(cons) 
+        if (debug) call cons%print(stdout)
+        endif
+      case ('atoms')
+        if (.not.allocated(pairwise)) allocate (pairwise(mol%nat),source=.false.)
+        call get_atlist(mol%nat,atlist,kv%rawvalue,mol%at)
+        do j = 1,mol%nat
+          if (atlist(j)) pairwise(j) = .true.
+        end do
+
+      case ('elements')
+        if (.not.allocated(pairwise)) allocate (pairwise(mol%nat),source=.false.)
+        if (kv%id == valuetypes%raw_array) then
+          do j = 1,kv%na
+            i1 = e2i(kv%value_rawa(j))
+            do k = 1,mol%nat
+              if (i1 == mol%at(k)) pairwise(k) = .true.
+            end do
+          end do
+        else
+          i1 = e2i(kv%rawvalue)
+          do j = 1,mol%nat
+            if (i1 == mol%at(j)) pairwise(j) = .true.
+          end do
+        end if
+
+      case default
+        write (stdout,'(a,a,a)') 'xtb-style input key: "',kv%key,'" not defined for CREST'
+
+      end select
+    end do
+
+!>--- if the pairwise section was allocated, set the distance constraints up here
+    if (allocated(pairwise)) then
+!>--- to reduce overhead, we allocate all of these constraints at once
+      k = 0
+      do i = 1,mol%nat
+        do j = 1,i-1
+          if (pairwise(i).and.pairwise(j)) k = k +1
+        enddo
+      enddo
+      allocate(conslist(k))
+      k = 0
+      do i = 1,mol%nat
+        do j = 1,i-1
+          if (pairwise(i).and.pairwise(j)) then
+            if (useref) then
+              dist = molref%dist(j,i)
+            else
+              dist = mol%dist(j,i)
+            end if
+            k = k + 1
+            !call cons%deallocate()
+            call conslist(k)%bondconstraint(j,i,dist,force_constant)
+            if (debug) call conslist(k)%print(stdout)
+            !call env%calc%add(cons)
+          end if
+        end do
+      end do
+      call env%calc%add(k,conslist)
+      deallocate (conslist) 
+      deallocate (pairwise)
+    end if
+
+  end subroutine get_xtb_constraint_block
+
+  subroutine get_xtb_wall_block(env,blk)
+!**************************************
+!* This is a reader for the $wall block
+!***************************************
+    implicit none
+    type(systemdata),intent(inout) :: env
+    type(filetype) :: file
+    integer :: i,j,k,io
+    type(keyvalue) :: kv
+    type(datablock),intent(in) :: blk
+    real(wp) :: force_constant,dist,angl
+    real(wp) :: T,alpha,beta
+    real(wp) :: rdum,rabc(3),r1,r2,r3
+    type(coord) :: mol
+    logical,allocatable :: pairwise(:)
+    logical,allocatable :: atlist(:)
+    integer :: i1,i2,i3,i4
+    integer :: pot
+    type(constraint) :: cons
+
+    if(debug) write(*,*) 'parsing $wall block'
+
+!>--- asome defaults
+    force_constant = 1.0_wp
+    alpha = 30
+    beta = 6.0_wp
+    T = 300.0_wp
+    pot = 1 !> 1= polynomial, 2= logfermi
+
+!>--- get reference input geometry
+    call env%ref%to(mol)
+
+!>--- get the parameters first
+    do i = 1,blk%nkv
+      kv = blk%kv_list(i)
+      select case (kv%key)
+      case ('force constant')
+        !> already read above
+        read (kv%rawvalue,*,iostat=io) rdum
+        if (io == 0) force_constant = rdum
+
+      case ('potential')
+        if (trim(kv%rawvalue) .eq. 'logfermi') then
+          pot = 2
+        else
+          pot = 1
+        end if
+
+      case ('alpha')
+        read (kv%rawvalue,*,iostat=io) i1
+        if (io == 0) alpha = i1
+
+      case ('beta')
+        read (kv%rawvalue,*,iostat=io) i1
+        if (io == 0) beta = i1
+
+      case ('temp')
+        read (kv%rawvalue,*,iostat=io) i1
+        if (io == 0) T = i1
+
+      end select
+    end do
+
+!>--- create the potentials
+    do i = 1,blk%nkv
+      kv = blk%kv_list(i)
+      select case (kv%key)
+      case ('force constant','potential','alpha','beta','temp')
+        !> created in higher prio loop already
+
+      case ('sphere')
+        !> the sphere constraint si technically identical to the ellipsoid one, but
+        !> with equal axis lengths in all 3 directions
+        if (kv%na > 0) then
+          if (trim(kv%value_rawa(1)) .eq. 'auto') then
+            !> determine sphere
+            call wallpot_core(mol,rabc,potscal=env%potscal)
+            rdum = maxval(rabc(:))
+            rabc(:) = rdum
+          else
+            read (kv%rawvalue,*,iostat=io) rdum
+            if (io == 0) rabc(:) = rdum
+          end if
+          call get_atlist(mol%nat,atlist,kv%rawvalue,mol%at)
+          call cons%deallocate()
+          select case (pot)
+          case (1) !> polynomial
+            call cons%ellipsoid(mol%nat,atlist,rabc,force_constant,alpha,.false.)
+          case (2) !> logfermi
+            call cons%ellipsoid(mol%nat,atlist,rabc,T,beta,.true.)
+          end select
+          if (debug) call cons%print(stdout)
+          call env%calc%add(cons)
+        end if
+
+      case ('ellipsoid')
+        if(debug) write(*,*) 'parsing ellipsoid',kv%na
+        if (kv%na > 0) then
+          if (trim(kv%value_rawa(1)) .eq. 'auto') then
+            !> determine ellipsoid
+            call wallpot_core(mol,rabc,potscal=env%potscal)
+          else
+            read (kv%value_rawa(1),*,iostat=io) r1
+            if (io == 0) read (kv%value_rawa(2),*,iostat=io) r2
+            if (io == 0) read (kv%value_rawa(3),*,iostat=io) r3
+            if (io == 0) then
+              rabc(1) = r1
+              rabc(2) = r2
+              rabc(3) = r3
+            end if
+          end if
+          call get_atlist(mol%nat,atlist,kv%rawvalue,mol%at)
+          call cons%deallocate()
+          select case (pot)
+          case (1) !> polynomial
+            call cons%ellipsoid(mol%nat,atlist,rabc,force_constant,alpha,.false.)
+          case (2) !> logfermi
+            call cons%ellipsoid(mol%nat,atlist,rabc,T,beta,.true.)
+          end select
+          if (debug) call cons%print(stdout)
+          call env%calc%add(cons)
+        end if
+
+      case default
+        write (stdout,'(a,a,a)') 'xtb-style input key: "',kv%key,'" not defined for CREST'
+
+      end select
+    end do
+
+  end subroutine get_xtb_wall_block
+
+  subroutine get_xtb_fix_block(env,blk)
+!**************************************
+!* This is a reader for the $fix block
+!***************************************
+    implicit none
+    type(systemdata),intent(inout) :: env
+    type(filetype) :: file
+    integer :: i,j,k,io
+    type(keyvalue) :: kv
+    type(datablock),intent(in) :: blk
+    real(wp) :: force_constant,dist,angl
+    real(wp) :: T,alpha,beta
+    real(wp) :: rdum,rabc(3),r1,r2,r3
+    type(coord) :: mol
+    logical,allocatable :: pairwise(:)
+    logical,allocatable :: atlist(:)
+    integer :: i1,i2,i3,i4
+    integer :: pot
+
+!>--- get reference input geometry
+    call env%ref%to(mol)
+
+!>--- get the parameters first
+    do i = 1,blk%nkv
+      kv = blk%kv_list(i)
+      select case (kv%key)
+
+      case ('atoms')
+        !> define frozen atoms via indices
+        if (.not.allocated(pairwise)) allocate (pairwise(mol%nat),source=.false.)
+        call get_atlist(mol%nat,atlist,kv%rawvalue,mol%at)
+        do j = 1,mol%nat
+          if (atlist(j)) pairwise(j) = .true.
+        end do
+
+      case ('elements')
+        !> define frozen atoms via elements
+        if (.not.allocated(pairwise)) allocate (pairwise(mol%nat),source=.false.)
+        if (kv%id == valuetypes%raw_array) then
+          do j = 1,kv%na
+            i1 = e2i(kv%value_rawa(j))
+            do k = 1,mol%nat
+              if (i1 == mol%at(k)) pairwise(k) = .true.
+            end do
+          end do
+        else
+          i1 = e2i(kv%rawvalue)
+          do j = 1,mol%nat
+            if (i1 == mol%at(j)) pairwise(j) = .true.
+          end do
+        end if
+
+      case default
+        write (stdout,'(a,a,a)') 'xtb-style input key: "',kv%key,'" not defined for CREST'
+
+      end select
+    end do
+
+    if (allocated(pairwise)) then
+      i1 = count(pairwise)
+      env%calc%nfreeze = i1
+      if (debug) then
+        write (stdout,'("> ",a)') 'Frozen atoms:'
+        do i = 1,mol%nat
+          if (pairwise(i)) write (stdout,'(1x,i0)',advance='no') i
+        end do
+        write (stdout,*)
+      end if
+      call move_alloc(pairwise,env%calc%freezelist)
+    end if
+
+  end subroutine get_xtb_fix_block
+
+
+
+  subroutine get_xtb_metadyn_block(env,blk)
+!**************************************
+!* This is a reader for the $metadyn block
+!***************************************
+    implicit none
+    type(systemdata),intent(inout) :: env
+    type(filetype) :: file
+    integer :: i,j,k,io
+    type(keyvalue) :: kv
+    type(datablock),intent(in) :: blk
+    real(wp) :: force_constant,dist,angl
+    real(wp) :: T,alpha,beta
+    real(wp) :: rdum,rabc(3),r1,r2,r3
+    type(coord) :: mol
+    logical,allocatable :: pairwise(:)
+    logical,allocatable :: atlist(:)
+    integer :: i1,i2,i3,i4
+    integer :: pot
+
+!>--- get reference input geometry
+    call env%ref%to(mol)
+
+!>--- get the parameters first
+    do i = 1,blk%nkv
+      kv = blk%kv_list(i)
+      select case (kv%key)
+
+      case ('atoms')
+        !> define atoms in metadynamics via indices
+        if (.not.allocated(pairwise)) allocate (pairwise(mol%nat),source=.false.)
+        call get_atlist(mol%nat,atlist,kv%rawvalue,mol%at)
+        do j = 1,mol%nat
+          if (atlist(j)) pairwise(j) = .true.
+        end do
+
+      case ('elements')
+        !> define atoms in metadynamics via elements
+        if (.not.allocated(pairwise)) allocate (pairwise(mol%nat),source=.false.)
+        if (kv%id == valuetypes%raw_array) then
+          do j = 1,kv%na
+            i1 = e2i(kv%value_rawa(j))
+            do k = 1,mol%nat
+              if (i1 == mol%at(k)) pairwise(k) = .true.
+            end do
+          end do
+        else
+          i1 = e2i(kv%rawvalue)
+          do j = 1,mol%nat
+            if (i1 == mol%at(j)) pairwise(j) = .true.
+          end do
+        end if
+  
+      case ('kscal')
+        !> define a global metadynamics k-push scaling factor
+        read(kv%rawvalue,*) r1
+        env%mtd_kscal = r1
+
+
+      case default
+        write (stdout,'(a,a,a)') 'xtb-style input key: "',kv%key,'" not defined for CREST'
+
+      end select
+    end do
+
+    if (allocated(pairwise)) then
+      i1 = count(pairwise)
+      if (debug) then
+        write (stdout,'("> ",a)') 'Metadynamics atoms:'
+        do i = 1,mol%nat
+          if (pairwise(i)) write (stdout,'(1x,i0)',advance='no') i
+        end do
+        write (stdout,*)
+      end if
+      if(.not.allocated(env%includeRMSD)) allocate(env%includeRMSD(mol%nat), source=0)
+      do i=1,mol%nat
+         if(pairwise(i)) env%includeRMSD(i) = 1
+      enddo
+      env%rednat = i1
+    end if
+
+    call mol%deallocate()
+  end subroutine get_xtb_metadyn_block
+
+
+!========================================================================================!
+
+  subroutine parse_xtb_input_fallback(fname,dict)
+!********************************************************************
+!* This is the fallback reader for xtb input files to set up a dict
+!********************************************************************
+    implicit none
+
+    character(len=*) :: fname !> name of the input file
+    type(root_object),intent(out) :: dict
+    type(filetype) :: file
+    integer :: i,j,k,io
+    logical :: get_root_kv
+    type(keyvalue) :: kvdum
+    type(datablock) :: blkdum
+
+    call dict%new()
+!>--- open file to read and remove comments
+    call file%open(trim(fname))
+    dict%filename = trim(file%filename)
+    call remove_comments(file)
+
+!>--- all valid key-values must be in $-blocks, no root-level ones
+    get_root_kv = .false.
+!>--- the loop where the input file is read
+    do i = 1,file%nlines
+      if (file%current_line > i) cycle
+
+      !> key-value pairs of the root dict (ignored for xtb)
+      if (get_root_kv) then
+        call get_keyvalue(kvdum,file%line(i),io)
+        if (io == 0) then
+          call dict%addkv(kvdum) !> add to dict
+        end if
+      end if
+
+      !> the $-blocks
+      if (isxtbheader(file%line(i))) then
+        get_root_kv = .false.
+        call read_xtbdatablock(file,i,blkdum)
+        call dict%addblk(blkdum) !> add to dict
+      end if
+    end do
+
+    call file%close()
+
+    return
+  end subroutine parse_xtb_input_fallback
+!========================================================================================!
+  subroutine remove_comments(file)
+    use filemod
+    implicit none
+    type(filetype) :: file
+    character(len=1),parameter :: com = '#'
+    integer :: i
+    do i = 1,file%nlines
+      call clearcomment(file%f(i),com)
+      call clearcomment(file%f(i),"$end")
+    end do
+  end subroutine remove_comments
+
+  function isxtbheader(str)
+    implicit none
+    logical :: isxtbheader
+    character(len=*) :: str
+    character(len=:),allocatable :: atmp
+    integer :: l
+    isxtbheader = .false.
+    atmp = adjustl(trim(str))
+    l = len_trim(atmp)
+    if (l < 1) return
+    if ((atmp(1:1) == '$')) then
+      isxtbheader = .true.
+    end if
+    return
+  end function isxtbheader
+
+!========================================================================================!
+
+  subroutine read_xtbdatablock(file,i,blk)
+    implicit none
+    type(filetype),intent(inout)  :: file
+    type(datablock),intent(inout) :: blk
+    integer,intent(in) :: i
+
+    character(len=:),allocatable :: rawline
+    type(keyvalue) :: kvdum
+    integer :: j,k,io
+
+    call blk%deallocate()
+
+    blk%header = file%line(i)
+    call clearxtbheader(blk%header)
+
+    do j = i+1,file%nlines
+      rawline = file%line(j)
+      if (isxtbheader(rawline)) exit
+      call get_xtb_keyvalue(kvdum,rawline,io)
+      if (io == 0) then
+        call blk%addkv(kvdum)
+      end if
+    end do
+
+  end subroutine read_xtbdatablock
+
+!========================================================================================!
+
+  subroutine get_xtb_keyvalue(kv,str,io)
+    implicit none
+    class(keyvalue) :: kv
+    character(len=*) :: str
+    integer,intent(out) :: io
+    character(len=:),allocatable :: tmpstr
+    character(len=:),allocatable :: ktmp
+    character(len=:),allocatable :: vtmp
+    integer :: i,j,k,na,plast
+    integer :: l(3)
+    call kv%deallocate()
+    io = 0
+    tmpstr = adjustl(lowercase(str))
+
+    !> key-value conditions
+    l(1) = index(tmpstr,'=')
+    l(2) = index(tmpstr,':')
+    l(3) = index(tmpstr,' ')
+
+    k = 0
+    if (l(1) .ne. 0) then
+      k = l(1)
+    else if (l(2) .ne. 0) then
+      k = l(2)
+    else if (l(3) .ne. 0) then
+      k = l(3)
+    end if
+
+    if (k .eq. 0) then
+      io = -1
+      return
+    end if
+
+    ktmp = trim(adjustl(tmpstr(:k-1)))
+    vtmp = trim(adjustl(tmpstr(k+1:)))
+    kv%key = ktmp !> the key as string
+    kv%rawvalue = vtmp !> value as unformatted string
+
+    !> comma denotes an array of strings
+    k = index(vtmp,',')
+    if (k .ne. 0) then
+      kv%id = valuetypes%raw_array
+      j = len_trim(vtmp)
+      na = 1
+      !> count elements
+      do i = 1,j
+        if (vtmp(i:i) .eq. ',') na = na+1
+      end do
+      !> allocate
+      kv%na = na
+      allocate (kv%value_rawa(na),source=repeat(' ',j))
+      plast = 1
+      na = 1
+      do i = 1,j
+        if (na == kv%na) then !> for the last argument
+          kv%value_rawa(na) = trim(adjustl(vtmp(plast:)))
+        end if
+        if (vtmp(i:i) .eq. ',') then
+          kv%value_rawa(na) = trim(adjustl(vtmp(plast:i-1)))
+          plast = i+1
+          na = na+1
+        end if
+      end do
+
+    end if
+  end subroutine get_xtb_keyvalue
+
+!========================================================================================!
+!> for given input file parse the next block
+  subroutine parse_xtbinfile_block(file,i,rawblk)
+    implicit none
+    type(filetype),intent(inout)      :: file
+    type(parseblock),intent(inout) :: rawblk
+    integer,intent(in) :: i
+    logical :: saveblock
+    integer :: j,k,l
+    character(len=:),allocatable :: src
+
+    call rawblk%deallocate()
+
+    src = repeat(' ',file%lwidth)
+
+    if (isxtbheader(file%line(i))) then
+      saveblock = .true.
+      rawblk%header = file%line(i)
+      !      cycle
+    end if
+    !> get blocklength
+    k = i+1
+    l = 0
+    jloop: do j = k,file%nlines
+      if (isxtbheader(file%line(j))) then
+        file%current_line = j
+        exit jloop
+      end if
+      if (len_trim(file%line(j)) > 0) then
+        l = l+1
+      end if
+      if (j == file%nlines) file%current_line = j
+    end do jloop
+    !if (l < 1) exit iloop
+    if (l < 1) return
+    !> get block
+    rawblk%len = l
+    allocate (rawblk%content(l),source=src)
+    l = 0
+    jloop2: do j = k,file%nlines
+      if (isheader(file%line(j))) then
+        saveblock = .false.
+        return
+      end if
+      if (len_trim(file%line(j)) > 0) then
+        l = l+1
+        rawblk%content(l) = file%line(j)
+      end if
+    end do jloop2
+    !end do iloop
+
+    return
+  end subroutine parse_xtbinfile_block
+
+!=======================================================================================!
+
+  subroutine clearxtbheader(hdr)
+    implicit none
+    character(len=*) :: hdr
+    integer :: i,k,l
+    character(len=:),allocatable :: atmp,btmp
+    character(len=1) :: s
+    atmp = adjustl(hdr)
+    atmp = trim(atmp)
+    !>remove whitespaces
+    l = len_trim(atmp)
+    k = index(hdr,'$')
+    if (k > 0) then
+      atmp(k:k) = ' '
+      atmp = adjustl(atmp)
+    end if
+    hdr = trim(atmp)
+    return
+  end subroutine clearxtbheader
+
+!========================================================================================!
+end module parse_xtbinput
Index: src/parsing/parse_csv.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/parse_csv.f90 b/src/parsing/parse_csv.f90
new file mode 100644
--- /dev/null	
+++ b/src/parsing/parse_csv.f90	
@@ -0,0 +1,372 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!> This module implements a simple reader for csv files
+!> NOT suitable for large csv tables
+
+module parse_csv
+  use filemod
+  use iomod
+  implicit none
+  private
+  !logical,parameter,private :: debug = .true.
+  logical,parameter,private :: debug = .false.
+
+  public :: parse_csv_file_column
+  interface parse_csv_file_column
+    module procedure :: parse_csv_file_columnname
+    module procedure :: parse_csv_file_columnnumber
+  end interface parse_csv_file_column
+
+  public :: parse_csv_column_int
+  interface parse_csv_column_int
+    module procedure :: parse_csv_columnname_int
+    module procedure :: parse_csv_columnnumber_int
+  end interface parse_csv_column_int
+
+  public :: parse_csv_column_real
+  interface parse_csv_column_real
+    module procedure :: parse_csv_columnname_real
+    module procedure :: parse_csv_columnnumber_real
+  end interface parse_csv_column_real
+
+!========================================================================================!
+!========================================================================================!
+contains  !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
+
+  subroutine parse_csv_file_columnname(fname,header,column)
+!******************************************
+!* Routine for parsing the csv file fname
+!* and get a column as array of strings
+!******************************************
+    implicit none
+    character(len=*),intent(in) :: fname
+    character(len=*),intent(in) :: header
+    character(len=:),intent(out),allocatable :: column(:)
+    logical :: ex
+    character(len=:),allocatable :: hdr
+    integer :: i,j,k,l
+    integer :: nrow,ncol,getcol
+    type(filetype) :: file
+
+    inquire (file=fname,exist=ex)
+    if (.not.ex) return
+    call file%open(fname)
+
+    call csv_params(file,nrow,ncol)
+    if (debug) write (*,*) 'nrow',nrow
+    if (debug) write (*,*) 'ncol',ncol
+    l = file%lwidth
+    allocate (column(nrow),source=repeat(' ',l))
+
+    !> first line should contain the header names
+    hdr = file%line(1)
+    if (debug) write (*,*) trim(hdr)
+    getcol = csv_get_column_number(hdr,header,ncol)
+    if (debug) write (*,*) 'trying to get column',getcol
+    if (getcol > 0) then
+      do i = 1,nrow
+        column(i) = get_column_element(file%line(i),getcol)
+        if (debug) write (*,*) trim(column(i))
+      end do
+    end if
+
+    call file%close()
+    !if (debug) stop
+  end subroutine parse_csv_file_columnname
+
+  subroutine parse_csv_file_columnnumber(fname,getcol,column)
+!*********************************************
+!* Routine for parsing the csv file fname
+!* and get a column as array of strings
+!*********************************************
+    implicit none
+    character(len=*),intent(in) :: fname
+    integer,intent(in) :: getcol
+    character(len=:),intent(out),allocatable :: column(:)
+    logical :: ex
+    character(len=:),allocatable :: hdr
+    integer :: i,j,k,l,nrow,ncol
+    type(filetype) :: file
+
+    inquire (file=fname,exist=ex)
+    if (.not.ex) return
+    call file%open(fname)
+
+    call csv_params(file,nrow,ncol)
+    if (debug) write (*,*) 'nrow',nrow
+    if (debug) write (*,*) 'ncol',ncol
+    l = file%lwidth
+    allocate (column(nrow),source=repeat(' ',l))
+
+    if (debug) write (*,*) 'trying to get column',getcol
+    if (getcol > 0.and.getcol <= ncol) then
+      do i = 1,nrow
+        !if (debug) write(*,*) file%line(i)
+        column(i) = get_column_element(file%line(i),getcol)
+        if (debug) write (*,*) trim(column(i))
+      end do
+    end if
+    !if (debug) stop
+  end subroutine parse_csv_file_columnnumber
+
+!========================================================================================!
+
+  subroutine parse_csv_columnname_real(fname,header,column)
+!*********************************************
+!* Routine for parsing the csv file fname
+!* and get a column as array of reals
+!*********************************************
+    implicit none
+    character(len=*),intent(in) :: fname
+    character(len=*),intent(in) ::header
+    real(wp),intent(out),allocatable :: column(:)
+    character(len=:),allocatable :: strcolumn(:)
+    logical :: ex
+    character(len=:),allocatable :: hdr
+    integer :: i,j,k,l,io
+    real(wp) :: dum
+
+    if(debug) write(*,*) 'parse column as real'
+    call parse_csv_file_column(fname,header,strcolumn)
+    l = size(strcolumn,1)
+    k = l-1
+    allocate (column(k),source=0.0_wp)
+    do i = 2,l
+      k = i-1
+      read (strcolumn(i),*,iostat=io) dum
+      if (io == 0) column(k) = dum
+      if (debug) write (*,*) dum
+    end do
+    deallocate (strcolumn)
+    if (debug) stop
+  end subroutine parse_csv_columnname_real
+
+  subroutine parse_csv_columnnumber_real(fname,getcol,column)
+!*********************************************
+!* Routine for parsing the csv file fname
+!* and get a column as array of reals
+!*********************************************
+    implicit none
+    character(len=*),intent(in) :: fname
+    integer,intent(in) :: getcol
+    real(wp),intent(out),allocatable :: column(:)
+    character(len=:),allocatable :: strcolumn(:)
+    logical :: ex
+    integer :: i,j,k,l,io
+    real(wp) :: dum
+
+    if(debug) write(*,*) 'parse column as real'
+    call parse_csv_file_column(fname,getcol,strcolumn)
+    l = size(strcolumn,1)
+    k = l-1
+    allocate (column(k),source=0.0_wp)
+    do i = 2,l
+      k = i-1
+      read (strcolumn(i),*,iostat=io) dum
+      if (io == 0) column(k) = dum
+      if (debug) write (*,*) dum
+    end do
+    deallocate (strcolumn)
+    if (debug) stop
+  end subroutine parse_csv_columnnumber_real
+
+!========================================================================================!
+
+  subroutine parse_csv_columnname_int(fname,header,column)
+!*********************************************
+!* Routine for parsing the csv file fname
+!* and get a column as array of integers
+!*********************************************
+    implicit none
+    character(len=*),intent(in) :: fname
+    character(len=*),intent(in) ::header
+    integer,intent(out),allocatable :: column(:)
+    character(len=:),allocatable :: strcolumn(:)
+    logical :: ex
+    character(len=:),allocatable :: hdr
+    integer :: i,j,k,l,io
+
+    call parse_csv_file_column(fname,header,strcolumn)
+    l = size(strcolumn,1)
+    k = l-1
+    allocate (column(k),source=0)
+    do i = 2,l
+      k = i-1
+      read (strcolumn(i),*,iostat=io) j
+      if(io==0) column(k) = j
+      if (debug) write (*,*) j
+    end do
+    deallocate (strcolumn)
+    if (debug) stop
+  end subroutine parse_csv_columnname_int
+
+  subroutine parse_csv_columnnumber_int(fname,getcol,column)
+!*********************************************
+!* Routine for parsing the csv file fname
+!* and get a column as array of integers
+!*********************************************
+    implicit none
+    character(len=*),intent(in) :: fname
+    integer,intent(in) :: getcol
+    integer,intent(out),allocatable :: column(:)
+    character(len=:),allocatable :: strcolumn(:)
+    logical :: ex
+    integer :: i,j,k,l,io
+
+    call parse_csv_file_column(fname,getcol,strcolumn)
+    l = size(strcolumn,1)
+    k = l-1
+    allocate (column(k),source=0)
+    do i = 2,l
+      k = i-1
+      read (strcolumn(i),*,iostat=io) j
+      if(io==0) column(k) = j
+      if (debug) write (*,*) j
+    end do
+    deallocate (strcolumn)
+    !if (debug) stop
+  end subroutine parse_csv_columnnumber_int
+
+!========================================================================================!
+
+  function count_columns(str) result(columns)
+!***************************************************
+!* count columns of a row based on number of commas
+!***************************************************
+    implicit none
+    character(len=*) :: str
+    character(len=:),allocatable :: atmp
+    integer :: columns
+    integer :: l,commas,i
+    atmp = adjustl(trim(str))
+    l = len_trim(atmp)
+    commas = 0
+    columns = 1
+    if (l < 1) return
+    do i = 1,l
+      if ((atmp(i:i) == ',')) then
+        commas = commas+1
+      end if
+    end do
+    columns = columns+commas
+    return
+  end function count_columns
+
+!========================================================================================!
+
+  function get_column_element(str,nr) result(col)
+!***************************************************
+!* count columns of a row based on number of commas
+!***************************************************
+    implicit none
+    character(len=*) :: str
+    integer,intent(in) :: nr
+    character(len=:),allocatable :: atmp
+    character(len=:),allocatable :: col
+    integer :: l,k,commas
+    atmp = adjustl(trim(str))
+    l = len_trim(atmp)
+    col = ''
+    k = 0
+    commas = 0
+    if (l < 1) return
+    do k = 1,l
+      if ((atmp(k:k) == ',')) then
+        if (commas+1 == nr) exit
+        commas = commas+1
+        col = ''
+      end if
+      col = col//atmp(k:k)
+      !if(debug) write(*,*) col
+    end do
+    !> if we don't have enough columnd
+    if (nr-commas > 1) col = ''
+    !> some formatting
+    if (col(1:1) == ',') col(1:1) = ' '
+    col = trim(adjustl(col))
+    return
+  end function get_column_element
+
+!========================================================================================!
+
+  subroutine csv_params(file,rows,columns)
+!*****************************************************************
+!* analyse a csv file and get the max numbers of rows and columns
+!*****************************************************************
+    implicit none
+    type(filetype) :: file
+    integer,intent(out) :: rows,columns
+    integer :: i,c
+    rows = 0
+    columns = 0
+    rows = file%nlines
+    do i = 1,rows
+      c = count_columns(file%line(i))
+      if (c > columns) columns = c
+    end do
+  end subroutine csv_params
+
+!========================================================================================!
+
+  function csv_get_column_number(line,header,maxelement) result(colnr)
+!***************************************************
+!* get the column number matching to a given header
+!***************************************************
+    implicit none
+    integer :: colnr
+    character(len=*),intent(in) :: line
+    character(len=*),intent(in) :: header
+    integer,intent(in) :: maxelement
+    character(len=:),allocatable :: element
+    integer :: i,j,k
+    logical :: casesensitive
+    character(len=26),parameter :: abc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+
+    colnr = 0
+    !> check if we have any uppercase characters in the header.
+    !> if so, we treat the search case-sensitively
+    casesensitive = .false.
+    do i = 1,26
+      if (index(header,abc(i:i)) .ne. 0) casesensitive = .true.
+    end do
+    !> iterate through column elements
+    do i = 1,maxelement
+      if (casesensitive) then
+        element = get_column_element(line,i)
+        element = lowercase(element)
+        if (element .eq. lowercase(header)) then
+          colnr = i
+          exit
+        end if
+      else
+        element = get_column_element(line,i)
+        if (element .eq. header) then
+          colnr = i
+          exit
+        end if
+      end if
+    end do
+  end function csv_get_column_number
+
+!========================================================================================!
+!========================================================================================!
+end module parse_csv
Index: src/wallsetup.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/wallsetup.f90 b/src/wallsetup.f90
new file mode 100644
--- /dev/null	
+++ b/src/wallsetup.f90	
@@ -0,0 +1,284 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2018-2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+module wall_setup
+   use crest_parameters
+   use miscdata
+   use strucrd
+   use axis_module
+   implicit none
+   private
+
+   public :: wallpot_core
+   public :: wall_dummypot
+
+   real(wp),parameter,private :: pi43 = pi * (4.0_wp / 3.0_wp)
+   real(wp),parameter,private :: third = 1.0_wp / 3.0_wp
+   real(wp),parameter,private :: kdefault = 1.0_wp  !> xtb version doesn't use k
+   real(wp),parameter,private :: alphadefault = 30.0_wp !> polynomial default in xtb
+
+!========================================================================================!
+!========================================================================================!
+contains !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
+
+subroutine wallpot_core(mol_in,rabc,potscal,atlist)
+!********************************************
+!* calculate a surrounding ellipsoid for mol
+!* the ellipsoid axes are returened as rabc
+!********************************************
+  implicit none
+  !> INPUT
+  type(coord) :: mol_in
+  real(wp),intent(in),optional :: potscal
+  logical,intent(in),optional :: atlist(mol_in%nat)
+  !> OUTPUT
+  real(wp),intent(out) :: rabc(3)
+  !> LOCAL
+  type(coord) :: mol
+  integer :: nat
+  real(wp) :: eaxr(3)
+  real(wp) :: rmax
+  real(wp) :: sola,vtot
+  real(wp) :: r,roff,boxr
+  real(wp) :: pshape,pscal
+  real(wp) :: natfac,erffac,erfscal
+  logical,parameter :: pr = .false.
+
+  pshape = 1.0d0
+  eaxr = 0.0d0
+  if(present(potscal))then
+     pscal = potscal
+  else
+     pscal = 1.0_wp
+  endif
+  
+
+!>-- obtain structure
+  if(present(atlist))then
+    mol = mol_in%cutout( atlist )
+  else
+    mol = mol_in
+  endif
+
+!>--- CMA trafo
+  nat = mol%nat
+  call axis(pr,mol%nat,mol%at,mol%xyz,eaxr)
+  sola = sqrt(1.0d0 + (abs(eaxr(1) - eaxr(3))) / (abs(eaxr(1) + eaxr(2) + eaxr(3)) / 3.0d0))
+  call getmaxdist(mol%nat, mol%xyz, mol%at, rmax)
+
+!>--- volume as sum of speherical atoms (crude approximation)
+  vtot = volsum(mol%nat,mol%at)
+
+!>--- calculate ellipsoid
+  roff = sola * vtot / 1000.0d0
+  boxr = ((sola * vtot) / pi43)**third + roff + rmax * 0.5_wp
+  r = (boxr**3 / (eaxr(1) * eaxr(2) * eaxr(3)))**third  ! volume of ellipsoid = volume of sphere
+  rabc = eaxr**pshape / sum((eaxr(1:3))**pshape)
+
+!> scale pot size by number of atoms
+!> pure empirics
+  natfac = 0.08_wp * nat - 0.08_wp * 50.0_wp
+  erffac = erf(natfac) * 0.25_wp
+  erfscal = 1.0_wp - erffac
+!> erfscal is ~ 1.25 for systems <<50 atoms
+!> erfscal is ~ 0.75 for systems >>50 atoms
+  rabc = eaxr * r * pscal * erfscal * 1.5_wp
+
+  return
+end subroutine wallpot_core
+
+!========================================================================================!
+
+subroutine getmaxdist(n,xyz,at,dist)
+  implicit none
+  integer :: n
+  integer :: at(n)
+  integer :: i
+  real(wp) :: xyz(3,n)
+  real(wp) :: dist
+  real(wp) :: dum
+
+  dist = 0.0d0
+
+  do i = 1,n
+    dum = sqrt(xyz(1,i)**2 + xyz(2,i)**2 + xyz(3,i)**2)
+    dum = dum + rcov(at(i))
+    if (dum .gt. dist) dist = dum
+  end do
+
+end subroutine getmaxdist
+
+!========================================================================================!
+
+subroutine wall_dummypot(ellips,xyz,at,nat)
+  implicit none
+
+  integer :: i
+  integer :: nat,ich
+  integer :: at(nat)
+
+  real(wp) :: xyz(3,nat)
+  real(wp) :: r,dum
+  real(wp) :: ellips(3)
+
+  real(wp) :: point(3)
+
+!---- ellipsoide has to statisfy x²/a² + y²/b² + z²/c² = 1
+
+  call init_random_seed()
+  open (file='wall.coord',newunit=ich)
+  write (ich,'(a)') "$coord"
+
+  do i = 1,nat
+    write (ich,'(3F24.12,5x,a2)') xyz(1:3,i),i2e(at(i))
+  end do
+
+  point = 0.0d0
+  do i = 1,100
+    call random_number(r)
+    point(1) = r * ellips(1)
+    do
+      call random_number(r)
+      point(2) = r * ellips(2)
+      dum = (point(1)**2 / ellips(1)**2)  &
+      &    + (point(2)**2 / ellips(2)**2)
+      if (dum .lt. 1.0d0) exit
+    end do
+    dum = 1.0d0 - (point(1)**2 / ellips(1)**2) - (point(2)**2 / ellips(2)**2)
+    dum = dum * ellips(3)**2
+
+    point(3) = sqrt(dum)
+
+    write (ich,'(3F24.12,5x,a2)') point(1:3),'he'
+    write (ich,'(3F24.12,5x,a2)') - 1 * point(1:3),'he'
+    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),point(2),point(3),'he'
+    write (ich,'(3F24.12,5x,a2)') point(1),-1 * point(2),point(3),'he'
+    write (ich,'(3F24.12,5x,a2)') point(1),point(2),-1 * point(3),'he'
+    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),-1 * point(2),point(3),'he'
+    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),point(2),-1 * point(3),'he'
+    write (ich,'(3F24.12,5x,a2)') point(1),-1 * point(2),-1 * point(3),'he'
+  end do
+
+  write (ich,'(a)') "$end"
+  close (ich)
+end subroutine wall_dummypot
+
+SUBROUTINE init_random_seed()
+  INTEGER :: i,n,clock
+  INTEGER,DIMENSION(:),ALLOCATABLE :: seed
+
+  CALL RANDOM_SEED(size=n)
+  ALLOCATE (seed(n))
+
+  CALL SYSTEM_CLOCK(COUNT=clock)
+
+  seed = clock + 37 * (/(i - 1,i=1,n)/)
+  CALL RANDOM_SEED(PUT=seed)
+
+  DEALLOCATE (seed)
+END SUBROUTINE
+
+!========================================================================================!
+
+function getbox(n,xyz,box)
+!************************************
+!* set up  a box around the molecule.
+!* the return value is the box volume
+!*************************************
+  implicit none
+  real(wp) :: getbox
+  integer,intent(in)  :: n
+  real(wp),intent(in) :: xyz(3,n)
+  real(wp),intent(out) :: box(3,3)
+  integer :: i
+  box = 0.0_wp
+  getbox = 1.0_wp
+  do i = 1,3 !i are the X,Y,Z axis
+    box(i,1) = maxval(xyz(i,:))
+    box(i,2) = minval(xyz(i,:))
+    box(i,3) = abs(box(i,1) - box(i,2)) !side length
+    getbox = getbox * box(i,3)          !to volume
+  end do
+  return
+end function getbox
+
+!========================================================================================!
+
+function getbox2(n,xyz,at,box)
+!************************************
+!* set up  a box around the molecule.
+!* the return value is the box volume
+!*************************************
+  implicit none
+  real(wp) :: getbox2
+  integer,intent(in)  :: n
+  real(wp),intent(in) :: xyz(3,n)
+  real(wp),intent(out) :: box(3,3)
+  integer,intent(in) :: at(n)
+  integer :: i
+  real(wp),allocatable :: rat(:)
+  real(wp) :: rcovmax
+  do i = 1,n
+    rat(i) = rcov(at(i))
+  end do
+  rcovmax = maxval(rat)
+  box = 0.0_wp
+  getbox2 = 1.0_wp
+  do i = 1,3 !i are the X,Y,Z axis
+    box(i,1) = maxval(xyz(i,:))
+    box(i,2) = minval(xyz(i,:))
+    box(i,3) = abs(box(i,1) - box(i,2)) !side length
+    if (box(i,3) .lt. 1d-6) then
+      box(i,1) = rcovmax
+      box(i,2) = -rcovmax
+      box(i,3) = rcovmax * 2.0_wp
+    end if
+    getbox2 = getbox2 * box(i,3)          !to volume
+  end do
+  deallocate (rat)
+  return
+end function getbox2
+
+!========================================================================================!
+
+function volsum(n,at)
+!***********************************************
+!* get the volume simply as a sum of 
+!* spherical atom volumes (crude approximation)
+!***********************************************
+  implicit none
+  real(wp) :: volsum
+  integer,intent(in)  :: n
+  integer,intent(in) :: at(n)
+  integer :: i
+  real(wp) :: r
+  !> using D3 vdW radii
+  volsum = 0.0_wp
+  do i = 1,n
+    r = vdw_d3(at(i))
+    volsum = volsum + (4.0_wp / 3.0_wp) * (3.14159265359_wp * r**3)
+  end do
+  return
+end function volsum
+
+!========================================================================================!
+!========================================================================================!
+end module wall_setup
Index: src/restartlog.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/restartlog.f90 b/src/restartlog.f90
new file mode 100644
--- /dev/null	
+++ b/src/restartlog.f90	
@@ -0,0 +1,431 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!> global variables to keep track of restart
+
+module crest_restartlog
+  use crest_parameters
+  use crest_data
+  use miscdata, only: PSE
+  use iomod, only: command
+  implicit none
+  private
+
+  !logical,parameter :: debug = .true.
+  logical,parameter :: debug = .false.
+  logical,parameter :: saveensembles = .true.
+
+!>--- tracking variables
+  integer :: restart_tracker = 0
+  integer :: restart_goal = 0
+
+  logical,allocatable :: last_processed(:)
+  character(len=300) :: last_dumped
+
+  !> a backup of the crest envrionment
+  type(systemdata),allocatable :: restart_env
+
+  !> backup of the last processed ensemble
+  character(len=300) :: last_file
+  integer :: last_nat = 0
+  integer :: last_nall = 0
+  integer,allocatable  :: last_at(:)
+  real(wp),allocatable :: last_xyz(:,:,:)
+  character(len=128),allocatable :: last_comments(:)
+
+!>--- routines/functions
+  public :: trackrestart
+  public :: restart_save_env
+  public :: trackensemble
+  interface trackensemble
+    module procedure :: trackensemble_comments
+    module procedure :: trackensemble_energy
+  end interface trackensemble
+  public :: restart_write_dummy
+
+  public :: dump_restart,read_restart
+
+!========================================================================================!
+!========================================================================================!
+contains !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
+!> Tracking routines to be called within the algos
+
+  function trackrestart(env) result(skip)
+!****************************************
+!* This function is to be called both
+!* to increment the restart tracker, and
+!* to check if a step needs to be skiped
+!****************************************
+    implicit none
+    logical :: skip
+    type(systemdata),intent(in),optional :: env
+    skip = .false.
+    restart_tracker = restart_tracker+1
+    if (debug) write (stdout,*) '%%% RESTART_TRACKER =',restart_tracker
+
+    if (restart_tracker < restart_goal) skip = .true.
+    if (.not.skip.and.present(env)) then
+      call restart_save_env(env)
+      call dump_restart()
+    end if
+    if(restart_tracker == restart_goal-1)then
+      if (debug) write (stdout,*) '%%% RESTART_RESTORE %%%'
+      call restore_ensemble()
+    endif
+  end function trackrestart
+
+
+  subroutine trackensemble_comments(fname,nat,nall,at,xyz,comments)
+!*******************************************************
+!* This subroutine decides wether to track the ensemble
+!* Typically, this routine is called in CREGEN
+!*******************************************************
+     implicit none
+     character(len=*),intent(in) :: fname
+     integer,intent(in)  :: nat,nall
+     integer,intent(in)  :: at(nat)
+     real(wp),intent(in) :: xyz(3,nat,nall)
+     character(len=*),intent(in) :: comments(nall)
+
+    if (restart_tracker > restart_goal)then
+      call restart_save_ensemble(fname,nat,nall,at,xyz,comments)
+    if (debug) write (stdout,*) '%%% RESTART_ENSEMBLE = ',trim(fname)
+    endif
+  end subroutine trackensemble_comments
+
+  subroutine trackensemble_energy(fname,nat,nall,at,xyz,eread)
+!*******************************************************
+!* This subroutine decides wether to track the ensemble
+!* Typically, this routine is called in CREGEN
+!*******************************************************
+     implicit none
+     character(len=*),intent(in) :: fname
+     integer,intent(in)  :: nat,nall
+     integer,intent(in)  :: at(nat)
+     real(wp),intent(in) :: xyz(3,nat,nall)
+     real(wp),intent(in) :: eread(nall)
+     character(len=50),allocatable  :: comments(:)
+     integer :: i
+    if (restart_tracker > restart_goal)then
+      allocate(comments(nall))
+      do i=1,nall
+        write(comments(i),*) eread(i)
+      enddo
+      call restart_save_ensemble(fname,nat,nall,at,xyz,comments)
+      deallocate(comments)
+    if (debug) write (stdout,*) '%%% RESTART_ENSEMBLE = ',trim(last_file)
+    endif
+  end subroutine trackensemble_energy
+
+
+  subroutine restart_write_dummy(fname)
+!*******************************************************
+!* This subroutine produces a placeholder file with
+!* only one structure
+!*******************************************************
+     implicit none
+     character(len=*),intent(in) :: fname
+     integer :: i,ich
+     if (restart_tracker < restart_goal-1)then
+     if(.not.debug) write (stdout,'(a,a)') 'CREST_RESTART> writing DUMMY file ',trim(fname)
+      open(newunit=ich, file=trim(fname))   
+      write(ich,*) last_nat
+      write(ich,*) trim(last_comments(1))
+      do i=1,last_nat
+      write(ich,'(a2,3f20.10)') PSE(last_at(i)),last_xyz(1:3,i,1)
+      enddo
+      close(ich)
+      if (debug) write (stdout,*) '%%% RESTART_DUMMY = ',trim(fname)
+     endif
+  end subroutine restart_write_dummy
+
+
+  subroutine restore_ensemble()
+!*******************************************************
+!* This subroutine produces a placeholder file with
+!* only one structure
+!*******************************************************
+     implicit none
+     integer :: i,ich,j,k
+     character(len=:),allocatable :: fname
+     character(len=:),allocatable :: atmp
+     !if(index(last_file,crefile).ne.0)then
+     ! call command('rm -f '//crefile//'* 2>/dev/null')
+     ! fname = crefile//'_0.xyz'
+     !else
+      fname=trim(last_file)
+     !endif
+
+      if(.not.debug)then
+         atmp = 'CREST_RESTART> RESTORING file '//trim(fname)
+         k = len_trim(atmp)+2
+         write (stdout,'(a,/,a,/,a)') repeat(':',k),trim(atmp),repeat(':',k) 
+      endif
+      open(newunit=ich, file=trim(fname))
+      do j=1,last_nall
+      write(ich,*) last_nat
+      write(ich,*) trim(last_comments(j))
+      do i=1,last_nat
+      write(ich,'(a2,3f20.10)') PSE(last_at(i)),last_xyz(1:3,i,j)
+      enddo
+      enddo
+      close(ich)
+      if (debug) write (stdout,*) '%%% RESTORE_ENSEMBLE = ',trim(fname)
+  end subroutine restore_ensemble
+
+
+
+
+
+!========================================================================================!
+!========================================================================================!
+!> DUMP to binary routines
+
+  subroutine dump_restart()
+    implicit none
+    integer :: ich,i,j,k,l
+    character(len=250) :: atmp
+    if (debug) write (stdout,*) '%%% RESTART DEBUG dump summary'
+
+    !> DO NOT OVERWRITE IF WE HAVEN'T REACHED THE PREVIOUS RESTART ENTRY POINT
+    if( restart_tracker < restart_goal) return
+
+    open (newunit=ich,file='crest.restart',status='replace',form='unformatted')
+
+    write (ich) restart_tracker
+    if (debug) write (stdout,*) '%%% RESTART_TRACKER =',restart_tracker
+
+    if (allocated(restart_env)) then
+      atmp = restart_env%cmd
+      write (ich) atmp
+      if (debug) write (stdout,*) '%%% cmd: ',trim(atmp)
+
+      atmp = restart_env%inputcoords
+      write (ich) atmp
+      if (debug) write (stdout,*) '%%% inputcoords: ',trim(atmp)
+
+      write (ich) restart_env%eprivious
+      if (debug) write (stdout,*) '%%% eprivious: ',restart_env%eprivious
+
+      write (ich) restart_env%elowest
+      if (debug) write (stdout,*) '%%% elowest: ',restart_env%elowest
+
+      j = restart_env%ref%nat
+      write(ich) j
+      if (debug) write (stdout,*) '%%% ref natoms: ', j
+      do i=1,j
+        write(ich) restart_env%ref%at(i)
+      enddo
+      do i=1,j
+        write(ich) restart_env%ref%xyz(1:3,i)
+      enddo
+   
+    end if
+
+    call dump_last_ensemble(ich)
+    if (debug) write (stdout,'(1x,a,a)') '%%% ensemble: ',trim(last_file)
+    if (debug) write (stdout,*) '%%% nall: ',last_nall
+
+    close (ich)
+  end subroutine dump_restart
+
+  subroutine dump_last_ensemble(ich)
+!******************************************
+!* dump last saved ensemble as binary data
+!******************************************
+    implicit none
+    integer, intent(in) :: ich
+    integer :: nat,nall,i,j,k,l
+    write(ich) last_file
+    nat = last_nat
+    write(ich) nat
+    nall = last_nall
+    write(ich) nall
+    if(allocated(last_comments) .and. allocated(last_xyz))then
+    do k=1,nat
+      write(ich) last_at(k)
+    enddo
+    do i=1,nall
+      write(ich) last_comments(i)
+      do j=1,nat
+        write(ich) last_xyz(1:3,j,i)
+      enddo
+    enddo
+    endif
+  end subroutine dump_last_ensemble
+
+!========================================================================================!
+!========================================================================================!
+!> read from binary subroutines
+
+  subroutine read_restart(env)
+    implicit none
+    type(systemdata),intent(inout) :: env
+    integer :: ich,i,j,k,l
+    character(len=250) :: atmp
+    real(wp) :: rdum,xyzdum(3)
+    integer :: idum
+    logical :: ex
+    integer,allocatable :: at(:) 
+    real(wp),allocatable :: xyz(:,:)
+    inquire(file='crest.restart', exist=ex)
+
+    if(.not.ex)then
+     write(stderr,'(a)') '**ERROR** while attempting to read crest.restart: file does not exist'
+     error stop
+    endif
+
+    open (newunit=ich,file='crest.restart',status='old',form='unformatted')
+    write(stdout,'(/,a)') repeat(":",80)
+    write(stdout,'(a)') 'READING crest.restart ...'
+    write(stdout,'(/,a)') '**WARNING**'
+    write(stdout,'(1x,a)') "It is a user responsibility to re-use an identical job setup,"
+    write(stdout,'(1x,a)') 'either via cmd or input file. The restart option only tracks'
+    write(stdout,'(1x,a)') 'structure information and a non-unique restart step ID'
+    write(stdout,'(a,/)') '**WARNING**'
+
+
+
+    read (ich) restart_goal
+    write(stdout,'(1x,a,i0)') 'Target restart step: ',restart_goal  
+
+    read (ich) atmp 
+    env%cmd = trim(atmp)
+    write(stdout,'(1x,a,2a)') 'Previous crest cmd: "',env%cmd,'"'
+
+    read (ich) atmp
+    env%inputcoords = trim(atmp)
+    write(stdout,'(1x,a,a)') 'Previous coord input file: ',env%inputcoords
+
+    read (ich) env%eprivious
+    read (ich) env%elowest
+    write(stdout,'(1x,a,f20.10)') 'Previous lowest energy: ',env%elowest
+
+    read (ich) j
+    write(stdout,'(1x,a,i0,a)') 'Original input coordinates for ',j,' atoms (Angström, CMA shifted): '
+    allocate(at(j))
+    do i=1,j
+      read(ich) at(i)
+    enddo
+    allocate(xyz(3,j))
+    do i=1,j
+      read(ich) xyzdum(1:3)
+      xyz(:,i) = xyzdum(:) 
+    enddo
+    write(stdout,'(a5,3a16)') 'at','X','Y','Z'
+    do i=1,j
+      write(stdout,'(a5,3f16.8)') trim(PSE(at(i))),xyz(1:3,i)*autoaa
+    enddo
+    env%ref%nat = j
+    call move_alloc(at, env%ref%at)
+    call move_alloc(xyz, env%ref%xyz)
+     
+
+    call read_last_ensemble(ich)
+    if(last_nat > 0 .and. last_nall > 0)then
+      write(stdout,'(1x,a,a)') 'Last processed ensemble file: ',trim(last_file)
+      write(stdout,'(1x,a,i0)') 'Number of saved structures: ',last_nall
+    endif
+
+
+    close (ich)
+    write(stdout,'(a)') 'FINISHED READING crest.restart ...'
+    write(stdout,'(a,/)') repeat(":",80)
+    !stop
+
+  end subroutine read_restart
+
+  subroutine read_last_ensemble(ich)
+!******************************************
+!* dump last saved ensemble as binary data
+!******************************************
+    implicit none
+    integer, intent(in) :: ich
+    integer :: nat,nall,i,j,k,l
+    read(ich) last_file
+    read(ich) nat
+    last_nat = nat
+    read(ich) nall
+    last_nall = nall
+    if(nat > 0 .and. nall > 0) then
+      allocate(last_at(nat))
+      allocate(last_xyz(3,nat,nall))
+      allocate(last_comments(nall)) 
+      do k=1,nat
+        read(ich) last_at(k)
+      enddo
+      do i=1,nall
+        read(ich) last_comments(i)
+        do j=1,nat
+          read(ich) last_xyz(1:3,j,i)
+        enddo
+      enddo
+    endif
+  end subroutine read_last_ensemble
+
+
+
+!========================================================================================!
+!========================================================================================!
+!> some routines to create backup data
+
+  subroutine restart_save_env(env)
+!*************
+!* backup env
+!*************  
+    implicit none
+    type(systemdata),intent(in) :: env
+    if (.not.allocated(restart_env)) then
+      allocate (restart_env,source=env)
+    end if
+    restart_env = env
+  end subroutine restart_save_env
+
+
+  subroutine restart_save_ensemble(fname,nat,nall,at,xyz,comments)
+!*********************************
+!* backup last processed ensemble
+!*********************************
+     implicit none
+     character(len=*),intent(in) :: fname
+     integer,intent(in)  :: nat,nall
+     integer,intent(in)  :: at(nat)
+     real(wp),intent(in) :: xyz(3,nat,nall)
+     character(len=*),intent(in) :: comments(nall)
+     integer :: i
+     if(.not.saveensembles) return
+     !> backup of the last processed ensemble
+     last_file = trim(fname)
+     last_nat = nat
+     last_nall = nall
+     if(.not.allocated(last_at)) allocate(last_at(nat))
+     last_at(:) = at(:)
+     if(allocated(last_xyz)) deallocate(last_xyz)
+     if(allocated(last_comments)) deallocate(last_comments)
+     allocate(last_xyz(3,nat,nall))
+     allocate(last_comments(nall))
+     last_xyz(:,:,:) = xyz(:,:,:)
+     last_comments(:) = comments(:)
+  end subroutine restart_save_ensemble
+
+!========================================================================================!
+!========================================================================================!
+end module crest_restartlog
Index: src/entropy/thermocalc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=========================================================================================!\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!\n!=========================================================================================!\n\nsubroutine prepthermo(nat,at,xyz,pr,molmass,rabc,avmom,symnum,symchar)\n!***********************************************************************\n!* Prepare the calculation of thermodynamic properties of a structure\n!* In particular, determine rotational constants and check the symmetry\n!***********************************************************************\n  use crest_parameters,only:wp,bohr,stdout\n  use atmasses,only:molweight\n  use iomod,only:to_lower\n  use axis_module\n  implicit none\n  integer,intent(in)     :: nat\n  integer,intent(in)     :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat) !> in Angstroem\n  logical,intent(in)     :: pr\n  real(wp),intent(out)   :: molmass\n  real(wp),intent(inout) :: rabc(3)\n  real(wp),intent(out)   :: avmom\n  real(wp),intent(out)   :: symnum\n\n  real(wp) :: a,b,c\n  character(len=4) :: sfsym\n  character(len=3) :: sym,symchar\n  real(wp),parameter :: desy = 0.1_wp\n  integer,parameter  :: maxat = 200\n\n  !>--- molecular mass in amu\n  molmass = molweight(nat,at)\n\n  if (pr) then\n    write (stdout,'(a,f8.2)') 'Mol. weight /amu  : ',molmass\n  end if\n\n  !>--- rotational constants in cm-1\n  rabc = 0.0d0\n  call axis(nat,at,xyz,rabc(1:3),avmom)\n  if (pr) then\n    write (stdout,'(a,3f8.2)') 'Rot. const. /MHz  : ',rabc(1:3)\n  end if\n  rabc = rabc/2.99792458d+4   ! MHz to cm-1\n  a = rabc(1)\n  b = rabc(2)\n  c = rabc(3)\n  if (pr) then\n    write (stdout,'(a,3f8.2)') 'Rot. const. /cm-1 : ',rabc(1:3)\n  end if\n\n  !>--- symmetry number from rotational symmetry\n  xyz = xyz/bohr\n  call getsymmetry2(.false.,6,nat,at,xyz,desy,maxat,sfsym)\n  xyz = xyz*bohr\n  sym = sfsym(1:3)\n  symchar = sym\n  symnum = 1.0d0\n  if (a .lt. 1.d-9.or.b .lt. 1.d-9.or.c .lt. 1.d-9) then\n    if (index(sym,'d') .ne. 0) symnum = 2.0d0\n  else\n    call to_lower(sym)\n    if (index(sym,'c2') .ne. 0) symnum = 2.0d0\n    if (index(sym,'s4') .ne. 0) symnum = 2.0d0\n    if (index(sym,'c3') .ne. 0) symnum = 3.0d0\n    if (index(sym,'s6') .ne. 0) symnum = 3.0d0\n    if (index(sym,'c4') .ne. 0) symnum = 4.0d0\n    if (index(sym,'s8') .ne. 0) symnum = 4.0d0\n    if (index(sym,'c5') .ne. 0) symnum = 5.0d0\n    if (index(sym,'c6') .ne. 0) symnum = 6.0d0\n    if (index(sym,'c7') .ne. 0) symnum = 7.0d0\n    if (index(sym,'c8') .ne. 0) symnum = 8.0d0\n    if (index(sym,'c9') .ne. 0) symnum = 9.0d0\n    if (index(sym,'d2') .ne. 0) symnum = 4.0d0\n    if (index(sym,'d3') .ne. 0) symnum = 6.0d0\n    if (index(sym,'d4') .ne. 0) symnum = 8.0d0\n    if (index(sym,'d5') .ne. 0) symnum = 10.0d0\n    if (index(sym,'d6') .ne. 0) symnum = 12.0d0\n    if (index(sym,'d7') .ne. 0) symnum = 14.0d0\n    if (index(sym,'d8') .ne. 0) symnum = 16.0d0\n    if (index(sym,'d9') .ne. 0) symnum = 18.0d0\n    if (index(sym,'t') .ne. 0) symnum = 12.0d0\n    if (index(sym,'td') .ne. 0) symnum = 12.0d0\n    if (index(sym,'th') .ne. 0) symnum = 12.0d0\n    if (index(sym,'o') .ne. 0) symnum = 24.0d0\n    if (index(sym,'oh') .ne. 0) symnum = 24.0d0\n    if (index(sym,'ih') .ne. 0) symnum = 60.0d0\n  end if\n\n  if (pr) then\n    write (stdout,'(a,4x,a)') 'Symmetry:',sym\n  end if\n  return\nend subroutine prepthermo\n\n!=========================================================================================!\nsubroutine calcthermo(nat,at,xyz,freq,pr,ithr,fscal,sthr,nt,temps, &\n    &      et,ht,gt,stot)\n!**************************************************************\n!* Calculate thermodynamic contributions for a given structure\n!* from it's frequencies (from second derivatives/the Hessian)\n!* Based on xtb's \"print_thermo\" routine\n!**************************************************************\n  use crest_parameters,only:wp,bohr,stdout\n  use crest_thermo\n  use atmasses,only:molweight\n  use iomod,only:to_lower\n  implicit none\n  integer,intent(in)     :: nat\n  integer,intent(in)     :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat)  !in Angstroem\n  real(wp),intent(inout) :: freq(3*nat) !in cm-1\n  logical,intent(in)     :: pr\n  real(wp),intent(in) :: ithr     !imag. inv. in cm-1\n  real(wp),intent(in) :: fscal    !freq scaling\n  real(wp),intent(in) :: sthr     !rotor cut\n  integer,intent(in)  :: nt\n  real(wp),intent(in) :: temps(nt)\n  real(wp) :: et(nt)          !< enthalpy in Eh\n  real(wp) :: ht(nt)          !< enthalpy in Eh\n  real(wp) :: gt(nt)          !< free energy in Eh\n  real(wp) :: stot(nt)        !< entropy in cal/molK\n  real(wp) :: ts(nt)          !< entropy*T in Eh\n  real(wp) :: rabc(3),a,b,c\n  real(wp) :: avmom\n  real(wp) :: molmass\n  real(wp) :: sym\n  real(wp) :: zp\n  character(len=3) :: symchar\n  logical :: pr2\n  logical :: linear = .false.\n  logical :: atom = .false.\n  integer :: nvib_theo\n  integer :: nvib,nimag\n  real(wp) :: vibthr\n  real(wp),allocatable :: vibs(:)\n\n  integer :: i,j\n  integer :: n3,rt\n  real(wp) :: adum(nt)\n  character(len=64) :: atmp\n\n  character(len=*),parameter :: outfmt = &\n  &  '(9x,\"::\",1x,a,f24.12,1x,a,1x,\"::\")'\n  character(len=*),parameter :: dblfmt = &\n  &  '(10x,\":\",2x,a,f24.7,1x,a,1x,\":\")'\n  character(len=*),parameter :: intfmt = &\n  &  '(10x,\":\",2x,a,i24,       6x,\":\")'\n  character(len=*),parameter :: chrfmt = &\n  &  '(10x,\":\",2x,a,a24,       6x,\":\")'\n\n  real(wp),parameter :: autorcm = 219474.63067_wp\n  real(wp),parameter :: rcmtoau = 1.0_wp/autorcm\n  real(wp),parameter :: autocal = 627.50947428_wp*1000.0_wp\n\n  call prepthermo(nat,at,xyz,pr,molmass,rabc,avmom,sym,symchar)\n\n  n3 = 3*nat\n  allocate (vibs(n3))\n  vibthr = 1.0\n  a = rabc(1)\n  b = rabc(2)\n  c = rabc(3)\n\n  nvib_theo = 3*nat-6\n  if (c .lt. 1.d-10) linear = .true.\n  if (linear) nvib_theo = 3*nat-5\n\n  if (a+b+c .lt. 1.d-6) then\n    atom = .true.\n    nvib = 0\n    nvib_theo = 0\n  end if\n\n  nvib = 0\n  vibs = 0.0\n  do i = 1,n3\n    if (abs(freq(i)) .gt. vibthr) then\n      nvib = nvib+1\n      vibs(nvib) = freq(i)\n    end if\n  end do\n  ! scale\n  vibs(1:nvib) = vibs(1:nvib)*fscal\n\n  ! invert imaginary modes\n  nimag = 0\n  do i = 1,nvib\n    if (vibs(i) .lt. 0.and.vibs(i) .gt. ithr) then\n      vibs(i) = -vibs(i)\n      if (pr) write (stdout,*) 'inverting freq ',i,vibs(i)\n    end if\n    if (vibs(i) < 0.0) then\n      nimag = nimag+1\n    end if\n  end do\n\n  if (pr) then\n    write (stdout,'(a)')\n    write (stdout,'(10x,51(\".\"))')\n    write (stdout,'(10x,\":\",22x,a,22x,\":\")') \"SETUP\"\n    write (stdout,'(10x,\":\",49(\".\"),\":\")')\n    write (stdout,intfmt) \"# frequencies    \",nvib\n    write (stdout,intfmt) \"# imaginary freq.\",nimag\n    write (atmp,*) linear\n    write (stdout,chrfmt) \"linear?          \",trim(atmp)\n    write (stdout,chrfmt) \"symmetry         \",adjustr(symchar)\n    write (stdout,intfmt) \"rotational number\",nint(sym)\n    write (stdout,dblfmt) \"scaling factor   \",fscal,\"    \"\n    write (stdout,dblfmt) \"rotor cutoff     \",sthr,\"cm⁻¹\"\n    write (stdout,dblfmt) \"imag. cutoff     \",ithr,\"cm⁻¹\"\n    write (stdout,'(10x,\":\",49(\".\"),\":\")')\n  end if\n\n  vibs = vibs*rcmtoau   ! thermodyn needs vibs and zp in Eh\n\n  zp = 0.5_wp*sum(vibs(1:nvib))\n  adum = abs(temps-298.15d0)\n  rt = minloc(adum,1)  !temperature closest to 298.15 is the ref.\n  do j = 1,nt\n    if ((j == rt).and.pr) then\n      pr2 = .true.\n    else\n      pr2 = .false.\n    end if\n    if (pr2) then\n      call print_thermo_sthr_ts(stdout,nvib,vibs,avmom,sthr,temps(j))\n    end if\n    call thermodyn(stdout,a,b,c,avmom,linear,atom,sym,molmass,vibs,nvib, &\n    & temps(j),sthr,et(j),ht(j),gt(j),ts(j),zp,pr2)\n    stot(j) = (ts(j)/temps(j))*autocal\n  end do\n\n  if ((nt > 1).and.pr) then\n    write (stdout,'(a)')\n    write (stdout,'(a10)',advance='no') \"T/K\"\n    write (stdout,'(a16)',advance='no') \"H(0)-H(T)+PV\"\n    write (stdout,'(a16)',advance='no') \"H(T)/Eh\"\n    write (stdout,'(a16)',advance='no') \"T*S/Eh\"\n    write (stdout,'(a16)',advance='no') \"G(T)/Eh\"\n    write (stdout,'(a)')\n    write (stdout,'(3x,72(\"-\"))')\n    do i = 1,nt\n      write (stdout,'(3f10.2)',advance='no') temps(i)\n      write (stdout,'(3e16.6)',advance='no') ht(i)\n      write (stdout,'(3e16.6)',advance='no') et(i)\n      write (stdout,'(3e16.6)',advance='no') ts(i)\n      write (stdout,'(3e16.6)',advance='no') gt(i)\n      if (i == rt) then\n        write (stdout,'(1x,\"(used)\")')\n      else\n        write (stdout,'(a)')\n      end if\n    end do\n    write (stdout,'(3x,72(\"-\"))')\n  end if\n\n  deallocate (vibs)\n  return\nend subroutine calcthermo\n\n!=========================================================================================!\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!\n!=========================================================================================!\n\nsubroutine thermo_wrap_legacy(env,pr,nat,at,xyz,dirname, &\n        &  nt,temps,et,ht,gt,stot,bhess)\n!**********************************************\n!* Wrapper for a Hessian calculation to get\n!* the thermodynamics of the molecule.\n!* Legacy version that uses xtb and reads\n!* the frequencies from a vibspectrum file\n!*********************************************\n  use crest_parameters,only:wp,stdout\n  use crest_data\n  use iomod\n  use strucrd\n  implicit none\n  !> INPUT\n  type(systemdata) :: env\n  logical,intent(in) :: pr\n  integer,intent(in) :: nat\n  integer,intent(inout) :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat)  !> in Angstroem!\n  character(len=*) :: dirname\n  integer,intent(in)  :: nt\n  real(wp),intent(in)  :: temps(nt)\n  logical,intent(in) :: bhess       !> calculate bhess instead?\n  !> OUTPUT\n  real(wp),intent(out) :: et(nt)    !> enthalpy in Eh\n  real(wp),intent(out) :: ht(nt)    !> enthalpy in Eh\n  real(wp),intent(out) :: gt(nt)    !> free energy in Eh\n  real(wp),intent(out) :: stot(nt)  !> entropy in cal/molK\n  !> LOCAL\n  logical :: subdir,ex\n  integer :: i,io,r,ich\n  character(len=1024) :: jobcall\n  character(len=*),parameter :: pipe = '2>/dev/null'\n  character(len=*),parameter :: xname = 'freq.xyz'\n  character(len=:),allocatable :: optpath\n  character(len=:),allocatable :: jobcall2\n  character(len=128) :: atmp\n  character(len=258) :: thispath\n  real(wp) :: etot\n  integer :: nfreq\n  real(wp),allocatable :: freq(:)\n  real(wp) :: ithr,fscal,sthr\n\n  integer :: TID,OMP_GET_THREAD_NUM\n\n!!$OMP PARALLEL PRIVATE(TID)\n  TID = OMP_GET_THREAD_NUM()\n  !awrite(*,*) '---->',TID\n!!$OMP END PARALLEL\n  ich = (TID+1)*1000   ! generate CPU dependent file channel number\n\n  call initsignal()\n\n  optpath = ''\n\n  subdir = .false.\n  i = len_trim(dirname)\n  if (i > 0) subdir = .true.\n\n  !>-- build the jobcall\n  jobcall = \"\"\n  jobcall = trim(jobcall)//trim(env%ProgName)\n  if (bhess) then\n    jobcall = trim(jobcall)//\" \"//trim(xname)//' --bhess loose'\n  else\n    jobcall = trim(jobcall)//\" \"//trim(xname)//' --ohess'\n  end if\n  jobcall = trim(jobcall)//\" \"//trim(env%gfnver)\n  jobcall = trim(jobcall)//\" \"//trim(env%solv)\n  if (env%chrg /= 0) then\n    jobcall = trim(jobcall)//\" --chrg \"//to_str(env%chrg)\n  end if\n  if (env%uhf /= 0) then\n    jobcall = trim(jobcall)//\" --uhf \"//to_str(env%uhf)\n  end if\n  jobcall = trim(jobcall)//' --ceasefiles > xtb.out '//trim(pipe)\n\n  if (subdir) then\n    call rmrf(trim(dirname))\n    r = makedir(trim(dirname))\n    optpath = trim(dirname)//'/'\n  end if\n\n  call env%wrtCHRG(trim(optpath))\n  inquire (file='gfnff_topo',exist=ex)\n  if (env%gfnver == '--gff'.and.subdir.and.ex) then\n    call getcwd(thispath)\n    io = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(optpath)//'gfnff_topo')\n  end if\n  if (index(env%fixfile,'none selected') .eq. 0) then\n    io = sylnk(trim(thispath)//'/'//env%fixfile,trim(optpath)//env%fixfile)\n  end if\n\n!$omp critical\n  open (unit=ich,file=trim(optpath)//xname)\n  call wrxyz(ich,nat,at,xyz)\n  if (env%thermo%constrhess) then\n    call write_cts(ich,env%cts)\n  end if\n  close (ich)\n!$omp end critical\n\n  if (subdir) then\n    jobcall2 = 'cd '//trim(dirname)//' && '//trim(jobcall)\n    call command( jobcall2, io )\n  else\n    call command( jobcall, io )\n  end if\n\n  et = 0.0_wp\n  ht = 0.0_wp\n  gt = 0.0_wp\n  stot = 0.0_wp\n\n  if (io /= 0) then  !if the calc failed\n    return\n  end if\n\n!$omp critical\n  call rdxmol(trim(optpath)//'xtbopt.xyz',nat,at,xyz,atmp)\n  etot = grepenergy(atmp)\n  nfreq = 3*nat\n\n  allocate (freq(nfreq))\n  call rdfreq(trim(optpath)//'vibspectrum',nfreq,freq)\n\n  ithr = env%thermo%ithr\n  fscal = env%thermo%fscal\n  sthr = env%thermo%sthr\n  call calcthermo(nat,at,xyz,freq,pr,ithr,fscal,sthr, &\n  &    nt,temps,et,ht,gt,stot)\n  deallocate (freq)\n!$omp end critical\n  call initsignal()\n  return\nend subroutine thermo_wrap_legacy\n\n!=========================================================================================!\nsubroutine rdfreq(fname,nmodes,freq)\n!**************************************\n!* read vibspectrum file in TM format\n!**************************************\n  use crest_parameters,only:wp\n  use crest_data\n  use iomod\n  implicit none\n  character(len=*),intent(in) :: fname\n  integer,intent(in)   :: nmodes\n  real(wp),intent(out) :: freq(nmodes)    !frequencies\n  integer :: k,ich,io,n\n  character(len=256) :: atmp\n  real(wp) :: floats(10)\n  logical :: ex\n  integer :: TID,OMP_GET_THREAD_NUM\n\n!!$OMP PARALLEL PRIVATE(TID)\n  TID = OMP_GET_THREAD_NUM()\n!      write(*,*) '---->',TID\n!!$OMP END PARALLEL\n  ich = (TID+1)*1000   ! generate CPU dependent file channel number\n\n  freq = 0.0_wp\n  inquire (file=fname,exist=ex)\n  if (.not.ex) return\n  k = 1 !modes\n  open (file=fname,unit=ich)\n  rdfile: do\n    read (ich,'(a)',iostat=io) atmp\n    if (io < 0) exit\n    if (index(atmp,'$vibrational spectrum') .ne. 0) then\n      rdblock: do\n        read (ich,'(a)',iostat=io) atmp\n        if (io < 0) exit rdfile\n        if (index(atmp,'$end') .ne. 0) exit rdfile\n        if (index(atmp,'#') .ne. 0) cycle rdblock !skip comment lines\n        call readl(atmp,floats,n)\n        freq(k) = floats(2)\n        k = k+1\n      end do rdblock\n    end if\n  end do rdfile\n  close (ich)\n  return\nend subroutine rdfreq\n\n!=========================================================================================!\n\nsubroutine thermo_wrap_new(env,pr,nat,at,xyz,dirname, &\n        &  nt,temps,et,ht,gt,stot,bhess)\n!*********************************************\n!* Wrapper for a Hessian calculation to get\n!* the thermodynamics of the molecule.\n!* Updated version without xtb subprocess\n!*********************************************\n!*** WARNING: xyz is expected in ANGSTROEM ***\n!*********************************************\n  use crest_parameters,only:wp,stdout,aatoau\n  use crest_data\n  use crest_calculator\n  use iomod\n  use strucrd\n  use hessian_tools\n  implicit none\n  !> INPUT\n  type(systemdata) :: env\n  logical,intent(in) :: pr\n  integer,intent(in) :: nat\n  integer,intent(inout) :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat)  !> in Angstroem!\n  character(len=*) :: dirname\n  integer,intent(in)  :: nt\n  real(wp),intent(in)  :: temps(nt)\n  logical,intent(in) :: bhess       !> calculate bhess instead?\n  !> OUTPUT\n  real(wp),intent(out) :: et(nt)    !> enthalpy in Eh\n  real(wp),intent(out) :: ht(nt)    !> enthalpy in Eh\n  real(wp),intent(out) :: gt(nt)    !> free energy in Eh\n  real(wp),intent(out) :: stot(nt)  !> entropy in cal/molK\n  !> LOCAL\n  type(coord) :: mol\n  type(calcdata) :: calctmp\n  character(len=10) :: atmp\n  logical :: subdir,ex\n  integer :: i,io,r,ich\n  real(wp) :: etot\n  integer :: nfreq\n  real(wp),allocatable :: hess(:,:)\n  real(wp),allocatable :: freq(:)\n  real(wp) :: ithr,fscal,sthr\n\n  integer :: TID,OMP_GET_THREAD_NUM\n\n!!$OMP PARALLEL PRIVATE(TID)\n  TID = OMP_GET_THREAD_NUM()\n  !awrite(*,*) '---->',TID\n!!$OMP END PARALLEL\n  ich = (TID+1)*1000   ! generate CPU dependent file channel number\n\n  call initsignal()\n\n  subdir = .false.\n  if (len_trim(dirname) > 0) subdir = .true.\n\n!>-- create a calculation object locally, modify calc dir\n!$omp critical\n  calctmp = env%calc\n  calctmp%pr_energies = .false. !> never do that!\n  mol%nat = nat\n  mol%at = at\n  mol%xyz = xyz*aatoau\n\n  do i = 1,calctmp%ncalculations\n    write (atmp,'(\".\",i0)') i\n    if (subdir) then\n      calctmp%calcs(i)%calcspace = trim(dirname)\n    else if (allocated(calctmp%calcs(i)%calcspace)) then\n      deallocate (calctmp%calcs(i)%calcspace)\n    end if\n  end do\n!>-- also, allocate frequncy and hessian space\n  nfreq = 3*nat\n  allocate (freq(nfreq),source=0.0_wp)\n  allocate (hess(nfreq,nfreq),source=0.0_wp)\n!$omp end critical\n\n!>-- numerical Hessian\n\n  !TODO bhess currently not coded with new calculator\n  if (bhess) then\n    write (stdout,'(\"> \",a)') 'bhess not implemented for calculator routines'\n  end if\n  !else\n  call numhess1(mol%nat,mol%at,mol%xyz,calctmp,hess,io)\n  !end if\n\n  if (io /= 0) then  !if the calc failed\n    return\n  end if\n\n!>-- project and get frequencies\n!$omp critical\n  !>-- Projects and mass-weights the Hessian\n  call prj_mw_hess(mol%nat,mol%at,nfreq,mol%xyz,hess)\n  !>-- Computes the Frequencies\n  call frequencies(mol%nat,mol%at,mol%xyz,nfreq,calctmp,hess,freq,io)\n!$omp end critical\n\n!>--- get thermodynamics\n!$omp critical\n  et = 0.0_wp\n  ht = 0.0_wp\n  gt = 0.0_wp\n  stot = 0.0_wp\n\n  ithr = env%thermo%ithr\n  fscal = env%thermo%fscal\n  sthr = env%thermo%sthr\n  call calcthermo(nat,at,xyz,freq,pr,ithr,fscal,sthr, &\n  &    nt,temps,et,ht,gt,stot)\n  deallocate (hess,freq)\n!$omp end critical\n  call initsignal()\n  return\nend subroutine thermo_wrap_new\n\n!=========================================================================================!\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!\n!=========================================================================================!\nsubroutine calcSrrhoav(env,ensname)\n!*******************************************************\n!* Calculate S_RRHO averages for a given ensemlbe\n!*******************************************************\n  use crest_parameters\n  use crest_data\n  use strucrd\n  use iomod\n  implicit none\n  !> INPUT\n  type(systemdata) :: env\n  character(len=*) :: ensname\n  !> LOCAL\n  real(wp),allocatable :: cp(:)\n  real(wp),allocatable :: hconf(:)\n  integer :: nat,nall\n  integer,allocatable :: at(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  real(wp),allocatable :: er(:)\n  real(wp),allocatable :: erel(:)\n  real(wp),allocatable :: efree(:,:)\n  real(wp),allocatable :: g(:) !> degeneracies, either read from cre_degen2 (if present), or set to unity\n  real(wp),allocatable :: p(:,:) !> populations at different T\n  integer,allocatable :: pindex(:)\n  real(wp),allocatable :: gatt(:,:)\n  real(wp),allocatable :: satt(:,:)\n  real(wp),allocatable :: srrho(:),sav(:)\n  real(wp),allocatable :: bsatt(:)\n  real(wp),allocatable :: gav(:)\n  real(wp),allocatable :: pdum(:)\n  real(wp) :: psum,emin,sdum\n  real(wp) :: quick_rmsd,rmsdval\n  integer :: eloc,ploc\n  logical :: avbhess\n\n  integer :: nt\n  real(wp),allocatable :: temps(:)\n  real(wp),allocatable :: et(:)\n  real(wp),allocatable :: ht(:)\n  real(wp),allocatable :: gt(:)\n  real(wp),allocatable :: stot(:)\n  real(wp),allocatable :: c0(:,:)\n  real(wp),allocatable :: sref(:)\n  character(len=64) :: atmp\n  integer :: i,j,k,ich,io,popf,ii\n  logical :: ex\n  logical :: niceprint\n  real(wp) :: percent\n  character(len=52) :: bar\n  integer :: ncalc,vz,nlimit,nav\n  character(len=512) :: thispath,tmppath\n\n  real(wp),parameter :: Tref = 298.15  !> room temperature is reference\n  real(wp),parameter :: kcal = autokcal\n\n!>--- read the given ensemble\n  call rdensembleparam(trim(ensname),nat,nall)\n  allocate (at(nat),xyz(3,nat,nall),er(nall))\n  call rdensemble(trim(ensname),nat,nall,at,xyz,er)\n\n  if (any(er(:) > 0.0d0)) then\n    error stop 'ensemble file must contain energies in Eh! must stop'\n  end if\n\n  write (tmppath,'(a)') 'Frequency Calculation and Averages'\n  write (stdout,*)\n  call smallhead(trim(tmppath))\n\n!>--- temperatures from sys object\n  if (.not.allocated(env%thermo%temps)) then\n    call env%thermo%get_temps()\n  end if\n  nt = env%thermo%ntemps\n  allocate (temps(nt))\n  temps = env%thermo%temps\n\n!>--- space for populations and degeneracies\n  allocate (g(nall),source=1.0_wp)\n  allocate (p(nall,nt))\n\n!>--- read degeneracies?\n  inquire (file='cre_degen2',exist=ex)\n  if (ex) then\n    open (newunit=ich,file='cre_degen2')\n    read (ich,*) atmp\n    do i = 1,nall\n      read (ich,*,iostat=io) j,g(i)\n      if (io < 0) exit\n    end do\n    close (ich)\n  else\n    g = 1\n  end if\n\n!========================================================================================!\n!> FREQUENCY CALCULATION AND THERMODYNAMICS\n!========================================================================================!\n!>--- determine how many hessians must be calculated\n!>--- NOTE: this assumes the ensemble is ordered by energy, lowest first.\n  allocate (erel(nall),pdum(nall),pindex(nall))\n  emin = minval(er(:),1)\n  erel = (er-emin)*kcal\n  call entropy_boltz(nall,Tref,erel,g,pdum)\n\n!>--- set up index for ensemble that are NOT energy-sorted\n  do i = 1,nall\n    pindex(i) = i\n  end do\n  pdum(:) = -pdum(:)             !> Hack because qsort does low-to-high\n  call qsort(pdum,1,nall,pindex) !> pindex is what we are after\n  pdum(:) = -pdum(:)             !> and switch sign back\n\n!>--- and with the sorted pdum, just count how many calculations we need\n  ncalc = 1  !> always take the lowest\n  ploc = maxloc(pdum(:),1)\n  psum = pdum(ploc)\n  nlimit = env%thermo%pcap !> limit strucs (for VERY large SE)\n  do i = 2,nall\n    psum = psum+pdum(i)\n    ncalc = ncalc+1\n    if (ncalc == nlimit) then\n      exit\n    end if\n    if (psum > env%thermo%ptot) then\n      exit\n    end if\n  end do\n  deallocate (pdum)\n\n!>--- print something\n  write (stdout,'(1x,a,i0)') 'Nconf on file      : ',nall\n  write (atmp,'(1x,a,f6.2,a)') '(=',psum*100.0d0,'% total population)'\n  write (stdout,'(1x,a,i0,a)') 'Taken for Hessians : ',ncalc,trim(atmp)\n  if (psum < env%thermo%ptot) then\n    write (stdout,'(2x,a,i0,a)') '=> (Limited to ',ncalc,' structures due to amount of calcs.)'\n  end if\n  write (stdout,'(1x,a,f8.2,1x,f8.2)') \"T range  /K    : \",temps(1),temps(nt)\n  write (stdout,'(1x,a,f17.6,1x,a)') \"scaling factor : \",env%thermo%fscal,\"    \"\n  write (stdout,'(1x,a,f17.6,1x,a)') \"rotor cutoff   : \",env%thermo%sthr,\"cm⁻¹\"\n  write (stdout,'(1x,a,f17.6,1x,a)') \"imag. cutoff   : \",env%thermo%ithr,\"cm⁻¹\"\n  write (stdout,*)\n\n!>--- calculate Hessians for ncalc lowest structures\n  allocate (gatt(nall,nt),satt(nall,nt),source=0.0_wp)\n\n  io = makedir('HESSIANS')\n  call getcwd(thispath)\n  inquire (file='gfnff_topo',exist=ex)\n\n  call chdir('HESSIANS')\n  if (env%legacy) then\n    if (env%gfnver == '--gff'.and.ex) then\n      call getcwd(tmppath)\n      io = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(tmppath)//'/'//'gfnff_topo')\n    end if\n    if (index(env%fixfile,'none selected') .eq. 0) then\n      io = sylnk(trim(thispath)//'/'//env%fixfile,trim(tmppath)//'/'//env%fixfile)\n    end if\n  end if\n\n  k = 0\n  niceprint = env%niceprint\n\n!>--- OMP stuff\n  if (env%autothreads) then\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,ncalc) !set global OMP/MKL variable for xtb jobs\n  end if\n\n!>--- the parallel loop\n  avbhess = env%thermo%avbhess\n  write (stdout,'(1x,a,i0,a)') 'Running ',ncalc,' calculations ...'\n!$omp parallel &\n!$omp shared( vz,tmppath,ncalc,percent,k,bar,niceprint) &\n!$omp shared( env,nat,at,xyz,c0,et,ht,gt,stot,temps,nt,gatt,satt,avbhess,pindex )\n!$omp single\n  allocate (et(nt),ht(nt),gt(nt),stot(nt))\n  allocate (c0(3,nat))\n  do i = 1,ncalc\n    call initsignal()\n    vz = pindex(i) !> restore index\n    !$omp task firstprivate( vz ) private( tmppath,et,ht,gt,stot,c0 )\n    call initsignal()\n    !$omp critical\n    write (tmppath,'(''hess'',i0)') vz\n    c0(1:3,1:nat) = xyz(1:3,1:nat,vz)\n    !$omp end critical\n\n    call thermo_wrap(env,.false.,nat,at,c0,tmppath, &\n    &    nt,temps,et,ht,gt,stot,avbhess)\n\n    !$omp critical\n    gatt(vz,1:nt) = gt(1:nt)\n    satt(vz,1:nt) = stot(1:nt)\n    !$omp end critical\n    if (.not.env%keepModef) call rmrf(trim(tmppath))\n\n    !$omp critical\n    k = k+1\n    if (niceprint) then\n      percent = float(k)/float(ncalc)*100\n      call progbar(percent,bar)\n      call printprogbar(percent,bar)\n    else\n      if (gui) then\n        call wrGUIpercent(k,ncalc,100)\n      else\n        write (6,'(1x,i0)',advance='no') k\n        flush (6)\n      end if\n    end if\n    !$omp end critical\n    !$omp end task\n  end do\n  deallocate (c0)\n  deallocate (stot,gt,ht,et)\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n  if (niceprint) then\n    write (stdout,'(/)')\n  else\n    write (stdout,'(/,1x,a,/)') 'done.'\n  end if\n  call chdir(thispath)\n  if (.not.env%keepModef) call rmrf('HESSIANS')\n\n!========================================================================================!\n!>--- process the calculated free energies and entropies into accurate populations\n  allocate (srrho(nt),sav(nt),gav(nt),efree(nall,nt))\n  srrho = 0.0_wp\n  sav = 0.0_wp\n  gav = 0.0_wp\n  nav = ncalc\n  write (stdout,'(1x,a)',advance='no') 'calculating averages for G and S ... '\n  flush (stdout)\n  do j = 1,nt\n    do ii = 1,ncalc\n      i = pindex(ii) !> restore index\n      if (abs(gatt(i,j)) .lt. 1.d-10) then  !> failed calcs?\n        if (j == 1) nav = nav-1\n      end if\n      gav(j) = gav(j)+gatt(i,j)\n      sav(j) = sav(j)+satt(i,j)\n    end do\n  end do\n  gav = gav/float(nav)   !> get the average G(T)\n  sav = sav/float(nav)   !> get the avverage S(T)\n  write (stdout,'(a8)') 'done.'\n\n!>--- get the free energies\n  do j = 1,nt\n    efree(:,j) = er(:) !> all based on etot\n    do ii = 1,nall\n      i = pindex(ii) !> restore index\n      if (ii <= ncalc) then\n        if (abs(gatt(i,j)) < 1.d-10) then\n          efree(i,j) = efree(i,j)+gav(j) !> add |G(T)| (for failed calcs)\n        else\n          efree(i,j) = efree(i,j)+gatt(i,j) !> add G(T)\n        end if\n      else\n!>-- for all energies that were not included in the free energy calculation add the average\n        efree(i,j) = efree(i,j)+gav(j)\n      end if\n    end do\n  end do\n\n!>--- make relative energies and calculate Boltzman populations\n  write (stdout,'(1x,a)',advance='no') 'calculating Boltzmann weights ... '\n  flush (stdout)\n  allocate (pdum(nall))\n  do j = 1,nt\n    emin = minval(efree(:,j),1)    !> lowest as reference\n    erel = (efree(:,j)-emin)*kcal  !> to relative energies in kcal/mol\n    pdum = 0.0d0\n    call entropy_boltz(nall,temps(j),erel,g,pdum)\n    !call entropy_boltz(ncalc,temps(j),erel,g(1:ncalc),pdum(1:ncalc))\n    p(:,j) = pdum(:)\n  end do\n  deallocate (pdum)\n  write (stdout,'(a11)') 'done.'\n  if (env%thermo%printpop) then\n    popf = makedir('populations')\n    do j = 1,nt\n      write (tmppath,'(a,a,a,i0)') 'populations','/','.pop_',nint(temps(j))\n      open (newunit=popf,file=trim(tmppath))\n      do k = 1,nall\n        write (popf,'(f16.8)') p(k,j)\n      end do\n      close (popf)\n    end do\n  end if\n\n!=========================================================================================!\n!==== after this point p now contains the correct populations based on free energies =====!\n!=========================================================================================!\n!>--- S_avRRHO must be calculated relative to the actual DFT reference structure\n!>--- the corresponding frequencies can be calculated with bhess\n  if (env%emtd%bhess.and.allocated(env%emtd%xyz)) then\n    allocate (bsatt(nt))\n    allocate (et(nt),ht(nt),gt(nt))\n    write (stdout,'(1x,a)',advance='no') 'calculating reference S (bhess) ... '\n    flush (stdout)\n    call thermo_wrap(env,.false.,env%emtd%nat,env%emtd%at,  &\n  &    env%emtd%xyz,'BHESS',nt,temps,et,ht,gt,bsatt,.true.)\n    if (.not.env%keepModef) call rmrf('BHESS')\n    deallocate (gt,ht,et)\n    write (stdout,'(a9)') 'done.'\n  end if\n!>--- average S_rrho with CORRECT populations\n  allocate (sref(nt),source=0.0_wp)\n  write (stdout,'(1x,a)',advance='no') 'calculating δSrrho ... '\n  flush (stdout)\n  srrho = 0.0d0\n  do j = 1,nt\n    do ii = 1,nall\n      i = pindex(ii) !> restore index\n      if (ii <= ncalc) then\n        if (abs(satt(i,j)) < 1.d-10) then\n          srrho(j) = srrho(j)+p(i,j)*sav(j)    !> (for failed hess calcs)\n        else\n          srrho(j) = srrho(j)+p(i,j)*satt(i,j) !> corrected for different S_rrho\n        end if\n      else\n        srrho(j) = srrho(j)+p(i,j)*sav(j)\n      end if\n    end do\n!>--- substract the reference value to shift the average\n    if (env%emtd%bhess.and.allocated(env%emtd%xyz)) then\n      sref(j) = bsatt(j) !> if a bhess value is available\n    else\n      sref(j) = satt(pindex(1),j) !> lowest in ensemble otherwise\n    end if\n    srrho(j) = srrho(j)-sref(j)\n  end do\n  write (stdout,'(a22)') 'done.'\n\n  if (env%emtd%bhess.and.allocated(env%emtd%xyz)) then\n    write (stdout,*)\n    call underline('Coordinates for the bhess reference structure (Ångström):')\n    call wrxyz(stdout,env%emtd%nat,env%emtd%at,env%emtd%xyz)\n    write (stdout,*) '-----------------------------------------------------------'\n    write (stdout,'(1x,a,a,a)') 'as read from <',env%emtd%fromfile,'>'\n    inquire (file='crest_best.xyz',exist=ex)\n    if (ex) then\n      rmsdval = quick_rmsd('crest_best.xyz',env%emtd%nat,env%emtd%at,env%emtd%xyz,.true.)\n      write (stdout,'(1x,a)') 'Heavy-atom RMSD between lowest conformer and this reference :'\n      write (stdout,'(1x,a,f16.6,a)') 'RMSD(heavy) =',rmsdval,' Å'\n      write (stdout,*)\n    end if\n    write (stdout,'(1x,a)') 'msRRHO(bhess) reference entropies:'\n    do i = 1,nt\n      write (stdout,'(2x,f10.2,2x,f16.6)') temps(i),bsatt(i)\n    end do\n  end if\n\n!>--- prinout for the average free energy and entropy\n  if ((nt > 1)) then\n    write (stdout,'(a)')\n    write (stdout,'(a10)',advance='no') \"T/K\"\n    write (stdout,'(a17)',advance='no') \"|S(T)|/cal/molK\"\n    write (stdout,'(a16)',advance='no') \"|G(T)|/Eh\"\n    write (stdout,'(a16)',advance='no') \"G_lowest/Eh\"\n    write (stdout,'(a10)',advance='no') \"(conf)\"\n    write (stdout,'(a)')\n    write (stdout,'(3x,65(\"-\"))')\n    do i = 1,nt\n      write (stdout,'(3f10.2)',advance='no') temps(i)\n      write (stdout,'(3e16.6)',advance='no') srrho(i)+sref(i)\n      write (stdout,'(3e16.6)',advance='no') gav(i)\n      emin = minval(efree(:,i),1)\n      write (stdout,'(f16.6)',advance='no') emin\n      eloc = minloc(efree(:,i),1)\n      write (stdout,'(i10)',advance='no') eloc\n      write (stdout,'(a)')\n    end do\n    write (stdout,'(3x,65(\"-\"))')\n    write (stdout,'(3x,a,a)') 'NOTE: if |G(T)| is the averaged ', &\n    & 'contributrion to the free energy.'\n    write (stdout,'(3x,a,a,i0,a)') '|G(T)| used only for the higher-energetic ', &\n    & 'structures (n > ',ncalc,').'\n    write (stdout,'(3x,a,a)') 'All other structures use ', &\n    & 'G(T) from the respective Hessian calculations.'\n  end if\n\n!>--- properties based on free energies\n  allocate (cp(nt),hconf(nt))\n  do j = 1,nt\n    emin = minval(efree(:,j),1)       !> lowest as reference\n    erel = (efree(:,j)-emin)*kcal     !> to relative energies in kcal/mol\n    call entropy_S(nall,temps(j),1.0d0,erel, &\n    &    g,sdum,cp(j),hconf(j))  !> g read from file or set to 1\n  end do\n\n  if ((nt > 1)) then\n    write (stdout,*)\n    write (stdout,'(1x,a)') 'Quantities calculated on free energies:'\n    write (stdout,'(a10)',advance='no') \"T/K\"\n    write (stdout,'(a17)',advance='no') \"δSrrho\"\n    write (stdout,'(a16)',advance='no') \"Cp(T)\"\n    write (stdout,'(a16)',advance='no') \"[H(T)-H(0)]\"\n    write (stdout,'(a)')\n    write (stdout,'(3x,55(\"-\"))')\n    do i = 1,nt\n      write (stdout,'(3f10.2)',advance='no') temps(i)\n      write (stdout,'(3e16.6)',advance='no') srrho(i)\n      write (stdout,'(3e16.6)',advance='no') cp(i)\n      write (stdout,'(f16.6)',advance='no') hconf(i)\n      write (stdout,'(a)')\n    end do\n    write (stdout,'(3x,55(\"-\"))')\n    write (stdout,'(3x,a,a)') 'NOTE: δSrrho(T) = |S(T)| - Sref(T)'\n  end if\n\n  if (allocated(env%emtd%soft)) then\n    env%emtd%soft(:) = srrho(:)  !> this is \\overline{S}_{msRRHO}\n  end if\n  if (allocated(env%emtd%cpoft)) then\n    env%emtd%cpoft(:) = cp(:)    !> this is Cp_conf\n  end if\n  if (allocated(env%emtd%hoft)) then\n    env%emtd%hoft(:) = hconf(:)  !> this is H_conf\n  end if\n\n  if (allocated(sref)) deallocate (sref)\n  if (allocated(bsatt)) deallocate (bsatt)\n  if (allocated(pindex)) deallocate (pindex)\n  deallocate (satt,gatt)\n  deallocate (efree,gav,sav,srrho)\n  deallocate (erel,p,g,temps)\n  deallocate (er,xyz,at)\n  return\nend subroutine calcSrrhoav\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/entropy/thermocalc.f90 b/src/entropy/thermocalc.f90
--- a/src/entropy/thermocalc.f90	
+++ b/src/entropy/thermocalc.f90	
@@ -760,6 +760,7 @@
 !>--- the parallel loop
   avbhess = env%thermo%avbhess
   write (stdout,'(1x,a,i0,a)') 'Running ',ncalc,' calculations ...'
+  call crest_oloop_pr_progress(env,ncalc,0)
 !$omp parallel &
 !$omp shared( vz,tmppath,ncalc,percent,k,bar,niceprint) &
 !$omp shared( env,nat,at,xyz,c0,et,ht,gt,stot,temps,nt,gatt,satt,avbhess,pindex )
@@ -787,18 +788,19 @@
 
     !$omp critical
     k = k+1
-    if (niceprint) then
-      percent = float(k)/float(ncalc)*100
-      call progbar(percent,bar)
-      call printprogbar(percent,bar)
-    else
-      if (gui) then
-        call wrGUIpercent(k,ncalc,100)
-      else
-        write (6,'(1x,i0)',advance='no') k
-        flush (6)
-      end if
-    end if
+    !if (niceprint) then
+    !  percent = float(k)/float(ncalc)*100
+    !  call progbar(percent,bar)
+    !  call printprogbar(percent,bar)
+    !else
+    !  if (gui) then
+    !    call wrGUIpercent(k,ncalc,100)
+    !  else
+    !    write (6,'(1x,i0)',advance='no') k
+    !    flush (6)
+    !  end if
+    !end if
+    call crest_oloop_pr_progress(env,ncalc,k)
     !$omp end critical
     !$omp end task
   end do
@@ -807,11 +809,12 @@
 !$omp taskwait
 !$omp end single
 !$omp end parallel
-  if (niceprint) then
-    write (stdout,'(/)')
-  else
-    write (stdout,'(/,1x,a,/)') 'done.'
-  end if
+  !if (niceprint) then
+  !  write (stdout,'(/)')
+  !else
+  !  write (stdout,'(/,1x,a,/)') 'done.'
+  !end if
+  call crest_oloop_pr_progress(env,ncalc,-1)
   call chdir(thispath)
   if (.not.env%keepModef) call rmrf('HESSIANS')
 
Index: src/entropy/entropy.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2020-2023 Stefan Grimme, Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nsubroutine calculateEntropy(nconf_tot,energies,nrot, &\n    &                       corefac,T,S,Cp,Hconf,pr,pr2)\n!****************************************************************\n!* Subroutine to calculate the molecular entropy of the system\n!*\n!* On Input:  nconf     - number of conformers\n!*            energies  - energy of each conformer\n!*            nrot      - number of rotamers for each conformer\n!*            corefac   - degeneracy arising from enantiomers\n!*            tlen      - total MTD length in ps\n!*            T         - temperature in K\n!*            pr        - boolean for printout\n!*\n!* On Output: S  - molecular entropy\n!*            Cp - molecular heat capacity\n!* \n!****************************************************************\n  use iso_fortran_env,wp => real64,idp => int64\n  implicit none\n\n  integer,intent(in)  :: nconf_tot\n  real(wp),intent(in) :: energies(nconf_tot)\n  integer(idp),intent(in)  :: nrot(nconf_tot)\n  real(wp),intent(in) :: corefac(nconf_tot)\n  logical,intent(in)  :: pr\n  logical,intent(in) :: pr2\n\n  real(wp) :: S,T\n  real(wp) :: sconf,hconf,cp\n  real(wp) :: dum1,dum2\n  real(wp),allocatable  :: e(:)\n  real(wp),allocatable  :: sr(:)\n  real(wp),allocatable  :: g(:)\n  real(wp),allocatable  :: p(:)\n\n  character(len=16) :: nmbr\n  character(len=26) :: prnt\n  integer :: i,ii\n  integer :: nconf\n\n  real(wp),parameter ::expo = 0\n\n  if (pr) then\n    write (*,*)\n    call smallhead('CALCULATION OF MOLECULAR ENTROPY')\n    write (*,*) 'entropies in cal/mol K, (free)energies in kcal/mol'\n  end if\n\n  nconf = nconf_tot\n  if (nconf .lt. 1) stop 'nconf < 1'\n  allocate (e(nconf),g(nconf),sr(nconf),p(nconf))\n\n  i = 0\n  do ii = 1,nconf_tot\n    i = i+1\n    g(i) = float(nrot(ii))\n    e(i) = 627.509541_wp*(energies(ii)-energies(1)) ! in kcal/mol\n  end do\n!shift\n  e = e-e(1)\n\n! calc conformer populations\n! this includes degeneracies true g()\n  call entropy_boltz(nconf,t,e,g,p)\n\n! calc S_conf\n  !call entropy_S(nconf,t,expo, e,g,sconf,dum1,dum2) ! g'\n  call entropy_S(nconf,t,1.0d0,e,corefac,sconf,dum1,dum2) !\"enantiomer\" factor\n  call entropy_S(nconf,t,1.0d0,e,g,dum1,cp,hconf)  ! g\n\n  S = sconf\n\n  if (pr2) then\n    write (nmbr,'(f16.2)') T\n    write (prnt,'(a,a,a)') 'H(',trim(adjustl(nmbr)),'K)-H(0) (conf)'\n    write (*,'(1x,a26,2x,f12.6)') adjustr(prnt),hconf\n    write (*,'(1x,''                  Cp(conf)  '',f12.6)') cp     ! no contrib from geometry or symmetry change\n    write (*,'(1x,''                   S(conf)  '',f12.6)') sconf\n  end if\n\n  deallocate (e,g,sr,p)\n\n  if (pr) then\n    write (*,'(/,1x,''final cp(total) =            '',f12.6)') cp\n    write (*,'(/,1x,''final S (total) =            '',f12.6)') S\n    write (*,'(/,1x,''CRE correction to G =        '',f12.6)')-S*T/1000.0_wp+hconf\n  end if\n\n  return\nend subroutine calculateEntropy\n\n!=========================================================================================!\nsubroutine entropy_boltz(n,t,e,g,p)\n!***************************************************\n!* compute Boltzmann populations p for given\n!* T, level energies e(), and\n!* level degeneracies g()\n!***************************************************\n  use crest_parameters\n  implicit none\n  integer n\n  real(wp) :: e(n),p(n),g(n)\n  real(wp) :: t,f,esum\n  integer i\n  real(wp),parameter :: R = Rcal\n\n  f = 1.0d0/(T*R*0.001d0)\n\n  esum = 0\n  do i = 1,n\n    esum = esum+g(i)*exp(-e(i)*f)\n  end do\n  do i = 1,n\n    p(i) = g(i)*exp(-e(i)*f)/esum\n  end do\n\n  if (abs(1.0d0-sum(p)) .gt. 1.d-6) stop 'error in entropy_boltz()'\n\nend subroutine entropy_boltz\n\n!=========================================================================================!\nsubroutine entropy_S(n,T,expo,e,g,s,cp,htmh0)\n!***************************************************\n!* compute entropy in cal/mol K for given T\n!* effective level energies e(), and\n!* level degeneracies g()\n!* returns also heat capacity cp(conf) and thermal\n!* correction H-H0(conf)\n!***************************************************\n  use crest_parameters\n  implicit none\n  integer :: n\n  real(wp) :: e(n),g(n),s,t,expo,cp,htmh0\n\n  real(wp),parameter :: R = Rcal\n  real(wp) :: f,esum,esum2,esum3,gi,p_i\n  integer :: i\n\n  f = 1.0d0/(T*R*0.001d0)\n\n  esum = 0\n  esum2 = 0\n  esum3 = 0\n  do i = 1,n\n    gi = g(i)**expo\n    p_i = gi*exp(-e(i)*f)\n    esum = esum+p_i\n    esum2 = esum2+p_i*(e(i)*f)\n    esum3 = esum3+p_i*(e(i)*f)**2\n  end do\n\n  !> Eq. 30 from https://cccbdb.nist.gov/thermo.asp\n  s = R*(log(esum)+esum2/esum) \n\n  !> Eq. 31 from https://cccbdb.nist.gov/thermo.asp\n  cp = R*(esum3/esum-(esum2/esum)**2) \n\n  !> Eq. 32 from https://cccbdb.nist.gov/thermo.asp\n  htmh0 = T*R*esum2/esum*0.001d0 \n\n  return\nend subroutine entropy_S\n\n!=========================================================================================!\nsubroutine newentropyextrapol(env)\n!*********************************************************\n!* Entropy extrapolation.\n!*********************************************************\n  use crest_parameters\n  use crest_data\n  use strucrd\n  implicit none\n  type(systemdata) :: env\n\n  integer :: i,j,k,l\n  integer :: iter,nt,itry\n  real(wp) :: T\n  real(wp),allocatable :: nconflist(:)\n  real(wp),allocatable :: cplist(:,:)\n  real(wp),allocatable :: slist(:,:)\n  real(wp),allocatable :: hlist(:,:)\n  real(wp),allocatable :: sfinal(:)\n  real(wp),allocatable :: cpfinal(:)\n  real(wp),allocatable :: hfinal(:)\n  real(wp),allocatable :: srrho(:)\n\n  character(len=128) :: btmp\n  character(len=64) :: btmp2\n  character(len=16) :: nmbr\n  character(len=26) :: prnt\n  real(wp) :: dum2,val\n  real(wp) :: p3,pmin,rmsd,rmin\n  logical  :: ok,okmin\n  integer  :: nall\n  integer  :: rt,ri\n  integer :: ich\n\n  logical :: prt,wrdegen\n  real(wp),allocatable :: temps(:)\n  real(wp),allocatable :: adum(:)\n\n!>--- determine temperature dependence\n  if (.not.allocated(env%thermo%temps)) then\n    call env%thermo%get_temps()\n  end if\n  nt = env%thermo%ntemps\n  allocate (temps(nt))\n  temps = env%thermo%temps\n  T = temps(1)\n\n  if (.not.allocated(env%emtd%soft)) then\n    allocate (env%emtd%soft(nt),source=0.0d0)\n  end if\n  if (.not.allocated(env%emtd%cpoft)) then\n    allocate (env%emtd%cpoft(nt),source=0.0d0)\n  end if\n  if (.not.allocated(env%emtd%hoft)) then\n    allocate (env%emtd%hoft(nt),source=0.0d0)\n  end if\n\n  iter = env%emtd%iterlast+1   !> we always have the zero-th iteration, hence +1\n  allocate (nconflist(iter),source=0.0d0)\n  allocate (cplist(iter,nt),source=0.0d0)\n  allocate (slist(iter,nt),source=0.0d0)\n  allocate (hlist(iter,nt),source=0.0d0)\n\n  !>--- sorting settings\n  env%cgf(2) = .false.\n  env%confgo = .true.\n\n  call largehead('ENSEMBLE ENTROPY CALCULATION')\n  allocate (adum(nt))\n  adum = abs(temps-298.15d0)\n  rt = minloc(adum,1)  !temperature closest to 298.15 is the ref.\n  deallocate (adum)\n\n  !>--- fallback for diatomics\n  if (env%nat .le. 2) then\n    T = temps(rt)\n    allocate (cpfinal(nt),sfinal(nt),hfinal(nt),srrho(nt),source=0.0d0)\n    write (*,*) 'Note: di- or monoatomic molecules have no conformational entropy'\n    call entropyprintout(T,srrho(rt),sfinal(rt),cpfinal(rt),hfinal(rt))\n    deallocate (srrho,hfinal,sfinal,cpfinal)\n    deallocate (hlist,slist,cplist,nconflist)\n    deallocate (env%emtd%hoft,env%emtd%cpoft,env%emtd%soft,temps)\n    return\n  end if\n\n  T = 298.15d0\n  wrdegen = .false.\n  open (unit=111,file='.data')\n  open (unit=222,file='.entropydata')\n  write (222,*) iter,nt\n  ITERATIONLOOP: do i = 1,iter\n\n    l = i-1  !ITER INCLUDES ZEROTH ITERATATION!\n    write (*,'(a)') '======================================================'\n    write (btmp,'(a,i0,a)') 'crest_entropy_rotamer_',l,'.xyz'\n\n    !-- new read .dataX files\n    write (btmp2,'(a,i0)') 'Sdata',l\n    open (newunit=ich,file=trim(btmp2))\n    read (ich,*) nall\n    write (222,*) nall\n    do j = 1,nt\n      read (ich,*) slist(i,j),cplist(i,j),hlist(i,j)\n      write (222,'(3F18.10)') slist(i,j),cplist(i,j),hlist(i,j)\n    end do\n    close (ich,status='delete')\n\n    write (*,'(1x,a,i0,a)') 'Containing ',nall,' conformers :'\n    env%confgo = .false.\n    nconflist(i) = float(nall)\n\n    write (nmbr,'(f16.2)') T\n    write (prnt,'(a,a,a)') 'H(',trim(adjustl(nmbr)),'K)-H(0) (conf)'\n    write (*,'(1x,a26,2x,f12.6)') adjustr(prnt),hlist(i,rt)\n    write (*,'(1x,''                  Cp(conf)  '',f12.6)') cplist(i,rt)\n    write (*,'(1x,''                   S(conf)  '',f12.6)') slist(i,rt)\n\n    write (111,'(i10,2F12.6)') nall,Slist(i,rt),Cplist(i,rt)\n  end do ITERATIONLOOP\n  close (222)\n  close (111)\n  write (*,'(a,/)') '======================================================'\n\n!>--- Sconf extrapolation\n  call smallhead('FINAL CALCULATION OF MOLECULAR ENTROPY')\n  write (*,*)\n  allocate (cpfinal(nt),sfinal(nt),hfinal(nt),srrho(nt),source=0.0d0)\n  TLOOP: do k = 1,nt\n    T = temps(k)\n    prt = .false.\n    if (k .eq. rt) prt = .true.  !printout only for RT\n\n    if (iter .gt. 3) then ! at least 3 points (sMTDs)\n      do itry = iter,5,-1   ! try with decreasing number of points untily fit is valid\n        p3 = 1.0d0\n        pmin = 1.0d0\n        rmin = 1.0d+42\n        okmin = .false.\n        do ri = 1,51  ! constrained search for best p3\n          call marqfit(.false.,.false.,iter,itry,slist(1:iter,k),p3,val,rmsd,ok) ! (last) 10 points max\n          if (rmsd .lt. rmin.and.ok) then\n            pmin = p3\n            rmin = rmsd\n            okmin = .true.\n          end if\n          p3 = p3-0.01d0\n        end do\n        if (okmin) exit\n      end do\n      call marqfit(.false.,prt,iter,itry,slist(1:iter,k),pmin,val,rmsd,ok) ! final with best p3\n      if (.not.ok) then\n        val = maxval(slist(1:iter,k))\n        if (prt) then\n          write (*,'(''WARNING: large fit error expected'',/)')\n          write (*,'(''FINAL ENTROPY (max conf.)  : '',f12.5)') val\n        end if\n      else\n        if (prt) write (*,'(''FINAL ENTROPY (extrapol.)  : '',f12.5)') val\n      end if\n    else\n      val = maxval(slist(1:iter,k))\n      if (prt) then\n        write (*,'(''WARNING: Not enough blocks for extrapolation.'')')\n        write (*,'(''         Taking full ensemble entropy instead.'',/)')\n        write (*,'(''FINAL ENTROPY (max conf.)  : '',f12.5)') val\n      end if\n    end if\n    sfinal(k) = val\n  end do TLOOP\n\n!>--- Srrho correction to Sconf\n  call calcSrrhoav(env,'crest_conformers.xyz')\n  if (env%nreset > 0) then\n    write (*,*)\n    write (*,'(1x,a)') 'Attention:'\n    write (*,'(1x,a,a)') 'The algorithm has found a better global ', &\n    & 'minimum structure and restarted at least once.'\n    write (*,'(1x,a)') 'The associated restart can strongly affect the δSrrho values.'\n  end if\n  srrho(:) = env%emtd%soft(:)\n!>--- cpfinal and hfinal come also from calcSrrhoav, but only\n!>    to use populations based on the free energies.\n  !cpfinal(:) = cplist(iter,:)\n  cpfinal(:) = env%emtd%cpoft(:)\n  !hfinal(:) = hlist(iter,:)\n  hfinal(:) = env%emtd%hoft(:)\n  do i = 1,nt\n    sfinal(i) = sfinal(i)+srrho(i)\n  end do\n\n!>---- temperature dependence printout\n  if (nt > 1) then\n    write (*,*)\n    call smallhead('TEMPERATURE DEPENDENCE')\n    write (*,*)\n    write (*,'(1x,a)') 'Final CONFORMATIONAL quantities at given T:'\n    write (*,'(a10)',advance='no') \"T/K\"\n    write (*,'(a16)',advance='no') \"S(total)\"\n    write (*,'(a16)',advance='no') \"Cp(T)\"\n    write (*,'(a16)',advance='no') \"[H(T)-H(0)]\"\n    write (*,'(a16)',advance='no') \"G(total)\"\n    write (*,'(a)')\n    write (*,'(3x,71(\"-\"))')\n    do i = 1,nt\n      write (*,'(f10.2)',advance='no') temps(i)\n      write (*,'(f16.6)',advance='no') sfinal(i)\n      write (*,'(f16.6)',advance='no') cpfinal(i)\n      write (*,'(f16.6)',advance='no') hfinal(i)\n      dum2 = -sfinal(i)*temps(i)/1000.0_wp+hfinal(i)\n      write (*,'(f16.6)',advance='no') dum2\n      write (*,'(a)')\n    end do\n    write (*,'(3x,71(\"-\"))')\n    write (*,'(3x,a)') 'S and Cp in cal/mol*K; H and G in kcal/mol'\n    write (*,'(3x,a,a)') 'G(total) is the ensemble free energy (H-T*S)', &\n    &    ' and S(total) = S(conf,extrapol.) + δSrrho'\n  end if\n\n!>---- last summary print\n  T = temps(rt)\n  call entropyprintout(T,srrho(rt),sfinal(rt),cpfinal(rt),hfinal(rt))\n\n  deallocate (srrho,hfinal,sfinal,cpfinal)\n  deallocate (hlist)\n  deallocate (slist)\n  deallocate (cplist)\n  deallocate (nconflist)\n\n  return\nend subroutine newentropyextrapol\n\n!========================================================================================!\nsubroutine entropyprintout(T,Srrho,S,Cp,H)\n  use crest_parameters, only: wp => real64\n  implicit none\n  real(wp) :: T\n  real(wp) :: Srrho\n  real(wp) :: S\n  real(wp) :: Cp\n  real(wp) :: H\n  character(len=80) :: atmp,btmp\n  character(len=*),parameter :: sunit = ' (cal mol⁻¹ K⁻¹)'\n  character(len=*),parameter :: gunit = ' (kcal mol⁻¹)'\n\n  write (*,*)\n  write (atmp,'(f12.2)') T\n  write (btmp,'(a,1x,a,1x,a)') '|'//repeat(' ',6)//'FINAL MOLECULAR ENTROPY AT T=', &\n  & trim(adjustl(atmp)),'K'//repeat(' ',6)//'|'\n  call smallhead(trim(btmp))\n\n  write (*,'(3x,''  Sconf   =      '',f12.6)') S-Srrho\n  write (*,'(3x,''+ δSrrho  =      '',f12.6)') Srrho\n  write (*,'(1x,53(\"-\"))')\n  write (*,'(1x,''= S(total)  =      '',f12.6,1x,a)') S, sunit\n  write (*,*)\n  write (*,'(3x,''H(T)-H(0) =      '',f12.6)') h\n  write (*,'(3x,''G         =      '',f12.6,a)') (-S*T/1000.0_wp),'   (-T*S)'\n  write (*,'(1x,53(\"-\"))')\n  write (*,'(1x,''= G(total)  =      '',f12.6,a,a)') (-S*T/1000.0_wp+H),'  (H-T*S)',gunit\n  write (*,*)\n  write (*,'(3x,''Cp(total) =      '',f12.6,1x,a)') cp, sunit\n  write (*,*)\n\n  return\nend subroutine entropyprintout\n\n!=========================================================================================!\nsubroutine redo_extrapol(fname,rtin)\n!*****************************************************************\n!*  Helper routine to re-do the extrapolation for\n!*  a read-in file. The two corresponding file formats\n!*  written by crest are .data and .entropydata (see code above)\n!*  Use by:\n!*  crest --redoextrapol .data\n!*****************************************************************\n  use crest_parameters\n  use crest_data\n  implicit none\n  character(len=*) :: fname\n  integer :: ich\n  integer :: i,j,k\n  integer :: iter,nt,rt,rtin\n  real(wp),allocatable :: temps(:)\n  real(wp),allocatable :: slist(:,:)\n  integer,allocatable  :: nalls(:)\n  real(wp),allocatable :: cpfinal(:)\n  real(wp),allocatable :: sfinal(:)\n  real(wp),allocatable :: hfinal(:)\n  real(wp),allocatable :: srrho(:)\n  integer :: itry,ri\n  real(wp) :: p3,val,pmin,rmin,rmsd\n  logical :: okmin,ok,prt\n  character(len=80) :: atmp\n  integer :: io\n  real(wp) :: dum1,dum2\n\n  rt = rtin\n  call smallhead('entropy extrapolation from file '//trim(fname))\n  write (*,*)\n\n  if (trim(fname) == '.entropydata') then\n    open (newunit=ich,file=fname)\n    read (ich,*) iter,nt\n    allocate (temps(nt),slist(iter,nt),source=0.0_wp)\n    allocate (nalls(iter),source=0)\n    do i = 1,iter\n      read (ich,*) nalls(i)\n      do j = 1,nt\n        read (ich,*) slist(i,j),dum1,dum2\n      end do\n    end do\n    close (ich)\n    if (rtin == 0) rt = 3 !the third entry for each block is 298K in the crest default\n\n  else if (trim(fname) == '.data') then\n    open (newunit=ich,file=fname)\n    iter = 0\n    do\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      iter = iter+1\n    end do\n    close (ich)\n    nt = 1\n    rt = 1  !.data only has the data for 298K\n    allocate (temps(nt),slist(iter,nt),source=0.0_wp)\n    allocate (nalls(iter),source=0)\n    open (newunit=ich,file=fname)\n    do i = 1,iter\n      read (ich,*) nalls(i),slist(i,nt),dum1\n    end do\n    close (ich)\n\n  else\n    write (*,*) 'unknown file. must be either \".data\" or \".entropydata\"'\n    error stop\n  end if\n\n  allocate (cpfinal(nt),sfinal(nt),hfinal(nt),srrho(nt),source=0.0d0)\n  TLOOP: do k = 1,nt\n    !      T = temps(k)   !for the read in version we dont need the temperatures\n    prt = .false.\n    if (k .eq. rt) prt = .true.  !printout only for RT\n\n    if (iter .gt. 3) then ! at least 3 points (sMTDs)\n      do itry = iter,5,-1   ! try with decreasing number of points untily fit is valid\n        p3 = 1.0d0\n        pmin = 1.0d0\n        rmin = 1.0d+42\n        okmin = .false.\n        do ri = 1,51  ! constrained search for best p3\n          call marqfit(.false.,.false.,iter,itry,slist(1:iter,k),p3,val,rmsd,ok) ! (last) 10 points max\n          if (rmsd .lt. rmin.and.ok) then\n            pmin = p3\n            rmin = rmsd\n            okmin = .true.\n          end if\n          p3 = p3-0.01d0\n        end do\n        if (okmin) exit\n      end do\n      call marqfit(prt,prt,iter,itry,slist(1:iter,k),pmin,val,rmsd,ok) ! final with best p3\n      if (.not.ok) then\n        val = maxval(slist(1:iter,k))\n        if (prt) then\n          write (*,'(''WARNING: large fit error expected'',/)')\n          write (*,'(''FINAL ENTROPY (max conf.)  : '',f12.5)') val\n        end if\n      else\n        if (prt) write (*,'(''FINAL ENTROPY (extrapol.)  : '',f12.5)') val\n      end if\n    else\n      val = maxval(slist(1:iter,k))\n      if (prt) then\n        write (*,'(''WARNING: Not enough blocks for extrapolation.'')')\n        write (*,'(''         Taking full ensemble entropy instead.'',/)')\n        write (*,'(''FINAL ENTROPY (max conf.)  : '',f12.5)') val\n      end if\n    end if\n    sfinal(k) = val\n  end do TLOOP\n\n  return\nend subroutine redo_extrapol\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/entropy/entropy.f90 b/src/entropy/entropy.f90
--- a/src/entropy/entropy.f90	
+++ b/src/entropy/entropy.f90	
@@ -354,7 +354,7 @@
   call calcSrrhoav(env,'crest_conformers.xyz')
   if (env%nreset > 0) then
     write (*,*)
-    write (*,'(1x,a)') 'Attention:'
+    write (*,'(1x,a)') '**WARNING**'
     write (*,'(1x,a,a)') 'The algorithm has found a better global ', &
     & 'minimum structure and restarted at least once.'
     write (*,'(1x,a)') 'The associated restart can strongly affect the δSrrho values.'
Index: src/miscdata.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/miscdata.f90 b/src/miscdata.f90
new file mode 100644
--- /dev/null	
+++ b/src/miscdata.f90	
@@ -0,0 +1,101 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2018-2020 Stefan Grimme
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+module miscdata
+  use crest_parameters
+  implicit none
+  public
+
+!&<
+  !> Element symbols
+  character(len=2),parameter :: PSE(118) = [ &
+   & 'H ',                                                                                'He', &
+   & 'Li','Be',                                                  'B ','C ','N ','O ','F ','Ne', &
+   & 'Na','Mg',                                                  'Al','Si','P ','S ','Cl','Ar', &
+   & 'K ','Ca','Sc','Ti','V ','Cr','Mn','Fe','Co','Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr', &
+   & 'Rb','Sr','Y ','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn','Sb','Te','I ','Xe', &
+   & 'Cs','Ba','La',                                                                            &
+   &                'Ce','Pr','Nd','Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu',      &
+   &                'Hf','Ta','W ','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At','Rn', &
+   & 'Fr','Ra','Ac',                                                                            &
+   &                'Th','Pa','U ','Np','Pu','Am','Cm','Bk','Cf','Es','Fm','Md','No','Lr',      &
+   &                'Rf','Db','Sg','Bh','Hs','Mt','Ds','Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og' ]
+!&>
+
+!&<
+  !> Covalent radii (taken from Pyykko and Atsumi, Chem. Eur. J. 15, 2009,
+  !> 188-197), values for metals decreased by 10%.
+  !> As used in D3
+  real(wp), parameter :: rcov(1:118) = [ &
+   & 0.32_wp,0.46_wp, & ! H,He
+   & 1.20_wp,0.94_wp,0.77_wp,0.75_wp,0.71_wp,0.63_wp,0.64_wp,0.67_wp, & ! Li-Ne
+   & 1.40_wp,1.25_wp,1.13_wp,1.04_wp,1.10_wp,1.02_wp,0.99_wp,0.96_wp, & ! Na-Ar
+   & 1.76_wp,1.54_wp, & ! K,Ca
+   &                 1.33_wp,1.22_wp,1.21_wp,1.10_wp,1.07_wp, & ! Sc-
+   &                 1.04_wp,1.00_wp,0.99_wp,1.01_wp,1.09_wp, & ! -Zn
+   &                 1.12_wp,1.09_wp,1.15_wp,1.10_wp,1.14_wp,1.17_wp, & ! Ga-Kr
+   & 1.89_wp,1.67_wp, & ! Rb,Sr
+   &                 1.47_wp,1.39_wp,1.32_wp,1.24_wp,1.15_wp, & ! Y-
+   &                 1.13_wp,1.13_wp,1.08_wp,1.15_wp,1.23_wp, & ! -Cd
+   &                 1.28_wp,1.26_wp,1.26_wp,1.23_wp,1.32_wp,1.31_wp, & ! In-Xe
+   & 2.09_wp,1.76_wp, & ! Cs,Ba
+   &         1.62_wp,1.47_wp,1.58_wp,1.57_wp,1.56_wp,1.55_wp,1.51_wp, & ! La-Eu
+   &         1.52_wp,1.51_wp,1.50_wp,1.49_wp,1.49_wp,1.48_wp,1.53_wp, & ! Gd-Yb
+   &                 1.46_wp,1.37_wp,1.31_wp,1.23_wp,1.18_wp, & ! Lu-
+   &                 1.16_wp,1.11_wp,1.12_wp,1.13_wp,1.32_wp, & ! -Hg
+   &                 1.30_wp,1.30_wp,1.36_wp,1.31_wp,1.38_wp,1.42_wp, & ! Tl-Rn
+   & 2.01_wp,1.81_wp, & ! Fr,Ra
+   &         1.67_wp,1.58_wp,1.52_wp,1.53_wp,1.54_wp,1.55_wp,1.49_wp, & ! Ac-Am
+   &         1.49_wp,1.51_wp,1.51_wp,1.48_wp,1.50_wp,1.56_wp,1.58_wp, & ! Cm-No
+   &                 1.45_wp,1.41_wp,1.34_wp,1.29_wp,1.27_wp, & ! Lr-
+   &                 1.21_wp,1.16_wp,1.15_wp,1.09_wp,1.22_wp, & ! -Cn
+   &                 1.36_wp,1.43_wp,1.46_wp,1.58_wp,1.48_wp,1.57_wp] & ! Nh-Og
+   & * aatoau * 4.0_wp / 3.0_wp
+!&>
+
+!&<
+  !> D3 pairwise van-der-Waals radii (only homoatomic pairs present here)
+  real(wp), parameter :: vdw_D3(1:94) = aatoau * [&
+   & 1.09155_wp, 0.86735_wp, 1.74780_wp, 1.54910_wp, &
+   & 1.60800_wp, 1.45515_wp, 1.31125_wp, 1.24085_wp, &
+   & 1.14980_wp, 1.06870_wp, 1.85410_wp, 1.74195_wp, &
+   & 2.00530_wp, 1.89585_wp, 1.75085_wp, 1.65535_wp, &
+   & 1.55230_wp, 1.45740_wp, 2.12055_wp, 2.05175_wp, &
+   & 1.94515_wp, 1.88210_wp, 1.86055_wp, 1.72070_wp, &
+   & 1.77310_wp, 1.72105_wp, 1.71635_wp, 1.67310_wp, &
+   & 1.65040_wp, 1.61545_wp, 1.97895_wp, 1.93095_wp, &
+   & 1.83125_wp, 1.76340_wp, 1.68310_wp, 1.60480_wp, &
+   & 2.30880_wp, 2.23820_wp, 2.10980_wp, 2.02985_wp, &
+   & 1.92980_wp, 1.87715_wp, 1.78450_wp, 1.73115_wp, &
+   & 1.69875_wp, 1.67625_wp, 1.66540_wp, 1.73100_wp, &
+   & 2.13115_wp, 2.09370_wp, 2.00750_wp, 1.94505_wp, &
+   & 1.86900_wp, 1.79445_wp, 2.52835_wp, 2.59070_wp, &
+   & 2.31305_wp, 2.31005_wp, 2.28510_wp, 2.26355_wp, &
+   & 2.24480_wp, 2.22575_wp, 2.21170_wp, 2.06215_wp, &
+   & 2.12135_wp, 2.07705_wp, 2.13970_wp, 2.12250_wp, &
+   & 2.11040_wp, 2.09930_wp, 2.00650_wp, 2.12250_wp, &
+   & 2.04900_wp, 1.99275_wp, 1.94775_wp, 1.87450_wp, &
+   & 1.72280_wp, 1.67625_wp, 1.62820_wp, 1.67995_wp, &
+   & 2.15635_wp, 2.13820_wp, 2.05875_wp, 2.00270_wp, &
+   & 1.93220_wp, 1.86080_wp, 2.53980_wp, 2.46470_wp, &
+   & 2.35215_wp, 2.21260_wp, 2.22970_wp, 2.19785_wp, &
+   & 2.17695_wp, 2.21705_wp]
+!&>
+
+end module miscdata
Index: src/deprecated/neighbor.f
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/deprecated/neighbor.f b/src/deprecated/neighbor.f
new file mode 100644
--- /dev/null	
+++ b/src/deprecated/neighbor.f	
@@ -0,0 +1,321 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2017 Stefan Grimme
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!c determine ring and ringsize from neighbor list
+!c SG 2017, for QMDFF
+!      subroutine getring(n,nbin,a0,c,iring)
+!      implicit none
+!      integer n,nbin(20,n),a0,iring,i,nb(20,0:n)
+!      integer    i1,i2,i3,i4,i5,i6,i7,i8,i9,i10
+!      integer n0,n1,n2,n3,n4,n5,n6,n7,n8,n9,n10
+!      integer    a1,a2,a3,a4,a5,a6,a7,a8,a9,a10
+!      integer c(10)
+!      logical chk
+! 
+!      if(n.le.2) return
+!
+!      nb(:,1:n)=nbin(:,:)
+!      do i=1,n
+!         if(nb(20,i).eq.1)nb(20,i)=0
+!      enddo
+!
+!      iring =0
+!      c     =0
+!
+!      n0=nb(20,a0)
+!
+!      do i1=1,n0
+!         a1=nb(i1,a0)
+!         if(a1.eq.a0) cycle
+!         n1=nb(20,a1)
+!         do i2=1,n1
+!            a2=nb(i2,a1)
+!            if(a2.eq.a1) cycle
+!            n2=nb(20,a2)
+!            do i3=1,n2
+!               a3=nb(i3,a2)
+!               n3=nb(20,a3)
+!               if(a3.eq.a2) cycle
+!               c(1)=a1
+!               c(2)=a2
+!               c(3)=a3
+!               if(a3.eq.a0.and.chk(n,3,c))then
+!               iring=3
+!               goto 99
+!               endif
+!               do i4=1,n3
+!                  a4=nb(i4,a3)
+!                  n4=nb(20,a4)
+!                  if(a4.eq.a3) cycle
+!                  c(4)=a4
+!                  if(a4.eq.a0.and.chk(n,4,c))then
+!                     iring=4
+!                     goto 99
+!                  endif
+!                  do i5=1,n4
+!                     a5=nb(i5,a4)
+!                     n5=nb(20,a5)
+!                     if(a5.eq.a4) cycle
+!                     c(5)=a5
+!                     if(a5.eq.a0.and.chk(n,5,c))then
+!                        iring=5
+!                        goto 99
+!                     endif
+!                     do i6=1,n5
+!                        a6=nb(i6,a5)
+!                        n6=nb(20,a6)
+!                        if(a6.eq.a5) cycle
+!                        c(6)=a6
+!                        if(a6.eq.a0.and.chk(n,6,c))then
+!                           iring=6
+!                           goto 99
+!                        endif
+!                        do i7=1,n6
+!                           a7=nb(i7,a6)
+!                           n7=nb(20,a7)
+!                           if(a7.eq.a6) cycle
+!                           c(7)=a7
+!                           if(a7.eq.a0.and.chk(n,7,c))then
+!                              iring=7
+!                              goto 99
+!                           endif
+!                           do i8=1,n7
+!                              a8=nb(i8,a7)
+!                              n8=nb(20,a8)
+!                              if(a8.eq.a7) cycle
+!                              c(8)=a8
+!                              if(a8.eq.a0.and.chk(n,8,c))then
+!                                 iring=8
+!                                 goto 99
+!                              endif
+!                              do i9=1,n8
+!                                 a9=nb(i9,a8)
+!                                 n9=nb(20,a9)
+!                                 if(a9.eq.a8) cycle
+!                                 c(9)=a9
+!                                 if(a9.eq.a0.and.chk(n,9,c))then
+!                                    iring=9
+!                                    goto 99
+!                                 endif
+!                                 do i10=1,n9
+!                                    a10=nb(i10,a9)
+!                                    n10=nb(20,a10)
+!                                    if(a10.eq.a9) cycle
+!                                    c(10)=a10
+!                                    if(a10.eq.a0.and.chk(n,10,c))then
+!                                       iring=10
+!                                       goto 99
+!                                    endif
+!                                 enddo
+!                              enddo
+!                           enddo
+!                        enddo
+!                     enddo
+!                  enddo
+!               enddo
+!            enddo
+!         enddo
+!      enddo
+!
+!      return
+!
+! 99   continue
+!c     write(*,*) 'atom ',a0,'ring found',c(1:iring)
+!c     call isort(iring,c)
+!      return
+!
+!      end
+!
+!      logical function chk(nn,n,c)
+!      implicit none
+!      integer n,idum(0:nn),nn,c(10),i,j
+!      chk=.true.
+!      idum=0
+!      do i=1,n
+!         idum(c(i))=idum(c(i))+1
+!      enddo
+!      j=0
+!      do i=1,nn
+!         if(idum(i).eq.1) j=j+1
+!      enddo
+!      if(j.ne.n) chk=.false.
+!      end
+!
+!
+!      logical function samering(n,i,j,c,s)
+!      implicit none
+!      integer n,i,j,c(10,n),s(n)
+!      integer m,k
+!
+!      samering=.false.
+!      if(s(i).eq.0   ) return
+!      if(s(i).ne.s(j)) return
+!
+!      m=0
+!      do k=1,s(i)
+!         m=m+c(k,i)-c(k,j)
+!      enddo
+!      if(m.eq.0) then
+!         samering=.true.
+!         return
+!      endif
+!      
+!      do k=1,s(i)
+!         if(c(k,i).eq.j)then
+!            samering=.true.
+!            return
+!         endif
+!      enddo
+!      do k=1,s(j)
+!         if(c(k,j).eq.i)then
+!            samering=.true.
+!            return
+!         endif
+!      enddo
+!
+!      end
+!
+!      subroutine neighborh(natoms,at,xyz,nb)
+!      implicit none  
+!      integer at(natoms),natoms,nb(20,natoms)
+!      real*8  xyz(3,natoms)
+!
+!      logical da
+!      integer iat,i,j,k,nn
+!      real*8 rad(94)
+!      real*8 dx,dy,dz,r,rco,r2,f
+!      data rad/
+!     . 0.80628308, 1.15903197, 3.02356173, 2.36845659, 1.94011865,
+!     . 1.88972601, 1.78894056, 1.58736983, 1.61256616, 1.68815527,
+!     . 3.52748848, 3.14954334, 2.84718717, 2.62041997, 2.77159820,
+!     . 2.57002732, 2.49443835, 2.41884923, 4.43455700, 3.88023730,
+!     . 3.35111422, 3.07395437, 3.04875805, 2.77159820, 2.69600923,
+!     . 2.62041997, 2.51963467, 2.49443835, 2.54483100, 2.74640188,
+!     . 2.82199085, 2.74640188, 2.89757982, 2.77159820, 2.87238349,
+!     . 2.94797246, 4.76210950, 4.20778980, 3.70386304, 3.50229216,
+!     . 3.32591790, 3.12434702, 2.89757982, 2.84718717, 2.84718717,
+!     . 2.72120556, 2.89757982, 3.09915070, 3.22513231, 3.17473967,
+!     . 3.17473967, 3.09915070, 3.32591790, 3.30072128, 5.26603625,
+!     . 4.43455700, 4.08180818, 3.70386304, 3.98102289, 3.95582657,
+!     . 3.93062995, 3.90543362, 3.80464833, 3.82984466, 3.80464833,
+!     . 3.77945201, 3.75425569, 3.75425569, 3.72905937, 3.85504098,
+!     . 3.67866672, 3.45189952, 3.30072128, 3.09915070, 2.97316878,
+!     . 2.92277614, 2.79679452, 2.82199085, 2.84718717, 3.32591790,
+!     . 3.27552496, 3.27552496, 3.42670319, 3.30072128, 3.47709584,
+!     . 3.57788113, 5.06446567, 4.56053862, 4.20778980, 3.98102289,
+!     . 3.82984466, 3.85504098, 3.88023730, 3.90543362 /
+!
+!      nb=0
+!      nn=min(natoms,2)-1
+!
+!      do i=1,natoms
+!      f=1.0
+!      k=0
+! 100  do iat=1,natoms
+!         da=.false.
+!         do j=1,k
+!            if(nb(j,i).eq.iat)da=.true.
+!         enddo
+!         if(iat.ne.i.and.(.not.da))then
+!            dx=xyz(1,iat)-xyz(1,i)
+!            dy=xyz(2,iat)-xyz(2,i)
+!            dz=xyz(3,iat)-xyz(3,i)
+!            r2=dx*dx+dy*dy+dz*dz 
+!            r=sqrt(r2)
+!            rco=rad(at(i))+rad(at(iat))
+!c critical step            
+!            if(r.lt.f*rco.and.k.lt.19)then
+!               k=k+1
+!               nb(k,i)=iat
+!            endif
+!         endif
+!      enddo
+!      if(k.lt.1.and.f.lt.1.5)then
+!         f=f*1.1
+!         goto 100
+!      endif
+!      nb(20,i)=k
+!      enddo
+!
+!      end
+
+      subroutine neighdist(natoms,at,xyz,nb,dist)
+      implicit none  
+      integer at(natoms),natoms,nb(200,natoms)
+      real*8  xyz(3,natoms),dist(natoms,natoms)
+
+      logical da
+      integer iat,i,j,k,nn
+      real*8 rad(94)
+      real*8 dx,dy,dz,r,rco,r2,f
+      data rad/
+     . 0.80628308, 1.15903197, 3.02356173, 2.36845659, 1.94011865,
+     . 1.88972601, 1.78894056, 1.58736983, 1.61256616, 1.68815527,
+     . 3.52748848, 3.14954334, 2.84718717, 2.62041997, 2.77159820,
+     . 2.57002732, 2.49443835, 2.41884923, 4.43455700, 3.88023730,
+     . 3.35111422, 3.07395437, 3.04875805, 2.77159820, 2.69600923,
+     . 2.62041997, 2.51963467, 2.49443835, 2.54483100, 2.74640188,
+     . 2.82199085, 2.74640188, 2.89757982, 2.77159820, 2.87238349,
+     . 2.94797246, 4.76210950, 4.20778980, 3.70386304, 3.50229216,
+     . 3.32591790, 3.12434702, 2.89757982, 2.84718717, 2.84718717,
+     . 2.72120556, 2.89757982, 3.09915070, 3.22513231, 3.17473967,
+     . 3.17473967, 3.09915070, 3.32591790, 3.30072128, 5.26603625,
+     . 4.43455700, 4.08180818, 3.70386304, 3.98102289, 3.95582657,
+     . 3.93062995, 3.90543362, 3.80464833, 3.82984466, 3.80464833,
+     . 3.77945201, 3.75425569, 3.75425569, 3.72905937, 3.85504098,
+     . 3.67866672, 3.45189952, 3.30072128, 3.09915070, 2.97316878,
+     . 2.92277614, 2.79679452, 2.82199085, 2.84718717, 3.32591790,
+     . 3.27552496, 3.27552496, 3.42670319, 3.30072128, 3.47709584,
+     . 3.57788113, 5.06446567, 4.56053862, 4.20778980, 3.98102289,
+     . 3.82984466, 3.85504098, 3.88023730, 3.90543362 /
+
+      nb=0
+      nn=min(natoms,2)-1
+
+      do i=1,natoms
+      f=1.0
+      k=0
+ 100  do iat=1,natoms
+         da=.false.
+         do j=1,k
+            if(nb(j,i).eq.iat)da=.true.
+         enddo
+         dx=xyz(1,iat)-xyz(1,i)
+         dy=xyz(2,iat)-xyz(2,i)
+         dz=xyz(3,iat)-xyz(3,i)
+         r2=dx*dx+dy*dy+dz*dz 
+         r=sqrt(r2)
+         dist(iat,i)=r
+         if(iat.ne.i.and.(.not.da))then
+            rco=rad(at(i))+rad(at(iat))
+c critical step            
+            if(r.lt.f*rco.and.k.lt.199)then
+               k=k+1
+               nb(k,i)=iat
+            endif
+         endif
+      enddo
+      if(k.lt.1.and.f.lt.1.5)then
+         f=f*1.1
+         goto 100
+      endif
+      nb(200,i)=k
+      enddo
+
+      end
Index: src/graphs/shortpath.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Stefan Grimme\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nsubroutine fragmentize(nspin,maxsystem,maxmagnat,jab,neigh,ispinsyst,nspinsyst,nsystem)\n  implicit none\n  !Dummy Arguments:\n  integer,intent(in)  :: nspin\n  integer,intent(in)  :: maxsystem\n  integer,intent(in)  :: maxmagnat\n  integer,intent(in)  :: neigh(200,nspin)\n  real*8,intent(in)  :: jab(nspin * (nspin + 1) / 2)\n  integer,intent(out) :: ispinsyst(10 * nspin,maxsystem)\n  integer,intent(out) :: nspinsyst(maxsystem)\n  integer,intent(out) :: nsystem\n\n  !Stack\n  integer:: i\n  integer:: current\n  integer:: ass\n  integer:: k\n  integer:: j\n  integer:: lin\n  integer:: maxdistatoms(2)\n  integer:: max_linkatoms(2)\n  integer:: assigned_to_frag(nspin)\n  integer:: precessor(nspin)\n  real*8:: magdist(nspin,nspin)\n  real*8:: rmaxab(nspin,nspin)\n  real*8:: shortest_distance\n  real*8:: maxdist\n  real*8:: cur_dist\n  real*8:: max_link\n  logical:: visited(nspin)\n  logical:: assigned(nspin,nspin)\n\n  real*8,parameter :: thr_j = 0.001d0\n\n!    write(*,*) nspin, maxsystem, nsystem\n!      write( *, * ) \"Coupling-Matrix\"\n  do i = 1,nspin\n!           write(*,'(16(f6.3,1x))') (abs(jab(lin(j,i))),j=1,nspin)\n  end do ! End Loop over  i from 1 to nspin\n\n  magdist = huge(1.0d0)\n!    write( *, * ) \"inverse couplings\"\n  do i = 1,nspin\n    do j = 1,nspin\n      if (i .eq. j .or. abs(jab(lin(j,i))) .lt. thr_j) cycle\n      !magdist(j,i) = maxab - abs(jab(lin(j,i)))\n      magdist(j,i) = 1 / abs(jab(lin(j,i)))\n    end do\n!        write(*,'(16(f6.3,1x))') (magdist(j,i),j=1,nspin)\n  end do\n\n  rmaxab = 0\n!    write( *, * ) \"shortest distances\"\n  do i = 1,nspin\n    do j = 1,nspin\n      rmaxab(j,i) = shortest_distance(nspin,i,j,neigh,magdist,visited,precessor)\n    end do ! End Loop over  j from 1 to nspin\n!        write(*,'(16(f6.3,1x))') (rmaxab(j,i),j=1,nspin)\n  end do ! End Loop over  i from 1 to nspin\n\n  ispinsyst = 0\n  nspinsyst = 0\n\n  assigned_to_frag = 0\n  nsystem = 0\n  !If spin systems are already separated, keep them:\n  if (maxval(rmaxab,mask=assigned) == huge(1.0d0)) then\n    assigned = .true.\n    do while (maxval(rmaxab,mask=assigned) == huge(1.0d0))\n      nsystem = nsystem + 1\n      maxdistatoms = maxloc(rmaxab,mask=assigned)\n      cur_dist = shortest_distance(nspin,maxdistatoms(1),maxdistatoms(2),neigh,magdist,visited,precessor)\n      nspinsyst(nsystem) = count(visited)\n      ispinsyst(:,nsystem) = 0\n      k = 1\n      do i = 1,nspin\n        if (visited(i) .eqv. .true.) then\n          ispinsyst(k,nsystem) = i\n          assigned(i,:) = .false.\n          k = k + 1\n        end if\n      end do ! End Loop over  i from 1 to count(visited)\n    end do\n  else\n    !else put everything in one big spinsystem\n    nsystem = 1\n    nspinsyst(1) = nspin\n    do i = 1,nspin\n      ispinsyst(i,1) = i\n    end do ! End Loop over  i from 1 to nspin\n  end if\n\n  !Find Sub-Systems with nspinsyst > maxmagnat\n  ass = maxloc(nspinsyst,1)\n  do while (nspinsyst(ass) > maxmagnat)\n\n    !Set Spins in this list as available for algorithm\n    assigned = .false.\n    do i = 1,nspinsyst(ass)\n      do j = 1,nspinsyst(ass)\n        assigned(ispinsyst(i,ass),ispinsyst(j,ass)) = .true.\n      end do ! End Loop over  j from 1 to nspinsyst(ass)\n    end do ! End Loop over  i from 1 to nspin\n\n!               do i = 1, nspin\n!                   write(*,'(16(L3))') (assigned(j,i),j=1,nspin)\n!               end do ! End Loop over  i from 1 to nspin\n!\n!                write( *, * ) \"\"\n!                do i = 1, nspin\n!                    write(*,'(16(f6.3,1x))') (rmaxab(j,i),j=1,nspin)\n!                end do ! End Loop over  i from 1 to nspin\n\n    !Find largest distance:\n    maxdist = maxval(rmaxab,mask=assigned)\n    maxdistatoms = maxloc(rmaxab,mask=assigned)\n    !        write( *, * ) \"maxdistatoms\", maxdistatoms\n\n    !If a Path is found between A and B\n    if (maxdist < huge(1.0d0)) then\n\n      !get shortest Path from A to B\n      cur_dist = shortest_distance(nspin,maxdistatoms(1),maxdistatoms(2),neigh,magdist,visited,precessor)\n      current = maxdistatoms(2)\n\n      !loop while A and B are still connected\n      do while (cur_dist < huge(1.0d0))\n\n        !find weakest link\n        max_link = 0\n        max_linkatoms = 0\n        do while (precessor(current) /= 0)\n          if (magdist(current,precessor(current)) > max_link) then\n            max_link = magdist(current,precessor(current))\n            max_linkatoms(1) = current\n            max_linkatoms(2) = precessor(current)\n          end if\n          current = precessor(current)\n        end do ! End loop: while precessor(current) /= 0\n\n        !Split weakest link, set distance to infinity\n        magdist(max_linkatoms(1),max_linkatoms(2)) = huge(1.0d0)\n        magdist(max_linkatoms(2),max_linkatoms(1)) = huge(1.0d0)\n\n        !Get next-shortest Path:\n        cur_dist = shortest_distance(nspin,maxdistatoms(1),maxdistatoms(2),neigh,magdist,visited,precessor)\n        current = maxdistatoms(2)\n      end do ! cur_dist < huge(1.0d0\n\n      !A and B are now Seperated:\n      rmaxab(maxdistatoms(1),maxdistatoms(2)) = huge(1.0d0)\n      rmaxab(maxdistatoms(2),maxdistatoms(1)) = huge(1.0d0)\n    end if ! End if: while maxdist < huge(1.0d0)\n\n    !Split into subsystems:\n    !Overwrite old spinsystem:\n\n    cur_dist = shortest_distance(nspin,maxdistatoms(1),maxdistatoms(2),neigh,magdist,visited,precessor)\n    nspinsyst(ass) = count(visited)\n    ispinsyst(:,ass) = 0\n    k = 1\n    do i = 1,nspin\n      if (visited(i)) then\n        ispinsyst(k,ass) = i\n        k = k + 1\n      end if\n    end do ! End Loop over  i from 1 to count(visited)\n\n    !add new spinsystem\n    cur_dist = shortest_distance(nspin,maxdistatoms(2),maxdistatoms(1),neigh,magdist,visited,precessor)\n    nsystem = nsystem + 1\n    nspinsyst(nsystem) = count(visited)\n    k = 1\n    do i = 1,nspin\n      if (visited(i)) then\n        ispinsyst(k,nsystem) = i\n        k = k + 1\n      end if\n    end do ! End Loop over  i from 1 to count(visited)\n    ass = maxloc(nspinsyst,1)\n\n    !        write(*,*)'spinsystem    nuclei (after iteration)'\n    !        do i=1,nsystem\n    !            write(*,'(i5,5x,20i4)')i,(ispinsyst(j,i),j=1,nspinsyst(i))\n    !        end do\n  end do ! End loop: while nspinsyst(ass) > maxmagnat\n\n!   rmaxab = 0\n!   write( *, * ) \"Final map\"\n!   do i = 1, nspin\n!       do j = 1, nspin\n!           rmaxab(j,i) = shortest_distance(nspin, i, j, neigh, magdist, visited, precessor)\n!       end do ! End Loop over  j from 1 to nspin\n!       write(*,'(16(f6.3,1x))') (rmaxab(j,i),j=1,nspin)\n!   end do ! End Loop over  i from 1 to nspin\n\nend subroutine fragmentize\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!calculates the shortest path between two atoms\n!start and goal are integers, determining the index in xyz\n!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nreal * 8 function shortest_distance(nspin,start,goal,neighbours,input_distances,visited,precessor)\n  implicit none\n  !Dummy Arguments:\n  integer,intent(in) :: nspin\n  integer,intent(in) :: start\n  integer,intent(in) :: goal\n  integer,intent(in) :: neighbours(200,nspin)\n  real*8,intent(in) :: input_distances(nspin,nspin)\n  logical,intent(out):: visited(nspin)\n  integer,intent(out):: precessor(nspin)\n\n  !Stack:\n  integer:: current\n  integer:: neighbour\n  integer:: i_neighbours\n  real*8:: alt_dist\n  integer:: bonds\n  real*8:: distance(nspin)\n\n  !logical:: visited(nspin)\n\n  bonds = 0\n  precessor = 0\n  distance = huge(distance)\n  distance(start) = 0\n  visited = .false.\n  do while (all(visited) .eqv. .false.) !as long there are unvisited nodes\n    current = minloc(distance,1,.not. visited)\n\n    !Abort if Fragments are not connected:\n    if (distance(current) == huge(distance)) then\n      shortest_distance = huge(distance)\n      return\n    end if ! distance(current) == huge(distance)\n\n    visited(current) = .true.\n    if (current == goal) then\n      shortest_distance = distance(goal)\n      !route to target found\n      do while (precessor(current) /= 0)\n        bonds = bonds + 1\n        current = precessor(current)\n      end do ! End loop: while precessor(current) /= 0\n      exit\n    else\n      !loop over all neighbours of current atom\n      do i_neighbours = 1,neighbours(200,current)\n        neighbour = neighbours(i_neighbours,current)\n        if (visited(neighbour) .eqv. .false.) then\n          !distanzupdate\n          alt_dist = distance(current) + input_distances(current,neighbour)\n          !write( *, * ) alt_dist, distance(current),\n          if ((alt_dist < distance(neighbour))) then\n            distance(neighbour) = alt_dist\n            precessor(neighbour) = current\n          end if ! (alt_dist < distance(neighbour))\n        end if !(visited(neighbour))\n      end do ! End Loop over  i_neighbours from 1 to all_Atoms(current)%n_neighbours\n    end if\n  end do ! End loop: while sum(visited) /= 0\n  !initialize\n  shortest_distance = distance(goal)\nend function shortest_distance\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/graphs/shortpath.f90 b/src/graphs/shortpath.f90
--- a/src/graphs/shortpath.f90	
+++ b/src/graphs/shortpath.f90	
@@ -18,6 +18,7 @@
 !================================================================================!
 
 subroutine fragmentize(nspin,maxsystem,maxmagnat,jab,neigh,ispinsyst,nspinsyst,nsystem)
+  use utilities
   implicit none
   !Dummy Arguments:
   integer,intent(in)  :: nspin
@@ -35,7 +36,6 @@
   integer:: ass
   integer:: k
   integer:: j
-  integer:: lin
   integer:: maxdistatoms(2)
   integer:: max_linkatoms(2)
   integer:: assigned_to_frag(nspin)
Index: config/modules/Findlwoniom.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config/modules/Findlwoniom.cmake b/config/modules/Findlwoniom.cmake
new file mode 100644
--- /dev/null	
+++ b/config/modules/Findlwoniom.cmake	
@@ -0,0 +1,47 @@
+# This file is part of crest.
+# SPDX-Identifier: LGPL-3.0-or-later
+#
+# crest is free software: you can redistribute it and/or modify it under
+# the terms of the GNU Lesser General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# crest is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public License
+# along with crest.  If not, see <https://www.gnu.org/licenses/>.
+
+set(_lib "lwoniom")
+set(_pkg "LWONIOM")
+set(_url "https://github.com/pprcht/lwoniom")
+
+if(NOT DEFINED "${_pkg}_FIND_METHOD")
+  if(DEFINED "${PROJECT_NAME}-dependency-method")
+    set("${_pkg}_FIND_METHOD" "${${PROJECT_NAME}-dependency-method}")
+  else()
+    set("${_pkg}_FIND_METHOD" "cmake" "pkgconf" "subproject" "fetch")
+  endif()
+  set("_${_pkg}_FIND_METHOD")
+endif()
+
+include("${CMAKE_CURRENT_LIST_DIR}/crest-utils.cmake")
+
+crest_find_package("${_lib}" "${${_pkg}_FIND_METHOD}" "${_url}")
+
+if(TARGET "lwoniom::lwoniom")
+  set (found TRUE)
+else()
+  set (found FALSE)
+endif()
+message("-- Found lwONIOM: ${found}")
+
+if(DEFINED "_${_pkg}_FIND_METHOD")
+  unset("${_pkg}_FIND_METHOD")
+  unset("_${_pkg}_FIND_METHOD")
+endif()
+unset(_lib)
+unset(_pkg)
+unset(_url)
Index: src/legacy_algos/confscript2_main.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=========================================================================================!\n! iMTD(RMSD)-GC Algorithm (also Entropy mode and iMTD-sMTD Algo --v4)\n! This is the algo for the conformational search.\n!=========================================================================================!\nsubroutine confscript2i_legacy(env,tim)\n  use iso_fortran_env,only:wp => real64\n  use crest_data\n  use iomod\n  use strucrd,only:coord2xyz,xyz2coord\n  implicit none\n  type(systemdata) :: env\n  type(timer)   :: tim\n  integer :: i,k,m\n  integer :: eit,eit2\n  real(wp) :: ewin\n  integer :: dum,bref\n  character(len=256) :: str,atmp,btmp\n  integer :: nallout\n  logical :: lower\n  logical :: start\n  logical :: ex\n  logical :: stopiter,fail\n\n  real(wp) :: autokcal\n  parameter(autokcal=627.509541d0)\n\n  settingLogs:associate (performMTD => env%performMTD,restartopt => env%restartopt, &\n  &         rotamermds => env%rotamermds,performCross => env%performCross,           &\n  &         doNMR => env%doNMR)\n\n  settingData:associate (nat => env%nat,cgf => env%cgf,thresholds => env%thresholds)\n\n!--- some defaults\n  ewin = env%ewin    !EWIN\n\n!--- prepare the directory\n  if (performMTD) then\n    call V2cleanup(restartopt)\n  end if\n!--- if we only have 2 atoms, do not do anything, except copying the coords\n  if (nat .le. 2) then\n    call catchdiatomic(env)\n    return\n  end if\n\n!---- Get do a single trial MTD to test the settings\n  call md_length_setup(env)  !> sets the MD length according to a flexibility measure\n!---- set number of regular MDs\n  call adjustnormmd(env)\n\n  if (performMTD) then\n    call tim%start(1,'test MD')\n    call trialmd(env)    !calculate a short 1ps test MTD to check settings\n    call tim%stop(1)\n  end if\n\n!---- copy the original coord\n  call copy('coord','coord.original')\n  call coord2xyz('coord','.history.xyz')\n\n!===========================================================================================!\n!===========================================================================================!\n\n  if (env%performMTD) then\n    write (*,*)\n    write (*,*) 'list of Vbias parameters applied:'\n    do m = 1,env%nmetadyn\n      write (*,'(''$metadyn '',f10.5,f8.3,i5)') env%metadfac(m) / env%rednat,env%metadexp(m)\n    end do\n  end if\n\n  env%nreset = 0\n  start = .true.\n  MAINLOOP: do\n    if (env%iterativeV2) then\n      call printiter\n    end if\n    if (.not. start) then\n      call clean_V2i  !--- clean Dir for new iterations\n      env%nreset = env%nreset + 1\n    else !--at the beginning clean existing backup-ensembles\n      call rmrfw('.cre_')\n    end if\n!-------- iterative loop over MTDs\n    mtdloop: do i = 1,env%Maxrestart\n      !---- Small Header\n      write (*,*)\n      write (*,'(''========================================'')')\n      if (env%Maxrestart .gt. 1) then\n        write (*,'(''            MTD Iteration '',i2,13x)') i\n      else\n        write (*,'(''            MTD Simulations '',15x)')\n      end if\n      write (*,'(''========================================'')')\n      !---- do the MTDs\n      call tim%start(2,'MTD')\n      call MetaMD_para_OMP(env)\n      call tim%stop(2)\n\n      MULTILEVELSKIP: if (env%multilevelopt) then\n        !---- Optimize using confopt (parallel)\n        call tim%start(3,'multilevel OPT')\n        write (*,*)\n        write (*,'(''-----------------------'')')\n        write (*,'(''Multilevel Optimization'')')\n        write (*,'(''-----------------------'')')\n        write (*,*)\n        if (env%optlev >= -2.0d0) then\n          call multilevel_opt(env,4)\n        end if\n        call append_INPUT_to('coord','input')   !include the input structure into the last optimization\n        if (.not. env%superquick .and. env%optlev >= 1.0d0) then\n          if (.not. env%entropic) then\n            call multilevel_opt(env,5)\n          else\n            call multilevel_opt(env,99)   !--- the last CREGEN is done within this subroutine\n          end if\n        end if\n        call tim%stop(3)\n        !---- save the CRE under a backup name\n        call checkname_xyz(crefile,atmp,str)\n        call checkname_xyz('.cre',str,btmp)\n        call rename(atmp,btmp)\n        !---- save cregen output\n        call checkname_tmp('cregen',atmp,btmp)\n        call rename('cregen.out.tmp',btmp)\n      else\n        exit mtdloop\n      end if MULTILEVELSKIP\n\n      !---- in the first cycle just save the energy and cycle\n      if (i .eq. 1 .and. start) then\n        !---- clean the dir\n        start = .false.       !--- only in the first cycle of MAINLOOP the MTDs are done at least 2 times\n        if (.not. env%readbias .and. &\n        &   env%runver .ne. 33 .and. &\n        &   env%runver .ne. 787878 ) then\n          dum = env%nmetadyn - 2\n          env%nmetadyn = dum !--- only in the first cycle two MTDs are done additionally with extreme Vbias settings\n        end if\n        call clean_V2i\n        env%eprivious = env%elowest !in the first cycle only save the energy\n        !---- save the new best conformer\n        inquire (file='crest_best.xyz',exist=ex)\n        if (ex) then\n          call XYZappendto('crest_best.xyz','.history.xyz')\n          call xyz2coord('crest_best.xyz','coord')             !new reference coord to start the MTDs with\n        end if\n\n        cycle  !--- always do at least 2 cycles\n      end if\n\n      !---- check elowest\n      call elowcheck(lower,env)\n      if (.not. lower) then\n        exit mtdloop\n      end if\n    end do mtdloop\n\n!--------\n    write (*,'(''========================================'')')\n    if (env%Maxrestart .gt. 1) then\n      write (*,'(''            MTD Iterations done         '')')\n    else\n      write (*,'(''           MTD Simulations done         '')')\n    end if\n    write (*,'(''========================================'')')\n    write (*,'(1x,''Collecting ensembles.'')')\n    call collectcre(env)                      !--- collecting all ensembles saved as \".cre_*.xyz\"\n      if (.not. env%entropic .and. env%crestver .ne. 22) then\n        call newcregen(env,0)\n      else\n        call newcregen(env,2)\n      end if\n    call checkname_xyz(crefile,atmp,btmp)\n    call remaining_in(atmp,ewin,nallout) !--- remaining number of structures\n    write (*,*)\n!====================================================================!\n!---- (Optional) sampling of additional XH positions\n    if (env%doOHflip) then\n      call XHorient(env,conformerfile)\n      inquire (file='oh_ensemble.xyz',exist=ex)\n      if (ex) then\n        call checkname_xyz(crefile,atmp,btmp)\n        call appendto('oh_ensemble.xyz',atmp)\n        call remove('oh_ensemble.xyz')\n        if (.not. env%entropic .and. env%crestver .ne. 22) then\n          call newcregen(env,0)\n        else\n          call newcregen(env,2)\n        end if\n        call remaining_in(btmp,ewin,nallout)\n        write (*,*)\n      end if\n    end if\n!====================================================================!\n!---- Perform additional MDs on the lowest conformers\n    if (env%rotamermds) then\n      call tim%start(4,'MD ')\n      call normalMD_para_OMP(env,env%nrotammds,env%temps)\n      if (env%multilevelopt) then\n        if (env%optlev >= 1.0d0) then\n          call multilevel_opt(env,6)\n        else\n          call multilevel_opt(env,99)\n        end if\n        call elowcheck(lower,env)\n      else\n        lower = .false.\n      end if\n      call tim%stop(4)\n      if (lower) then\n        call checkname_xyz(crefile,atmp,str)\n        call checkname_xyz('.cre',str,btmp)\n        call rename(atmp,btmp)\n        if (env%iterativeV2) cycle MAINLOOP\n      end if\n    end if\n!====================================================================!\n!---- Genetic crossing\n    if (env%performCross) then\n      call tim%start(5,'GC')\n      call cross3(env)\n      call tim%stop(5)\n      call confg_chk3(env)\n      call elowcheck(lower,env)\n      if (lower) then\n        call checkname_xyz(crefile,atmp,str)\n        call checkname_xyz('.cre',str,btmp)\n        call rename(atmp,btmp)\n        if (env%iterativeV2) cycle MAINLOOP\n      end if\n    end if\n!====================================================================!\n!---- Entropy mode iterative statically biased MDs\n    if (env%entropymd) then\n      call mtdatoms(env)\n      call tim%start(6,'static MTD')\n      call emtdcopy(env,0,stopiter,fail)\n      bref = env%emtd%nbias\n\n      ENTROPYITER: do eit = 1,env%emtd%iter\n        dum = nint(float(env%emtd%nbias) * env%emtd%nbiasgrow)\n        !env%emtd%nbias = nint(float(env%emtd%nbias) * env%emtd%nbiasgrow)\n        env%emtd%nbias = max(env%emtd%nbias + 1,dum)\n        fail = .false.\n        EFALLBACK: do k = 1,env%emtd%maxfallback\n          call printiter2(eit)\n          call tim%start(6,'static MTD')\n          call entropyMD_para_OMP(env)\n          call tim%stop(6)\n          call emtdcheckempty(env,fail,env%emtd%nbias)\n          if (fail) then\n            if (k == env%emtd%maxfallback) then\n              stopiter = .true.\n            else\n              cycle EFALLBACK\n            end if\n          else\n            call tim%start(3,'multilevel OPT')\n            if (env%optlev >= -1.0d0) then\n              call multilevel_opt(env,2)\n            end if\n            call multilevel_opt(env,99)\n\n            call tim%stop(3)\n            !--- if in the entropy mode a lower structure was found\n            !    --> cycle, required for extrapolation\n            call elowcheck(lower,env)\n            if (lower .and. env%entropic) then\n              env%emtd%nbias = bref  !IMPORTANT, reset for restart\n              cycle MAINLOOP\n            end if\n            !--- file handling\n            eit2 = eit\n            call emtdcopy(env,eit2,stopiter,fail)\n            env%emtd%iterlast = eit2\n          end if\n          if (.not. lower .and. fail .and. .not. stopiter) then\n            cycle EFALLBACK\n          end if\n          exit EFALLBACK  !fallback loop is exited on first opportuinity\n        end do EFALLBACK\n        if (stopiter) then\n          exit ENTROPYITER\n        end if\n      end do ENTROPYITER\n    end if\n\n!-------\n    exit MAINLOOP !--- if this point is reached, i.e., there weren't any further restarts, exit the loop\n  end do MAINLOOP\n\n!==========================================================================================!\n!==========================================================================================!\n\n  !if(.not.env%entropic .and. .not.(env%crestver == 22))then\n  if (.not. env%entropymd) then\n    !------ last optimization (with user set optlevel)\n    write (*,*)\n    write (*,*)\n    write (*,'(3x,''================================================'')')\n    write (*,'(3x,''|           Final Geometry Optimization        |'')')\n    write (*,'(3x,''================================================'')')\n\n    if (doNMR) cgf(3) = .true.  !--- if NMR equivalencies are requested, turn them on here\n    call tim%start(7,'')\n    call multilevel_opt(env,99) !--- the last CREGEN is done within this subroutine\n    call tim%stop(7)                                 !--- optlevel is userset\n  else\n    !------ or just sort the last ensemble for entropy mode\n    !if(doNMR) cgf(3)=.true.\n    !call confg_chk3(env)\n  end if\n\n!>---- print CREGEN results and clean up Directory a bit\n  if (env%crestver .ne. crest_solv) then\n    call V2terminating()\n  end if\n\n  end associate settingData\n  end associate settingLogs\n\nend subroutine confscript2i_legacy\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/confscript2_main.f90 b/src/legacy_algos/confscript2_main.f90
--- a/src/legacy_algos/confscript2_main.f90	
+++ b/src/legacy_algos/confscript2_main.f90	
@@ -26,6 +26,7 @@
   use crest_data
   use iomod
   use strucrd,only:coord2xyz,xyz2coord
+  use utilities
   implicit none
   type(systemdata) :: env
   type(timer)   :: tim
Index: src/legacy_algos/tautomerize.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nsubroutine tauthead\n      implicit none\n      write(*,*)'       __________________________________________'\n      write(*,*)'      |                                          |'\n      write(*,*)'      |     automated tautomerization script     |'\n      write(*,*)'      |__________________________________________|'\n      write(*,*)' Universitaet Bonn, MCTC'\n      write(*,*)' P.Pracht, Wed 28. Nov 13:11:52 CEST 2018'\n      write(*,*)\n      write(*,*)'Cite as:'\n      write(*,*)'P.Pracht, R.Wilcken, A.Udvarhelyi, S.Rodde, S.Grimme'\n      write(*,*)'JCAMD, 2018, 32, 1139-1149.'\n      write(*,*)\nend subroutine tauthead\n\n!--------------------------------------------------------------------------------------------\n! Tautomerization workflow with GFNn-xTB\n!--------------------------------------------------------------------------------------------\nsubroutine tautomerize(env,tim)\n      use crest_parameters\n      use crest_data\n      use iomod\n      use strucrd, only: coord2xyz\n      implicit none\n      type(systemdata) :: env\n      type(timer)      :: tim\n      type(protobj)    :: taut\n\n      character(len=32)  :: dirn\n      character(len=64)  :: tautname\n      character(len=256) :: thispath\n      character(len=256) :: filename\n      character(len=128) :: inpnam,outnam\n      character(len=128) :: dummy\n\n      integer :: ich,i\n      integer :: natp,nallout,refchrg\n\n      logical :: ex\n\n!--- printout & clean directory\n      call tautclean\n      call tauthead\n\n      if(.not.allocated(env%ptb%atmap))allocate(env%ptb%atmap(env%nat))\n      if(.not.env%ptb%strictPDT .and. .not.env%ptb%fixPDT)then\n!--- sort the input file (H atoms to the bottom)\n        call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)\n      else\n!--- or sort AND apply heavy atom bond constraints\n         call PDT_constraints(env)\n      endif\n\n!--- get some settings\n      call getcwd(thispath)\n      dirn='PROT'\n      tautname='tautomerize_0.xyz'\n      taut=env%ptb\n      natp=env%nat     !backup Nat\n      refchrg=env%chrg\n\n     !-- for the regular mode we have to start with a modified protonation cycle \n     if(.not.taut%deprotprot)then    \n!--- do Protonation\n       write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &\n       & 1,' of ',taut%iter+1\n       call largehead(trim(dummy))\n       call protsmall(env,taut,tim)\n       inquire(file='coordprot.0',exist=ex)\n       if(.not.ex) return\n       call checkname_xyz('tautomerize',inpnam,outnam)\n       call rename('protonated.xyz',outnam)\n!--- do Deprotonation\n       write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &\n       & 1,' of ',taut%iter+1\n       call largehead(trim(dummy))\n       call checkname_xyz('tautomerize',inpnam,outnam)\n       call deprotens(inpnam,env,taut,tim)\n       call rename('deprotonated.xyz',outnam)\n      else\n      !-- for the reversed deprotonation/protonation mode we can use the iteration loop\n      !   below instead, but we have to set up some minor things   \n       call checkname_xyz('tautomerize',inpnam,outnam)\n       call coord2xyz('coord',outnam) !get input in the xyz format\n       taut%iter = taut%iter + 1\n      endif\n\n\n      !taut%ewin=taut%ewin/2.0d0\n!--- further iterations\n      do i=1,taut%iter\n      call tautclean2\n      if(.not.taut%deprotprot)then\n      !--- do Protonation\n        write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &\n        & i+1,' of ',taut%iter+1\n        call largehead(trim(dummy))\n        call checkname_xyz('tautomerize',inpnam,outnam)\n        call protens(inpnam,env,taut,tim)\n        call rename('protonated.xyz',outnam)\n      !--- do Deprotonation\n        write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &\n        & i+1,' of ',taut%iter+1\n        call largehead(trim(dummy))\n\n        call checkname_xyz('tautomerize',inpnam,outnam)\n        call deprotens(inpnam,env,taut,tim)\n        call rename('deprotonated.xyz',outnam)\n      else\n      !--- do Deprotonation\n        write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &\n        & i,' of ',taut%iter\n        call largehead(trim(dummy))\n\n        call checkname_xyz('tautomerize',inpnam,outnam)\n        call deprotens(inpnam,env,taut,tim)\n        call rename('deprotonated.xyz',outnam)\n      !--- do Protonation\n        write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &\n        & i,' of ',taut%iter\n        call largehead(trim(dummy))\n        call checkname_xyz('tautomerize',inpnam,outnam)\n        call protens(inpnam,env,taut,tim)\n        call rename('protonated.xyz',outnam)\n      endif\n      enddo\n \n!--- clean all temporary ensemble files\n      call tautclean2\n\n!--- reverse (Deprotonation - Protonation)\n      !call tautclean\n\n      !call coord2xyz('coord',\"struc_0.xyz\")\n      !call deprotens(\"struc_0.xyz\",env,taut,tim)\n\n!--- reset data for main dir\n     env%chrg=refchrg\n     if(env%chrg .eq. 0) then\n       call remove('.CHRG')\n     else\n       open(newunit=ich,file='.CHRG')\n       write(ich,*) env%chrg\n       close(ich)\n     endif\n     env%nat=natp    !reset Nat\n\n!--- get the new charge and set up the calculations\n     !call printtaut\n     call largehead('T A U T O M E R I Z E')\n     call tim%start(2,'multilevel OPT')\n\n     call smallhead('Final Geometry Optimization')\n     call checkname_xyz('tautomerize',inpnam,outnam)\n     call MDopt_para(env,inpnam,0)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        call sort_ens(taut,outnam,.false.)\n        call remaining_in(outnam,taut%ewin,nallout) !--- remaining number of structures\n\n\n     call cosort(outnam,'tautomers.xyz',.false.,.false.)\n     call sort_ens(taut,'tautomers.xyz',.true.)\n     call tim%stop(2)\n\n\n!>--- (optional) post-processing\n      if(env%relax)then\n        call relaxensemble('tautomers.xyz',env,tim)\n      endif\n\n      if(env%outputsdf)then\n       call new_wrsdfens(env,'tautomers.xyz','tautomers.sdf',.true.)\n      endif\n\n\n\nend subroutine tautomerize\n\n!--------------------------------------------------------------------------------------------\n! small verion of the protonate routine\n!--------------------------------------------------------------------------------------------\nsubroutine protsmall(env,prot,tim)\n      use crest_parameters\n      use iomod\n      use crest_data\n      use strucrd, only: coord2xyz\n      implicit none\n      type(systemdata) :: env\n      type(protobj)    :: prot\n      type(timer)      :: tim\n\n      integer :: ich,natp,nallout\n\n      character(len=64)  :: protname\n      character(len=256) :: thispath\n      character(len=256) :: filename\n      character(len=128) :: inpnam,outnam\n\n      logical :: ex\n      integer :: refchrg\n \n     !call printprotcy\n     \n\n     call getcwd(thispath)\n!--- do the xTB calculation for the LMOs\n      call tim%start(1,'LMO calc.')\n      call xtblmo(env)\n      call tim%stop(1)\n      inquire(file='coordprot.0',exist=ex)\n      if(.not.ex)then\n        write(*,*)\n        write(*,*) '***Warning***'\n        write(*,*) 'No \"coordprot.0\" file was written, it is possible that'\n        write(*,*) 'there are no suitable LP- or π-centers in the molecule.'\n        write(*,*) 'Hence the procedure could not be automatized. (sorry)'\n        write(*,*) '***Warning***'\n        return\n      endif\n\n!--- get the new charge and set up the calculations\n     natp = env%nat + 1\n     prot%newchrg = env%chrg + 1  !increase chrg by one\n     refchrg = env%chrg\n     env%chrg = env%chrg + 1\n\n     protname='protonate_0.xyz'\n     call tim%start(2,'multilevel OPT')\n     open(newunit=ich,file='.CHRG')\n     write(ich,*) prot%newchrg     !new charge written here\n     close(ich)\n     write(*,'(''-----------------------'')')\n     write(*,'(''Multilevel Optimization'')')\n     write(*,'(''-----------------------'')')\n\n     call coord2xyz('coordprot.0',trim(protname))\n     call appendto('xtbscreen.xyz',protname)\n     env%nat=natp\n\n     call smallhead('1. crude pre-optimization')\n     call checkname_xyz('protonate',inpnam,outnam)\n     call MDopt_para(env,protname,1)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        prot%ewin=prot%ewin*2.0d0\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n        write(*,*)\n\n     call smallhead('2. loose optimization')\n     call checkname_xyz('protonate',inpnam,outnam)\n     call MDopt_para(env,inpnam,2)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        prot%ewin=prot%ewin/2.0d0\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n        call cosort(outnam,'protonated.xyz',.false.,.true.)\n\n     call tim%stop(2)    \n     \n     env%nat=natp - 1   !reset Nat\n     env%chrg=refchrg   !reset chrg\n     return\nend subroutine protsmall\n\n!--------------------------------------------------------------------------------------------\n! deprotonate every structure of an ensemble file\n!--------------------------------------------------------------------------------------------\nsubroutine deprotens(ens,env,prot,tim)\n      use crest_parameters\n      use iomod\n      use crest_data\n      use strucrd, only: rdensembleparam,rdensemble,i2e\n      implicit none\n      type(systemdata) :: env\n      type(protobj)    :: prot\n      type(timer)      :: tim\n\n      integer :: ich,nallout\n      integer :: nat,nall\n      integer :: i,j,k,l\n\n      character(len=*)   :: ens\n      character(len=64)  :: protname\n      character(len=256) :: thispath\n      character(len=256) :: filename\n      character(len=128) :: inpnam,outnam\n\n      real(wp),allocatable :: xyz(:,:,:),eread(:)\n      integer,allocatable  :: at(:)\n      integer :: refchrg\n\n      !call printdeprotcy\n\n!--- settings\n     call getcwd(thispath)\n     protname='deprotonate_0.xyz'\n     prot%newchrg=prot%newchrg - 1\n     refchrg = env%chrg\n\n!--- read the file\n     call rdensembleparam(ens,nat,nall)\n     allocate(xyz(3,nat,nall),at(nat),eread(nall))\n     call rdensemble(ens,nat,nall,at,xyz,eread)\n\n     open(newunit=ich,file=protname)\n\n      l=0\n      do k=1,nall\n       do i=1,nat\n         if(at(i).ne.1)cycle\n          write(ich,'(1x,i6)') nat-1\n          write(ich,*)\n         do j=1,nat\n             if(i.eq.j) then\n                 cycle\n             else\n                 write(ich,'(a2,2x,3F16.10)')i2e(at(j),'nc'),xyz(1:3,j,k)\n             endif\n         enddo\n         l=l+1\n       enddo\n      enddo\n\n     close(ich)\n     deallocate(eread,at,xyz)\n     if(l.lt.1)then\n         error stop 'no new structures written in deprotonation setup!'\n     endif\n\n!--- get the new charge and set up the calculations\n     call tim%start(2,'multilevel OPT')\n     open(newunit=ich,file='.CHRG')\n     write(ich,*) prot%newchrg     !new charge written here\n     close(ich)\n     write(*,'(''-----------------------'')')\n     write(*,'(''Multilevel Optimization'')')\n     write(*,'(''-----------------------'')')\n\n!--- update Nat for optimization\n     env%nat=nat-1\n     env%chrg = prot%newchrg\n\n     call smallhead('1. crude pre-optimization')\n     call checkname_xyz('deprotonate',inpnam,outnam)\n     call MDopt_para(env,protname,1)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        prot%ewin=prot%ewin*2.0d0\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n        write(*,*)\n\n     call smallhead('2. loose optimization')\n     call checkname_xyz('deprotonate',inpnam,outnam)\n     call MDopt_para(env,inpnam,2)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        prot%ewin=prot%ewin/2.0d0\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n        call cosort(outnam,'deprotonated.xyz',.false.,.true.)\n\n     call tim%stop(2)\n\n!--- reset Nat\n      env%nat = nat\n      env%chrg = refchrg\n\nend subroutine deprotens\n\n!--------------------------------------------------------------------------------------------\n! protonate routine to be used on an ensemble (quite lengthy and a lot of bookkeeping)\n!--------------------------------------------------------------------------------------------\nsubroutine protens(ens,env,prot,tim)\n      use crest_parameters\n      use iomod\n      use crest_data\n      use strucrd, only: coord2xyz,wrc0,rdensembleparam,rdensemble\n      implicit none\n      type(systemdata) :: env\n      type(protobj)    :: prot\n      type(timer)      :: tim\n\n      integer :: ich,natp,nallout\n      integer :: nat,nall\n      integer :: i,k,r\n      integer :: vz,io,refchrg\n\n      real(wp) :: percent\n\n      character(len=*)   :: ens\n      character(len=32)  :: dirn\n      character(len=256) :: thispath,tmppath\n      character(len=256) :: filename\n      character(len=128) :: inpnam,outnam\n      character(len=512) :: jobcall\n      character(len=52) :: bar\n\n      logical :: niceprint\n\n      real(wp),allocatable :: xyz(:,:,:),eread(:)\n      integer,allocatable  :: at(:)\n\n      !call printprotcy\n\n!--- some settings \n      call getcwd(thispath)\n      dirn='PROT'\n      niceprint=env%niceprint\n      refchrg = env%chrg\n\n\n      r = makedir(trim(dirn))      \n\n!--- read the file\n     call rdensembleparam(ens,nat,nall)\n     allocate(xyz(3,nat,nall),at(nat),eread(nall))\n     call rdensemble(ens,nat,nall,at,xyz,eread)\n     xyz=xyz/bohr  !--- Ang to bohr\n     natp=nat+1\n\n!--- change dir\n      call chdir(trim(dirn))\n      call getcwd(tmppath)\n!--- make new dirs\n      do i=1,nall  \n         write(filename,'(a,i0)')trim(dirn),i\n         r = makedir(trim(filename))\n         call chdir(trim(filename))\n         call wrc0('coord',nat,at,xyz(:,:,i))\n         open(newunit=ich,file='.CHRG')\n          write(ich,*) prot%newchrg           !--- not yet updated; for LMO calculation\n         close(ich)\n         call chdir(tmppath)\n      enddo\n      deallocate(eread,at,xyz)\n\n!--- thread stuff\n      if(env%autothreads)then\n          call ompautoset(env%threads,7,env%omp,env%MAXRUN,nall) !set the global OMP/MKL variables for the xtb jobs\n      endif\n\n!--- creating the job\n      write(jobcall,'(a,1x,a,1x,a,'' --sp --lmo '',a,1x,a,a)') &\n      &     trim(env%ProgName),'coord',trim(env%gfnver),trim(env%solv),' > xtb.out 2>/dev/null'\n\n\n!--- calculation loop for LMOs\n      call tim%start(1,'LMO calc.')\n      write(*,'(a,a,a)')'Calculating LMOs for all structures in file <',trim(ens),'>'\n   \n      k=0 !counting the finished jobs\n      if(niceprint)then\n        call printemptybar()\n      endif\n!$omp parallel &\n!$omp shared( vz,jobcall,nall,dirn,percent,k,niceprint,bar )\n!$omp single\n      do i=1,nall\n         vz=i\n      !$omp task firstprivate( vz ) private( filename,io )\n         call initsignal()\n         write(filename,'(a,i0)')trim(dirn),vz\n         call command('cd '//trim(filename)//' && '//trim(jobcall), io)\n      !$omp critical\n        k=k+1\n        if(niceprint)then\n          percent=float(k)/float(nall)*100.0d0\n          call  progbar(percent,bar)\n          call printprogbar(percent,bar)\n        else\n          write(6,'(1x,i0)',advance='no')k\n          flush(6)\n        endif\n      !$omp end critical\n      !$omp end task\n      enddo\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n       !--- this is a test for BASF\n       if(env%threads > 8)then\n         call sleep(5)\n       endif\n       write(*,*)\n       write(*,'(a)',advance='no') 'Collecting generated protomers ...'\n       jobcall=trim(tmppath)//'/'//'protomers.xyz'\n       do i=1,nall\n          write(filename,'(a,i0)')trim(dirn),i\n          call chdir(trim(filename))\n          call coord2xyz('coordprot.0','struc_0.xyz')\n          call appendto('struc_0.xyz',jobcall)\n          call appendto('xtbscreen.xyz',jobcall)\n          call chdir(tmppath)\n       enddo\n       write(*,*) 'done.'\n       call tim%stop(1)\n\n!--- clean up the sub-dirs\n       call rmrfw('PROT')\n\n!--- optimize\n     call tim%start(2,'multilevel OPT')\n     prot%newchrg=prot%newchrg + 1\n     open(newunit=ich,file='.CHRG')\n     write(ich,*) prot%newchrg     !new charge written here\n     close(ich)\n     write(*,*)\n     write(*,'(''-----------------------'')')\n     write(*,'(''Multilevel Optimization'')')\n     write(*,'(''-----------------------'')')\n\n!--- update nat\n     env%nat=nat+1\n     env%chrg = prot%newchrg\n\n     call smallhead('1. crude pre-optimization')\n     call checkname_xyz('protonate',inpnam,outnam)\n     call MDopt_para(env,'protomers.xyz',1)\n        filename=trim(tmppath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        prot%ewin=prot%ewin*2.0d0\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n        write(*,*)\n\n     call smallhead('2. loose optimization')\n     call checkname_xyz('protonate',inpnam,outnam)\n     call MDopt_para(env,inpnam,2)\n        filename=trim(tmppath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        prot%ewin=prot%ewin/2.0d0\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n        call cosort(outnam,'protonated.xyz',.false.,.true.)\n\n     call tim%stop(2)\n\n!--- reset Nat\n      env%nat=nat\n      env%chrg = refchrg\n\n!--- change back to original dir and copy the file with optimized protomers\n     call chdir(thispath)\n     write(jobcall,'(a,a,a)')trim(tmppath),'/','protonated.xyz'\n     call rename(trim(jobcall),'protonated.xyz')\n     call rmrf(dirn)\n     return\nend subroutine protens\n\n\n\n!==============================================================================!\n! build the blacklist to decide which atoms are valid deprotonation candidates\n!==============================================================================!\nsubroutine tautomerize_blacklist(env,fname,nat,atlist)\n     use crest_parameters\n     use iomod\n     use crest_data\n     use strucrd, only : rdcoord\n     implicit none\n     type(systemdata) :: env\n     integer :: nat\n     character(len=*) :: atlist\n     integer,allocatable :: unconstrained(:)\n     character(len=*) :: fname\n     integer :: ncon,i,j,k\n     integer,allocatable :: at(:)\n     real(wp),allocatable :: xyz(:,:)\n     real(wp),allocatable :: dist(:,:)\n\n     write(*,'(1x,a,a)') 'Input list of atoms: ',trim(atlist)\n\n     allocate(unconstrained(nat))\n     call parse_atlist(atlist,ncon,nat,unconstrained) !\"unconstrained\" contains all the selected atoms\n\n     if(ncon .lt. 1)then\n         deallocate(unconstrained)\n         return\n     endif\n\n     if(.not.allocated(env%ptb%blacklist))then\n         allocate(env%ptb%blacklist(nat))\n         env%ptb%blacklist = .false. !none of the atoms is initially blacklisted\n     endif    \n\n     allocate(xyz(3,nat),dist(nat,nat))\n     call rdcoord(fname,nat,at,xyz)\n\n     !setup distmat\n     do i=1,nat\n       dist(i,i) = 9999.9_wp\n       do j=1,i-1\n          dist(i,j) = (xyz(1,i)-xyz(1,j))**2 + &\n         &            (xyz(2,i)-xyz(2,j))**2 + &\n         &            (xyz(3,i)-xyz(3,j))**2  \n          dist(i,j) = sqrt(dist(i,j))\n          dist(j,i) = dist(i,j)\n       enddo\n     enddo\n\n     !loop over the atoms and decide which to blacklist\n     do i=1,nat\n       if(unconstrained(i) == 1)then\n           if(at(i) == 1)then\n              k = minloc(dist(i,:),1) \n              env%ptb%blacklist(k) = .true.\n           else\n              env%ptb%blacklist(i) = .true.\n           endif\n       endif\n     enddo\n\n     deallocate(dist,xyz,unconstrained)\n     return\nend subroutine tautomerize_blacklist\n\n!========================================================!\n! check if the input atom order is kompatible with\n! the tautomerization tools, i.e., if all hydrogen\n! atoms are at the bottom of the list.\n!========================================================!\nfunction taut_check_atomorder(n,at) result(bool)\n    implicit none\n    integer :: n\n    integer :: at(n)\n    logical :: bool\n    integer :: i\n    bool = .true.\n    do i=2,n\n       if( at(i-1)==1 )then\n           if( at(i) .ne. 1)then  \n             bool=.false.\n             exit\n           endif    \n       endif    \n    enddo\n    return\nend function taut_check_atomorder\n\n!============================================================================================!\n! Tautomerization workflow with GFNn-xTB (*extended version)\n!============================================================================================!\nsubroutine tautomerize_ext(ensemb,env,tim)\n      use crest_parameters\n      use crest_data\n      use iomod\n      use strucrd\n      implicit none\n      character(len=*) :: ensemb\n      type(systemdata) :: env\n      type(timer)      :: tim\n      type(protobj)    :: taut\n\n      character(len=32)  :: dirn\n      character(len=64)  :: tautname\n      character(len=256) :: thispath\n      character(len=256) :: filename\n      character(len=128) :: inpnam,outnam\n      character(len=128) :: dummy,atmp\n      character(len=:),allocatable :: btmp\n\n      type(ensemble) :: efile\n      integer,allocatable :: slist(:)\n      integer :: smax,s,sc\n      real(wp),allocatable :: c0(:,:)\n\n      integer :: ich,i,io\n      integer :: natp,nallout,refchrg\n      integer,allocatable :: atmaps(:,:)\n      logical :: ex\n      \n\n!--- printout & clean directory\n      call tautclean\n      call tauthead\n\n!--- get some settings\n      call getcwd(thispath)\n      dirn='PROT'\n      tautname='tautomerize_0.xyz'\n      taut=env%ptb\n      natp=env%nat     !backup Nat\n      refchrg=env%chrg\n\n!--- read the given ensemble\n      call efile%open(ensemb)\n      allocate(c0(3,efile%nat))\n      env%rednat=efile%nat\n      env%nat=efile%nat\n      \n      if(taut%alldivers)then\n         smax=efile%nall \n         allocate(slist(smax))\n         do i=1,smax\n            slist(i) = i\n         enddo\n      else\n         smax = taut%divers\n         allocate(slist(smax))\n         !ANALYZE DIVERSITY AND SELECT STRUCTURES\n         do i=1,smax   !<-- temporary workaround\n            slist(i) = i\n         enddo\n      endif         \n      allocate(atmaps(smax,natp))\n\n!---------------------------      \n      SLOOP : do s=1,smax\n!---------------------------\n        sc=slist(s) !sc is the current structure\n        write(atmp,'(a,i0)') 'TP',sc\n        btmp=trim(atmp)\n        io = makedir(btmp)\n\n        call chdir(btmp)\n        c0(:,:) = efile%xyz(:,:,sc)/bohr\n        !---  write .CHRG and .UHF files\n        env%chrg=refchrg\n        if(env%chrg.ne.0)then\n          open(newunit=ich,file='.CHRG')\n          write(ich,*)env%chrg\n          close(ich)\n        endif\n        if(env%uhf.ne.0)then\n          open(newunit=ich,file='.UHF')\n          write(ich,*)env%uhf\n          close(ich)\n        endif\n        call wrc0('coord',efile%nat,efile%at,c0)\n\n\n\n!--- sort the input file (H atoms to the bottom)\n      call htothebottom('coord',env%chrg,natp,atmaps(s,1:natp))\n \n     !-- for the regular mode we have to start with a modified protonation cycle \n     if(.not.taut%deprotprot)then    \n!--- do Protonation\n       write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &\n       & 1,' of ',taut%iter+1\n       call largehead(trim(dummy))\n       call protsmall(env,taut,tim)\n       inquire(file='coordprot.0',exist=ex)\n       if(.not.ex) return\n       call checkname_xyz('tautomerize',inpnam,outnam)\n       call rename('protonated.xyz',outnam)\n!--- do Deprotonation\n       write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &\n       & 1,' of ',taut%iter+1\n       call largehead(trim(dummy))\n       call checkname_xyz('tautomerize',inpnam,outnam)\n       call deprotens(inpnam,env,taut,tim)\n       call rename('deprotonated.xyz',outnam)\n!--- Relax structures by performing a small conformational search\n       env%nat = natp\n       call relaxensemble(outnam,env,tim)\n       call rename('relax.'//outnam,outnam)\n      else\n      !-- for the reversed deprotonation/protonation mode we can use the iteration loop\n      !   below instead, but we have to set up some minor things   \n       call checkname_xyz('tautomerize',inpnam,outnam)\n       call coord2xyz('coord',outnam) !get input in the xyz format\n       taut%iter = taut%iter + 1\n      endif\n\n\n      !taut%ewin=taut%ewin/2.0d0\n!--- further iterations\n      do i=1,taut%iter\n      call tautclean2\n      if(.not.taut%deprotprot)then\n      !--- do Protonation\n        write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &\n        & i+1,' of ',taut%iter+1\n        call largehead(trim(dummy))\n        call checkname_xyz('tautomerize',inpnam,outnam)\n        call protens(inpnam,env,taut,tim)\n        call rename('protonated.xyz',outnam)\n      !--- do Deprotonation\n        write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &\n        & i+1,' of ',taut%iter+1\n        call largehead(trim(dummy))\n\n        call checkname_xyz('tautomerize',inpnam,outnam)\n        call deprotens(inpnam,env,taut,tim)\n        call rename('deprotonated.xyz',outnam)\n      else\n      !--- do Deprotonation\n        write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &\n        & i,' of ',taut%iter\n        call largehead(trim(dummy))\n\n        call checkname_xyz('tautomerize',inpnam,outnam)\n        call deprotens(inpnam,env,taut,tim)\n        call rename('deprotonated.xyz',outnam)\n      !--- do Protonation\n        write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &\n        & i,' of ',taut%iter\n        call largehead(trim(dummy))\n        call checkname_xyz('tautomerize',inpnam,outnam)\n        call protens(inpnam,env,taut,tim)\n        call rename('protonated.xyz',outnam)\n      endif\n!--- relax structures after each cycle\n        env%nat = natp\n        call relaxensemble(outnam,env,tim)\n        call rename('relax.'//outnam,outnam)\n      enddo\n\n!--- clean all temporary ensemble files\n      call tautclean2\n\n      call chdir(thispath)\n\n      btmp=trim(btmp)//'/'//trim(outnam)\n      call appendto(btmp,'collected.xyz')\n!-------------------------\n      enddo SLOOP\n!-------------------------      \n!      return\n\n\n!--- reset data for main dir\n     env%chrg=refchrg\n     if(env%chrg .eq. 0) then\n       call remove('.CHRG')\n     else\n       open(newunit=ich,file='.CHRG')\n       write(ich,*) env%chrg\n       close(ich)\n     endif\n     env%nat=natp    !reset Nat\n\n!--- get the new charge and set up the calculations\n     !call printtaut\n     call largehead('T A U T O M E R I Z E')\n     call tim%start(2,'multilevel OPT')\n\n     call smallhead('Final Geometry Optimization')\n     call checkname_xyz('tautomerize',inpnam,outnam)\n\n     call rename('collected.xyz',inpnam)\n\n     call MDopt_para(env,inpnam,0)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        call sort_ens(taut,outnam,.false.)\n        call remaining_in(outnam,taut%ewin,nallout) !--- remaining number of structures\n\n     call cosort(outnam,'tautomers.xyz',.false.,.false.)\n     call sort_ens(taut,'tautomers.xyz',.true.)\n     call tim%stop(2)\n\nend subroutine tautomerize_ext\n\n!--------------------------------------------------------------------------------------------!\n! first sort file and then \n! check if strict mode is active to define bond constraints (only for the heavy atoms)\n!--------------------------------------------------------------------------------------------!\nsubroutine PDT_constraints(env)\n      use crest_parameters\n      use crest_data\n      use iomod\n      use zdata\n      implicit none\n      type(systemdata) :: env\n      type(zmolecule) :: zmol\n   !-- a default for the force constant (quite strong already)\n\n      logical,parameter :: vverbose = .false.\n      integer :: i,h,nh\n\n   !-- sort all H atoms to the end of the file    \n      call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)\n\n   !-- decide between atom fixing and bond constraints\n      if(env%ptb%strictPDT .or. env%ptb%fixPDT)then   \n\n      !-- if -for some reason- there is a constraint already specified, remove it\n         if(env%cts%used)then\n           call env%cts%deallocate()\n         endif     \n\n         env%cts%used=.true.\n   !-- if heavy-atom bond constraints shall be specified\n      if(.not.env%ptb%fixPDT)then\n\n         write(*,*) 'Strict mode active. Heavy atom bond constraints will be applied.'\n         write(*,'(1x,a,f8.4,a)') 'Selected force constant:',env%forceconst,' Eh'\n\n      !-- analyse sorted coord and write bondlength constraint \n         call autoHeavyConstraint('coord',env%forceconst)\n\n      !-- read (only) the bondlength file as constraint\n         call read_constrainbuffer('bondlengths',env%cts)\n\n         if(vverbose)then\n             write(*,*) 'The following bonds are affected:'\n             do i=1,env%cts%ndim\n             if(trim(env%cts%sett(i)).ne.'')then\n                 write(*,'(''>'',1x,a)') trim(env%cts%sett(i))\n             endif\n             enddo\n         endif\n\n     !--- otherwise do exact atom fixing (of heavy atoms only)    \n      else \n        write(*,*) 'Very strict mode active. Heavy atom positions will be constrained.'\n        write(*,'(1x,a,f8.4,a)') 'Selected force constant:',env%forceconst,' Eh'\n\n        call simpletopo_file('coord',zmol,.false.,.false.,'')\n        h = zmol%hydrogen() !-- count hydrogen\n        nh = zmol%nat - h\n        call fix_first_X_atoms(nh,env%forceconst,'fixpositions')\n        if(env%ptb%strictPDT)then\n        call getbmat(zmol,3,env%forceconst)\n        call appendto('bondlengths','fixpositions')\n        endif\n        call zmol%deallocate()\n\n        call read_constrainbuffer('fixpositions',env%cts)\n      endif\n      endif\n\n      return\nend subroutine PDT_constraints\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/tautomerize.f90 b/src/legacy_algos/tautomerize.f90
--- a/src/legacy_algos/tautomerize.f90	
+++ b/src/legacy_algos/tautomerize.f90	
@@ -18,380 +18,377 @@
 !================================================================================!
 
 subroutine tauthead
-      implicit none
-      write(*,*)'       __________________________________________'
-      write(*,*)'      |                                          |'
-      write(*,*)'      |     automated tautomerization script     |'
-      write(*,*)'      |__________________________________________|'
-      write(*,*)' Universitaet Bonn, MCTC'
-      write(*,*)' P.Pracht, Wed 28. Nov 13:11:52 CEST 2018'
-      write(*,*)
-      write(*,*)'Cite as:'
-      write(*,*)'P.Pracht, R.Wilcken, A.Udvarhelyi, S.Rodde, S.Grimme'
-      write(*,*)'JCAMD, 2018, 32, 1139-1149.'
-      write(*,*)
+  implicit none
+  write (*,*) '       __________________________________________'
+  write (*,*) '      |                                          |'
+  write (*,*) '      |     automated tautomerization script     |'
+  write (*,*) '      |__________________________________________|'
+  write (*,*) ' Universitaet Bonn, MCTC'
+  write (*,*) ' P.Pracht, Wed 28. Nov 13:11:52 CEST 2018'
+  write (*,*)
+  write (*,*) 'Cite as:'
+  write (*,*) 'P.Pracht, R.Wilcken, A.Udvarhelyi, S.Rodde, S.Grimme'
+  write (*,*) 'JCAMD, 2018, 32, 1139-1149.'
+  write (*,*)
 end subroutine tauthead
 
 !--------------------------------------------------------------------------------------------
 ! Tautomerization workflow with GFNn-xTB
 !--------------------------------------------------------------------------------------------
 subroutine tautomerize(env,tim)
-      use crest_parameters
-      use crest_data
-      use iomod
-      use strucrd, only: coord2xyz
-      implicit none
-      type(systemdata) :: env
-      type(timer)      :: tim
-      type(protobj)    :: taut
+  use crest_parameters
+  use crest_data
+  use iomod
+  use strucrd,only:coord2xyz
+  use utilities
+  implicit none
+  type(systemdata) :: env
+  type(timer)      :: tim
+  type(protobj)    :: taut
 
-      character(len=32)  :: dirn
-      character(len=64)  :: tautname
-      character(len=256) :: thispath
-      character(len=256) :: filename
-      character(len=128) :: inpnam,outnam
-      character(len=128) :: dummy
+  character(len=32)  :: dirn
+  character(len=64)  :: tautname
+  character(len=256) :: thispath
+  character(len=256) :: filename
+  character(len=128) :: inpnam,outnam
+  character(len=128) :: dummy
 
-      integer :: ich,i
-      integer :: natp,nallout,refchrg
+  integer :: ich,i
+  integer :: natp,nallout,refchrg
 
-      logical :: ex
+  logical :: ex
 
 !--- printout & clean directory
-      call tautclean
-      call tauthead
+  call tautclean
+  call tauthead
 
-      if(.not.allocated(env%ptb%atmap))allocate(env%ptb%atmap(env%nat))
-      if(.not.env%ptb%strictPDT .and. .not.env%ptb%fixPDT)then
+  if (.not.allocated(env%ptb%atmap)) allocate (env%ptb%atmap(env%nat))
+  if (.not.env%ptb%strictPDT.and..not.env%ptb%fixPDT) then
 !--- sort the input file (H atoms to the bottom)
-        call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)
-      else
+    call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)
+  else
 !--- or sort AND apply heavy atom bond constraints
-         call PDT_constraints(env)
-      endif
+    call PDT_constraints(env)
+  end if
 
 !--- get some settings
-      call getcwd(thispath)
-      dirn='PROT'
-      tautname='tautomerize_0.xyz'
-      taut=env%ptb
-      natp=env%nat     !backup Nat
-      refchrg=env%chrg
+  call getcwd(thispath)
+  dirn = 'PROT'
+  tautname = 'tautomerize_0.xyz'
+  taut = env%ptb
+  natp = env%nat     !backup Nat
+  refchrg = env%chrg
 
-     !-- for the regular mode we have to start with a modified protonation cycle 
-     if(.not.taut%deprotprot)then    
+  !-- for the regular mode we have to start with a modified protonation cycle
+  if (.not.taut%deprotprot) then
 !--- do Protonation
-       write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &
-       & 1,' of ',taut%iter+1
-       call largehead(trim(dummy))
-       call protsmall(env,taut,tim)
-       inquire(file='coordprot.0',exist=ex)
-       if(.not.ex) return
-       call checkname_xyz('tautomerize',inpnam,outnam)
-       call rename('protonated.xyz',outnam)
+    write (dummy,'(a,i0,a,i0)') 'P R O T O N A T I O N   C Y C L E     ', &
+    & 1,' of ',taut%iter+1
+    call largehead(trim(dummy))
+    call protsmall(env,taut,tim)
+    inquire (file='coordprot.0',exist=ex)
+    if (.not.ex) return
+    call checkname_xyz('tautomerize',inpnam,outnam)
+    call rename('protonated.xyz',outnam)
 !--- do Deprotonation
-       write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &
-       & 1,' of ',taut%iter+1
-       call largehead(trim(dummy))
-       call checkname_xyz('tautomerize',inpnam,outnam)
-       call deprotens(inpnam,env,taut,tim)
-       call rename('deprotonated.xyz',outnam)
-      else
-      !-- for the reversed deprotonation/protonation mode we can use the iteration loop
-      !   below instead, but we have to set up some minor things   
-       call checkname_xyz('tautomerize',inpnam,outnam)
-       call coord2xyz('coord',outnam) !get input in the xyz format
-       taut%iter = taut%iter + 1
-      endif
+    write (dummy,'(a,i0,a,i0)') 'D E P R O T O N A T I O N   C Y C L E     ', &
+    & 1,' of ',taut%iter+1
+    call largehead(trim(dummy))
+    call checkname_xyz('tautomerize',inpnam,outnam)
+    call deprotens(inpnam,env,taut,tim)
+    call rename('deprotonated.xyz',outnam)
+  else
+    !-- for the reversed deprotonation/protonation mode we can use the iteration loop
+    !   below instead, but we have to set up some minor things
+    call checkname_xyz('tautomerize',inpnam,outnam)
+    call coord2xyz('coord',outnam) !get input in the xyz format
+    taut%iter = taut%iter+1
+  end if
 
-
-      !taut%ewin=taut%ewin/2.0d0
+  !taut%ewin=taut%ewin/2.0d0
 !--- further iterations
-      do i=1,taut%iter
-      call tautclean2
-      if(.not.taut%deprotprot)then
+  do i = 1,taut%iter
+    call tautclean2
+    if (.not.taut%deprotprot) then
       !--- do Protonation
-        write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &
-        & i+1,' of ',taut%iter+1
-        call largehead(trim(dummy))
-        call checkname_xyz('tautomerize',inpnam,outnam)
-        call protens(inpnam,env,taut,tim)
-        call rename('protonated.xyz',outnam)
+      write (dummy,'(a,i0,a,i0)') 'P R O T O N A T I O N   C Y C L E     ', &
+      & i+1,' of ',taut%iter+1
+      call largehead(trim(dummy))
+      call checkname_xyz('tautomerize',inpnam,outnam)
+      call protens(inpnam,env,taut,tim)
+      call rename('protonated.xyz',outnam)
       !--- do Deprotonation
-        write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &
-        & i+1,' of ',taut%iter+1
-        call largehead(trim(dummy))
+      write (dummy,'(a,i0,a,i0)') 'D E P R O T O N A T I O N   C Y C L E     ', &
+      & i+1,' of ',taut%iter+1
+      call largehead(trim(dummy))
 
-        call checkname_xyz('tautomerize',inpnam,outnam)
-        call deprotens(inpnam,env,taut,tim)
-        call rename('deprotonated.xyz',outnam)
-      else
+      call checkname_xyz('tautomerize',inpnam,outnam)
+      call deprotens(inpnam,env,taut,tim)
+      call rename('deprotonated.xyz',outnam)
+    else
       !--- do Deprotonation
-        write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &
-        & i,' of ',taut%iter
-        call largehead(trim(dummy))
+      write (dummy,'(a,i0,a,i0)') 'D E P R O T O N A T I O N   C Y C L E     ', &
+      & i,' of ',taut%iter
+      call largehead(trim(dummy))
 
-        call checkname_xyz('tautomerize',inpnam,outnam)
-        call deprotens(inpnam,env,taut,tim)
-        call rename('deprotonated.xyz',outnam)
+      call checkname_xyz('tautomerize',inpnam,outnam)
+      call deprotens(inpnam,env,taut,tim)
+      call rename('deprotonated.xyz',outnam)
       !--- do Protonation
-        write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &
-        & i,' of ',taut%iter
-        call largehead(trim(dummy))
-        call checkname_xyz('tautomerize',inpnam,outnam)
-        call protens(inpnam,env,taut,tim)
-        call rename('protonated.xyz',outnam)
-      endif
-      enddo
- 
+      write (dummy,'(a,i0,a,i0)') 'P R O T O N A T I O N   C Y C L E     ', &
+      & i,' of ',taut%iter
+      call largehead(trim(dummy))
+      call checkname_xyz('tautomerize',inpnam,outnam)
+      call protens(inpnam,env,taut,tim)
+      call rename('protonated.xyz',outnam)
+    end if
+  end do
+
 !--- clean all temporary ensemble files
-      call tautclean2
+  call tautclean2
 
 !--- reverse (Deprotonation - Protonation)
-      !call tautclean
+  !call tautclean
 
-      !call coord2xyz('coord',"struc_0.xyz")
-      !call deprotens("struc_0.xyz",env,taut,tim)
+  !call coord2xyz('coord',"struc_0.xyz")
+  !call deprotens("struc_0.xyz",env,taut,tim)
 
 !--- reset data for main dir
-     env%chrg=refchrg
-     if(env%chrg .eq. 0) then
-       call remove('.CHRG')
-     else
-       open(newunit=ich,file='.CHRG')
-       write(ich,*) env%chrg
-       close(ich)
-     endif
-     env%nat=natp    !reset Nat
+  env%chrg = refchrg
+  if (env%chrg .eq. 0) then
+    call remove('.CHRG')
+  else
+    open (newunit=ich,file='.CHRG')
+    write (ich,*) env%chrg
+    close (ich)
+  end if
+  env%nat = natp    !reset Nat
 
 !--- get the new charge and set up the calculations
-     !call printtaut
-     call largehead('T A U T O M E R I Z E')
-     call tim%start(2,'multilevel OPT')
+  !call printtaut
+  call largehead('T A U T O M E R I Z E')
+  call tim%start(2,'multilevel OPT')
 
-     call smallhead('Final Geometry Optimization')
-     call checkname_xyz('tautomerize',inpnam,outnam)
-     call MDopt_para(env,inpnam,0)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        call sort_ens(taut,outnam,.false.)
-        call remaining_in(outnam,taut%ewin,nallout) !--- remaining number of structures
+  call smallhead('Final Geometry Optimization')
+  call checkname_xyz('tautomerize',inpnam,outnam)
+  call MDopt_para(env,inpnam,0)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  call sort_ens(taut,outnam,.false.)
+  call remaining_in(outnam,taut%ewin,nallout) !--- remaining number of structures
 
-
-     call cosort(outnam,'tautomers.xyz',.false.,.false.)
-     call sort_ens(taut,'tautomers.xyz',.true.)
-     call tim%stop(2)
+  call cosort(outnam,'tautomers.xyz',.false.,.false.)
+  call sort_ens(taut,'tautomers.xyz',.true.)
+  call tim%stop(2)
 
-
 !>--- (optional) post-processing
-      if(env%relax)then
-        call relaxensemble('tautomers.xyz',env,tim)
-      endif
+  if (env%relax) then
+    call relaxensemble('tautomers.xyz',env,tim)
+  end if
 
-      if(env%outputsdf)then
-       call new_wrsdfens(env,'tautomers.xyz','tautomers.sdf',.true.)
-      endif
+  if (env%outputsdf) then
+    call new_wrsdfens(env,'tautomers.xyz','tautomers.sdf',.true.)
+  end if
 
-
-
 end subroutine tautomerize
 
 !--------------------------------------------------------------------------------------------
 ! small verion of the protonate routine
 !--------------------------------------------------------------------------------------------
 subroutine protsmall(env,prot,tim)
-      use crest_parameters
-      use iomod
-      use crest_data
-      use strucrd, only: coord2xyz
-      implicit none
-      type(systemdata) :: env
-      type(protobj)    :: prot
-      type(timer)      :: tim
+  use crest_parameters
+  use iomod
+  use crest_data
+  use strucrd,only:coord2xyz
+  use utilities
+  implicit none
+  type(systemdata) :: env
+  type(protobj)    :: prot
+  type(timer)      :: tim
 
-      integer :: ich,natp,nallout
+  integer :: ich,natp,nallout
 
-      character(len=64)  :: protname
-      character(len=256) :: thispath
-      character(len=256) :: filename
-      character(len=128) :: inpnam,outnam
+  character(len=64)  :: protname
+  character(len=256) :: thispath
+  character(len=256) :: filename
+  character(len=128) :: inpnam,outnam
 
-      logical :: ex
-      integer :: refchrg
- 
-     !call printprotcy
-     
+  logical :: ex
+  integer :: refchrg
+
+  !call printprotcy
 
-     call getcwd(thispath)
+  call getcwd(thispath)
 !--- do the xTB calculation for the LMOs
-      call tim%start(1,'LMO calc.')
-      call xtblmo(env)
-      call tim%stop(1)
-      inquire(file='coordprot.0',exist=ex)
-      if(.not.ex)then
-        write(*,*)
-        write(*,*) '***Warning***'
-        write(*,*) 'No "coordprot.0" file was written, it is possible that'
-        write(*,*) 'there are no suitable LP- or π-centers in the molecule.'
-        write(*,*) 'Hence the procedure could not be automatized. (sorry)'
-        write(*,*) '***Warning***'
-        return
-      endif
+  call tim%start(1,'LMO calc.')
+  call xtblmo(env)
+  call tim%stop(1)
+  inquire (file='coordprot.0',exist=ex)
+  if (.not.ex) then
+    write (*,*)
+    write (*,*) '***Warning***'
+    write (*,*) 'No "coordprot.0" file was written, it is possible that'
+    write (*,*) 'there are no suitable LP- or π-centers in the molecule.'
+    write (*,*) 'Hence the procedure could not be automatized. (sorry)'
+    write (*,*) '***Warning***'
+    return
+  end if
 
 !--- get the new charge and set up the calculations
-     natp = env%nat + 1
-     prot%newchrg = env%chrg + 1  !increase chrg by one
-     refchrg = env%chrg
-     env%chrg = env%chrg + 1
+  natp = env%nat+1
+  prot%newchrg = env%chrg+1  !increase chrg by one
+  refchrg = env%chrg
+  env%chrg = env%chrg+1
 
-     protname='protonate_0.xyz'
-     call tim%start(2,'multilevel OPT')
-     open(newunit=ich,file='.CHRG')
-     write(ich,*) prot%newchrg     !new charge written here
-     close(ich)
-     write(*,'(''-----------------------'')')
-     write(*,'(''Multilevel Optimization'')')
-     write(*,'(''-----------------------'')')
+  protname = 'protonate_0.xyz'
+  call tim%start(2,'multilevel OPT')
+  open (newunit=ich,file='.CHRG')
+  write (ich,*) prot%newchrg     !new charge written here
+  close (ich)
+  write (*,'(''-----------------------'')')
+  write (*,'(''Multilevel Optimization'')')
+  write (*,'(''-----------------------'')')
 
-     call coord2xyz('coordprot.0',trim(protname))
-     call appendto('xtbscreen.xyz',protname)
-     env%nat=natp
+  call coord2xyz('coordprot.0',trim(protname))
+  call appendto('xtbscreen.xyz',protname)
+  env%nat = natp
 
-     call smallhead('1. crude pre-optimization')
-     call checkname_xyz('protonate',inpnam,outnam)
-     call MDopt_para(env,protname,1)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        prot%ewin=prot%ewin*2.0d0
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
-        write(*,*)
+  call smallhead('1. crude pre-optimization')
+  call checkname_xyz('protonate',inpnam,outnam)
+  call MDopt_para(env,protname,1)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  prot%ewin = prot%ewin*2.0d0
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  write (*,*)
 
-     call smallhead('2. loose optimization')
-     call checkname_xyz('protonate',inpnam,outnam)
-     call MDopt_para(env,inpnam,2)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        prot%ewin=prot%ewin/2.0d0
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
-        call cosort(outnam,'protonated.xyz',.false.,.true.)
+  call smallhead('2. loose optimization')
+  call checkname_xyz('protonate',inpnam,outnam)
+  call MDopt_para(env,inpnam,2)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  prot%ewin = prot%ewin/2.0d0
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  call cosort(outnam,'protonated.xyz',.false.,.true.)
 
-     call tim%stop(2)    
-     
-     env%nat=natp - 1   !reset Nat
-     env%chrg=refchrg   !reset chrg
-     return
+  call tim%stop(2)
+
+  env%nat = natp-1   !reset Nat
+  env%chrg = refchrg   !reset chrg
+  return
 end subroutine protsmall
 
 !--------------------------------------------------------------------------------------------
 ! deprotonate every structure of an ensemble file
 !--------------------------------------------------------------------------------------------
 subroutine deprotens(ens,env,prot,tim)
-      use crest_parameters
-      use iomod
-      use crest_data
-      use strucrd, only: rdensembleparam,rdensemble,i2e
-      implicit none
-      type(systemdata) :: env
-      type(protobj)    :: prot
-      type(timer)      :: tim
+  use crest_parameters
+  use iomod
+  use crest_data
+  use strucrd,only:rdensembleparam,rdensemble,i2e
+  use utilities
+  implicit none
+  type(systemdata) :: env
+  type(protobj)    :: prot
+  type(timer)      :: tim
 
-      integer :: ich,nallout
-      integer :: nat,nall
-      integer :: i,j,k,l
+  integer :: ich,nallout
+  integer :: nat,nall
+  integer :: i,j,k,l
 
-      character(len=*)   :: ens
-      character(len=64)  :: protname
-      character(len=256) :: thispath
-      character(len=256) :: filename
-      character(len=128) :: inpnam,outnam
+  character(len=*)   :: ens
+  character(len=64)  :: protname
+  character(len=256) :: thispath
+  character(len=256) :: filename
+  character(len=128) :: inpnam,outnam
 
-      real(wp),allocatable :: xyz(:,:,:),eread(:)
-      integer,allocatable  :: at(:)
-      integer :: refchrg
+  real(wp),allocatable :: xyz(:,:,:),eread(:)
+  integer,allocatable  :: at(:)
+  integer :: refchrg
 
-      !call printdeprotcy
+  !call printdeprotcy
 
 !--- settings
-     call getcwd(thispath)
-     protname='deprotonate_0.xyz'
-     prot%newchrg=prot%newchrg - 1
-     refchrg = env%chrg
+  call getcwd(thispath)
+  protname = 'deprotonate_0.xyz'
+  prot%newchrg = prot%newchrg-1
+  refchrg = env%chrg
 
 !--- read the file
-     call rdensembleparam(ens,nat,nall)
-     allocate(xyz(3,nat,nall),at(nat),eread(nall))
-     call rdensemble(ens,nat,nall,at,xyz,eread)
+  call rdensembleparam(ens,nat,nall)
+  allocate (xyz(3,nat,nall),at(nat),eread(nall))
+  call rdensemble(ens,nat,nall,at,xyz,eread)
 
-     open(newunit=ich,file=protname)
+  open (newunit=ich,file=protname)
 
-      l=0
-      do k=1,nall
-       do i=1,nat
-         if(at(i).ne.1)cycle
-          write(ich,'(1x,i6)') nat-1
-          write(ich,*)
-         do j=1,nat
-             if(i.eq.j) then
-                 cycle
-             else
-                 write(ich,'(a2,2x,3F16.10)')i2e(at(j),'nc'),xyz(1:3,j,k)
-             endif
-         enddo
-         l=l+1
-       enddo
-      enddo
+  l = 0
+  do k = 1,nall
+    do i = 1,nat
+      if (at(i) .ne. 1) cycle
+      write (ich,'(1x,i6)') nat-1
+      write (ich,*)
+      do j = 1,nat
+        if (i .eq. j) then
+          cycle
+        else
+          write (ich,'(a2,2x,3F16.10)') i2e(at(j),'nc'),xyz(1:3,j,k)
+        end if
+      end do
+      l = l+1
+    end do
+  end do
 
-     close(ich)
-     deallocate(eread,at,xyz)
-     if(l.lt.1)then
-         error stop 'no new structures written in deprotonation setup!'
-     endif
+  close (ich)
+  deallocate (eread,at,xyz)
+  if (l .lt. 1) then
+    error stop 'no new structures written in deprotonation setup!'
+  end if
 
 !--- get the new charge and set up the calculations
-     call tim%start(2,'multilevel OPT')
-     open(newunit=ich,file='.CHRG')
-     write(ich,*) prot%newchrg     !new charge written here
-     close(ich)
-     write(*,'(''-----------------------'')')
-     write(*,'(''Multilevel Optimization'')')
-     write(*,'(''-----------------------'')')
+  call tim%start(2,'multilevel OPT')
+  open (newunit=ich,file='.CHRG')
+  write (ich,*) prot%newchrg     !new charge written here
+  close (ich)
+  write (*,'(''-----------------------'')')
+  write (*,'(''Multilevel Optimization'')')
+  write (*,'(''-----------------------'')')
 
 !--- update Nat for optimization
-     env%nat=nat-1
-     env%chrg = prot%newchrg
+  env%nat = nat-1
+  env%chrg = prot%newchrg
 
-     call smallhead('1. crude pre-optimization')
-     call checkname_xyz('deprotonate',inpnam,outnam)
-     call MDopt_para(env,protname,1)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        prot%ewin=prot%ewin*2.0d0
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
-        write(*,*)
+  call smallhead('1. crude pre-optimization')
+  call checkname_xyz('deprotonate',inpnam,outnam)
+  call MDopt_para(env,protname,1)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  prot%ewin = prot%ewin*2.0d0
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  write (*,*)
 
-     call smallhead('2. loose optimization')
-     call checkname_xyz('deprotonate',inpnam,outnam)
-     call MDopt_para(env,inpnam,2)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        prot%ewin=prot%ewin/2.0d0
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
-        call cosort(outnam,'deprotonated.xyz',.false.,.true.)
+  call smallhead('2. loose optimization')
+  call checkname_xyz('deprotonate',inpnam,outnam)
+  call MDopt_para(env,inpnam,2)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  prot%ewin = prot%ewin/2.0d0
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  call cosort(outnam,'deprotonated.xyz',.false.,.true.)
 
-     call tim%stop(2)
+  call tim%stop(2)
 
 !--- reset Nat
-      env%nat = nat
-      env%chrg = refchrg
+  env%nat = nat
+  env%chrg = refchrg
 
 end subroutine deprotens
 
@@ -399,249 +396,247 @@
 ! protonate routine to be used on an ensemble (quite lengthy and a lot of bookkeeping)
 !--------------------------------------------------------------------------------------------
 subroutine protens(ens,env,prot,tim)
-      use crest_parameters
-      use iomod
-      use crest_data
-      use strucrd, only: coord2xyz,wrc0,rdensembleparam,rdensemble
-      implicit none
-      type(systemdata) :: env
-      type(protobj)    :: prot
-      type(timer)      :: tim
+  use crest_parameters
+  use iomod
+  use crest_data
+  use strucrd,only:coord2xyz,wrc0,rdensembleparam,rdensemble
+  use utilities
+  implicit none
+  type(systemdata) :: env
+  type(protobj)    :: prot
+  type(timer)      :: tim
 
-      integer :: ich,natp,nallout
-      integer :: nat,nall
-      integer :: i,k,r
-      integer :: vz,io,refchrg
+  integer :: ich,natp,nallout
+  integer :: nat,nall
+  integer :: i,k,r
+  integer :: vz,io,refchrg
 
-      real(wp) :: percent
+  real(wp) :: percent
 
-      character(len=*)   :: ens
-      character(len=32)  :: dirn
-      character(len=256) :: thispath,tmppath
-      character(len=256) :: filename
-      character(len=128) :: inpnam,outnam
-      character(len=512) :: jobcall
-      character(len=52) :: bar
+  character(len=*)   :: ens
+  character(len=32)  :: dirn
+  character(len=256) :: thispath,tmppath
+  character(len=256) :: filename
+  character(len=128) :: inpnam,outnam
+  character(len=512) :: jobcall
+  character(len=52) :: bar
 
-      logical :: niceprint
+  logical :: niceprint
 
-      real(wp),allocatable :: xyz(:,:,:),eread(:)
-      integer,allocatable  :: at(:)
+  real(wp),allocatable :: xyz(:,:,:),eread(:)
+  integer,allocatable  :: at(:)
 
-      !call printprotcy
+  !call printprotcy
 
-!--- some settings 
-      call getcwd(thispath)
-      dirn='PROT'
-      niceprint=env%niceprint
-      refchrg = env%chrg
+!--- some settings
+  call getcwd(thispath)
+  dirn = 'PROT'
+  niceprint = env%niceprint
+  refchrg = env%chrg
 
-
-      r = makedir(trim(dirn))      
+  r = makedir(trim(dirn))
 
 !--- read the file
-     call rdensembleparam(ens,nat,nall)
-     allocate(xyz(3,nat,nall),at(nat),eread(nall))
-     call rdensemble(ens,nat,nall,at,xyz,eread)
-     xyz=xyz/bohr  !--- Ang to bohr
-     natp=nat+1
+  call rdensembleparam(ens,nat,nall)
+  allocate (xyz(3,nat,nall),at(nat),eread(nall))
+  call rdensemble(ens,nat,nall,at,xyz,eread)
+  xyz = xyz/bohr  !--- Ang to bohr
+  natp = nat+1
 
 !--- change dir
-      call chdir(trim(dirn))
-      call getcwd(tmppath)
+  call chdir(trim(dirn))
+  call getcwd(tmppath)
 !--- make new dirs
-      do i=1,nall  
-         write(filename,'(a,i0)')trim(dirn),i
-         r = makedir(trim(filename))
-         call chdir(trim(filename))
-         call wrc0('coord',nat,at,xyz(:,:,i))
-         open(newunit=ich,file='.CHRG')
-          write(ich,*) prot%newchrg           !--- not yet updated; for LMO calculation
-         close(ich)
-         call chdir(tmppath)
-      enddo
-      deallocate(eread,at,xyz)
+  do i = 1,nall
+    write (filename,'(a,i0)') trim(dirn),i
+    r = makedir(trim(filename))
+    call chdir(trim(filename))
+    call wrc0('coord',nat,at,xyz(:,:,i))
+    open (newunit=ich,file='.CHRG')
+    write (ich,*) prot%newchrg           !--- not yet updated; for LMO calculation
+    close (ich)
+    call chdir(tmppath)
+  end do
+  deallocate (eread,at,xyz)
 
 !--- thread stuff
-      if(env%autothreads)then
-          call ompautoset(env%threads,7,env%omp,env%MAXRUN,nall) !set the global OMP/MKL variables for the xtb jobs
-      endif
+  if (env%autothreads) then
+    call ompautoset(env%threads,7,env%omp,env%MAXRUN,nall) !set the global OMP/MKL variables for the xtb jobs
+  end if
 
 !--- creating the job
-      write(jobcall,'(a,1x,a,1x,a,'' --sp --lmo '',a,1x,a,a)') &
-      &     trim(env%ProgName),'coord',trim(env%gfnver),trim(env%solv),' > xtb.out 2>/dev/null'
+  write (jobcall,'(a,1x,a,1x,a,'' --sp --lmo '',a,1x,a,a)') &
+  &     trim(env%ProgName),'coord',trim(env%gfnver),trim(env%solv),' > xtb.out 2>/dev/null'
 
-
 !--- calculation loop for LMOs
-      call tim%start(1,'LMO calc.')
-      write(*,'(a,a,a)')'Calculating LMOs for all structures in file <',trim(ens),'>'
-   
-      k=0 !counting the finished jobs
-      if(niceprint)then
-        call printemptybar()
-      endif
+  call tim%start(1,'LMO calc.')
+  write (*,'(a,a,a)') 'Calculating LMOs for all structures in file <',trim(ens),'>'
+
+  k = 0 !counting the finished jobs
+  if (niceprint) then
+    call printemptybar()
+  end if
 !$omp parallel &
 !$omp shared( vz,jobcall,nall,dirn,percent,k,niceprint,bar )
 !$omp single
-      do i=1,nall
-         vz=i
-      !$omp task firstprivate( vz ) private( filename,io )
-         call initsignal()
-         write(filename,'(a,i0)')trim(dirn),vz
-         call command('cd '//trim(filename)//' && '//trim(jobcall), io)
-      !$omp critical
-        k=k+1
-        if(niceprint)then
-          percent=float(k)/float(nall)*100.0d0
-          call  progbar(percent,bar)
-          call printprogbar(percent,bar)
-        else
-          write(6,'(1x,i0)',advance='no')k
-          flush(6)
-        endif
-      !$omp end critical
-      !$omp end task
-      enddo
+  do i = 1,nall
+    vz = i
+    !$omp task firstprivate( vz ) private( filename,io )
+    call initsignal()
+    write (filename,'(a,i0)') trim(dirn),vz
+    call command('cd '//trim(filename)//' && '//trim(jobcall),io)
+    !$omp critical
+    k = k+1
+    if (niceprint) then
+      percent = float(k)/float(nall)*100.0d0
+      call progbar(percent,bar)
+      call printprogbar(percent,bar)
+    else
+      write (6,'(1x,i0)',advance='no') k
+      flush (6)
+    end if
+    !$omp end critical
+    !$omp end task
+  end do
 !$omp taskwait
 !$omp end single
 !$omp end parallel
-       !--- this is a test for BASF
-       if(env%threads > 8)then
-         call sleep(5)
-       endif
-       write(*,*)
-       write(*,'(a)',advance='no') 'Collecting generated protomers ...'
-       jobcall=trim(tmppath)//'/'//'protomers.xyz'
-       do i=1,nall
-          write(filename,'(a,i0)')trim(dirn),i
-          call chdir(trim(filename))
-          call coord2xyz('coordprot.0','struc_0.xyz')
-          call appendto('struc_0.xyz',jobcall)
-          call appendto('xtbscreen.xyz',jobcall)
-          call chdir(tmppath)
-       enddo
-       write(*,*) 'done.'
-       call tim%stop(1)
+  !--- this is a test for BASF
+  if (env%threads > 8) then
+    call sleep(5)
+  end if
+  write (*,*)
+  write (*,'(a)',advance='no') 'Collecting generated protomers ...'
+  jobcall = trim(tmppath)//'/'//'protomers.xyz'
+  do i = 1,nall
+    write (filename,'(a,i0)') trim(dirn),i
+    call chdir(trim(filename))
+    call coord2xyz('coordprot.0','struc_0.xyz')
+    call appendto('struc_0.xyz',jobcall)
+    call appendto('xtbscreen.xyz',jobcall)
+    call chdir(tmppath)
+  end do
+  write (*,*) 'done.'
+  call tim%stop(1)
 
 !--- clean up the sub-dirs
-       call rmrfw('PROT')
+  call rmrfw('PROT')
 
 !--- optimize
-     call tim%start(2,'multilevel OPT')
-     prot%newchrg=prot%newchrg + 1
-     open(newunit=ich,file='.CHRG')
-     write(ich,*) prot%newchrg     !new charge written here
-     close(ich)
-     write(*,*)
-     write(*,'(''-----------------------'')')
-     write(*,'(''Multilevel Optimization'')')
-     write(*,'(''-----------------------'')')
+  call tim%start(2,'multilevel OPT')
+  prot%newchrg = prot%newchrg+1
+  open (newunit=ich,file='.CHRG')
+  write (ich,*) prot%newchrg     !new charge written here
+  close (ich)
+  write (*,*)
+  write (*,'(''-----------------------'')')
+  write (*,'(''Multilevel Optimization'')')
+  write (*,'(''-----------------------'')')
 
 !--- update nat
-     env%nat=nat+1
-     env%chrg = prot%newchrg
+  env%nat = nat+1
+  env%chrg = prot%newchrg
 
-     call smallhead('1. crude pre-optimization')
-     call checkname_xyz('protonate',inpnam,outnam)
-     call MDopt_para(env,'protomers.xyz',1)
-        filename=trim(tmppath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        prot%ewin=prot%ewin*2.0d0
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
-        write(*,*)
+  call smallhead('1. crude pre-optimization')
+  call checkname_xyz('protonate',inpnam,outnam)
+  call MDopt_para(env,'protomers.xyz',1)
+  filename = trim(tmppath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  prot%ewin = prot%ewin*2.0d0
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  write (*,*)
 
-     call smallhead('2. loose optimization')
-     call checkname_xyz('protonate',inpnam,outnam)
-     call MDopt_para(env,inpnam,2)
-        filename=trim(tmppath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        prot%ewin=prot%ewin/2.0d0
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
-        call cosort(outnam,'protonated.xyz',.false.,.true.)
+  call smallhead('2. loose optimization')
+  call checkname_xyz('protonate',inpnam,outnam)
+  call MDopt_para(env,inpnam,2)
+  filename = trim(tmppath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  prot%ewin = prot%ewin/2.0d0
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  call cosort(outnam,'protonated.xyz',.false.,.true.)
 
-     call tim%stop(2)
+  call tim%stop(2)
 
 !--- reset Nat
-      env%nat=nat
-      env%chrg = refchrg
+  env%nat = nat
+  env%chrg = refchrg
 
 !--- change back to original dir and copy the file with optimized protomers
-     call chdir(thispath)
-     write(jobcall,'(a,a,a)')trim(tmppath),'/','protonated.xyz'
-     call rename(trim(jobcall),'protonated.xyz')
-     call rmrf(dirn)
-     return
+  call chdir(thispath)
+  write (jobcall,'(a,a,a)') trim(tmppath),'/','protonated.xyz'
+  call rename(trim(jobcall),'protonated.xyz')
+  call rmrf(dirn)
+  return
 end subroutine protens
 
-
-
 !==============================================================================!
 ! build the blacklist to decide which atoms are valid deprotonation candidates
 !==============================================================================!
 subroutine tautomerize_blacklist(env,fname,nat,atlist)
-     use crest_parameters
-     use iomod
-     use crest_data
-     use strucrd, only : rdcoord
-     implicit none
-     type(systemdata) :: env
-     integer :: nat
-     character(len=*) :: atlist
-     integer,allocatable :: unconstrained(:)
-     character(len=*) :: fname
-     integer :: ncon,i,j,k
-     integer,allocatable :: at(:)
-     real(wp),allocatable :: xyz(:,:)
-     real(wp),allocatable :: dist(:,:)
+  use crest_parameters
+  use iomod
+  use crest_data
+  use strucrd,only:rdcoord
+  use utilities
+  implicit none
+  type(systemdata) :: env
+  integer :: nat
+  character(len=*) :: atlist
+  integer,allocatable :: unconstrained(:)
+  character(len=*) :: fname
+  integer :: ncon,i,j,k
+  integer,allocatable :: at(:)
+  real(wp),allocatable :: xyz(:,:)
+  real(wp),allocatable :: dist(:,:)
 
-     write(*,'(1x,a,a)') 'Input list of atoms: ',trim(atlist)
+  write (*,'(1x,a,a)') 'Input list of atoms: ',trim(atlist)
 
-     allocate(unconstrained(nat))
-     call parse_atlist(atlist,ncon,nat,unconstrained) !"unconstrained" contains all the selected atoms
+  allocate (unconstrained(nat))
+  call parse_atlist(atlist,ncon,nat,unconstrained) !"unconstrained" contains all the selected atoms
 
-     if(ncon .lt. 1)then
-         deallocate(unconstrained)
-         return
-     endif
+  if (ncon .lt. 1) then
+    deallocate (unconstrained)
+    return
+  end if
 
-     if(.not.allocated(env%ptb%blacklist))then
-         allocate(env%ptb%blacklist(nat))
-         env%ptb%blacklist = .false. !none of the atoms is initially blacklisted
-     endif    
+  if (.not.allocated(env%ptb%blacklist)) then
+    allocate (env%ptb%blacklist(nat))
+    env%ptb%blacklist = .false. !none of the atoms is initially blacklisted
+  end if
 
-     allocate(xyz(3,nat),dist(nat,nat))
-     call rdcoord(fname,nat,at,xyz)
+  allocate (xyz(3,nat),dist(nat,nat))
+  call rdcoord(fname,nat,at,xyz)
 
-     !setup distmat
-     do i=1,nat
-       dist(i,i) = 9999.9_wp
-       do j=1,i-1
-          dist(i,j) = (xyz(1,i)-xyz(1,j))**2 + &
-         &            (xyz(2,i)-xyz(2,j))**2 + &
-         &            (xyz(3,i)-xyz(3,j))**2  
-          dist(i,j) = sqrt(dist(i,j))
-          dist(j,i) = dist(i,j)
-       enddo
-     enddo
+  !setup distmat
+  do i = 1,nat
+    dist(i,i) = 9999.9_wp
+    do j = 1,i-1
+      dist(i,j) = (xyz(1,i)-xyz(1,j))**2+ &
+     &            (xyz(2,i)-xyz(2,j))**2+ &
+     &            (xyz(3,i)-xyz(3,j))**2
+      dist(i,j) = sqrt(dist(i,j))
+      dist(j,i) = dist(i,j)
+    end do
+  end do
 
-     !loop over the atoms and decide which to blacklist
-     do i=1,nat
-       if(unconstrained(i) == 1)then
-           if(at(i) == 1)then
-              k = minloc(dist(i,:),1) 
-              env%ptb%blacklist(k) = .true.
-           else
-              env%ptb%blacklist(i) = .true.
-           endif
-       endif
-     enddo
+  !loop over the atoms and decide which to blacklist
+  do i = 1,nat
+    if (unconstrained(i) == 1) then
+      if (at(i) == 1) then
+        k = minloc(dist(i,:),1)
+        env%ptb%blacklist(k) = .true.
+      else
+        env%ptb%blacklist(i) = .true.
+      end if
+    end if
+  end do
 
-     deallocate(dist,xyz,unconstrained)
-     return
+  deallocate (dist,xyz,unconstrained)
+  return
 end subroutine tautomerize_blacklist
 
 !========================================================!
@@ -650,164 +645,161 @@
 ! atoms are at the bottom of the list.
 !========================================================!
 function taut_check_atomorder(n,at) result(bool)
-    implicit none
-    integer :: n
-    integer :: at(n)
-    logical :: bool
-    integer :: i
-    bool = .true.
-    do i=2,n
-       if( at(i-1)==1 )then
-           if( at(i) .ne. 1)then  
-             bool=.false.
-             exit
-           endif    
-       endif    
-    enddo
-    return
+  implicit none
+  integer :: n
+  integer :: at(n)
+  logical :: bool
+  integer :: i
+  bool = .true.
+  do i = 2,n
+    if (at(i-1) == 1) then
+      if (at(i) .ne. 1) then
+        bool = .false.
+        exit
+      end if
+    end if
+  end do
+  return
 end function taut_check_atomorder
 
 !============================================================================================!
 ! Tautomerization workflow with GFNn-xTB (*extended version)
 !============================================================================================!
 subroutine tautomerize_ext(ensemb,env,tim)
-      use crest_parameters
-      use crest_data
-      use iomod
-      use strucrd
-      implicit none
-      character(len=*) :: ensemb
-      type(systemdata) :: env
-      type(timer)      :: tim
-      type(protobj)    :: taut
+  use crest_parameters
+  use crest_data
+  use iomod
+  use strucrd
+  use utilities
+  implicit none
+  character(len=*) :: ensemb
+  type(systemdata) :: env
+  type(timer)      :: tim
+  type(protobj)    :: taut
 
-      character(len=32)  :: dirn
-      character(len=64)  :: tautname
-      character(len=256) :: thispath
-      character(len=256) :: filename
-      character(len=128) :: inpnam,outnam
-      character(len=128) :: dummy,atmp
-      character(len=:),allocatable :: btmp
+  character(len=32)  :: dirn
+  character(len=64)  :: tautname
+  character(len=256) :: thispath
+  character(len=256) :: filename
+  character(len=128) :: inpnam,outnam
+  character(len=128) :: dummy,atmp
+  character(len=:),allocatable :: btmp
 
-      type(ensemble) :: efile
-      integer,allocatable :: slist(:)
-      integer :: smax,s,sc
-      real(wp),allocatable :: c0(:,:)
+  type(ensemble) :: efile
+  integer,allocatable :: slist(:)
+  integer :: smax,s,sc
+  real(wp),allocatable :: c0(:,:)
 
-      integer :: ich,i,io
-      integer :: natp,nallout,refchrg
-      integer,allocatable :: atmaps(:,:)
-      logical :: ex
-      
+  integer :: ich,i,io
+  integer :: natp,nallout,refchrg
+  integer,allocatable :: atmaps(:,:)
+  logical :: ex
 
 !--- printout & clean directory
-      call tautclean
-      call tauthead
+  call tautclean
+  call tauthead
 
 !--- get some settings
-      call getcwd(thispath)
-      dirn='PROT'
-      tautname='tautomerize_0.xyz'
-      taut=env%ptb
-      natp=env%nat     !backup Nat
-      refchrg=env%chrg
+  call getcwd(thispath)
+  dirn = 'PROT'
+  tautname = 'tautomerize_0.xyz'
+  taut = env%ptb
+  natp = env%nat     !backup Nat
+  refchrg = env%chrg
 
 !--- read the given ensemble
-      call efile%open(ensemb)
-      allocate(c0(3,efile%nat))
-      env%rednat=efile%nat
-      env%nat=efile%nat
-      
-      if(taut%alldivers)then
-         smax=efile%nall 
-         allocate(slist(smax))
-         do i=1,smax
-            slist(i) = i
-         enddo
-      else
-         smax = taut%divers
-         allocate(slist(smax))
-         !ANALYZE DIVERSITY AND SELECT STRUCTURES
-         do i=1,smax   !<-- temporary workaround
-            slist(i) = i
-         enddo
-      endif         
-      allocate(atmaps(smax,natp))
+  call efile%open(ensemb)
+  allocate (c0(3,efile%nat))
+  env%rednat = efile%nat
+  env%nat = efile%nat
+
+  if (taut%alldivers) then
+    smax = efile%nall
+    allocate (slist(smax))
+    do i = 1,smax
+      slist(i) = i
+    end do
+  else
+    smax = taut%divers
+    allocate (slist(smax))
+    !ANALYZE DIVERSITY AND SELECT STRUCTURES
+    do i = 1,smax   !<-- temporary workaround
+      slist(i) = i
+    end do
+  end if
+  allocate (atmaps(smax,natp))
 
-!---------------------------      
-      SLOOP : do s=1,smax
+!---------------------------
+  SLOOP: do s = 1,smax
 !---------------------------
-        sc=slist(s) !sc is the current structure
-        write(atmp,'(a,i0)') 'TP',sc
-        btmp=trim(atmp)
-        io = makedir(btmp)
+    sc = slist(s) !sc is the current structure
+    write (atmp,'(a,i0)') 'TP',sc
+    btmp = trim(atmp)
+    io = makedir(btmp)
 
-        call chdir(btmp)
-        c0(:,:) = efile%xyz(:,:,sc)/bohr
-        !---  write .CHRG and .UHF files
-        env%chrg=refchrg
-        if(env%chrg.ne.0)then
-          open(newunit=ich,file='.CHRG')
-          write(ich,*)env%chrg
-          close(ich)
-        endif
-        if(env%uhf.ne.0)then
-          open(newunit=ich,file='.UHF')
-          write(ich,*)env%uhf
-          close(ich)
-        endif
-        call wrc0('coord',efile%nat,efile%at,c0)
+    call chdir(btmp)
+    c0(:,:) = efile%xyz(:,:,sc)/bohr
+    !---  write .CHRG and .UHF files
+    env%chrg = refchrg
+    if (env%chrg .ne. 0) then
+      open (newunit=ich,file='.CHRG')
+      write (ich,*) env%chrg
+      close (ich)
+    end if
+    if (env%uhf .ne. 0) then
+      open (newunit=ich,file='.UHF')
+      write (ich,*) env%uhf
+      close (ich)
+    end if
+    call wrc0('coord',efile%nat,efile%at,c0)
 
-
-
 !--- sort the input file (H atoms to the bottom)
-      call htothebottom('coord',env%chrg,natp,atmaps(s,1:natp))
- 
-     !-- for the regular mode we have to start with a modified protonation cycle 
-     if(.not.taut%deprotprot)then    
+    call htothebottom('coord',env%chrg,natp,atmaps(s,1:natp))
+
+    !-- for the regular mode we have to start with a modified protonation cycle
+    if (.not.taut%deprotprot) then
 !--- do Protonation
-       write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &
-       & 1,' of ',taut%iter+1
-       call largehead(trim(dummy))
-       call protsmall(env,taut,tim)
-       inquire(file='coordprot.0',exist=ex)
-       if(.not.ex) return
-       call checkname_xyz('tautomerize',inpnam,outnam)
-       call rename('protonated.xyz',outnam)
+      write (dummy,'(a,i0,a,i0)') 'P R O T O N A T I O N   C Y C L E     ', &
+      & 1,' of ',taut%iter+1
+      call largehead(trim(dummy))
+      call protsmall(env,taut,tim)
+      inquire (file='coordprot.0',exist=ex)
+      if (.not.ex) return
+      call checkname_xyz('tautomerize',inpnam,outnam)
+      call rename('protonated.xyz',outnam)
 !--- do Deprotonation
-       write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &
-       & 1,' of ',taut%iter+1
-       call largehead(trim(dummy))
-       call checkname_xyz('tautomerize',inpnam,outnam)
-       call deprotens(inpnam,env,taut,tim)
-       call rename('deprotonated.xyz',outnam)
+      write (dummy,'(a,i0,a,i0)') 'D E P R O T O N A T I O N   C Y C L E     ', &
+      & 1,' of ',taut%iter+1
+      call largehead(trim(dummy))
+      call checkname_xyz('tautomerize',inpnam,outnam)
+      call deprotens(inpnam,env,taut,tim)
+      call rename('deprotonated.xyz',outnam)
 !--- Relax structures by performing a small conformational search
-       env%nat = natp
-       call relaxensemble(outnam,env,tim)
-       call rename('relax.'//outnam,outnam)
-      else
+      env%nat = natp
+      call relaxensemble(outnam,env,tim)
+      call rename('relax.'//outnam,outnam)
+    else
       !-- for the reversed deprotonation/protonation mode we can use the iteration loop
-      !   below instead, but we have to set up some minor things   
-       call checkname_xyz('tautomerize',inpnam,outnam)
-       call coord2xyz('coord',outnam) !get input in the xyz format
-       taut%iter = taut%iter + 1
-      endif
+      !   below instead, but we have to set up some minor things
+      call checkname_xyz('tautomerize',inpnam,outnam)
+      call coord2xyz('coord',outnam) !get input in the xyz format
+      taut%iter = taut%iter+1
+    end if
 
-
-      !taut%ewin=taut%ewin/2.0d0
+    !taut%ewin=taut%ewin/2.0d0
 !--- further iterations
-      do i=1,taut%iter
+    do i = 1,taut%iter
       call tautclean2
-      if(.not.taut%deprotprot)then
-      !--- do Protonation
-        write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &
+      if (.not.taut%deprotprot) then
+        !--- do Protonation
+        write (dummy,'(a,i0,a,i0)') 'P R O T O N A T I O N   C Y C L E     ', &
         & i+1,' of ',taut%iter+1
         call largehead(trim(dummy))
         call checkname_xyz('tautomerize',inpnam,outnam)
         call protens(inpnam,env,taut,tim)
         call rename('protonated.xyz',outnam)
-      !--- do Deprotonation
-        write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &
+        !--- do Deprotonation
+        write (dummy,'(a,i0,a,i0)') 'D E P R O T O N A T I O N   C Y C L E     ', &
         & i+1,' of ',taut%iter+1
         call largehead(trim(dummy))
 
@@ -815,143 +807,143 @@
         call deprotens(inpnam,env,taut,tim)
         call rename('deprotonated.xyz',outnam)
       else
-      !--- do Deprotonation
-        write(dummy,'(a,i0,a,i0)')'D E P R O T O N A T I O N   C Y C L E     ', &
+        !--- do Deprotonation
+        write (dummy,'(a,i0,a,i0)') 'D E P R O T O N A T I O N   C Y C L E     ', &
         & i,' of ',taut%iter
         call largehead(trim(dummy))
 
         call checkname_xyz('tautomerize',inpnam,outnam)
         call deprotens(inpnam,env,taut,tim)
         call rename('deprotonated.xyz',outnam)
-      !--- do Protonation
-        write(dummy,'(a,i0,a,i0)')'P R O T O N A T I O N   C Y C L E     ', &
+        !--- do Protonation
+        write (dummy,'(a,i0,a,i0)') 'P R O T O N A T I O N   C Y C L E     ', &
         & i,' of ',taut%iter
         call largehead(trim(dummy))
         call checkname_xyz('tautomerize',inpnam,outnam)
         call protens(inpnam,env,taut,tim)
         call rename('protonated.xyz',outnam)
-      endif
+      end if
 !--- relax structures after each cycle
-        env%nat = natp
-        call relaxensemble(outnam,env,tim)
-        call rename('relax.'//outnam,outnam)
-      enddo
+      env%nat = natp
+      call relaxensemble(outnam,env,tim)
+      call rename('relax.'//outnam,outnam)
+    end do
 
 !--- clean all temporary ensemble files
-      call tautclean2
+    call tautclean2
 
-      call chdir(thispath)
+    call chdir(thispath)
 
-      btmp=trim(btmp)//'/'//trim(outnam)
-      call appendto(btmp,'collected.xyz')
+    btmp = trim(btmp)//'/'//trim(outnam)
+    call appendto(btmp,'collected.xyz')
 !-------------------------
-      enddo SLOOP
-!-------------------------      
+  end do SLOOP
+!-------------------------
 !      return
 
-
 !--- reset data for main dir
-     env%chrg=refchrg
-     if(env%chrg .eq. 0) then
-       call remove('.CHRG')
-     else
-       open(newunit=ich,file='.CHRG')
-       write(ich,*) env%chrg
-       close(ich)
-     endif
-     env%nat=natp    !reset Nat
+  env%chrg = refchrg
+  if (env%chrg .eq. 0) then
+    call remove('.CHRG')
+  else
+    open (newunit=ich,file='.CHRG')
+    write (ich,*) env%chrg
+    close (ich)
+  end if
+  env%nat = natp    !reset Nat
 
 !--- get the new charge and set up the calculations
-     !call printtaut
-     call largehead('T A U T O M E R I Z E')
-     call tim%start(2,'multilevel OPT')
+  !call printtaut
+  call largehead('T A U T O M E R I Z E')
+  call tim%start(2,'multilevel OPT')
 
-     call smallhead('Final Geometry Optimization')
-     call checkname_xyz('tautomerize',inpnam,outnam)
+  call smallhead('Final Geometry Optimization')
+  call checkname_xyz('tautomerize',inpnam,outnam)
 
-     call rename('collected.xyz',inpnam)
+  call rename('collected.xyz',inpnam)
 
-     call MDopt_para(env,inpnam,0)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        call sort_ens(taut,outnam,.false.)
-        call remaining_in(outnam,taut%ewin,nallout) !--- remaining number of structures
+  call MDopt_para(env,inpnam,0)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  call sort_ens(taut,outnam,.false.)
+  call remaining_in(outnam,taut%ewin,nallout) !--- remaining number of structures
 
-     call cosort(outnam,'tautomers.xyz',.false.,.false.)
-     call sort_ens(taut,'tautomers.xyz',.true.)
-     call tim%stop(2)
+  call cosort(outnam,'tautomers.xyz',.false.,.false.)
+  call sort_ens(taut,'tautomers.xyz',.true.)
+  call tim%stop(2)
 
 end subroutine tautomerize_ext
 
 !--------------------------------------------------------------------------------------------!
-! first sort file and then 
+! first sort file and then
 ! check if strict mode is active to define bond constraints (only for the heavy atoms)
 !--------------------------------------------------------------------------------------------!
 subroutine PDT_constraints(env)
-      use crest_parameters
-      use crest_data
-      use iomod
-      use zdata
-      implicit none
-      type(systemdata) :: env
-      type(zmolecule) :: zmol
-   !-- a default for the force constant (quite strong already)
+  use crest_parameters
+  use crest_data
+  use iomod
+  use zdata
+  use utilities
+  implicit none
+  type(systemdata) :: env
+  type(zmolecule) :: zmol
+  !-- a default for the force constant (quite strong already)
 
-      logical,parameter :: vverbose = .false.
-      integer :: i,h,nh
+  logical,parameter :: vverbose = .false.
+  integer :: i,h,nh
 
-   !-- sort all H atoms to the end of the file    
-      call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)
+  !-- sort all H atoms to the end of the file
+  call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)
 
-   !-- decide between atom fixing and bond constraints
-      if(env%ptb%strictPDT .or. env%ptb%fixPDT)then   
+  !-- decide between atom fixing and bond constraints
+  if (env%ptb%strictPDT.or.env%ptb%fixPDT) then
 
-      !-- if -for some reason- there is a constraint already specified, remove it
-         if(env%cts%used)then
-           call env%cts%deallocate()
-         endif     
+    !-- if -for some reason- there is a constraint already specified, remove it
+    if (env%cts%used) then
+      call env%cts%deallocate()
+    end if
 
-         env%cts%used=.true.
-   !-- if heavy-atom bond constraints shall be specified
-      if(.not.env%ptb%fixPDT)then
+    env%cts%used = .true.
+    !-- if heavy-atom bond constraints shall be specified
+    if (.not.env%ptb%fixPDT) then
 
-         write(*,*) 'Strict mode active. Heavy atom bond constraints will be applied.'
-         write(*,'(1x,a,f8.4,a)') 'Selected force constant:',env%forceconst,' Eh'
+      write (*,*) 'Strict mode active. Heavy atom bond constraints will be applied.'
+      write (*,'(1x,a,f8.4,a)') 'Selected force constant:',env%forceconst,' Eh'
 
-      !-- analyse sorted coord and write bondlength constraint 
-         call autoHeavyConstraint('coord',env%forceconst)
+      !-- analyse sorted coord and write bondlength constraint
+      call autoHeavyConstraint('coord',env%forceconst)
 
       !-- read (only) the bondlength file as constraint
-         call read_constrainbuffer('bondlengths',env%cts)
+      call read_constrainbuffer('bondlengths',env%cts)
 
-         if(vverbose)then
-             write(*,*) 'The following bonds are affected:'
-             do i=1,env%cts%ndim
-             if(trim(env%cts%sett(i)).ne.'')then
-                 write(*,'(''>'',1x,a)') trim(env%cts%sett(i))
-             endif
-             enddo
-         endif
+      if (vverbose) then
+        write (*,*) 'The following bonds are affected:'
+        do i = 1,env%cts%ndim
+          if (trim(env%cts%sett(i)) .ne. '') then
+            write (*,'(''>'',1x,a)') trim(env%cts%sett(i))
+          end if
+        end do
+      end if
 
-     !--- otherwise do exact atom fixing (of heavy atoms only)    
-      else 
-        write(*,*) 'Very strict mode active. Heavy atom positions will be constrained.'
-        write(*,'(1x,a,f8.4,a)') 'Selected force constant:',env%forceconst,' Eh'
+      !--- otherwise do exact atom fixing (of heavy atoms only)
+    else
+      write (*,*) 'Very strict mode active. Heavy atom positions will be constrained.'
+      write (*,'(1x,a,f8.4,a)') 'Selected force constant:',env%forceconst,' Eh'
 
-        call simpletopo_file('coord',zmol,.false.,.false.,'')
-        h = zmol%hydrogen() !-- count hydrogen
-        nh = zmol%nat - h
-        call fix_first_X_atoms(nh,env%forceconst,'fixpositions')
-        if(env%ptb%strictPDT)then
+      call simpletopo_file('coord',zmol,.false.,.false.,'')
+      h = zmol%hydrogen() !-- count hydrogen
+      nh = zmol%nat-h
+      call fix_first_X_atoms(nh,env%forceconst,'fixpositions')
+      if (env%ptb%strictPDT) then
         call getbmat(zmol,3,env%forceconst)
         call appendto('bondlengths','fixpositions')
-        endif
-        call zmol%deallocate()
+      end if
+      call zmol%deallocate()
 
-        call read_constrainbuffer('fixpositions',env%cts)
-      endif
-      endif
+      call read_constrainbuffer('fixpositions',env%cts)
+    end if
+  end if
 
-      return
+  return
 end subroutine PDT_constraints
Index: src/legacy_algos/protonate.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!================================================================================!\n! AUTOMATED PROTONATION AND ENERGETIC RANKING SCRIPT\n! To use run:\n!    crest <input> --protonate\n!================================================================================!\n\nsubroutine prothead\n      implicit none\n      write(*,*)'       __________________________________________'\n      write(*,*)'      |                                          |'\n      write(*,*)'      |       automated protonation script       |'\n      write(*,*)'      |__________________________________________|'\n      write(*,*)' Universitaet Bonn, MCTC'\n      write(*,*)' P.Pracht, Wed 28. Nov 13:11:52 CEST 2018'\n      write(*,*)\n      write(*,*)' Cite as:'\n      write(*,*)' P.Pracht, C.A.Bauer, S.Grimme'\n      write(*,*)' JCC, 2017, 38, 2618–2631.'\n      write(*,*)\nend subroutine prothead\n\n\n!--------------------------------------------------------------------------------------------\n! Protonation workflow with GFNn-xTB\n!--------------------------------------------------------------------------------------------\nsubroutine protonate(env,tim)\n      use crest_parameters\n      use crest_data\n      use iomod\n      use strucrd, only: coord2xyz\n      implicit none\n      type(systemdata) :: env\n      type(timer)      :: tim\n      type(protobj)    :: prot\n\n      character(len=32)  :: dirn\n      character(len=64)  :: protname\n      character(len=256) :: thispath\n      character(len=256) :: filename\n      character(len=128) :: inpnam,outnam\n\n      integer :: ich\n      integer :: natp,nallout,refchrg\n\n      logical :: ex\n\n!--- printout & clean directory\n      call protclean\n      call prothead\n\n      if(.not.allocated(env%ptb%atmap))allocate(env%ptb%atmap(env%nat))\n      if(.not.env%ptb%strictPDT .and. .not.env%ptb%fixPDT)then\n!--- sort the input file (H atoms to the bottom)\n        call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)\n      else\n!--- or sort AND apply heavy atom bond constraints\n         call PDT_constraints(env)\n      endif\n\n!--- get some settings\n      call getcwd(thispath)\n      dirn='PROT'\n      protname='protonate_0.xyz'\n      prot=env%ptb\n      refchrg = env%chrg\n      prot%newchrg = env%chrg + 1  !increase chrg by one\n      natp=env%nat + 1 !additional proton, Nat is increased by one\n     \n!--- do the xTB calculation for the LMOs\n      call tim%start(1,'LMO calc.')\n      call xtblmo(env)   \n      call tim%stop(1)\n      inquire(file='coordprot.0',exist=ex)\n      if(.not.ex)then\n        write(*,*)\n        write(*,*) '***Warning***'\n        write(*,*) 'No \"coordprot.0\" file was written, it is possible that'\n        write(*,*) 'there are no suitable LP- or π-centers in the molecule.'     \n        write(*,*) 'Hence the procedure could not be automatized. (sorry)'\n        write(*,*) '***Warning***'\n        return\n      endif\n\n!--- get the new charge and set up the calculations\n     call tim%start(2,'multilevel OPT')\n     open(newunit=ich,file='.CHRG')\n     write(ich,*) prot%newchrg     !new charge written here\n     close(ich)\n     write(*,*)\n     write(*,'(''-----------------------'')')\n     write(*,'(''Multilevel Optimization'')')\n     write(*,'(''-----------------------'')')\n\n     call coord2xyz('coordprot.0',trim(protname))\n     call appendto('xtbscreen.xyz',protname)\n     env%nat=natp\n\n     !write(*,*) 'switching stuff:'\n     !write(*,*) prot%swelem\n     !write(*,*) prot%swat\n     !write(*,*) prot%swchrg\n     if(prot%swelem)then\n       call swelem(protname,env)\n     endif\n     env%chrg = prot%newchrg !!all optimizations access env%chrg!!!\n\n     call smallhead('1. crude pre-optimization')\n     call checkname_xyz('protonate',inpnam,outnam)\n     call MDopt_para(env,protname,1)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        !write(*,*) trim(filename)\n        !call copy(trim(filename),'ensemble-test.xyz')\n        if(prot%ABcorrection)then\n            call prot_correction(env,trim(filename))\n        endif\n        prot%ewin=prot%ewin*3.0d0\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n        !call prot_correction(env,trim(outnam))\n        write(*,*)\n\n     call smallhead('2. loose optimization')\n     call checkname_xyz('protonate',inpnam,outnam)\n     call MDopt_para(env,inpnam,2)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        if(prot%ABcorrection)then\n            call prot_correction(env,trim(filename))\n        endif\n        prot%ewin=prot%ewin*(2.0d0/3.0d0)\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n        write(*,*)\n\n     call smallhead('3. optimization with user-defined thresholds')\n     call checkname_xyz('protonate',inpnam,outnam)\n     call MDopt_para(env,inpnam,0)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        if(prot%ABcorrection)then\n            call prot_correction(env,trim(filename))\n        endif\n        prot%ewin=prot%ewin/2.0d0\n        call sort_ens(prot,outnam,.false.)\n        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures\n\n\n     !call rename(outnam,'protonated.xyz')\n     call cosort(outnam,'protonated.xyz',.false.,.false.)\n     call sort_ens(prot,'protonated.xyz',.true.)\n     call tim%stop(2)\n\n\n\n!>--- (optional) post-processing\n     if(env%relax)then\n       env%rednat = env%rednat +1\n       call relaxensemble('protonated.xyz',env,tim)\n     endif\n     \n     if(env%outputsdf)then\n     call new_wrsdfens(env,'protonated.xyz','protonated.sdf',.true.)\n     endif  \n\n\n!--- reset data for main dir\n     env%chrg = refchrg\n     if(env%chrg .eq. 0) then\n       call remove('.CHRG')\n     else\n       open(newunit=ich,file='.CHRG')\n       write(ich,*) env%chrg\n       close(ich)\n     endif\n     env%nat=natp - 1 !reset nat\nend subroutine protonate\n\n!--------------------------------------------------------------------------------------------\n! A quick single point xtb calculation and calculate LMOs\n!--------------------------------------------------------------------------------------------\nsubroutine xtblmo(env)\n         use crest_parameters\n         use iomod\n         use crest_data\n         implicit none\n         type(systemdata) :: env\n         character(len=80) :: fname\n         character(len=512) :: jobcall\n         integer :: io\n         character(len=*),parameter :: pipe = ' > xtb.out 2>/dev/null'\n\n!---- setting threads\n         if(env%autothreads)then\n            call ompautoset(env%threads,7,env%omp,env%MAXRUN,1) !set the global OMP/MKL variables for the xtb jobs\n         endif\n!---- new plain coord file\n         fname='tmpcoord'\n         call copy('coord',fname)\n         call clear_setblock(fname)\n!---- jobcall\n         write(*,*)\n         write(*,'('' LMO calculation ... '')',advance='no')\n         write(jobcall,'(a,1x,a,1x,a,'' --sp --lmo'',1x,a)') &\n         &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv)\n         jobcall = trim(jobcall)//trim(pipe)\n         call command(trim(jobcall), io)\n         write(*,'(''done.'')')\n\n!---- cleanup\n         call remove(fname)\n         call remove('xtb.out')\n         call remove('energy')\n         call remove('charges')\n         call remove('xtbrestart')\nend subroutine xtblmo\n\n!--------------------------------------------------------------------------------------------\n! swithc the added proton to a nother element\n!--------------------------------------------------------------------------------------------\nsubroutine swelem(iname,env)\n         use crest_parameters \n         use iomod\n         use crest_data\n         use strucrd, only: rdensembleparam,rdensemble,wrxyz\n         implicit none\n         type(systemdata) :: env\n         type(protobj) :: prot\n         character(len=*) :: iname\n\n         integer :: i,ich\n         integer :: nat,nall\n         integer :: nchrg\n         real(wp),allocatable :: xyz(:,:,:)\n         real(wp),allocatable :: eread(:)\n         integer,allocatable  :: at(:)\n\n         prot=env%ptb\n         nchrg=env%chrg + prot%swchrg\n         prot%newchrg=nchrg\n\n         call rdensembleparam(iname,nat,nall)\n         allocate(xyz(3,nat,nall),eread(nall),at(nat))\n         call rdensemble(iname,nat,nall,at,xyz,eread)\n\n         !---- write updated .CHRG file\n         open(newunit=ich,file='.CHRG')\n         write(ich,'(i6)')  nchrg    !new charge written here\n         close(ich)\n         call remove(iname)\n\n         open(newunit=ich,file=iname)\n         at(nat)=prot%swat\n         do i=1,nall\n            call wrxyz(ich,nat,at,xyz(:,:,i))\n         enddo\n         close(ich)\n         deallocate(at,eread,xyz)\n\n         env%ptb=prot\n         return\nend subroutine swelem\n\nsubroutine swparse(iname,prot)\n         use crest_parameters\n         use iomod\n         use crest_data\n         use strucrd, only: i2e,e2i\n         implicit none\n         type(protobj) :: prot\n         character(len=*) :: iname\n\n         integer :: i,slen\n         character(len=1) :: sig\n         character(len=10) :: el\n         character(len=10) :: numbers\n         character(len=10) :: elchrg\n         character(len=2)  :: chrg\n         character(len=1)  :: chrg2\n\n         numbers='0123456789'\n         chrg='+-'\n         elchrg=''\n         chrg2=''\n         el=''\n\n         !write(*,*)iname         \n\n         slen=len_trim(iname)\n         do i=1,slen\n            sig=iname(i:i)\n            !write(*,*) sig\n            if(sig=='')cycle\n            if(index(numbers,sig).ne.0)then\n              elchrg=trim(elchrg)//sig\n            elseif(index(chrg,sig).ne.0)then\n              chrg2=sig\n            else\n            el=trim(el)//sig            \n            !write(*,*) el\n            endif\n         enddo\n\n         prot%swat = e2i(el)\n\n         if(elchrg.ne.'')then\n           read(elchrg,*) prot%swchrg\n         elseif(chrg2=='+')then\n           prot%swchrg = 1\n         elseif(chrg2=='-')then\n           prot%swchrg = -1\n         else\n           prot%swchrg = 0\n         endif\n         if(chrg2=='-'.and.prot%swchrg.gt.0) prot%swchrg = prot%swchrg * (-1)\n\n         if(prot%swat.ne.0.and.prot%swat.le.86)then\n         write(*,'(2x,a,1x,a,1x,a,a,1x,i0,a)') '-swel :','using',trim(i2e(prot%swat,'nc')), &\n         & '-atom with charge',prot%swchrg,' instead of H⁺'\n\n         prot%swelem=.true.\n\n         endif\n\nend subroutine swparse\n\n!----------------------------------------------------!\n! for every structure calculate an correction\n! to the acid/base reaction\n!----------------------------------------------------!\nsubroutine prot_correction(env,iname)\n    use crest_parameters\n    use crest_data\n    use strucrd\n    implicit none\n    type(systemdata) :: env\n    character(len=*) :: iname\n    integer :: nat,nall\n    integer,allocatable :: at(:)\n    real(wp),allocatable :: xyz(:,:,:)\n    real(wp),allocatable :: eread(:)\n    integer :: i\n    real(wp) :: dE\n    real(wp) :: acidchrg\n    real(wp) :: d1,d2,d3,d4,d5,d6\n\n\n    write(*,'(1x,a)') 'Calculate acid/base correction ...'\n    call rdensembleparam(iname,nat,nall)\n    allocate(xyz(3,nat,nall),eread(nall),at(nat))\n    call rdensemble(iname,nat,nall,at,xyz,eread)\n\n    acidchrg = env%chrg + 1\n    do i=1,nall\n     call wrxyz('acid.xyz',nat,at,xyz(:,:,i))\n     call acidbase(env,'acid.xyz','coord',acidchrg,.true.,.false.,dE, &\n         & .false.,d1,d2,d3,d4,d5,d6)\n     !eread(i) = eread(i) - dE\n     eread(i) = d1+d3-dE\n    enddo\n\n    call wrensemble(iname,nat,nall,at,xyz,eread)\n\n    return\nend subroutine prot_correction\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/protonate.f90 b/src/legacy_algos/protonate.f90
--- a/src/legacy_algos/protonate.f90	
+++ b/src/legacy_algos/protonate.f90	
@@ -24,325 +24,320 @@
 !================================================================================!
 
 subroutine prothead
-      implicit none
-      write(*,*)'       __________________________________________'
-      write(*,*)'      |                                          |'
-      write(*,*)'      |       automated protonation script       |'
-      write(*,*)'      |__________________________________________|'
-      write(*,*)' Universitaet Bonn, MCTC'
-      write(*,*)' P.Pracht, Wed 28. Nov 13:11:52 CEST 2018'
-      write(*,*)
-      write(*,*)' Cite as:'
-      write(*,*)' P.Pracht, C.A.Bauer, S.Grimme'
-      write(*,*)' JCC, 2017, 38, 2618–2631.'
-      write(*,*)
+  implicit none
+  write (*,*) '       __________________________________________'
+  write (*,*) '      |                                          |'
+  write (*,*) '      |       automated protonation script       |'
+  write (*,*) '      |__________________________________________|'
+  write (*,*) ' Universitaet Bonn, MCTC'
+  write (*,*) ' P.Pracht, Wed 28. Nov 13:11:52 CEST 2018'
+  write (*,*)
+  write (*,*) ' Cite as:'
+  write (*,*) ' P.Pracht, C.A.Bauer, S.Grimme'
+  write (*,*) ' JCC, 2017, 38, 2618–2631.'
+  write (*,*)
 end subroutine prothead
 
-
 !--------------------------------------------------------------------------------------------
 ! Protonation workflow with GFNn-xTB
 !--------------------------------------------------------------------------------------------
 subroutine protonate(env,tim)
-      use crest_parameters
-      use crest_data
-      use iomod
-      use strucrd, only: coord2xyz
-      implicit none
-      type(systemdata) :: env
-      type(timer)      :: tim
-      type(protobj)    :: prot
+  use crest_parameters
+  use crest_data
+  use iomod
+  use strucrd,only:coord2xyz
+  use utilities
+  implicit none
+  type(systemdata) :: env
+  type(timer)      :: tim
+  type(protobj)    :: prot
 
-      character(len=32)  :: dirn
-      character(len=64)  :: protname
-      character(len=256) :: thispath
-      character(len=256) :: filename
-      character(len=128) :: inpnam,outnam
+  character(len=32)  :: dirn
+  character(len=64)  :: protname
+  character(len=256) :: thispath
+  character(len=256) :: filename
+  character(len=128) :: inpnam,outnam
 
-      integer :: ich
-      integer :: natp,nallout,refchrg
+  integer :: ich
+  integer :: natp,nallout,refchrg
 
-      logical :: ex
+  logical :: ex
 
 !--- printout & clean directory
-      call protclean
-      call prothead
+  call protclean
+  call prothead
 
-      if(.not.allocated(env%ptb%atmap))allocate(env%ptb%atmap(env%nat))
-      if(.not.env%ptb%strictPDT .and. .not.env%ptb%fixPDT)then
+  if (.not.allocated(env%ptb%atmap)) allocate (env%ptb%atmap(env%nat))
+  if (.not.env%ptb%strictPDT.and..not.env%ptb%fixPDT) then
 !--- sort the input file (H atoms to the bottom)
-        call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)
-      else
+    call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)
+  else
 !--- or sort AND apply heavy atom bond constraints
-         call PDT_constraints(env)
-      endif
+    call PDT_constraints(env)
+  end if
 
 !--- get some settings
-      call getcwd(thispath)
-      dirn='PROT'
-      protname='protonate_0.xyz'
-      prot=env%ptb
-      refchrg = env%chrg
-      prot%newchrg = env%chrg + 1  !increase chrg by one
-      natp=env%nat + 1 !additional proton, Nat is increased by one
-     
+  call getcwd(thispath)
+  dirn = 'PROT'
+  protname = 'protonate_0.xyz'
+  prot = env%ptb
+  refchrg = env%chrg
+  prot%newchrg = env%chrg+1  !increase chrg by one
+  natp = env%nat+1 !additional proton, Nat is increased by one
+
 !--- do the xTB calculation for the LMOs
-      call tim%start(1,'LMO calc.')
-      call xtblmo(env)   
-      call tim%stop(1)
-      inquire(file='coordprot.0',exist=ex)
-      if(.not.ex)then
-        write(*,*)
-        write(*,*) '***Warning***'
-        write(*,*) 'No "coordprot.0" file was written, it is possible that'
-        write(*,*) 'there are no suitable LP- or π-centers in the molecule.'     
-        write(*,*) 'Hence the procedure could not be automatized. (sorry)'
-        write(*,*) '***Warning***'
-        return
-      endif
+  call tim%start(1,'LMO calc.')
+  call xtblmo(env)
+  call tim%stop(1)
+  inquire (file='coordprot.0',exist=ex)
+  if (.not.ex) then
+    write (*,*)
+    write (*,*) '***Warning***'
+    write (*,*) 'No "coordprot.0" file was written, it is possible that'
+    write (*,*) 'there are no suitable LP- or π-centers in the molecule.'
+    write (*,*) 'Hence the procedure could not be automatized. (sorry)'
+    write (*,*) '***Warning***'
+    return
+  end if
 
 !--- get the new charge and set up the calculations
-     call tim%start(2,'multilevel OPT')
-     open(newunit=ich,file='.CHRG')
-     write(ich,*) prot%newchrg     !new charge written here
-     close(ich)
-     write(*,*)
-     write(*,'(''-----------------------'')')
-     write(*,'(''Multilevel Optimization'')')
-     write(*,'(''-----------------------'')')
+  call tim%start(2,'multilevel OPT')
+  open (newunit=ich,file='.CHRG')
+  write (ich,*) prot%newchrg     !new charge written here
+  close (ich)
+  write (*,*)
+  write (*,'(''-----------------------'')')
+  write (*,'(''Multilevel Optimization'')')
+  write (*,'(''-----------------------'')')
 
-     call coord2xyz('coordprot.0',trim(protname))
-     call appendto('xtbscreen.xyz',protname)
-     env%nat=natp
+  call coord2xyz('coordprot.0',trim(protname))
+  call appendto('xtbscreen.xyz',protname)
+  env%nat = natp
 
-     !write(*,*) 'switching stuff:'
-     !write(*,*) prot%swelem
-     !write(*,*) prot%swat
-     !write(*,*) prot%swchrg
-     if(prot%swelem)then
-       call swelem(protname,env)
-     endif
-     env%chrg = prot%newchrg !!all optimizations access env%chrg!!!
+  !write(*,*) 'switching stuff:'
+  !write(*,*) prot%swelem
+  !write(*,*) prot%swat
+  !write(*,*) prot%swchrg
+  if (prot%swelem) then
+    call swelem(protname,env)
+  end if
+  env%chrg = prot%newchrg !!all optimizations access env%chrg!!!
 
-     call smallhead('1. crude pre-optimization')
-     call checkname_xyz('protonate',inpnam,outnam)
-     call MDopt_para(env,protname,1)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        !write(*,*) trim(filename)
-        !call copy(trim(filename),'ensemble-test.xyz')
-        if(prot%ABcorrection)then
-            call prot_correction(env,trim(filename))
-        endif
-        prot%ewin=prot%ewin*3.0d0
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
-        !call prot_correction(env,trim(outnam))
-        write(*,*)
+  call smallhead('1. crude pre-optimization')
+  call checkname_xyz('protonate',inpnam,outnam)
+  call MDopt_para(env,protname,1)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  !write(*,*) trim(filename)
+  !call copy(trim(filename),'ensemble-test.xyz')
+  if (prot%ABcorrection) then
+    call prot_correction(env,trim(filename))
+  end if
+  prot%ewin = prot%ewin*3.0d0
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  !call prot_correction(env,trim(outnam))
+  write (*,*)
 
-     call smallhead('2. loose optimization')
-     call checkname_xyz('protonate',inpnam,outnam)
-     call MDopt_para(env,inpnam,2)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        if(prot%ABcorrection)then
-            call prot_correction(env,trim(filename))
-        endif
-        prot%ewin=prot%ewin*(2.0d0/3.0d0)
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
-        write(*,*)
+  call smallhead('2. loose optimization')
+  call checkname_xyz('protonate',inpnam,outnam)
+  call MDopt_para(env,inpnam,2)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  if (prot%ABcorrection) then
+    call prot_correction(env,trim(filename))
+  end if
+  prot%ewin = prot%ewin*(2.0d0/3.0d0)
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  write (*,*)
 
-     call smallhead('3. optimization with user-defined thresholds')
-     call checkname_xyz('protonate',inpnam,outnam)
-     call MDopt_para(env,inpnam,0)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call rmrf('OPTIM')
-        if(prot%ABcorrection)then
-            call prot_correction(env,trim(filename))
-        endif
-        prot%ewin=prot%ewin/2.0d0
-        call sort_ens(prot,outnam,.false.)
-        call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
+  call smallhead('3. optimization with user-defined thresholds')
+  call checkname_xyz('protonate',inpnam,outnam)
+  call MDopt_para(env,inpnam,0)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call rmrf('OPTIM')
+  if (prot%ABcorrection) then
+    call prot_correction(env,trim(filename))
+  end if
+  prot%ewin = prot%ewin/2.0d0
+  call sort_ens(prot,outnam,.false.)
+  call remaining_in(outnam,prot%ewin,nallout) !--- remaining number of structures
 
-
-     !call rename(outnam,'protonated.xyz')
-     call cosort(outnam,'protonated.xyz',.false.,.false.)
-     call sort_ens(prot,'protonated.xyz',.true.)
-     call tim%stop(2)
+  !call rename(outnam,'protonated.xyz')
+  call cosort(outnam,'protonated.xyz',.false.,.false.)
+  call sort_ens(prot,'protonated.xyz',.true.)
+  call tim%stop(2)
 
-
-
 !>--- (optional) post-processing
-     if(env%relax)then
-       env%rednat = env%rednat +1
-       call relaxensemble('protonated.xyz',env,tim)
-     endif
-     
-     if(env%outputsdf)then
-     call new_wrsdfens(env,'protonated.xyz','protonated.sdf',.true.)
-     endif  
+  if (env%relax) then
+    env%rednat = env%rednat+1
+    call relaxensemble('protonated.xyz',env,tim)
+  end if
+
+  if (env%outputsdf) then
+    call new_wrsdfens(env,'protonated.xyz','protonated.sdf',.true.)
+  end if
 
-
 !--- reset data for main dir
-     env%chrg = refchrg
-     if(env%chrg .eq. 0) then
-       call remove('.CHRG')
-     else
-       open(newunit=ich,file='.CHRG')
-       write(ich,*) env%chrg
-       close(ich)
-     endif
-     env%nat=natp - 1 !reset nat
+  env%chrg = refchrg
+  if (env%chrg .eq. 0) then
+    call remove('.CHRG')
+  else
+    open (newunit=ich,file='.CHRG')
+    write (ich,*) env%chrg
+    close (ich)
+  end if
+  env%nat = natp-1 !reset nat
 end subroutine protonate
 
 !--------------------------------------------------------------------------------------------
 ! A quick single point xtb calculation and calculate LMOs
 !--------------------------------------------------------------------------------------------
 subroutine xtblmo(env)
-         use crest_parameters
-         use iomod
-         use crest_data
-         implicit none
-         type(systemdata) :: env
-         character(len=80) :: fname
-         character(len=512) :: jobcall
-         integer :: io
-         character(len=*),parameter :: pipe = ' > xtb.out 2>/dev/null'
+  use crest_parameters
+  use iomod
+  use crest_data
+  implicit none
+  type(systemdata) :: env
+  character(len=80) :: fname
+  character(len=512) :: jobcall
+  integer :: io
+  character(len=*),parameter :: pipe = ' > xtb.out 2>/dev/null'
 
 !---- setting threads
-         if(env%autothreads)then
-            call ompautoset(env%threads,7,env%omp,env%MAXRUN,1) !set the global OMP/MKL variables for the xtb jobs
-         endif
+  if (env%autothreads) then
+    call ompautoset(env%threads,7,env%omp,env%MAXRUN,1) !set the global OMP/MKL variables for the xtb jobs
+  end if
 !---- new plain coord file
-         fname='tmpcoord'
-         call copy('coord',fname)
-         call clear_setblock(fname)
+  fname = 'tmpcoord'
+  call copy('coord',fname)
 !---- jobcall
-         write(*,*)
-         write(*,'('' LMO calculation ... '')',advance='no')
-         write(jobcall,'(a,1x,a,1x,a,'' --sp --lmo'',1x,a)') &
-         &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv)
-         jobcall = trim(jobcall)//trim(pipe)
-         call command(trim(jobcall), io)
-         write(*,'(''done.'')')
+  write (*,*)
+  write (*,'('' LMO calculation ... '')',advance='no')
+  write (jobcall,'(a,1x,a,1x,a,'' --sp --lmo'',1x,a)') &
+  &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv)
+  jobcall = trim(jobcall)//trim(pipe)
+  call command(trim(jobcall),io)
+  write (*,'(''done.'')')
 
 !---- cleanup
-         call remove(fname)
-         call remove('xtb.out')
-         call remove('energy')
-         call remove('charges')
-         call remove('xtbrestart')
+  call remove(fname)
+  call remove('xtb.out')
+  call remove('energy')
+  call remove('charges')
+  call remove('xtbrestart')
 end subroutine xtblmo
 
 !--------------------------------------------------------------------------------------------
 ! swithc the added proton to a nother element
 !--------------------------------------------------------------------------------------------
 subroutine swelem(iname,env)
-         use crest_parameters 
-         use iomod
-         use crest_data
-         use strucrd, only: rdensembleparam,rdensemble,wrxyz
-         implicit none
-         type(systemdata) :: env
-         type(protobj) :: prot
-         character(len=*) :: iname
+  use crest_parameters
+  use iomod
+  use crest_data
+  use strucrd,only:rdensembleparam,rdensemble,wrxyz
+  implicit none
+  type(systemdata) :: env
+  type(protobj) :: prot
+  character(len=*) :: iname
 
-         integer :: i,ich
-         integer :: nat,nall
-         integer :: nchrg
-         real(wp),allocatable :: xyz(:,:,:)
-         real(wp),allocatable :: eread(:)
-         integer,allocatable  :: at(:)
+  integer :: i,ich
+  integer :: nat,nall
+  integer :: nchrg
+  real(wp),allocatable :: xyz(:,:,:)
+  real(wp),allocatable :: eread(:)
+  integer,allocatable  :: at(:)
 
-         prot=env%ptb
-         nchrg=env%chrg + prot%swchrg
-         prot%newchrg=nchrg
+  prot = env%ptb
+  nchrg = env%chrg+prot%swchrg
+  prot%newchrg = nchrg
 
-         call rdensembleparam(iname,nat,nall)
-         allocate(xyz(3,nat,nall),eread(nall),at(nat))
-         call rdensemble(iname,nat,nall,at,xyz,eread)
+  call rdensembleparam(iname,nat,nall)
+  allocate (xyz(3,nat,nall),eread(nall),at(nat))
+  call rdensemble(iname,nat,nall,at,xyz,eread)
 
-         !---- write updated .CHRG file
-         open(newunit=ich,file='.CHRG')
-         write(ich,'(i6)')  nchrg    !new charge written here
-         close(ich)
-         call remove(iname)
+  !---- write updated .CHRG file
+  open (newunit=ich,file='.CHRG')
+  write (ich,'(i6)') nchrg    !new charge written here
+  close (ich)
+  call remove(iname)
 
-         open(newunit=ich,file=iname)
-         at(nat)=prot%swat
-         do i=1,nall
-            call wrxyz(ich,nat,at,xyz(:,:,i))
-         enddo
-         close(ich)
-         deallocate(at,eread,xyz)
+  open (newunit=ich,file=iname)
+  at(nat) = prot%swat
+  do i = 1,nall
+    call wrxyz(ich,nat,at,xyz(:,:,i))
+  end do
+  close (ich)
+  deallocate (at,eread,xyz)
 
-         env%ptb=prot
-         return
+  env%ptb = prot
+  return
 end subroutine swelem
 
 subroutine swparse(iname,prot)
-         use crest_parameters
-         use iomod
-         use crest_data
-         use strucrd, only: i2e,e2i
-         implicit none
-         type(protobj) :: prot
-         character(len=*) :: iname
+  use crest_parameters
+  use iomod
+  use crest_data
+  use strucrd,only:i2e,e2i
+  implicit none
+  type(protobj) :: prot
+  character(len=*) :: iname
 
-         integer :: i,slen
-         character(len=1) :: sig
-         character(len=10) :: el
-         character(len=10) :: numbers
-         character(len=10) :: elchrg
-         character(len=2)  :: chrg
-         character(len=1)  :: chrg2
+  integer :: i,slen
+  character(len=1) :: sig
+  character(len=10) :: el
+  character(len=10) :: numbers
+  character(len=10) :: elchrg
+  character(len=2)  :: chrg
+  character(len=1)  :: chrg2
 
-         numbers='0123456789'
-         chrg='+-'
-         elchrg=''
-         chrg2=''
-         el=''
+  numbers = '0123456789'
+  chrg = '+-'
+  elchrg = ''
+  chrg2 = ''
+  el = ''
 
-         !write(*,*)iname         
+  !write(*,*)iname
 
-         slen=len_trim(iname)
-         do i=1,slen
-            sig=iname(i:i)
-            !write(*,*) sig
-            if(sig=='')cycle
-            if(index(numbers,sig).ne.0)then
-              elchrg=trim(elchrg)//sig
-            elseif(index(chrg,sig).ne.0)then
-              chrg2=sig
-            else
-            el=trim(el)//sig            
-            !write(*,*) el
-            endif
-         enddo
+  slen = len_trim(iname)
+  do i = 1,slen
+    sig = iname(i:i)
+    !write(*,*) sig
+    if (sig == '') cycle
+    if (index(numbers,sig) .ne. 0) then
+      elchrg = trim(elchrg)//sig
+    elseif (index(chrg,sig) .ne. 0) then
+      chrg2 = sig
+    else
+      el = trim(el)//sig
+      !write(*,*) el
+    end if
+  end do
 
-         prot%swat = e2i(el)
+  prot%swat = e2i(el)
 
-         if(elchrg.ne.'')then
-           read(elchrg,*) prot%swchrg
-         elseif(chrg2=='+')then
-           prot%swchrg = 1
-         elseif(chrg2=='-')then
-           prot%swchrg = -1
-         else
-           prot%swchrg = 0
-         endif
-         if(chrg2=='-'.and.prot%swchrg.gt.0) prot%swchrg = prot%swchrg * (-1)
+  if (elchrg .ne. '') then
+    read (elchrg,*) prot%swchrg
+  elseif (chrg2 == '+') then
+    prot%swchrg = 1
+  elseif (chrg2 == '-') then
+    prot%swchrg = -1
+  else
+    prot%swchrg = 0
+  end if
+  if (chrg2 == '-'.and.prot%swchrg .gt. 0) prot%swchrg = prot%swchrg*(-1)
 
-         if(prot%swat.ne.0.and.prot%swat.le.86)then
-         write(*,'(2x,a,1x,a,1x,a,a,1x,i0,a)') '-swel :','using',trim(i2e(prot%swat,'nc')), &
-         & '-atom with charge',prot%swchrg,' instead of H⁺'
+  if (prot%swat .ne. 0.and.prot%swat .le. 86) then
+    write (*,'(2x,a,1x,a,1x,a,a,1x,i0,a)') '-swel :','using',trim(i2e(prot%swat,'nc')), &
+    & '-atom with charge',prot%swchrg,' instead of H⁺'
 
-         prot%swelem=.true.
+    prot%swelem = .true.
 
-         endif
+  end if
 
 end subroutine swparse
 
@@ -351,37 +346,36 @@
 ! to the acid/base reaction
 !----------------------------------------------------!
 subroutine prot_correction(env,iname)
-    use crest_parameters
-    use crest_data
-    use strucrd
-    implicit none
-    type(systemdata) :: env
-    character(len=*) :: iname
-    integer :: nat,nall
-    integer,allocatable :: at(:)
-    real(wp),allocatable :: xyz(:,:,:)
-    real(wp),allocatable :: eread(:)
-    integer :: i
-    real(wp) :: dE
-    real(wp) :: acidchrg
-    real(wp) :: d1,d2,d3,d4,d5,d6
+  use crest_parameters
+  use crest_data
+  use strucrd
+  implicit none
+  type(systemdata) :: env
+  character(len=*) :: iname
+  integer :: nat,nall
+  integer,allocatable :: at(:)
+  real(wp),allocatable :: xyz(:,:,:)
+  real(wp),allocatable :: eread(:)
+  integer :: i
+  real(wp) :: dE
+  real(wp) :: acidchrg
+  real(wp) :: d1,d2,d3,d4,d5,d6
 
-
-    write(*,'(1x,a)') 'Calculate acid/base correction ...'
-    call rdensembleparam(iname,nat,nall)
-    allocate(xyz(3,nat,nall),eread(nall),at(nat))
-    call rdensemble(iname,nat,nall,at,xyz,eread)
+  write (*,'(1x,a)') 'Calculate acid/base correction ...'
+  call rdensembleparam(iname,nat,nall)
+  allocate (xyz(3,nat,nall),eread(nall),at(nat))
+  call rdensemble(iname,nat,nall,at,xyz,eread)
 
-    acidchrg = env%chrg + 1
-    do i=1,nall
-     call wrxyz('acid.xyz',nat,at,xyz(:,:,i))
-     call acidbase(env,'acid.xyz','coord',acidchrg,.true.,.false.,dE, &
-         & .false.,d1,d2,d3,d4,d5,d6)
-     !eread(i) = eread(i) - dE
-     eread(i) = d1+d3-dE
-    enddo
+  acidchrg = env%chrg+1
+  do i = 1,nall
+    call wrxyz('acid.xyz',nat,at,xyz(:,:,i))
+    call acidbase(env,'acid.xyz','coord',acidchrg,.true.,.false.,dE, &
+        & .false.,d1,d2,d3,d4,d5,d6)
+    !eread(i) = eread(i) - dE
+    eread(i) = d1+d3-dE
+  end do
 
-    call wrensemble(iname,nat,nall,at,xyz,eread)
+  call wrensemble(iname,nat,nall,at,xyz,eread)
 
-    return
+  return
 end subroutine prot_correction
Index: src/algos/ConfSolv.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/ConfSolv.F90 b/src/algos/ConfSolv.F90
new file mode 100644
--- /dev/null	
+++ b/src/algos/ConfSolv.F90	
@@ -0,0 +1,464 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!> A data storage module for hosting ConfSolv as a http server with requests
+!> We need to know the server's PORT to create the request
+!> CREST can either try to host the server on its own, or the user
+!> must provide the PORT.
+!> All of this assumes that the ConfSolv submodule was loaded
+
+module ConfSolv_module
+  use crest_parameters
+  use crest_data
+  use strucrd
+  use iomod
+  implicit none
+  public
+
+  !> ConfSolv helper script PID
+  integer,allocatable :: cs_pid
+  !> ConfSolv helper script name
+  character(len=:),allocatable :: cs_bin
+  !> ConfSolv port server port
+  integer,allocatable :: cs_port
+  !> ConfSolv teardown instruction
+  logical :: cs_teardown = .false.
+  !> Keeping track of setup. Has it been called already?
+  logical :: cs_setup = .false. 
+
+  !> ConfSolv parameter location
+  character(len=:),allocatable :: cs_param
+  !> ConfSolv solvent & smiles
+  character(len=:),allocatable :: cs_solvent
+  character(len=:),allocatable :: cs_smiles
+
+!========================================================================================!
+!========================================================================================!
+contains  !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
+
+  subroutine cs_deallocate()
+    if (allocated(cs_pid)) deallocate (cs_pid)
+    if (allocated(cs_bin)) deallocate (cs_bin)
+    if (allocated(cs_port)) deallocate (cs_port)
+    if (allocated(cs_param)) deallocate (cs_param)
+    if (allocated(cs_solvent)) deallocate (cs_solvent)
+  end subroutine cs_deallocate
+
+!=================================================!
+
+  function cs_running() result(running)
+    implicit none
+    logical :: running
+    integer :: io
+    character(len=:),allocatable :: job
+    running = .false.
+
+    io = 0
+    if (.not.allocated(cs_bin).or. &
+    &  .not.allocated(cs_pid).or. &
+    &  .not.allocated(cs_port)) then
+      running = .false.
+      return
+    end if
+
+    job = trim(cs_bin)//' --test '//to_str(cs_port)
+
+    call command(job,io)
+
+  end function cs_running
+
+!=================================================!
+  subroutine cs_shutdown(io)
+    implicit none
+    integer,intent(out) :: io
+
+    io = 0
+    if (cs_teardown.and.allocated(cs_pid).and.allocated(cs_port)) then
+      write (stdout,'(/,a,i0)') 'Shutting down http://localhost/',cs_port
+      call kill(cs_pid,9,io)
+      deallocate (cs_pid)
+    end if
+
+  end subroutine cs_shutdown
+
+!=================================================!
+
+  subroutine cs_deploy()
+    implicit none
+    character(len=:),allocatable :: job
+    integer :: io,ich
+    character(len=50) :: atmp
+    logical :: ex
+
+    if(.not.allocated(cs_bin)) cs_bin = 'confsolvserver'
+    call remove('confsolv.out')
+    call remove('config_template.toml')
+
+    job = 'nohup '//trim(cs_bin)//' -l '//'> confsolv.out 2>/dev/null'//' &'
+
+    write(stdout,'(2x,a,a)') 'Hosting command: ',trim(job)
+    call command(job,io)
+
+    if(io /= 0) error stop '**ERROR** failed to host ConfSolv server'
+    !call sleep(3)
+    do 
+      call sleep(1)
+      inquire(file='config_template.toml',exist=ex)
+      if(ex) exit
+    enddo
+
+    !> read port and pid
+    open(newunit=ich,file='confsolv.out')
+    read(ich,*) atmp,cs_pid
+    read(ich,*) atmp,cs_port
+    close(ich) 
+    cs_teardown = .true.
+    cs_setup = .false.
+    write(stdout,'(2x,2(a,i0))') 'ConfSolv server will be running at http://localhost:',cs_port,' with PID ',cs_pid
+  end subroutine cs_deploy
+
+!=================================================!
+
+  subroutine cs_write_config(ensname,threads)
+    implicit none
+    character(len=*) :: ensname
+    integer :: threads
+    integer :: i,j,k,l,ich,io
+    character(len=1024) :: atmp
+
+    call getcwd(atmp)
+    open (newunit=ich,file='config.toml')
+    call wrtoml_int(ich,'port',cs_port)
+    call wrtoml_int(ich,'pid',cs_pid)
+    call wrtoml_int(ich,'num_cores',threads)
+    if (allocated(cs_param)) then
+      call wrtoml(ich,'model_path',cs_param)
+    end if
+    
+    call wrtoml(ich,'xyz_file',trim(atmp)//'/'//trim(ensname))
+    call wrtoml(ich,'solvent_file',trim(atmp)//'/'//'crest_solvents.csv')
+
+    call wrtoml_int(ich,'n_threshold_mols',1)
+    close (ich)
+  contains
+    subroutine wrtoml(ch,key,val)
+      integer :: ch
+      character(len=*) :: key
+      character(len=*) :: val
+      write (ch,'(a,a,a,a)') trim(key),' =  "',trim(val),'"'
+    end subroutine wrtoml
+    subroutine wrtoml_int(ch,key,val)
+      integer :: ch
+      character(len=*) :: key
+      integer :: val
+      write (ch,'(a,a,i0)') trim(key),' =  ',val
+    end subroutine wrtoml_int
+  end subroutine cs_write_config
+
+!========================================================================================!
+
+  subroutine cs_write_solvent_csv(solvent,smiles,ch)
+!**************************************************************
+!* From CREST's side it makes only sense to define ONE solvent
+!* despite ConfSolv being able to handle multiple.
+!* ConfSolv will read the solvents from a CSV file with the
+!* columns SOLVENT_NAME and SMILES
+!**************************************************************
+    implicit none
+    character(len=*),intent(in) :: solvent
+    character(len=*),intent(in),optional :: smiles
+    integer,intent(in),optional :: ch
+    integer :: ich
+    if (.not.present(ch)) then
+      open (newunit=ich,file='crest_solvents.csv')
+    else
+      ich = ch
+    end if
+    !> column names
+    write (ich,'(a,",",a)') 'SOLVENT_NAME','SMILES'
+    if (present(smiles)) then
+      write (ich,'(a,",",a)') solvent,smiles
+    else
+      !> switch case for available solvents, if no smiles was given
+      select case (lowercase(solvent))
+      case ('acetate')
+        write (ich,'(a,",",a)') solvent,'CC(=O)[O-]'
+      case ('acetic acid')
+        write (ich,'(a,",",a)') solvent,'CC(=O)O'
+      case ('acetone')
+        write (ich,'(a,",",a)') solvent,'CC(=O)C'
+      case ('acetonitrile')
+        write (ich,'(a,",",a)') solvent,'CC#N'
+      case ('ammonia')
+        write (ich,'(a,",",a)') solvent,'N'
+      case ('ammonium')
+        write (ich,'(a,",",a)') solvent,'[NH4+]'
+      case ('benzene')
+        write (ich,'(a,",",a)') solvent,'c1ccccc1'
+      case ('benzoate')
+        write (ich,'(a,",",a)') solvent,'[O-]C(=O)c1ccccc1'
+      case ('benzylacetate')
+        write (ich,'(a,",",a)') solvent,'CC(=O)OCc1ccccc1'
+      case ('butanone','2-butanone')
+        write (ich,'(a,",",a)') solvent,'CCC(=O)C'
+      case ('chloride')
+        write (ich,'(a,",",a)') solvent,'[Cl-]'
+      case ('trichlormethane')
+        write (ich,'(a,",",a)') solvent,'C(Cl)(Cl)Cl'
+      case ('cyclohexane')
+        write (ich,'(a,",",a)') solvent,'C1CCCCC1'
+      case ('dibutylamine')
+        write (ich,'(a,",",a)') solvent,'CC[C@H](C)N[C@H](C)CC'
+      case ('dichlormethane')
+        write (ich,'(a,",",a)') solvent,'C(Cl)Cl'
+      case ('diethanolamine')
+        write (ich,'(a,",",a)') solvent,'OCCNCCO'
+      case ('diethanolammonium')
+        write (ich,'(a,",",a)') solvent,'OCC[NH2+]CCO'
+      case ('diethylamine')
+        write (ich,'(a,",",a)') solvent,'CCNCC'
+      case ('diethylammonium')
+        write (ich,'(a,",",a)') solvent,'CC[NH2+]CC'
+      case ('diethylether')
+        write (ich,'(a,",",a)') solvent,'CCOCC'
+      case ('heptyloctylether')
+        write (ich,'(a,",",a)') solvent,'CCCCCCCCOCCCCCCC'
+      case ('acetamide')
+        write (ich,'(a,",",a)') solvent,'CC(=O)N(C)C'
+      case ('diethylformamide')
+        write (ich,'(a,",",a)') solvent,'CN(C)C=O'
+      case ('dmso')
+        write (ich,'(a,",",a)') solvent,'CS(=O)C'
+      case ('dioxolone','2-dioxolone')
+        write (ich,'(a,",",a)') solvent,'C1COC(=O)O1'
+      case ('ethylmethylester')
+        write (ich,'(a,",",a)') solvent,'CCOC(=O)OC'
+      case ('ethanol')
+        write (ich,'(a,",",a)') solvent,'CCO'
+      case ('ethylacetate')
+        write (ich,'(a,",",a)') solvent,'CCOC(=O)C'
+      case ('ethylamine')
+        write (ich,'(a,",",a)') solvent,'CCN'
+      case ('ethylaminium')
+        write (ich,'(a,",",a)') solvent,'CC[NH3+]'
+      case ('glycol')
+        write (ich,'(a,",",a)') solvent,'OCCO'
+      case ('formate')
+        write (ich,'(a,",",a)') solvent,'C(=O)[O-]'
+      case ('formic acid')
+        write (ich,'(a,",",a)') solvent,'C(=O)O'
+      case ('butyrolacetone')
+        write (ich,'(a,",",a)') solvent,'O=C1CCCO1'
+      case ('glycerin')
+        write (ich,'(a,",",a)') solvent,'OCC(O)CO'
+      case ('water','h2o')
+        write (ich,'(a,",",a)') solvent,'O'
+      case ('sulfuric acid')
+        write (ich,'(a,",",a)') solvent,'O=S(=O)(O)O'
+      case ('hexafluorobenzene')
+        write (ich,'(a,",",a)') solvent,'Fc1c(F)c(F)c(F)c(F)c1F'
+      case ('isooctane')
+        write (ich,'(a,",",a)') solvent,'CC(C)CC(C)(C)C'
+      case ('isopropanol')
+        write (ich,'(a,",",a)') solvent,'CC(O)C'
+      case ('methoxide')
+        write (ich,'(a,",",a)') solvent,'C[O-]'
+      case ('hexane','n-hexane')
+        write (ich,'(a,",",a)') solvent,'CCCCCC'
+      case ('1-nonadecanol','nonadecanol')
+        write (ich,'(a,",",a)') solvent,'CCCCCCCCCCCCCCCCCCCO'
+      case ('1-octanol','octanol')
+        write (ich,'(a,",",a)') solvent,'OCCCCCCCC'
+      case ('p-dichlorobenzene','dichlorobenzene')
+        write (ich,'(a,",",a)') solvent,'Clc1ccccc1Cl'
+      case ('perfluorohexane')
+        write (ich,'(a,",",a)') solvent,'C(C(C(C(F)(F)F)(F)F)(F)F)(C(C(F)(F)F)(F)F)(F)F'
+      case ('propanediol')
+        write (ich,'(a,",",a)') solvent,'C[C@@H](O)CO'
+      case ('tetraethylammoniom')
+        write (ich,'(a,",",a)') solvent,'CC[N+](CC)(CC)CC'
+      case ('thf','tetrahydrofuran')
+        write (ich,'(a,",",a)') solvent,'O1CCCC1'
+      case ('toluene')
+        write (ich,'(a,",",a)') solvent,'Cc1ccccc1'
+      case ('tributylphosphate')
+        write (ich,'(a,",",a)') solvent,'O=P(OCCCC)(OCCCC)OCCCC'
+      case ('triethanolamine','trolamine')
+        write (ich,'(a,",",a)') solvent,'OCCN(CCO)CCO'
+      case ('triethanolammonium')
+        write (ich,'(a,",",a)') solvent,'OCC[NH+](CCO)CCO'
+      case ('triethylamine','net3')
+        write (ich,'(a,",",a)') solvent,'CCN(CC)CC'
+      case ('triethylammonium')
+        write (ich,'(a,",",a)') solvent,'CC[NH+](CC)CC'
+      case ('triglyme')
+        write (ich,'(a,",",a)') solvent,'COCCOCCOCCOC'
+      case ('urea')
+        write (ich,'(a,",",a)') solvent,'NC(=O)N'
+      case default
+        write(stderr,'(2a)') '**ERROR** failed to find matching solvent SMILES for: ',solvent
+        error stop
+      end select
+    end if
+    close (ich)
+  end subroutine cs_write_solvent_csv
+
+!========================================================================================!
+!========================================================================================!
+end module ConfSolv_module
+
+!========================================================================================!
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+!========================================================================================!
+
+subroutine confsolv_request(ensname,nall,ncpus,gsoln,io)
+!***********************************************
+!* Interface to ConfSolv via https requests
+!*
+!* Input/Output:
+!*  ensname - ensemble file
+!*  nall    - number of structures in ensemble
+!*  ncpus   - number on cores to run on
+!*  gsoln   - ΔΔGsoln for each structure
+!*  io      - exit status 
+!***********************************************
+  use crest_parameters
+  use crest_data
+  use strucrd
+  use iomod
+  use ConfSolv_module
+  use parse_csv
+  implicit none
+  !> INPUT
+  character(len=*),intent(in) :: ensname
+  integer,intent(in) :: nall
+  integer,intent(in) :: ncpus
+  !> OUTPUT
+  real(wp),intent(out) :: gsoln(nall)
+  integer,intent(out)  :: io
+  !> LOCAL
+  integer :: i,j,k,l,ich
+  logical :: pr,wr
+  character(len=:),allocatable :: job
+  real(wp),allocatable :: column(:)
+  real(wp) :: avg
+
+  io = 0
+  gsoln(:) = 0.0_wp
+
+!>--- setup
+  if (allocated(cs_pid).and.allocated(cs_port)) then
+  !> user-provided PID and port (no automatic teardown)
+    write (stdout,'(2x,a,i0,a,i0)') 'Looking for ConfSolv server (PID: ',cs_pid,') running at '//&
+    & 'http://localhost:',cs_port
+    !cs_teardown = .false. 
+  else
+  !> fallback: automatic host (not recommended)
+    allocate(cs_pid,cs_port)
+    call cs_deploy() 
+  end if
+  if (allocated(cs_param)) then
+    write (stdout,'(2x,a,/,3x,a)') 'pyTorch checkpoint files located at ',cs_param
+  else
+    write (stderr,*) '**ERROR** cannot run ConfSolv without defining checkpoint file location!'
+    error stop
+  end if
+  if (allocated(cs_solvent).and.allocated(cs_smiles)) then
+    write (stdout,'(2x,a,a,3a)') 'Requested ΔΔGsoln for ',cs_solvent,' (SMILES: ',trim(cs_smiles),')'
+    call cs_write_solvent_csv(cs_solvent,smiles=cs_smiles)
+  else if(allocated(cs_solvent))then
+    write (stdout,'(2x,a,a,a)') 'Requested ΔΔGsoln for ',cs_solvent,' (trying to find SMILES ...)'
+    call cs_write_solvent_csv(cs_solvent)
+  end if
+  write (stdout,'(2x,a,a)') 'Processing ensemble file ',trim(ensname)
+
+!>---- creating the request configuration
+  write (stdout,'(2x,a)',advance='no') 'Writing config.toml file              ...'
+  flush(stdout) 
+  call cs_write_config(ensname,ncpus)
+  write(stdout,*) 'done.'
+
+
+  job = ''
+  job = trim(job)//' '//cs_bin//' -c config.toml'
+!>----- this should only be called once:
+  if(.not.cs_setup)then
+    write(stdout,'(2x,a)',advance='no') 'Instructing ConfSolv model setup      ...'
+    flush(stdout)
+    call command(trim(job)//' -s >> confsolv.out 2>/dev/null',io)
+    if(io/=0)then
+      write(stdout,*)
+      write(stderr,'(a)')"**ERROR** failed request to ConfSolv server"
+      call cs_shutdown(io)
+      error stop
+    endif 
+    cs_setup = .true.
+    write(stdout,*) 'done.'
+  endif 
+
+!>---- and then the actual evaluation
+  call remove('confsolv.csv')
+  call remove('confsolv_uncertainty.csv')
+  write(stdout,'(2x,a)',advance='no') 'Evaluation of ConfSolv D-MPNN         ...'
+  flush(stdout) 
+  call command(trim(job)//' -r >> confsolv.out 2>/dev/null',io)
+  write(stdout,*) 'done.'
+  if(io/=0)then
+    write(stdout,*)
+    write(stderr,'(a)')"**ERROR** failed request to ConfSolv server"
+    call cs_shutdown(io)
+    error stop
+  endif
+
+!>--- read ΔΔGsoln
+  write(stdout,'(2x,a)',advance='no') 'Reading confsolv.csv                  ...'
+  flush(stdout)
+  call parse_csv_column_real('confsolv.csv',cs_solvent,column)
+  write(stdout,*) 'done.'
+  if(size(column,1) == nall)then
+    gsoln(:) = column(:)
+  else
+    write(stdout,'(a)') '**ERROR** dimension mismatch in confsolv_request'
+    call cs_shutdown(io)
+    error stop
+  endif
+
+!>--- read uncertainty
+  write(stdout,'(2x,a)',advance='no') 'Reading confsolv_uncertainty.csv      ...'
+  flush(stdout)
+  call parse_csv_column_real('confsolv_uncertainty.csv',cs_solvent,column)
+  write(stdout,*) 'done.'
+  if(size(column,1) == nall)then
+    avg = sum(column(:))/real(nall,wp)
+    write(stdout,'(2x,a,f25.15)') 'Average uncertainty of ConfSolv prediction:',avg
+  else
+    write(stdout,'(a)') '**ERROR** dimension mismatch in confsolv_request'
+    call cs_shutdown(io)
+    error stop
+  endif
+
+  if(allocated(column)) deallocate(column)
+  return
+end subroutine confsolv_request
+
+!========================================================================================!
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+!========================================================================================!
Index: src/legacy_algos/confscript2_misc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!--------------------------------------------------------------------------------------------\n! A quick single point xtb calculation\n!--------------------------------------------------------------------------------------------\nsubroutine xtbsp_legacy(env,xtblevel)\n  use crest_parameters\n  use iomod\n  use crest_data\n  implicit none\n  type(systemdata) :: env\n  integer,optional :: xtblevel\n  character(len=80) :: fname,xtbflag\n  character(len=512) :: jobcall\n  integer :: io\n  character(*),parameter :: pipe = ' >xtb.out 2>/dev/null'\n!---- some options\n  !pipe=' > xtb.out 2>/dev/null'\n  call remove('gfnff_topo')\n  call remove('energy')\n  call remove('wbo')\n  if (.not.env%chargesfile) call remove('charges')\n!---- (OPTIONAL) select xtb level and set flag\n  if (present(xtblevel)) then\n    select case (xtblevel)\n    case (0)\n      xtbflag = '--gfn0'\n    case (1)\n      xtbflag = '--gfn1'\n    case (2)\n      xtbflag = '--gfn2'\n    case (3)\n      xtbflag = '--gfnff'\n    case default\n      xtbflag = trim(env%gfnver)\n    end select\n  else\n    xtbflag = trim(env%gfnver)\n  end if\n!---- setting threads\n  if (env%autothreads) then\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,1) !set the global OMP/MKL variables for the xtb jobs\n  end if\n!---- new plain coord file\n  fname = 'tmpcoord'\n  call copy('coord',fname)\n  call clear_setblock(fname)\n!---- jobcall\n  jobcall = \"\"\n  jobcall = trim(jobcall)//trim(env%ProgName)\n  jobcall = trim(jobcall)//\" \"//trim(fname)//\" --sp\"\n  jobcall = trim(jobcall)//\" \"//trim(xtbflag)\n  jobcall = trim(jobcall)//\" \"//trim(env%solv)\n  jobcall = trim(jobcall)//pipe\n  call command(trim(jobcall), io)\n!---- cleanup\n  call remove(fname)\n  call remove('xtb.out')\n  call remove('energy')\n  if (.not.env%chargesfile) call remove('charges')\n  call remove('xtbrestart')\n  call remove('xtbtopo.mol')\n  call remove('gfnff_topo')\nend subroutine xtbsp_legacy\n\n!--------------------------------------------------------------------------------------------\n! A quick single point xtb calculation\n!--------------------------------------------------------------------------------------------\nsubroutine xtbsp2_legacy(fname,env)\n  use crest_parameters\n  use iomod\n  use crest_data\n  implicit none\n  character(len=*) :: fname\n  type(systemdata) :: env\n  character(len=512) :: jobcall\n  character(*),parameter :: pipe = ' > xtbcalc.out 2>/dev/null'\n  character(len=4) :: chrgstr\n  integer :: io\n  call remove('gfnff_topo')\n  call remove('energy')\n  if (.not.env%chargesfile) call remove('charges')\n  call remove('xtbrestart')\n!---- setting threads\n  if (env%autothreads) then\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,1) !set the global OMP/MKL variables for the xtb jobs\n  end if\n!---- jobcall\n  jobcall = \"\"\n  jobcall = trim(jobcall)//trim(env%ProgName)\n  jobcall = trim(jobcall)//\" \"//trim(fname)//\" --sp --wbo\"\n  jobcall = trim(jobcall)//\" \"//trim(env%gfnver)\n  jobcall = trim(jobcall)//\" \"//trim(env%solv)\n  if (env%chrg /= 0) then\n    write (chrgstr,'(i0)') env%chrg\n    jobcall = trim(jobcall)//\" --chrg \"//trim(chrgstr)\n  end if\n  if (env%uhf /= 0) then\n    write (chrgstr,'(i0)') env%uhf\n    jobcall = trim(jobcall)//\" --uhf \"//trim(chrgstr)\n  end if\n  jobcall = trim(jobcall)//pipe\n  call command(trim(jobcall), io)\n!---- cleanup\n  call remove('xtbcalc.out')\n  call remove('energy')\n  if (.not.env%chargesfile) call remove('charges')\n  call remove('xtbrestart')\n  call remove('xtbtopo.mol')\n  call remove('gfnff_topo')\nend subroutine xtbsp2_legacy\n\n!--------------------------------------------------------------------------------------------\n! A quick xtb geometry optimization at the beginning of the program\n!--------------------------------------------------------------------------------------------\nsubroutine xtbopt(env)\n  use crest_parameters\n  use iomod\n  use crest_data\n  use strucrd\n  implicit none\n  type(systemdata) :: env\n  character(len=80) :: fname,pipe\n  character(len=512) :: jobcall\n  logical :: fin\n  character(len=256) :: atmp\n  character(len=4) :: chrgstr\n  integer :: ich,iost,io,i\n  type(coord) :: mol\n  integer :: ntopo\n  integer,allocatable :: topo(:)\n  logical :: tchange = .false.\n\n!---- small header\n  write (*,*)\n  call smallhead('xTB Geometry Optimization')\n!---- some options\n  pipe = ' > xtb.out 2>/dev/null'\n  call remove('gfnff_topo')\n  if (.not.env%chargesfile) call remove('charges')\n  call remove('grad')\n  call remove('mos')\n  call remove('xtbopt.log')\n  call remove('xtbrestart')\n\n!---- setting threads\n  if (env%autothreads) then\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,1) !set the global OMP/MKL variables for the xtb jobs\n  end if\n!---- new plain coord file\n  fname = 'tmpcoord'\n  !call copy('coord',fname)\n  call wrc0(fname,env%ref%nat,env%ref%at,env%ref%xyz)\n  call clear_setblock(fname)\n!---- coord setup section\n  open (newunit=ich,file=fname)\n  do\n    read (ich,'(a)',iostat=iost) atmp\n    if (iost < 0) exit\n    if (index(atmp,'$coord') .ne. 0) cycle\n    if (index(atmp(1:1),'$') .ne. 0) then\n      !write(ich,'(a)')'$end'\n      exit\n    end if\n  end do\n  !add constraints (only if given, else the routine returns)\n  call write_cts(ich,env%cts)\n  call write_cts_biasext(ich,env%cts)\n  write (ich,'(a)') '$end'\n  close (ich)\n\n!>---- jobcall\n  jobcall = \"\"\n  jobcall = trim(jobcall)//trim(env%ProgName)\n  jobcall = trim(jobcall)//\" \"//trim(fname)//' --opt'\n  jobcall = trim(jobcall)//\" \"//trim(env%gfnver)\n  jobcall = trim(jobcall)//\" \"//trim(env%solv)\n  if (env%chrg /= 0) then\n    jobcall = trim(jobcall)//\" --chrg \"//to_str(env%chrg)\n  end if\n  if (env%uhf /= 0) then\n    jobcall = trim(jobcall)//\" --uhf \"//to_str(env%uhf)\n  end if\n  jobcall = trim(jobcall)//pipe\n  call command(trim(jobcall), io)\n\n  call minigrep('xtb.out','optimized geometry written to:',fin)\n  if (.not.fin) then\n    write (*,*)\n    write (*,*) ' Initial geometry optimization failed!'\n    write (*,*) ' Please check your input.'\n    error stop\n  end if\n  write (*,*) 'Geometry successfully optimized.'\n!---- if necessary, check if the topology has changed!\n  call mol%open('xtbopt.coord')\n  if (allocated(env%ref%topo)) then\n    ntopo = mol%nat*(mol%nat+1)/2\n    allocate (topo(ntopo))\n    call quicktopo(mol%nat,mol%at,mol%xyz,ntopo,topo)\n    do i = 1,ntopo\n      if (topo(i) .ne. env%ref%topo(i)) tchange = .true.\n    end do\n    if (tchange) then\n      write (*,'(1x,a)') 'WARNING! Change in topology detected!'\n      !--- either update the topology (see option B below)\n      if (.not.env%reftopo) then\n        env%ref%topo = topo\n        !--- or abort the run\n      else\n        write (*,'(1x,a)') 'The topology change was seen in the initial geometry optimization.'\n        write (*,'(1x,a,a,a)') 'This could be an artifact of the chosen theory level (',trim(env%gfnver),').'\n        write (*,'(1x,a)') 'You can check the optimization trajectory in the \"xtbopt.log\" file.'\n        write (*,'(1x,a)') 'Try either of these options:'\n        write (*,'(/,4x,a)') 'A) Pre-optimize your input seperately with xtb and use the optimized'\n        write (*,'(4x,a)') '   structure as input for CREST. (Only recommended if structure is intact)'\n        write (*,'(/,4x,a)') 'B) Restart the same CREST call as before, but ignore the topology change'\n        write (*,'(4x,a)') '   by using the \"--noreftopo\" keyword. (May produce artifacts)'\n        write (*,'(/,4x,a)') 'C) Fix the initial input geometry by introducing bond length constraints'\n        write (*,'(4x,a)') '   or by using a method with fixed topology (GFN-FF).'\n        write (*,*)\n        error stop 'abnormal termination of crest'\n      end if\n    end if\n  end if\n!---- update reference with optimized geometry\n  env%ref%nat = mol%nat\n  env%ref%at = mol%at\n  env%ref%xyz = mol%xyz\n  call mol%deallocate()\n  call rename('xtbopt.coord','coord')\n\n!---- cleanup\n  call remove(fname)\n  call remove('xtb.out')\n  call remove('energy')\n  if (.not.env%chargesfile) call remove('charges')\n  call remove('grad')\n  call remove('mos')\n  call remove('xtbopt.log')\n  call remove('xtbrestart')\n  call remove('gfnff_topo')\nend subroutine xtbopt\n\n!--------------------------------------------------------------------------------------------\n! A single METADYN run (resp. its setup)\n!--------------------------------------------------------------------------------------------\nsubroutine MetaMD(env,nr,mdtime,fac,expo,dumplist)\n  use iso_c_binding\n  use crest_parameters\n  use iomod\n  use crest_data\n  use strucrd,only:wrc0,rdensembleparam,rdensemble\n  implicit none\n  type(systemdata) :: env\n\n  real(wp) :: mdtime\n\n  real(wp)  :: fac\n  real(wp)  :: expo\n  integer   :: dumplist,dumplist2\n  integer   :: nr\n\n  character(len=20)  :: fname\n  character(len=256) :: basename,dirname\n  character(len=512) :: tmppath,thispath\n  integer :: r\n\n  associate (nat => env%nat,hmass => env%hmass,mdtemp => env%mdtemp,    &\n  & mdstep => env%mdstep,shake => env%shake,mddumpxyz => env%mddumpxyz, &\n  & mdskip => env%mdskip,mddump => env%mddump)\n\n!---- some settings\n    basename = 'METADYN'  !base name of the directories\n    fname = 'coord'\n\n    dumplist2 = dumplist\n\n!----\n\n    call getcwd(thispath)              !current dir= thispath\n    !call getname_dir(trim(basename),dirname)\n    write (dirname,'(a,i0)') trim(basename),nr\n    tmppath = trim(dirname)\n    call rmrf(tmppath)         !clear old directory\n    r = makedir(trim(tmppath)) !create new directory\n\n    call copysub('coord',trim(tmppath))\n    !call copysub('.CHRG',trim(tmppath))\n    !call copysub('.UHF',trim(tmppath))\n    call env%wrtCHRG(trim(tmppath))\n    call copysub(env%fixfile,trim(tmppath))\n    call copysub(env%constraints,trim(tmppath))\n    if (env%useqmdff) then\n      call copysub('solvent',trim(tmppath))\n    end if\n    if (env%gfnver == '--gff') then\n!            l = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(tmppath)//'/'//'gfnff_topo')\n    end if\n\n    call chdir(trim(tmppath))  !switch to working directory\n\n!---- do stuff here\n    call setMDrun2(fname,hmass,mdtime,mdtemp,mdstep,shake,mddumpxyz, &\n    &             mdskip,mddump,-1,env%cts)\n    call setMetadyn2(fname,fac,expo,dumplist2)  ! Metadynamic settings\n\n!----\n    call chdir(thispath)  !go back to orgiginal directory\n  end associate\nend subroutine MetaMD\n\n!--------------------------------------------------------------------------------------------\n! Run several METADYN in parallel, OMP VERSION!\n!--------------------------------------------------------------------------------------------\nsubroutine MetaMD_para_OMP(env)\n  use crest_parameters\n  use iomod\n  use crest_data\n  implicit none\n\n  type(systemdata) :: env\n\n  integer :: i,vz\n  real(wp) :: time\n  character(len=512) :: thispath,tmppath\n  character(len=512) :: jobcall\n  character(len=80)  :: fname,pipe,atmp,btmp\n  integer :: dum,io\n  logical :: ex\n\n  if (env%autothreads) then\n    dum = env%nmetadyn\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,dum) !set the global OMP/MKL variables for the xtb jobs\n  end if\n\n  time = env%mdtime !for some reason this is necessary\n\n  call getcwd(thispath)\n\n  fname = 'coord'\n  pipe = ' > xtb.out 2>/dev/null'\n\n  write (jobcall,'(a,1x,a,1x,a,1x,''--md'',1x,a,1x,a,a)') &\n  &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe\n  !--- slightly different jobcall for QMDFF usage\n  if (env%useqmdff) then\n    write (jobcall,'(a,1x,a,1x,a,1x,''--md --qmdff'',1x,a,1x,a,a)') &\n    &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe\n  end if\n\n!---- Small Header\n  write (*,*)\n  write (*,'(5x,''========================================'')')\n  write (*,'(5x,''|         Meta-MD (MTD) Sampling       |'')')\n  write (*,'(5x,''========================================'')')\n  write (*,*)\n\n!---- set up directories\n  do i = 1,env%nmetadyn\n    call MetaMD(env,i,time,env%metadfac(i),env%metadexp(i), &\n&               env%metadlist(i))\n  end do\n\n!$omp parallel &\n!$omp shared( vz,jobcall,time,env )\n!$omp single\n  do i = 1,env%nmetadyn\n    call initsignal()\n    vz = i\n    !$omp task firstprivate( vz ) private( tmppath,io,ex )\n    call initsignal()\n    !$omp critical\n    write (*,'(a,i4,a)') 'Starting Meta-MD',vz,' with the settings:'\n    write (*,'(''     MD time /ps        :'',f8.1)') time\n    write (*,'(''     dt /fs             :'',f8.1)') env%mdstep\n    write (*,'(''     dumpstep(trj) /fs  :'',i8)') env%mddumpxyz\n    write (*,'(''     dumpstep(Vbias)/ps :'',f8.1)') float(env%mddump)/1000d0\n    write (*,'(''     Vbias factor k /Eh :'',f8.4)') env%metadfac(vz)\n    write (*,'(''     Vbias exp α /bohr⁻²:'',f8.2)') env%metadexp(vz)\n    !$omp end critical\n    write (tmppath,'(a,i0)') 'METADYN',vz\n    call command('cd '//trim(tmppath)//' && '//trim(jobcall), io)\n    inquire (file=trim(tmppath)//'/'//'xtb.trj',exist=ex)\n    if (.not.ex.or.io .ne. 0) then\n      write (*,'(a,i0,a)') '*Warning: Meta-MTD ',vz,' seemingly failed (no xtb.trj)*'\n      call system('cp -r '//trim(tmppath)//' FAILED-MTD')\n    else\n      write (*,'(a,i0,a)') '*Meta-MTD ',vz,' finished*'\n    end if\n    !$omp end task\n  end do\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n  if (env%trackorigin) then\n    call set_trj_origins('METADYN','mtd')\n  end if\n  call checkname_xyz(crefile,atmp,btmp)\n  call collect_trj_skipfirst('METADYN',trim(atmp))  !collect all 'xtb.trj' from the METADYN directories,skip the first point on .trj\n\n  if (.not.env%keepModef) then\n    call cleanMTD\n  end if\n\nend subroutine MetaMD_para_OMP\n\n!---------------------------------------------------------------------\n! Parallel Optimization along trajectory\n!---------------------------------------------------------------------\nsubroutine MDopt_para(env,ensnam,multilev)\n  use iso_c_binding\n  use crest_parameters\n  use crest_data\n  use iomod\n  use strucrd,only:rdensembleparam,rdensemble,wrxyz\n  implicit none\n  type(systemdata) :: env\n  character(len=*),intent(in)  :: ensnam\n  integer,intent(in) :: multilev\n  character(len=80)  :: fname,pipe\n  character(len=256) :: ctmp\n  character(len=512) :: thispath,optpath\n  character(len=40),allocatable :: origin(:)\n\n  real(wp),allocatable :: eread(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  integer,allocatable  :: at(:)\n\n  integer :: i,l\n  integer :: ich,r\n  integer :: nall\n\n  logical :: verbose,l1\n\n  associate (nat => env%nat)\n\n!------- IMPORTANT: wrapper if in-place mode is active ------------!\n! The in-place version does the same as this routine, but is\n! less heavy on the disk-space...\n    if (env%inplaceMode) then\n      call MDopt_para_inplace(env,ensnam,multilev)\n      return\n    end if\n!------------------------------------------------------------------!\n\n!---- get current path\n    call getcwd(thispath)\n\n!--- some general settings\n    fname = 'struc.xyz'\n    l1 = .true.\n    verbose = .true.\n    if (verbose) then\n      pipe = ' 2>/dev/null'\n    else\n      pipe = ' > xtb.out 2>/dev/null'\n    end if\n\n!---- read the input ensemble\n    call rdensembleparam(ensnam,nat,nall)\n    if (nall .lt. 1) return\n    allocate (xyz(3,nat,nall),at(nat),eread(nall))\n    if (.not.env%trackorigin) then\n      call rdensemble(ensnam,nat,nall,at,xyz,eread)\n    else\n      allocate (origin(nall))\n      call rdensemble_origin(ensnam,nat,nall,at,xyz,eread,origin)\n    end if\n\n!---- create directory for the optimizations\n    optpath = 'OPTIM'\n    call rmrf(optpath)\n    r = makedir(trim(optpath))\n\n    !call copysub('.CHRG',trim(optpath))\n    !call copysub('.UHF',trim(optpath))\n    call env%wrtCHRG(trim(optpath))\n    call copysub(env%fixfile,trim(optpath))\n    !call copysub(env%constraints,trim(optpath))\n    if (env%useqmdff) then\n      call copysub('solvent',trim(optpath))\n    end if\n    if (env%gfnver == '--gff') then\n      l = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(optpath)//'/'//'gfnff_topo')\n    end if\n\n    call chdir(trim(optpath))\n    call getcwd(optpath)\n\n!---- set up directories\n    write (6,'(1x,a,a,a)',advance='no') 'writing TMPCONF* Dirs from file \"',trim(ensnam),'\" ...'\n    do i = 1,nall\n      write (ctmp,'(''TMPCONF'',i0)') i\n      r = makedir(trim(ctmp))\n      call chdir(ctmp)\n      open (newunit=ich,file=fname)\n      call wrxyz(ich,nat,at,xyz(:,:,i))\n      if (multilev .ge. 0) then\n        l1 = .false.\n        write (ich,'(a)') '$end'\n        write (ich,'(a)') '$opt'\n        write (ich,'(1x,a,f14.4)') 'hlow=',env%hlowopt\n        write (ich,'(1x,a,i0)') 'microcycle=',nint(env%microopt)\n        write (ich,'(1x,a,f14.4)') 's6=',env%s6opt\n      end if\n      select case (multilev)\n      case (0) !--- from global variable\n        write (ich,'(2x,''optlevel='',i6)') nint(env%optlev)\n        write (ich,'(''$end'')')\n      case (1) !--- crude\n        write (ich,'(2x,''optlevel='',i6)')-3\n        write (ich,'(''$end'')')\n      case (2) !--- loose\n        write (ich,'(2x,''optlevel='',i6)')-1\n        write (ich,'(''$end'')')\n      case (3) !--- normal\n        write (ich,'(2x,''optlevel='',i6)') 0\n        write (ich,'(''$end'')')\n      case (4) !--- tight\n        write (ich,'(2x,''optlevel='',i6)') 1\n        write (ich,'(''$end'')')\n      case (5) !--- vtight\n        write (ich,'(2x,''optlevel='',i6)') 2\n        write (ich,'(''$end'')')\n      end select\n      call write_cts(ich,env%cts)\n      call write_cts_biasext(ich,env%cts)\n      close (ich)\n      call chdir(optpath)\n\n      !call copysub('.CHRG',trim(ctmp))\n      !call copysub('.UHF',trim(ctmp))\n      call env%wrtCHRG(trim(ctmp))\n      call copysub(env%fixfile,trim(ctmp))\n      if (env%useqmdff) then\n        call copysub('solvent',trim(ctmp))\n      end if\n      if (env%gfnver == '--gff') then\n        l = sylnk(trim(optpath)//'/'//'gfnff_topo',trim(ctmp)//'/'//'gfnff_topo')\n      end if\n    end do\n    write (*,'(1x,a)') 'done.'\n\n!---- clear some memory\n    deallocate (eread,at,xyz)\n\n!---- perform the optimizations using the confopt routine\n    call confopt(env,fname,nall,.false.)\n\n    if (env%trackorigin) then\n      call addorigin2('opt.xyz',origin,nall)\n      deallocate (origin)\n    end if\n\n!---- go back to original directory\n    call chdir(thispath)\n\n  end associate\nend subroutine MDopt_para\n\n!--------------------------------------------------------------------------------------------\n! Different handling of optimizations in multi-step-filtering\n!--------------------------------------------------------------------------------------------\nsubroutine multilevel_opt(env,modus)\n  use crest_parameters\n  use iomod\n  use crest_data\n  implicit none\n\n  type(systemdata) :: env\n\n  character(len=128) :: inpnam,outnam\n  character(len=512) :: thispath,filename\n  character(len=:),allocatable :: olev\n  character(len=:),allocatable :: headder\n  real(wp)  :: newthr\n  real(wp)  :: ewinbackup,rthrbackup\n  real(wp),allocatable :: backupthr(:)\n  integer :: modus\n\n  call getcwd(thispath)\n\n  allocate (backupthr(8))\n  backupthr = env%thresholds    !default thresholds\n  ewinbackup = env%ewin\n  rthrbackup = env%rthr\n\n!     if(multilevel)then\n  select case (modus)\n!--- first optimization with \"maxopt\"\n  case (1)\n    call smallhead('1. crude pre-optimization')\n    call checkname_xyz(crefile,inpnam,outnam)\n    call MDopt_para(env,trim(inpnam),modus)\n    filename = trim(thispath)//'/'//trim(outnam)\n    call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n    !---using cregen to sort the optimized structures\n    call checkname_xyz(crefile,inpnam,outnam)\n    !--- get other thresholds\n    newthr = aint(ewinbackup*(15.0d0/6.0d0))\n    env%ewin = newthr\n    env%rthr = rthrbackup*3.0d0 !larger RTHR\n    call sort_and_check(env,trim(filename))\n    !--- only if modus=1 the input file is overwritten with the sorted file\n    call remove(inpnam)\n    call rename(outnam,inpnam)\n    !-----\n    call rmoptim()\n    write (*,*)\n!--- then vloose optimization\n  case (2,22)\n    call checkname_xyz(crefile,inpnam,outnam)\n    if (modus == 2) then\n      call smallhead('Ensemble optimization with loose thresholds')\n      call MDopt_para(env,trim(inpnam),modus)\n    else\n      call smallhead('Ensemble optimization with crude thresholds')\n      call MDopt_para(env,trim(inpnam),1)\n    end if\n    filename = trim(thispath)//'/'//trim(outnam)\n    call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n    !--- get other thresholds\n    newthr = aint(ewinbackup*(10.0d0/6.0d0))\n    env%ewin = newthr   !\n    call sort_and_check(env,trim(filename))\n    call rmoptim()\n    write (*,*)\n!--- lastly vtight optimization\n  case (3)\n    call smallhead('3. optimization with very tight thresholds')\n    call checkname_xyz(crefile,inpnam,outnam)\n    call MDopt_para(env,trim(inpnam),0) !optlev is set from the module variable\n    filename = trim(thispath)//'/'//trim(outnam)\n    call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n    call sort_and_check(env,trim(filename))\n    call rmoptim()\n    write (*,*)\n!--- crude optimization\n  case (4)\n    call smallhead('1. crude pre-optimization')\n    call checkname_xyz(crefile,inpnam,outnam)\n    call MDopt_para(env,trim(inpnam),1)\n    filename = trim(thispath)//'/'//trim(outnam)\n    call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n    !---using cregen to sort the optimized structures\n    call checkname_xyz(crefile,inpnam,outnam)\n    !--- get other thresholds\n    newthr = aint(ewinbackup*2.0d0)\n    env%ewin = newthr\n    env%rthr = rthrbackup*2.0d0 !larger RTHR\n    call sort_and_check(env,trim(filename))\n    !--- only if modus=1 the input file is overwritten with the sorted file\n    call remove(inpnam)\n    call rename(outnam,inpnam)\n    !-----\n    call rmoptim()\n    write (*,*)\n!--- tight optimization\n  case (5:6)\n    if (modus .eq. 5) then\n      call smallhead('2. optimization with tight thresholds')\n    else if (modus .eq. 6) then\n      call smallhead('Ensemble optimization with tight thresholds')\n    end if\n    call checkname_xyz(crefile,inpnam,outnam)\n    call MDopt_para(env,trim(inpnam),4) !optlev is set from the module variable\n    filename = trim(thispath)//'/'//trim(outnam)\n    call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n    call sort_and_check(env,trim(filename))\n    call rmoptim()\n    write (*,*)\n!--- default optimization\n  case default\n    olev = optlevflag(env%optlev)\n    headder = 'Ensemble optimization with '//olev//' thresholds'\n    call smallhead(headder)\n    !call smallhead('Ensemble optimization')\n    call checkname_xyz(crefile,inpnam,outnam)\n    call MDopt_para(env,trim(inpnam),0) !optlev is set from the module variable\n    filename = trim(thispath)//'/'//trim(outnam)\n    call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n!        if (env%crestver .ne. crest_solv) then\n    if (.not.env%QCG) then\n      call sort_and_check(env,trim(filename))\n      call rmoptim()\n    end if\n    write (*,*)\n  end select\n\n  env%thresholds = backupthr\n  env%ewin = ewinbackup\n  env%rthr = rthrbackup\n  deallocate (backupthr)\n\nend subroutine multilevel_opt\n!--------------------------------------------------------------------------------------------\n! Construct MD $set-block version 2 (updated)\n!--------------------------------------------------------------------------------------------\nsubroutine setMDrun2(fname,hmass,mdtime,mdtemp,mdstep,shake,mddumpxyz, &\n &                   mdskip,mddump,nvt,cts)\n  use crest_parameters\n  use crest_data\n  implicit none\n  type(constra) :: cts\n  character(len=*) :: fname\n  real(wp) :: hmass\n  real(wp) :: mdtime\n  real(wp) :: mdtemp\n  real(wp) :: mdstep\n  integer  :: shake\n  integer  :: mddumpxyz\n  integer  :: mdskip\n  integer  :: mddump\n  integer  :: nvt\n  integer :: ich,iost\n  character(len=256):: atmp\n\n  !--- coord setup section\n  open (newunit=ich,file=fname)\n  !--- don't modify coords:\n  do\n    read (ich,'(a)',iostat=iost) atmp\n    if (iost < 0) exit\n    if (index(atmp,'$coord') .ne. 0) cycle\n    if (index(atmp(1:1),'$') .ne. 0) exit\n  end do\n  !--- then write the MD settings\n  write (ich,'(a)') '$md'\n  if (hmass > 0.0_wp) then      !set H-atom mass\n    write (ich,'(2x,a,i0)') 'hmass=',nint(hmass)\n  end if\n  if (mdtime > 0.0_wp) then     !set MD simulation time in ps\n    write (ich,'(2x,a,f10.2)') 'time=',mdtime\n  end if\n  if (mdtemp > 0.0_wp) then     !set MD Temperature\n    write (ich,'(2x,a,f10.2)') 'temp=',mdtemp\n  end if\n  if (mdstep .gt. 0) then     !set MD timestep in fs\n    write (ich,'(2x,a,f10.2)') 'step=',mdstep\n  end if\n  if (shake >= 0) then     !set MD shake mode\n    write (ich,'(2x,a,i0)') 'shake=',shake\n  end if\n  !the order of setting mddump and mddumpxyz is important!!!\n  if (mddumpxyz > 0) then    ! Frequency of structure dump into xtb.trj in fs\n    write (ich,'(2x,a,i0)') 'dump=',mddumpxyz\n  end if\n  if (mdskip >= 0) then    !skipping optimizations in -mdopt\n    write (ich,'(2x,a,i0)') 'skip=',mdskip\n  end if\n  if (nvt >= 0) then      ! NVT ensemble\n    if (nvt == 0) then\n      write (ich,'(2x,a)') 'nvt=false'\n    else\n      write (ich,'(2x,a)') 'nvt=true'\n    end if\n  end if\n  !the order of setting mddump and mddumpxyz is important!!!\n  if (mddump > 0) then     ! Vbias dump for metadyn in fs\n    write (ich,'(a)') '$set'\n    write (ich,'(2x,a,2x,i0)') 'mddump',mddump\n  end if\n  !--- add constraints (only if given, else the routines return)\n  call write_cts(ich,cts)\n  call write_cts_NCI(ich,cts)\n  if (cts%cbonds_md) then\n    call write_cts_CBONDS(ich,cts)\n  end if\n  if (cts%dispscal_md) then\n    call write_cts_DISP(ich,cts)\n  end if\n  call write_cts_rcontrol(ich,cts)\n  write (ich,'(a)') '$end'\n  close (ich)\n  return\nend subroutine setMDrun2\n\n!--------------------------------------------------------------------------------------------\nsubroutine setMetadyn2(fname,fac,expo,dumplist)\n  use crest_parameters\n  implicit none\n  character(len=*) :: fname\n  real(wp)  :: fac\n  real(wp)  :: expo\n  integer   :: dumplist\n  character(len=256) :: atmp\n  character(len=256),allocatable :: mdyn(:)\n  integer :: i\n  integer :: ich,ich2,iost,lz\n\n  allocate (mdyn(10))\n  mdyn(1:10) = ''\n  lz = 1\n\n  open (newunit=ich,file=fname)\n  open (newunit=ich2,file='tmpcoordfile')\n  do\n    read (ich,'(a)',iostat=iost) atmp\n    if (iost < 0) exit\n    if (index(atmp,'$metadyn') .ne. 0) then\n\n      do\n        read (ich,'(a)',iostat=iost) atmp\n        if (iost < 0) exit\n        if (index(atmp,'$') .ne. 0) exit\n        mdyn(lz) = adjustl(atmp)\n        lz = lz+1\n      end do\n    end if\n    write (ich2,'(a)') trim(atmp)\n  end do\n\n  write (ich2,'(a)') '$metadyn'\n  do i = 1,lz\n    if (index(mdyn(i),'save') .ne. 0) cycle\n    if (index(mdyn(i),'kpush') .ne. 0) cycle\n    if (index(mdyn(i),'alp') .ne. 0) cycle\n    if (trim(mdyn(i)) .eq. '') cycle\n    write (ich2,'(2x,a)') trim(mdyn(i))\n  end do\n  write (ich2,'(2x,a,i0)') 'save=',dumplist\n  write (atmp,'(f12.6)') fac\n  write (ich2,'(2x,a,a)') 'kpush=',adjustl(trim(atmp))\n  write (atmp,'(f12.6)') expo\n  write (ich2,'(2x,a,a)') 'alp=',adjustl(trim(atmp))\n  write (ich2,'(a)') '$end'\n  close (ich2)\n  close (ich)\n  deallocate (mdyn)\n  call rename('tmpcoordfile',fname)\n  return\nend subroutine setMetadyn2\n\n!---------------------------------------------------------------------\n! Modified verison of the GC (confscript.v.2)\n!---------------------------------------------------------------------\nsubroutine cross3(env)\n  use crest_parameters\n  use crest_data\n  use iomod\n  implicit none\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n  real(wp) :: ewinbackup\n  integer  :: i,imax,tmpconf,nremain\n  character(len=128) :: inpnam,outnam\n  character(len=512) :: thispath,tmppath\n\n  real(wp),allocatable :: backupthr(:)\n\n  allocate (backupthr(8))\n  backupthr = env%thresholds\n  ewinbackup = env%ewin\n\n  call getcwd(thispath)\n\n  do i = 1,1  !>-- technically it would be possible to repeat the crossing\n    !>-- determine max number of new structures\n    imax = min(nint(env%mdtime*50.0d0),5000)\n    if (env%setgcmax) then\n      imax = nint(env%gcmax)\n    end if\n    if (env%quick) then\n      imax = nint(float(imax)*0.5d0)\n    end if\n\n    !>-- call the crossing routine\n    call checkname_xyz(crefile,inpnam,outnam)\n    call crest_crossing(env,imax,trim(inpnam),env%gcmaxparent)\n    if (imax .lt. 1) then\n      return\n      exit\n    end if\n\n    !>-- optimize ensemble\n    if (env%gcmultiopt) then !> for printout\n      call smallhead('GC: loose pre-optimization')\n    end if\n    call MDopt_para(env,'confcross.xyz',2)\n\n    !>-- optional multilevel opt\n    if (env%gcmultiopt) then\n      call checkname_xyz('confcross',inpnam,outnam)\n      call rename('OPTIM'//'/'//'opt.xyz',trim(inpnam))\n      env%ewin = aint(ewinbackup*(10.0d0/6.0d0))\n      call newcregen(env,15)\n      call checkname_xyz('confcross',inpnam,outnam)\n      call remaining_in(inpnam,env%ewin,nremain)\n      env%thresholds = backupthr\n      env%ewin = ewinbackup\n      call smallhead('GC: optimization with tight thresholds')\n      if (env%iterativeV2) then\n        call MDopt_para(env,inpnam,4)\n      else\n        call MDopt_para(env,inpnam,0)\n      end if\n    end if\n\n    !>-- append optimized crossed structures to original crest_rotamers input\n    call checkname_xyz(crefile,inpnam,outnam)\n    call appendto('OPTIM'//'/'//'opt.xyz',trim(inpnam))\n  end do\n  call rmrfw('confcross_')\n  deallocate (backupthr)\nend subroutine cross3\n\n!---------------------------------------------------------------------\n! run confg check (confscript.v.2)\n!---------------------------------------------------------------------\nsubroutine confg_chk3(env)\n  use crest_data\n  implicit none\n  type(systemdata) :: env    !> MAIN SYSTEM DATA\n\n  call ompautoset(env%threads,4,env%omp,env%MAXRUN,0) !mode=4 --> Program intern Threads max\n  !>-- Special handling qcg, no RMSD,\n  !    because a CMA transformed structure would cause wrong wall pot.\n  if (env%crestver .eq. crest_solv) then\n    call newcregen(env,6)\n  else\n    call newcregen(env,0)\n  end if\n  call ompautoset(env%threads,5,env%omp,env%MAXRUN,0) !mode=5 --> Program intern Threads min\nend subroutine confg_chk3\n\n!---------------------------------------------------------------------\n! collect xtb.trj\n!---------------------------------------------------------------------\nsubroutine collect_trj(base,whichfile)\n  use iomod\n  implicit none\n  character(len=*) :: base,whichfile\n  character(len=256) :: str,dir\n  integer :: i\n  logical :: ex\n  i = 1\n  do\n    write (dir,'(a,i0)') trim(base),i\n    ex = directory_exist(trim(dir))\n    if (.not.ex) then\n      exit\n    else\n      write (str,'(a,a,''xtb.trj'')') trim(dir),'/'\n      call appendto(trim(str),whichfile)\n      i = i+1\n    end if\n  end do\n  return\nend subroutine collect_trj\n\n!---------------------------------------------------------------------\n! collect xtb.trj, but skip the first point on the trj\n!---------------------------------------------------------------------\nsubroutine collect_trj_skipfirst(base,whichfile)\n  use iomod\n  implicit none\n  character(len=*) :: base,whichfile\n  character(len=256) :: str,dir\n  integer :: i\n  logical :: ex\n  i = 1\n  do\n    write (dir,'(a,i0)') trim(base),i\n    ex = directory_exist(trim(dir))\n    if (.not.ex) then\n      exit\n    else\n      write (str,'(a,a,''xtb.trj'')') trim(dir),'/'\n      call TRJappendto_skipfirst(trim(str),whichfile)\n      i = i+1\n    end if\n  end do\n  return\nend subroutine collect_trj_skipfirst\n\n!------------------------------------------------------------------------\n! writes the Input coord to the first position of crest_rotamers_*.xyz\n!------------------------------------------------------------------------\nsubroutine append_INPUT_to(fnam,newtag)\n  use iomod\n  use crest_data\n  use strucrd,only:coord2xyz\n  implicit none\n  character(len=*)  :: fnam\n  character(len=80) :: tmpnam,inam,onam\n  character(len=*) :: newtag\n\n  tmpnam = 'ensemble.xyz.tmp'\n  call checkname_xyz(crefile,inam,onam)\n\n  call coord2xyz(fnam,trim(tmpnam))\n  call addoriginXYZ(trim(tmpnam),trim(newtag))\n\n  call appendto(inam,tmpnam)\n  call remove(inam)\n  call rename(tmpnam,inam)\n  return\nend subroutine append_INPUT_to\n\n!-------------------------------------------------------------------------\n! print the number of remaining files in an ensemble file for a given energy window\n!-------------------------------------------------------------------------\nsubroutine remaining_in(filename,ewin,nall)\n  use strucrd,only:rdensembleparam,rdensemble\n  implicit none\n  integer :: nall\n  real*8 :: ewin\n  character(len=*) :: filename\n  integer :: k,nat\n\n  open (newunit=k,file=trim(filename))\n  read (k,*) nat\n  close (k)\n\n  call rdensembleparam(trim(filename),nat,nall)\n\n  if (nall .lt. 1) then\n    write (*,*) 'No conformer was left. Something must be seriously wrong.'\n    write (*,*) 'Terminating the run.'\n    error stop\n  end if\n\n  write (*,'(1x,i0,'' structures remain within '',f8.2,'' kcal/mol window'')') &\n  &        nall,ewin\n  return\nend subroutine remaining_in\n\n!-------------------------------------------------------------------------\n! print the number of remaining files in an ensemble file for a given energy window\n!-------------------------------------------------------------------------\nsubroutine sort_and_check(env,filename)\n  use crest_parameters\n  use crest_data\n  use iomod\n  use strucrd,only:rdensembleparam,rdensemble\n  implicit none\n\n  type(systemdata) :: env\n  real(wp) :: ewin\n  character(len=*) :: filename\n  integer :: nallin,nallout,nallthr\n  real(wp) :: nthr,increase\n\n  character(len=80) :: inpnam,outnam\n\n  increase = 1.5d0  ! factor 1.5 increase\n  nthr = 0.05d0     ! 5%\n\n  ewin = env%ewin\n\n  call rdensembleparam(trim(filename),env%nat,nallin) !--initial number of structures\n  call checkname_xyz(crefile,inpnam,outnam)\n  call confg_chk3(env)\n  call remaining_in(outnam,ewin,nallout) !--- remaining number of structures\n\n  if (.not.env%entropic) then !don't do this for entropy mode\n    nallthr = nint(float(nallin)*nthr)\n    if (nallout .lt. nallthr) then\n      write (*,'(1x,''This is less than '',i0,''% of the initial '',i0,'' structures.'')') &\n      & nint(nthr*100.0d0),nallin\n      write (*,'(1x,''Increasing energy window to include more...'')')\n      call remove(outnam)                    !--- delete this file since it contains to few structures\n      env%ewin = ewin*increase\n      call confg_chk3(env)\n      call remaining_in(outnam,ewin*increase,nallout) !--- remaining number of structures\n    end if\n  end if\n\n  return\nend subroutine sort_and_check\n\n!--------------------------------------------------------------------------------------------\n! collect all the backup ensembles from the different runs into a new file.\n!--------------------------------------------------------------------------------------------\nsubroutine collectcre(env)\n  use iomod\n  use crest_data\n  implicit none\n\n  type(systemdata) :: env\n\n  character(len=80) :: atmp,btmp\n  character(len=80) :: crename\n  integer :: i\n  logical :: ex\n\n  !---- remove crest_romtamer and crest_conformer files\n  call rmcres()\n\n  !---- get the crename\n  call checkname_xyz(crefile,crename,btmp)\n\n  do i = 1,env%Maxrestart\n    call checkname_xyz('.cre',atmp,btmp)\n    inquire (file=atmp,exist=ex)\n    if (.not.ex) exit\n    call appendto(trim(atmp),trim(crename))\n    call remove(atmp)\n  end do\n  call rmrfw('.cre_')\n  return\nend subroutine collectcre\n\n!--------------------------------------------------------------------------------------------\n! check lower found\n!--------------------------------------------------------------------------------------------\nsubroutine elowcheck(lower,env)\n  use crest_parameters\n  use iomod\n  use crest_data\n  use strucrd,only:xyz2coord\n  implicit none\n  type(systemdata) :: env\n  real(wp) :: ediff,ethr,ewin\n  logical :: lower\n\n!--- some defaults\n  ethr = env%ethr  !ETHR threshold that is also used in CREGEN (=0.05 kcal/mol)\n  if (env%entropic) then !except for entropy mode\n    ethr = 0.1_wp\n  end if\n  ewin = env%ewin\n  lower = .false.\n\n  ediff = (env%eprivious-env%elowest)*autokcal\n  if (ediff .ge. ethr) then\n    write (*,'(1x,a)') '...............................................'\n    write (*,'(1x,a)') 'A new lower conformer was found!'\n    write (*,'(1x,a,f10.5,a,f10.5,a)') 'Improved by ',ediff/autokcal,' Eh or ',ediff,'kcal/mol'\n    write (*,'(1x,a)') '...............................................'\n    env%eprivious = env%elowest\n    lower = .true.\n    if (.not.env%allowrestart) then\n      lower = .false.\n      return\n    end if\n    if (env%entropic) then\n      write (*,'(1x,a)') 'Restart based on new lowest structure.'\n      call clean_V2i\n      call rmrfw('crest_entropy_rotamer_')\n      return\n    end if\n    !---- clean the dir\n    call clean_V2i\n    !---- save the new best conformer\n    call XYZappendto('crest_best.xyz','.history.xyz')\n    call xyz2coord('crest_best.xyz','coord') !new reference coord to start the MTDs with\n  else\n    lower = .false.\n  end if\n\n  return\nend subroutine elowcheck\n\n!-----------------------------------------------------------------------\n! diatomic \"error\" catcher ---> we will have no conformers\n!-----------------------------------------------------------------------\nsubroutine catchdiatomic(env)\n  use crest_parameters\n  use crest_data\n  use strucrd\n  use iomod\n  implicit none\n  type(systemdata) :: env\n  type(coord) :: strc\n  integer :: ich\n  character(len=1024) :: jobcall\n\n  call strc%open('coord')\n\n  open (file=conformerfile,newunit=ich)\n  strc%xyz = strc%xyz*bohr !to ang\n  call wrxyz(ich,strc%nat,strc%at,strc%xyz)\n  close (ich)\n  !create the system call (it is the same for every optimization)\n  write (jobcall,'(a,1x,a,1x,a,'' --opt '',a,1x,a,'' --ceasefiles  >xtb.out'')') &\n &    trim(env%ProgName),conformerfile,trim(env%gfnver),trim(env%solv),' 2>/dev/null'\n  call command(trim(jobcall), ich)\n  call copy('xtbopt.xyz',conformerfile)\n  call copy(conformerfile,'crest_rotamers.xyz')\n  call copy(conformerfile,'crest_best.xyz')\n\n  call strc%deallocate\n  return\nend subroutine catchdiatomic\n\n!-------------------------------------------------------------------------------------!\n! entropy ensemble file copy routine\n!-------------------------------------------------------------------------------------!\nsubroutine emtdcopy(env,iter,stopiter,broken)\n  use crest_parameters\n  use crest_data\n  use iomod\n  use strucrd\n  implicit none\n  type(systemdata) :: env\n  integer :: iter,iter2\n  logical :: stopiter\n  logical,intent(inout) :: broken\n  integer :: i,nall\n  real(wp) :: nallfrac\n  real(wp) :: sdiff\n  logical :: ex,conv1,conv2\n  character(len=80) :: atmp,btmp\n  character(len=80) :: crename\n  character(len=22),parameter :: sfile = 'crest_entropy_rotamer_'\n  character(len=11),parameter :: bfile = 'crest_smtd_'\n  character(len=:),allocatable :: filname\n  real(wp) :: T,S,Cp\n  integer :: nt\n\n  stopiter = .false.\n  broken = .false.\n  T = 298.15d0\n!>--- determine temperature dependence\n  if (.not.allocated(env%thermo%temps)) then\n    call env%thermo%get_temps()\n  end if\n  nt = env%thermo%ntemps\n!>--- space to save S,Cp,H(T) at different temperatures\n  if (.not.allocated(env%emtd%soft)) then\n    allocate (env%emtd%soft(nt),source=0.0d0)\n  end if\n  if (.not.allocated(env%emtd%cpoft)) then\n    allocate (env%emtd%cpoft(nt),source=0.0d0)\n  end if\n  if (.not.allocated(env%emtd%hoft)) then\n    allocate (env%emtd%hoft(nt),source=0.0d0)\n  end if\n\n!>--- output file name\n  if (env%crestver == crest_imtd2) then\n    filname = trim(bfile)\n  else\n    filname = trim(sfile)\n  end if\n\n!>--- Setup in the very first call\n  if (iter == 0) then\n    call checkname_xyz(crefile,atmp,crename)\n    write (btmp,'(a,i0,a)') filname,iter,'.xyz'\n    call rename(trim(atmp),trim(btmp))\n    call rmrfw('crest_rotamers_')\n    call rmrfw('.data')\n    env%emtd%sapproxlast = env%emtd%sapprox\n    call rdensembleparam(conformerfile,i,nall)\n    env%emtd%nconflast = nall\n    call entropic(env,.false.,.true.,.true.,trim(btmp),T,S,Cp)\n    call writesdata(env,nall,iter)\n    return\n  end if\n\n!>--- Setup in the iterations\n  if (iter >= 1) then\n    call checkname_xyz(crefile,atmp,crename)\n    iter2 = iter-1\n    write (btmp,'(a,i0,a)') filname,iter2,'.xyz' !-- file from last iter.\n    inquire (file=trim(btmp),exist=ex)\n    if (ex) then\n      call appendto(trim(btmp),trim(atmp)) !-- cat together\n      call newcregen(env,2)\n      sdiff = (env%emtd%sapproxlast/env%emtd%sapprox)\n      sdiff = 1.0d0-sdiff\n      sdiff = abs(sdiff)     !can dS be negative?\n      if (sdiff < 0.0d0) then\n        broken = .true.\n      else\n        broken = .false.\n        env%emtd%sapproxlast = env%emtd%sapprox\n      end if\n    end if\n  end if\n\n!>--- run checks\n  if (.not.broken) then\n    call checkname_xyz(crefile,crename,btmp)\n    write (btmp,'(a,i0,a)') filname,iter,'.xyz'\n    call rename(trim(crename),trim(btmp))\n  end if\n\n  call rdensembleparam(conformerfile,i,nall)\n  if (nall > 50000) then !safety fallback for extremely large ensembles (e.g. C18)\n    env%emtd%confthr = 0.1d0\n  end if\n!>---get convergence criteria\n  nallfrac = 1.0d0-(float(env%emtd%nconflast)/float(nall))\n  conv1 = (sdiff < env%emtd%sconvthr) !.and.(sdiff > 0.0d0)\n  conv2 = (nallfrac < env%emtd%confthr).and.(nallfrac >= 0.0d0)\n  if (nallfrac < 0.0d0) then !> if we for some reason got less conformers in this iteration\n    broken = .true.\n  end if\n  write (*,*)\n  write (*,'(1x,a,i0,a)') 'Static MTD simulation iteration ',iter,' finished'\n  write (*,'(1x,a,i0,a,f5.2,a,a)') 'A total of ',nall,' conformers (+',  &\n  &    nallfrac*100.0d0,'%) in ',conformerfile\n  write (*,'(1x,a,f12.6,a,f5.2,a)') 'S(approx.) =',env%emtd%sapprox, &\n  &     ' cal/molK (dS =',sdiff*100.0d0,'%)'\n  write (*,'(1x,a,l)') 'Convergence w.r.t. conformers: ',conv2\n  write (*,'(1x,a,l)') 'Convergence w.r.t. entropy   : ',conv1\n  write (*,*)\n\n  if (.not.broken) then !-- NORMAL case\n    if (conv1.and.conv2) then\n      stopiter = .true.\n      if (iter < env%emtd%iter) then\n        call copy(trim(btmp),trim(crename))\n      end if\n    end if\n    if (env%entropic.and.env%crestver .ne. crest_imtd2) then\n      call entropic(env,.false.,.true.,.true.,trim(btmp),T,S,Cp)\n      call writesdata(env,nall,iter)\n    end if\n!>--- save data for next iteraton\n    env%emtd%nconflast = nall\n    env%emtd%sapproxlast = env%emtd%sapprox\n  else                !-- ROLLBACK\n    !--- NOTE: instead of exiting one could also try to re-do the iteration,\n    !          but this is commented out. Relevant comments are marked by \"!*\"\n    write (*,'(1x,a)') 'Warning: Nconf DECREASED, which is unphysical.'\n    !write(*,'(1x,a)') 'Trying to re-do last iteration ...'   !*\n    write (*,'(1x,a)') 'Rewind ensemble and exit iterations ...'    !*\n    call checkname_xyz(crefile,crename,btmp)\n    call remove(crename)\n    write (btmp,'(a,i0,a)') filname,iter-1,'.xyz'\n    call copy(trim(btmp),trim(crename))\n    call xyz2coord(trim(crename),'coord')  !get the right coord again\n    call newcregen(env,2) !get the right crest_conformers again\n    iter = iter-1  !*\n    stopiter = .true.\n  end if\n\n  if (iter < env%emtd%iter.and..not.stopiter) then\n    call rmrfw('crest_rotamers_')\n  end if\n  return\ncontains\n  subroutine writesdata(env,nall,inum)\n    implicit none\n    type(systemdata) :: env\n    integer :: nall\n    integer :: inum\n    character(len=64) :: adum\n    integer :: ich,nt,i\n    nt = env%thermo%ntemps\n    write (adum,'(a,i0)') 'Sdata',inum\n    open (newunit=ich,file=trim(adum))\n    write (ich,*) nall\n    do i = 1,nt\n      write (ich,'(3F18.10)') env%emtd%soft(i), &\n      &   env%emtd%Cpoft(i),env%emtd%hoft(i)\n    end do\n    close (ich)\n    return\n  end subroutine writesdata\nend subroutine emtdcopy\n\nsubroutine emtdcheckempty(env,empty,nbias)\n  use crest_data\n  use strucrd\n  use iomod\n  implicit none\n  type(systemdata) :: env\n  logical :: empty\n  integer :: nbias\n  integer :: i,nall\n  character(len=128) :: atmp,btmp\n  call checkname_xyz(crefile,atmp,btmp)\n  call rdensembleparam(trim(atmp),i,nall)\n  empty = .false.\n\n  if (nall < 1) then\n    call remove(trim(atmp))\n    if (env%emtd%maxfallback > 1) then\n      write (*,'(1x,a)') 'Empty ensemble, retry iteration with less bias ...'\n    else\n      write (*,'(1x,a)') 'Empty ensemble, skipping ahead ...'\n    end if\n    call remove('crest_clustered.xyz')\n    call remove('crest_bias.xyz')\n    nbias = nbias-1\n    nbias = max(0,nbias)\n    empty = .true.\n  end if\n  return\nend subroutine emtdcheckempty\n\n!========================================================================!\n! Sample additional OH orientations\n!========================================================================!\nsubroutine XHorient(env,infile)\n  use crest_parameters\n  use crest_data\n  use strucrd\n  use zdata\n  use iomod\n  implicit none\n  type(systemdata) :: env\n  character(len=*) :: infile\n  integer :: nat,nall\n  character(len=:),allocatable :: newfile\n  newfile = 'oh_ensemble.xyz'\n  !--- shouldn't cost much\n  call ohflip_ensemble(infile,env%maxflip)\n  call rdensembleparam(newfile,nat,nall)\n  !--- only proceed if there are potential new structures\n  if (nall > 0) then\n    call smallhead('Additional orientation sampling')\n    call MDopt_para(env,newfile,0)\n    !---- printout and copy\n    call rename('OPTIM'//'/'//'opt.xyz',trim(newfile))\n    call rmrf('OPTIM')\n  else\n    call remove(newfile)\n  end if\n  return\nend subroutine XHorient\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/confscript2_misc.f90 b/src/legacy_algos/confscript2_misc.f90
--- a/src/legacy_algos/confscript2_misc.f90	
+++ b/src/legacy_algos/confscript2_misc.f90	
@@ -23,6 +23,7 @@
 subroutine xtbsp_legacy(env,xtblevel)
   use crest_parameters
   use iomod
+  use utilities
   use crest_data
   implicit none
   type(systemdata) :: env
@@ -61,7 +62,7 @@
 !---- new plain coord file
   fname = 'tmpcoord'
   call copy('coord',fname)
-  call clear_setblock(fname)
+
 !---- jobcall
   jobcall = ""
   jobcall = trim(jobcall)//trim(env%ProgName)
@@ -130,7 +131,7 @@
 !--------------------------------------------------------------------------------------------
 ! A quick xtb geometry optimization at the beginning of the program
 !--------------------------------------------------------------------------------------------
-subroutine xtbopt(env)
+subroutine xtbopt_legacy(env)
   use crest_parameters
   use iomod
   use crest_data
@@ -147,6 +148,7 @@
   integer :: ntopo
   integer,allocatable :: topo(:)
   logical :: tchange = .false.
+  logical :: ex 
 
 !---- small header
   write (*,*)
@@ -166,9 +168,8 @@
   end if
 !---- new plain coord file
   fname = 'tmpcoord'
-  !call copy('coord',fname)
   call wrc0(fname,env%ref%nat,env%ref%at,env%ref%xyz)
-  call clear_setblock(fname)
+
 !---- coord setup section
   open (newunit=ich,file=fname)
   do
@@ -202,52 +203,17 @@
   call command(trim(jobcall), io)
 
   call minigrep('xtb.out','optimized geometry written to:',fin)
-  if (.not.fin) then
-    write (*,*)
-    write (*,*) ' Initial geometry optimization failed!'
-    write (*,*) ' Please check your input.'
-    error stop
-  end if
-  write (*,*) 'Geometry successfully optimized.'
-!---- if necessary, check if the topology has changed!
-  call mol%open('xtbopt.coord')
-  if (allocated(env%ref%topo)) then
-    ntopo = mol%nat*(mol%nat+1)/2
-    allocate (topo(ntopo))
-    call quicktopo(mol%nat,mol%at,mol%xyz,ntopo,topo)
-    do i = 1,ntopo
-      if (topo(i) .ne. env%ref%topo(i)) tchange = .true.
-    end do
-    if (tchange) then
-      write (*,'(1x,a)') 'WARNING! Change in topology detected!'
-      !--- either update the topology (see option B below)
-      if (.not.env%reftopo) then
-        env%ref%topo = topo
-        !--- or abort the run
-      else
-        write (*,'(1x,a)') 'The topology change was seen in the initial geometry optimization.'
-        write (*,'(1x,a,a,a)') 'This could be an artifact of the chosen theory level (',trim(env%gfnver),').'
-        write (*,'(1x,a)') 'You can check the optimization trajectory in the "xtbopt.log" file.'
-        write (*,'(1x,a)') 'Try either of these options:'
-        write (*,'(/,4x,a)') 'A) Pre-optimize your input seperately with xtb and use the optimized'
-        write (*,'(4x,a)') '   structure as input for CREST. (Only recommended if structure is intact)'
-        write (*,'(/,4x,a)') 'B) Restart the same CREST call as before, but ignore the topology change'
-        write (*,'(4x,a)') '   by using the "--noreftopo" keyword. (May produce artifacts)'
-        write (*,'(/,4x,a)') 'C) Fix the initial input geometry by introducing bond length constraints'
-        write (*,'(4x,a)') '   or by using a method with fixed topology (GFN-FF).'
-        write (*,*)
-        error stop 'abnormal termination of crest'
-      end if
-    end if
-  end if
-!---- update reference with optimized geometry
-  env%ref%nat = mol%nat
-  env%ref%at = mol%at
-  env%ref%xyz = mol%xyz
+  inquire(file='xtbopt.coord',exist=ex)
+  if(ex)then
+    call mol%open('xtbopt.coord')
+  endif
+
+!>--- process the optimization status
+  call trialOPT_warning(env,mol,fin)
   call mol%deallocate()
   call rename('xtbopt.coord','coord')
 
-!---- cleanup
+!>---- cleanup
   call remove(fname)
   call remove('xtb.out')
   call remove('energy')
@@ -257,17 +223,18 @@
   call remove('xtbopt.log')
   call remove('xtbrestart')
   call remove('gfnff_topo')
-end subroutine xtbopt
+end subroutine xtbopt_legacy
 
-!--------------------------------------------------------------------------------------------
+!------------------------------------------------------------------------------
 ! A single METADYN run (resp. its setup)
-!--------------------------------------------------------------------------------------------
+!------------------------------------------------------------------------------
 subroutine MetaMD(env,nr,mdtime,fac,expo,dumplist)
   use iso_c_binding
   use crest_parameters
   use iomod
   use crest_data
   use strucrd,only:wrc0,rdensembleparam,rdensemble
+  use utilities
   implicit none
   type(systemdata) :: env
 
@@ -327,13 +294,14 @@
   end associate
 end subroutine MetaMD
 
-!--------------------------------------------------------------------------------------------
+!-----------------------------------------------------------------------------
 ! Run several METADYN in parallel, OMP VERSION!
-!--------------------------------------------------------------------------------------------
+!-----------------------------------------------------------------------------
 subroutine MetaMD_para_OMP(env)
   use crest_parameters
   use iomod
   use crest_data
+  use utilities
   implicit none
 
   type(systemdata) :: env
@@ -432,6 +400,7 @@
   use crest_data
   use iomod
   use strucrd,only:rdensembleparam,rdensemble,wrxyz
+  use utilities
   implicit none
   type(systemdata) :: env
   character(len=*),intent(in)  :: ensnam
@@ -584,6 +553,7 @@
   use crest_parameters
   use iomod
   use crest_data
+  use utilities
   implicit none
 
   type(systemdata) :: env
@@ -719,6 +689,7 @@
  &                   mdskip,mddump,nvt,cts)
   use crest_parameters
   use crest_data
+  use utilities
   implicit none
   type(constra) :: cts
   character(len=*) :: fname
@@ -857,6 +828,7 @@
   use crest_parameters
   use crest_data
   use iomod
+  use utilities
   implicit none
   type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
   real(wp) :: ewinbackup
@@ -971,6 +943,7 @@
 !---------------------------------------------------------------------
 subroutine collect_trj_skipfirst(base,whichfile)
   use iomod
+  use utilities
   implicit none
   character(len=*) :: base,whichfile
   character(len=256) :: str,dir
@@ -998,6 +971,7 @@
   use iomod
   use crest_data
   use strucrd,only:coord2xyz
+  use utilities
   implicit none
   character(len=*)  :: fnam
   character(len=80) :: tmpnam,inam,onam
@@ -1019,13 +993,17 @@
 ! print the number of remaining files in an ensemble file for a given energy window
 !-------------------------------------------------------------------------
 subroutine remaining_in(filename,ewin,nall)
+  use crest_parameters
+  use crest_restartlog, only: restart_write_dummy
   use strucrd,only:rdensembleparam,rdensemble
   implicit none
   integer :: nall
-  real*8 :: ewin
+  real(wp) :: ewin
   character(len=*) :: filename
   integer :: k,nat
 
+  call restart_write_dummy(trim(filename))
+
   open (newunit=k,file=trim(filename))
   read (k,*) nat
   close (k)
@@ -1051,6 +1029,7 @@
   use crest_data
   use iomod
   use strucrd,only:rdensembleparam,rdensemble
+  use utilities
   implicit none
 
   type(systemdata) :: env
@@ -1093,10 +1072,9 @@
 subroutine collectcre(env)
   use iomod
   use crest_data
+  use utilities
   implicit none
-
   type(systemdata) :: env
-
   character(len=80) :: atmp,btmp
   character(len=80) :: crename
   integer :: i
@@ -1127,6 +1105,7 @@
   use iomod
   use crest_data
   use strucrd,only:xyz2coord
+  use utilities 
   implicit none
   type(systemdata) :: env
   real(wp) :: ediff,ethr,ewin
@@ -1180,15 +1159,15 @@
   use iomod
   implicit none
   type(systemdata) :: env
-  type(coord) :: strc
+  type(coord) :: mol
   integer :: ich
   character(len=1024) :: jobcall
 
-  call strc%open('coord')
+  call mol%open('coord')
 
   open (file=conformerfile,newunit=ich)
-  strc%xyz = strc%xyz*bohr !to ang
-  call wrxyz(ich,strc%nat,strc%at,strc%xyz)
+  mol%xyz = mol%xyz*bohr !to ang
+  call wrxyz(ich,mol%nat,mol%at,mol%xyz)
   close (ich)
   !create the system call (it is the same for every optimization)
   write (jobcall,'(a,1x,a,1x,a,'' --opt '',a,1x,a,'' --ceasefiles  >xtb.out'')') &
@@ -1198,7 +1177,7 @@
   call copy(conformerfile,'crest_rotamers.xyz')
   call copy(conformerfile,'crest_best.xyz')
 
-  call strc%deallocate
+  call mol%deallocate
   return
 end subroutine catchdiatomic
 
@@ -1210,6 +1189,7 @@
   use crest_data
   use iomod
   use strucrd
+  use utilities 
   implicit none
   type(systemdata) :: env
   integer :: iter,iter2
@@ -1376,6 +1356,7 @@
   use crest_data
   use strucrd
   use iomod
+  use utilities 
   implicit none
   type(systemdata) :: env
   logical :: empty
Index: src/legacy_algos/deprotonate.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=========================================================================!\n! AUTOMATED DEPROTONATION AND ENERGETIC RANKING SCRIPT\n! To use run:\n!    crest <input> --deprotonate\n!========================================================================!\n\nsubroutine deprothead\n      implicit none\n      write(*,*)'       __________________________________________'\n      write(*,*)'      |                                          |'\n      write(*,*)'      |      automated deprotonation script      |'\n      write(*,*)'      |__________________________________________|'\n      write(*,*)' Universitaet Bonn, MCTC'\n      write(*,*)' P.Pracht, Wed 28. Nov 13:11:52 CEST 2018'\n      write(*,*)\nend subroutine deprothead\n\n!--------------------------------------------------------------------------------------------\n! Protonation workflow with GFNn-xTB\n!--------------------------------------------------------------------------------------------\nsubroutine deprotonate(env,tim)\n      use crest_parameters\n      use crest_data\n      use iomod\n      use strucrd, only: rdnat,rdcoord,i2e\n      implicit none\n      type(systemdata) :: env\n      type(timer)      :: tim\n      type(protobj)    :: deprot\n\n      real(wp),allocatable :: xyz(:,:)\n      integer,allocatable  :: at(:)\n\n      integer :: i,j\n      character(len=64)  :: deprotname\n      character(len=256) :: thispath\n      character(len=256) :: filename\n      character(len=128) :: inpnam,outnam\n\n      integer :: ich\n      integer :: natp,nallout,refchrg\n\n!--- printout & clean directory\n      call deprotclean\n      call deprothead\n\n      if(.not.allocated(env%ptb%atmap))allocate(env%ptb%atmap(env%nat))\n      if(.not.env%ptb%strictPDT .and. .not.env%ptb%fixPDT)then\n!--- sort the input file (H atoms to the bottom)\n        call htothebottom('coord',env%chrg,env%nat,env%ptb%atmap)\n      else\n!--- or sort AND apply heavy atom bond constraints\n         call PDT_constraints(env)\n      endif\n\n!--- get some settings\n      call getcwd(thispath)\n      deprotname='deprotonate_0.xyz'\n      deprot=env%ptb\n      refchrg = env%chrg\n      deprot%newchrg = env%chrg - 1  !increase chrg by one\n      env%chrg = env%chrg - 1  !in the new version all calculations access env%chrg!!!\n      natp=env%nat - 1 !additional proton, Nat is increased by one\n     \n!--- write a file with all the possible deprotonated structures\n      call tim%start(1,'INPUT generation')\n      allocate(xyz(3,env%nat),at(env%nat))\n      call rdcoord('coord',env%nat,at,xyz)\n      open(newunit=ich,file=deprotname)\n\n      do i=1,env%nat\n         if(at(i).ne.1)cycle\n         write(ich,'(1x,i6)') natp\n         write(ich,*)\n         do j=1,env%nat\n             if(i.eq.j) then\n                 cycle\n             else\n                 write(ich,'(a2,2x,3F16.10)')i2e(at(j),'nc'),xyz(1:3,j)*bohr\n             endif\n         enddo\n      enddo\n\n      close(ich)\n      deallocate(at,xyz)\n      call tim%stop(1)\n      \n!--- get the new charge and set up the calculations\n     call tim%start(2,'multilevel OPT')\n     open(newunit=ich,file='.CHRG')\n     write(ich,*) deprot%newchrg     !new charge written here\n     close(ich)\n     env%nat=natp  !required so that MDopt_para works\n\n     write(*,'(''-----------------------'')')\n     write(*,'(''Multilevel Optimization'')')\n     write(*,'(''-----------------------'')')\n\n     call smallhead('1. crude pre-optimization')\n     call checkname_xyz('deprotonate',inpnam,outnam)\n     call MDopt_para(env,deprotname,1)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        if(deprot%ABcorrection)then\n          call deprot_correction(env,trim(filename))\n        endif\n        deprot%ewin=deprot%ewin*3.0d0\n        call sort_ens(deprot,outnam,.false.)\n        call remaining_in(outnam,deprot%ewin,nallout) !--- remaining number of structures\n        write(*,*)\n\n     call smallhead('2. loose optimization')\n     call checkname_xyz('deprotonate',inpnam,outnam)\n     call MDopt_para(env,inpnam,2)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        if(deprot%ABcorrection)then\n          call deprot_correction(env,trim(filename))\n        endif\n        deprot%ewin=deprot%ewin*(2.0d0/3.0d0)\n        call sort_ens(deprot,outnam,.false.)\n        call remaining_in(outnam,deprot%ewin,nallout) !--- remaining number of structures\n        write(*,*)\n\n     call smallhead('3. optimization with user-defined thresholds')\n     call checkname_xyz('deprotonate',inpnam,outnam)\n     call MDopt_para(env,inpnam,0)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call rmrf('OPTIM')\n        if(deprot%ABcorrection)then\n          call deprot_correction(env,trim(filename))\n        endif\n        deprot%ewin=deprot%ewin/2.0d0\n        call sort_ens(deprot,outnam,.false.)\n        call remaining_in(outnam,deprot%ewin,nallout) !--- remaining number of structures\n\n\n     call cosort(outnam,'deprotonated.xyz',.false.,.false.)\n     call sort_ens(deprot,'deprotonated.xyz',.true.)\n     call tim%stop(2)\n\n!>--- (optional) post-processing\n     if(env%relax)then\n       env%rednat = env%rednat - 1\n       call relaxensemble('deprotonated.xyz',env,tim)\n     endif\n\n     if(env%outputsdf)then\n     call new_wrsdfens(env,'deprotonated.xyz','deprotonated.sdf',.true.)\n     endif\n\n!--- reset data for main dir\n     env%chrg = refchrg\n     if(env%chrg .eq. 0) then\n       call remove('.CHRG')\n     else\n       open(newunit=ich,file='.CHRG')\n       write(ich,*) env%chrg\n       close(ich)\n     endif\n     env%nat=natp + 1 !reset nat\n     !call chdir(thispath)\n\n     return\nend subroutine deprotonate\n\n!----------------------------------------------------!\n! for every structure calculate an correction\n! to the acid/base reaction\n!----------------------------------------------------!\nsubroutine deprot_correction(env,iname)\n    use crest_parameters\n    use crest_data\n    use strucrd\n    implicit none\n    type(systemdata) :: env\n    character(len=*) :: iname\n    integer :: nat,nall\n    integer,allocatable :: at(:)\n    real(wp),allocatable :: xyz(:,:,:)\n    real(wp),allocatable :: eread(:)\n    integer :: i\n    real(wp) :: dE\n    real(wp) :: acidchrg\n    real(wp) :: d1,d2,d3,d4,d5,d6\n    write(*,'(1x,a)') 'Calculate acid/base correction ...'\n    call rdensembleparam(iname,nat,nall)\n    allocate(xyz(3,nat,nall),eread(nall),at(nat))\n    call rdensemble(iname,nat,nall,at,xyz,eread)\n\n    acidchrg = env%chrg\n    do i=1,nall\n     call wrxyz('base.xyz',nat,at,xyz(:,:,i))\n     call acidbase(env,'coord','base.xyz',acidchrg,.true.,.false.,dE, &\n         &  .false.,d1,d2,d3,d4,d5,d6)\n     !eread(i) = eread(i) + dE\n     eread(i) = d4+d6+dE\n    enddo\n\n    call wrensemble(iname,nat,nall,at,xyz,eread)\n\n    return\nend subroutine deprot_correction\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/deprotonate.f90 b/src/legacy_algos/deprotonate.f90
--- a/src/legacy_algos/deprotonate.f90	
+++ b/src/legacy_algos/deprotonate.f90	
@@ -42,6 +42,7 @@
       use crest_data
       use iomod
       use strucrd, only: rdnat,rdcoord,i2e
+      use utilities
       implicit none
       type(systemdata) :: env
       type(timer)      :: tim
Index: src/algos/refine.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/refine.f90 b/src/algos/refine.f90
new file mode 100644
--- /dev/null	
+++ b/src/algos/refine.f90	
@@ -0,0 +1,122 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+subroutine crest_refine(env,input,output)
+!*******************************************************************
+!* subroutine crest_refine
+!* This subroutine will process the ensemble specified by "input"
+!* and either overwrite it or write a new file "output".
+!* The routine is intended to be called after geometry optimization
+!* to re-rank structures by singlepoint energies, or add other
+!* contributions to the energy.
+!*******************************************************************
+  use crest_parameters
+  use crest_data
+  use crest_calculator
+  use strucrd
+  implicit none
+  type(systemdata),intent(inout) :: env
+  character(len=*),intent(in) :: input
+  character(len=*),intent(in),optional :: output
+!===========================================================!
+  integer :: i,j,k,l,io,ich,m
+  logical :: pr,wr,ex
+!===========================================================!
+  character(len=:),allocatable :: outname
+  real(wp) :: energy,gnorm
+  real(wp),allocatable :: grad(:,:)
+  character(len=:),allocatable :: ensnam
+  integer :: nat,nall
+  real(wp),allocatable :: eread(:),etmp(:)
+  real(wp),allocatable :: xyz(:,:,:)
+  integer,allocatable  :: at(:)
+  integer :: nrefine,refine_stage
+!===========================================================!
+!>--- setup
+  if (present(output)) then
+    outname = output !> new file
+  else
+    outname = input  !> overwrite
+  end if
+  call rdensemble(input,nat,nall,at,xyz,eread)
+  allocate (etmp(nall),source=0.0_wp)
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+!>--- Important: crest_sploop requires coordinates in Bohrs
+    xyz = xyz / bohr
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+
+!===========================================================!
+  DO_REFINE: if (allocated(env%refine_queue)) then
+!===========================================================!
+
+    call smallhead('ensemble refinement')
+
+    nrefine = size(env%refine_queue,1)
+
+    do i = 1,nrefine
+      refine_stage = env%refine_queue(i)
+      !> set the calculator to the correct stage
+      env%calc%refine_stage = refine_stage
+
+      select case (refine_stage)
+      case (refine%singlepoint)
+        write (stdout,'("> Singlepoint re-ranking for ",i0," structures")') nall
+        call crest_sploop(env,nat,nall,at,xyz,eread)
+
+      case (refine%correction)
+        write (stdout,'("> Additive correction for ",i0," structures")') nall
+        call crest_sploop(env,nat,nall,at,xyz,etmp)
+        eread(:) = eread(:)+etmp(:)
+
+      case (refine%geoopt)
+        write (stdout,'("> Geometry optimization of ",i0," structures")') nall
+        call crest_oloop(env,nat,nall,at,xyz,eread,.false.)
+
+      case(refine%confsolv)
+        write (stdout,'("> ConfSolv: ΔΔGsoln estimation from 3D directed message passing neural networks (D-MPNN)")')
+        call confsolv_request( input, nall, env%threads, etmp, io)
+        !eread(:) = eread(:) + etmp(:)
+        if(io == 0)then
+        eread(:) = etmp(:)*kcaltoau  !> since CREGEN deals with Eh energies
+        endif   
+
+      end select
+      write(stdout,*) 
+    end do
+
+    !> reset the refinement stage of the calculator
+    env%calc%refine_stage = 0
+
+!===========================================================!
+  end if DO_REFINE
+!===========================================================!
+
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+!>--- Important: ensemble file must be written in AA
+  xyz = xyz / angstrom
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+!>--- write output ensemble
+  call wrensemble(outname,nat,nall,at,xyz,eread)
+
+!===========================================================!
+  deallocate (etmp,eread,xyz,at)
+  return
+end subroutine crest_refine
+!========================================================================================!
+!========================================================================================!
Index: src/utilmod.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/utilmod.f90 b/src/utilmod.f90
new file mode 100644
--- /dev/null	
+++ b/src/utilmod.f90	
@@ -0,0 +1,525 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2018-2023 Stefan Grimme, Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+module utilities
+  use crest_parameters
+  use ls_rmsd
+  implicit none
+  private
+  
+  !> subroutines
+  public :: boltz2
+  public :: boltz
+  public :: checkname_tmp
+  public :: checkname_xyz
+  public :: distance
+  public :: getanmrrc
+  public :: getname1
+  public :: heavyrmsd
+  public :: rdarg
+  public :: revlin_count
+  public :: revlin
+  public :: TRJappendto_skipfirst
+  public :: XYZappendto
+
+  !> functions
+  public :: lin
+  public :: lina
+  public :: linr
+  public :: ohbonded2
+  public :: ohbonded
+  public :: distcma
+
+!========================================================================================!
+!========================================================================================!
+contains  !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
+
+!*****************************************
+!* "lin" routines address in packed array
+!* formerly in "lin.f"
+!*****************************************
+  integer function lin(i1,i2)
+    integer ::  i1,i2,idum1,idum2
+    idum1 = max(i1,i2)
+    idum2 = min(i1,i2)
+    lin = idum2+idum1*(idum1-1)/2
+    return
+  end function lin
+!==========================================!
+  subroutine revlin(k,i,j)
+!******************************************
+!* determine i and j for a given index k
+!* (i.e., the reverse of the lin function)
+!******************************************
+    implicit none
+    integer(int64) :: k,b,x
+    integer :: i,j
+    real(wp) :: kf
+    real(wp) :: idum
+    kf = real(k,8)
+    idum = 1.0+8.0*kf
+    !idum = sqrt(idum)
+    idum = idum**0.5
+    idum = (1.0+idum)/2.0
+    i = floor(idum)
+    x = i-1
+    x = x*i
+    b = x/2
+    b = k-b
+    j = int(b)
+    return
+  end subroutine revlin
+!==========================================!
+  subroutine revlin_count(k,i,j,dimij)
+!********************************************
+!* determine i and j for a given index k
+!* by counting until k is reached
+!* (only for testing, because too expensive)
+!********************************************
+    implicit none
+    integer(int64) :: k
+    integer :: i,j
+    integer :: a,b
+    integer :: dimij
+    integer(int64) :: kdum
+    OUTER: do a = 1,dimij
+      do b = 1,a
+        kdum = lina(a,b)
+        if (kdum == k) then
+          i = a
+          j = b
+          exit OUTER
+        end if
+      end do
+    end do OUTER
+    return
+  end subroutine revlin_count
+!==========================================!
+  integer(int64) function lina(i1,i2)
+!*********************************
+!* int64 version of lin function
+!*********************************
+    integer :: i1,i2,idum1,idum2
+    idum1 = max(i1,i2)
+    idum2 = min(i1,i2)
+    lina = idum1
+    lina = lina*(idum1-1)
+    lina = lina/2
+    lina = lina+idum2
+    return
+  end function lina
+!==========================================!
+  integer(int64) function linr(o1,o2,i)
+    integer(int64) :: o1
+    integer   :: o2,i
+    linr = (o1+1)
+    linr = linr+i
+    linr = linr-o2
+    return
+  end function linr
+
+!========================================================================================!
+
+  subroutine boltz(n,t,e,p)
+!*********************************
+!* Boltzmann weighting routines
+!* formerly in "boltz.f"
+!*********************************
+    integer,intent(in) :: n
+    real(wp) :: e(*),p(*)
+    real(wp),allocatable :: e2(:)
+    real(wp) :: t,f,hsum,esum
+    integer :: i
+    allocate (e2(n))
+    !f=8.314*t/4.184d+3
+    f = 0.593d0/298.15d0
+    f = f*t
+    esum = 0
+    do i = 1,n
+      !e2(i) = (e(i) -e(1))* 627.5095
+      e2(i) = e(i)
+    end do
+
+    do i = 1,n
+      esum = esum+exp(-e2(i)/f)
+    end do
+    hsum = 0
+    do i = 1,n
+      p(i) = exp(-e2(i)/f)/esum
+    end do
+    deallocate (e2)
+  end subroutine boltz
+
+  subroutine boltz2(n,e,p)
+    implicit none
+
+    integer,intent(in)   :: n     ! Number of molecules
+    real(wp),intent(in)  :: e(n)  ! Molecule energies
+    real(wp),intent(out) :: p(n)  ! Population
+
+    !> Boltzman constant k in Eh/K
+    real(wp),parameter :: kh = 3.1668114d-6
+    !> Room temperature
+    real(wp),parameter :: T = 298.15_wp
+
+    real(wp) :: val
+    real(wp) :: denom
+    real(wp) :: emin
+    integer  :: i
+
+    p = 0.0_wp
+    emin = minval(e)
+
+    do i = 1,n
+      val = -(e(i)-emin)/(kh*T)
+      p(i) = exp(val)
+    end do
+    denom = sum(p)
+    p = p/denom
+  end subroutine boltz2
+
+!=========================================================================================!
+
+  subroutine heavyrmsd(n,nall,k,l,xyz,at,rmsdval)
+!*********************************
+!* Calculate heavy atom (+OH) RMSD
+!**********************************
+    use ls_rmsd
+    implicit none
+    integer n,at(n),j,nall,k,l,nn
+    real(wp) xyz(3,n,nall),rmsdval
+
+    logical ::  oh
+
+    real(wp),allocatable :: xyz1(:,:),xyz2(:,:)
+    !Dummys:
+    real(wp) g(3,3),U(3,3),x_center(3),y_center(3)
+    integer i
+
+    nn = 0
+    do j = 1,n
+      oh = ohbonded2(n,j,xyz(1,1,k),at)
+      if (at(j) .gt. 2.or.oh) nn = nn+1
+    end do
+    allocate (xyz1(3,nn),xyz2(3,nn))
+
+    i = 0
+    do j = 1,n
+      oh = ohbonded2(n,j,xyz(1,1,k),at)
+      if (at(j) .gt. 2.or.oh) then
+        i = i+1
+        xyz1(1:3,i) = xyz(1:3,j,k)*bohr
+        xyz2(1:3,i) = xyz(1:3,j,l)*bohr
+      end if
+    end do
+
+    call rmsd(i,xyz1,xyz2,0,U,x_center,y_center,rmsdval,.false.,g)
+
+    deallocate (xyz1,xyz2)
+  end subroutine heavyrmsd
+
+  logical function ohbonded2(n,m,xyz,at)
+    integer :: n,at(n),m,i
+    real(wp) :: xyz(3,n)
+    real(wp) :: r
+    ohbonded2 = .false.
+    if (at(m) .ne. 1) return
+
+    do i = 1,n
+      if (i .eq. m.or.at(i) .ne. 8) cycle
+      r = sqrt((xyz(1,i)-xyz(1,m))**2  &
+      &       +(xyz(2,i)-xyz(2,m))**2  &
+      &       +(xyz(3,i)-xyz(3,m))**2)
+      if (r*0.52917726d0 .lt. 1.1) then
+        ohbonded2 = .true.
+        exit
+      end if
+    end do
+
+  end function ohbonded2
+
+!--- formerly in "ohbonded.f"
+  logical function ohbonded(n,m,xyz,at,acid)
+    integer :: n,at(n),m,acid(86),i
+    real(wp) :: xyz(3,n)
+    real(wp) :: r
+
+    ohbonded = .false.
+    if (at(m) .ne. 1) return
+
+    do i = 1,n
+      if (i .eq. m) cycle
+      if (acid(at(i)) .eq. 0) cycle
+      r = sqrt((xyz(1,i)-xyz(1,m))**2  &
+      &       +(xyz(2,i)-xyz(2,m))**2  &
+      &       +(xyz(3,i)-xyz(3,m))**2)
+      if (r*0.52917726d0 .lt. 1.2) then
+        ohbonded = .true.
+        exit
+      end if
+    end do
+
+  end function ohbonded
+
+!========================================================================================!
+
+  subroutine distance(n,xyz,r)
+    implicit none
+    integer,intent(in) :: n
+    real(wp),intent(inout) :: r(:,:)
+    real(wp),intent(in) :: xyz(3,n)
+    real(wp) :: dx,dy,dz
+    integer :: i,j
+    do i = 1,n
+      do j = 1,n
+        dx = xyz(1,j)-xyz(1,i)
+        dy = xyz(2,j)-xyz(2,i)
+        dz = xyz(3,j)-xyz(3,i)
+        r(j,i) = sqrt(dx*dx+dy*dy+dz*dz)
+      end do
+      r(i,i) = 0
+    end do
+  end subroutine distance
+
+  real(wp) function distcma(n,j,xyz)
+    implicit none
+    integer,intent(in) :: n,j
+    real(wp),intent(in) :: xyz(3,n)
+    real(wp) :: dx,dy,dz
+    dx = xyz(1,j)
+    dy = xyz(2,j)
+    dz = xyz(3,j)
+    distcma = sqrt(dx*dx+dy*dy+dz*dz)
+  end function distcma
+
+!========================================================================================!
+
+  subroutine checkname_tmp(base,fname,checkname)
+!************************************************
+!* Iterate X through files called <base>_<X>.tmp
+!* And returns the file names
+!* <base>_<X>.tmp as <fname>
+!* and <base>_<X+1>.tmp as <checkname>
+!***********************************************
+    character(len=*) :: base,fname,checkname
+    integer :: i,j
+    logical :: ex
+    i = 0
+    do
+      write (checkname,'(a,''_'',i0,''.tmp'')') trim(base),i
+      inquire (file=trim(checkname),exist=ex)
+      if (ex) then
+        i = i+1
+      else
+        exit
+      end if
+    end do
+    j = max(0,i-1)
+    write (fname,'(a,''_'',i0,''.tmp'')') trim(base),j
+  end subroutine checkname_tmp
+
+!===============================================================!
+  subroutine checkname_xyz(base,fname,checkname)
+!************************************************
+!* Iterate X through files called <base>_<X>.xyz
+!* And returns the file names
+!* <base>_<X>.xyz as <fname>
+!* and <base>_<X+1>.xyz as <checkname>
+!************************************************
+    character(len=*) :: base,fname,checkname
+    integer :: i,j
+    logical :: ex
+    i = 0
+    do
+      write (checkname,'(a,''_'',i0,''.xyz'')') trim(base),i
+      inquire (file=trim(checkname),exist=ex)
+      if (ex) then
+        i = i+1
+      else
+        exit
+      end if
+    end do
+    j = max(0,i-1)
+    write (fname,'(a,''_'',i0,''.xyz'')') trim(base),j
+  end subroutine checkname_xyz
+
+!========================================================================================!
+
+  subroutine getname1(i,atmp)
+!*****************************************************
+!* generate file name scoord.<i> and return as <atmp>
+!*****************************************************
+    integer :: i
+    character(len=*) :: atmp
+    write (atmp,'(''scoord.'',i0)') i
+  end subroutine getname1
+
+!========================================================================================!
+
+  subroutine getanmrrc(atmp,fail)
+!*************************************
+!* check for existance of file <atmp>
+!* fail==.true. if it does not exist
+!*************************************
+    implicit none
+    character(len=*),intent(inout) :: atmp
+    logical,intent(out) :: fail
+    logical :: ex
+    inquire (file=trim(atmp),exist=ex)
+    fail = .not.ex
+    return
+  end subroutine getanmrrc
+
+!========================================================================================!
+
+! copy a coord file until an $set-block is encountered
+  subroutine clear_setblock(fname)
+    implicit none
+    character(len=*) :: fname
+    character(len=512) :: atmp
+    integer :: iost
+    integer :: ich,ich2
+
+    open (newunit=ich,file=fname)
+    open (newunit=ich2,file='.setdgtmp')
+
+    do
+      read (ich,'(a)',iostat=iost) atmp
+      if (iost < 0) exit
+      if ((index(atmp,'$set') .ne. 0).or.  &
+      &  (index(atmp,'$end') .ne. 0)) then
+        write (ich2,'(a)') '$end'
+        exit
+      else
+        write (ich2,'(a)') trim(atmp)
+      end if
+    end do
+    close (ich,status='delete')
+    close (ich2)
+    call rename('.setdgtmp',fname)
+  end subroutine clear_setblock
+
+
+!========================================================================================!
+
+  subroutine rdarg(str,arg,val)
+!*************************************************************************
+!* read a string <str> and get the value <val> (returned as string, also)
+!* that was assignet to the argument <arg>
+!* Example:
+!* <str>= "reference=foo"
+!* <arg>= "reference="  --> <val> will return "foo"
+!*************************************************************************
+    implicit none
+    character(len=*) :: str
+    character(len=*) :: arg
+    character(len=*) :: val
+    character(len=512) :: tmp
+    integer :: io
+    val = ''
+    io = index(str,arg,.true.)
+    if (io .ne. 0) then
+      io = io+len(arg)
+      tmp = str(io:)
+      val = trim(tmp)
+    else
+      val = ''
+    end if
+    return
+  end subroutine rdarg
+
+!========================================================================================!
+
+  subroutine TRJappendto_skipfirst(from,to)
+!*********************************************************************************
+!* append content of test file "from" into text file "to", similar to "cat A >> B"
+!* but specifically for TRJ files, but leaves out the first structure on "from"
+!*********************************************************************************
+    implicit none
+    integer :: io,ich,och
+    integer :: nat,i
+    character(len=*) :: from
+    character(len=*) :: to
+    character(len=1024) :: str
+    open (newunit=ich,file=to)
+    open (newunit=och,file=from)
+    do
+      read (ich,*,iostat=io)
+      if (io < 0) then
+        backspace (ich)
+        exit
+      end if
+    end do
+    !---first structure is read, but not copied
+    read (och,'(a)',iostat=io) str
+    if (io == 0) then
+      read (str,*) nat
+      read (och,'(a)',iostat=io) str
+      do i = 1,nat
+        read (och,'(a)',iostat=io) str
+      end do
+    end if
+    !---------------------------
+    do
+      read (och,'(a)',iostat=io) str
+      if (io < 0) exit
+      write (ich,'(a)') trim(str)
+    end do
+    close (och)
+    close (ich)
+  end subroutine TRJappendto_skipfirst
+
+!===============================================================!
+
+  subroutine XYZappendto(from,to)
+!**********************************************************************************
+!* append content of test file "from" into text file "to", similar to "cat A >> B"
+!* but specifically for XYZ files
+!**********************************************************************************
+    implicit none
+    integer :: io
+    character(len=*) :: from
+    character(len=*) :: to
+    integer :: i,nat,tunit,funit
+    character(len=1024) :: str
+    open (newunit=tunit,file=to)
+    open (newunit=funit,file=from)
+    do
+      read (tunit,*,iostat=io)
+      if (io < 0) then
+        backspace (tunit)
+        exit
+      end if
+    end do
+    read (funit,*) nat
+    write (tunit,*) nat
+    do i = 1,nat+1
+      read (funit,'(a)',iostat=io) str
+      if (io < 0) exit
+      write (tunit,'(a)') trim(str)
+    end do
+    close (funit)
+    close (tunit)
+  end subroutine XYZappendto
+
+!========================================================================================!
+!========================================================================================!
+end module utilities
Index: src/calculator/subprocess_types.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/subprocess_types.f90 b/src/calculator/subprocess_types.f90
new file mode 100644
--- /dev/null	
+++ b/src/calculator/subprocess_types.f90	
@@ -0,0 +1,197 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!> module orca_type
+!> a minimal implementation for storing an ORCA input file
+
+module orca_type
+  use crest_parameters,only:wp,stdout,stderr,autoaa
+  use iomod
+  use strucrd
+  implicit none
+  public
+
+  type :: orca_input
+    character(len=:),allocatable :: cmd
+    integer :: nlines = 0
+    character(len=:),allocatable :: input(:)
+    logical :: mpi = .false.
+  contains
+    procedure :: read => read_orca_input
+    procedure :: write => write_orca_input
+  end type orca_input
+
+!========================================================================================!
+!========================================================================================!
+contains  !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
+
+  subroutine read_orca_input(self,fname)
+    implicit none
+    class(orca_input) :: self
+    character(len=*),intent(in) :: fname
+    logical :: ex,trackcoord
+    integer :: nlines,width
+    integer :: io,ich,i,j,k,l
+    character(len=1056) :: atmp
+    logical :: gotengrad
+
+    inquire (file=fname,exist=ex)
+    if (.not.ex) then
+      write (stderr,'(3a)') '**ERROR** ORCA input template ',fname,' could not be found!'
+      error stop
+    else
+      write (stdout,'(3a)') 'Reading ORCA input template ',fname,' ...'
+    end if
+    nlines = getlines(fname,width)
+    open (newunit=ich,file=fname)
+    nlines = 0
+    trackcoord = .false.
+    gotengrad = .false.
+    !> count lines and check keywords
+    do
+      read (ich,'(a)',iostat=io) atmp
+      if (io /= 0) exit  !> EOF
+      atmp = adjustl(lowercase(atmp))
+
+      !> ignore coord lines, CREST will write those
+      if (trackcoord.and.atmp(1:1) == '*') then
+        trackcoord = .false.
+        cycle
+      end if
+      if (atmp(1:1).eq.'*' .and. index(atmp,'xyz ') .ne. 0) then
+        trackcoord = .true.
+        cycle
+      end if
+      if (atmp(1:1).eq.'*' .and. index(atmp,'xyzfile') .ne. 0) cycle
+
+      if (.not.trackcoord) nlines = nlines+1
+
+      if (index(atmp,'$new_job') .eq. 1) then
+        write (stderr,'(3a)') '**ERROR** In ORCA input template ',fname,': please define only single jobs (no $new_job)!'
+        error stop
+      end if
+
+      !> check runtypes from the simple input line
+      if (atmp(1:1) .eq. '!'.and.index(atmp,'engrad') .ne. 0) then
+        gotengrad = .true.
+      end if
+      if (atmp(1:1) .eq. '!'.and.index(atmp,'md') .ne. 0) then
+        write (stderr,'(3a)') '**ERROR** In ORCA input template ',fname,': only run EnGrad jobs!'
+        error stop
+      end if
+      if (atmp(1:1) .eq. '!'.and.index(atmp,'opt') .ne. 0) then
+        write (stderr,'(3a)') '**ERROR** In ORCA input template ',fname,': only run EnGrad jobs!'
+        error stop
+      end if
+      if (atmp(1:1) .eq. '!'.and.index(atmp,'freq') .ne. 0) then
+        write (stderr,'(3a)') '**ERROR** In ORCA input template ',fname,': only run EnGrad jobs!'
+        error stop
+      end if
+
+      !> coordinate input check, e.g.  remove Bohr keyword, if necessary
+      if (atmp(1:1) .eq. '%'.and.index(atmp,'coords') .ne. 0) then
+        write (stderr,'(3a)') '**ERROR** In ORCA input template ',fname,': please remove %coords block!'
+        error stop
+      end if
+
+      !> check if there is parallelization
+      if (atmp(1:1) .eq. '!'.and.index(atmp,'pal') .ne. 0) then
+        self%mpi = .true.
+      end if
+      if (atmp(1:1) .eq. '%'.and.index(atmp,'pal') .ne. 0) then
+        self%mpi = .true.
+      end if
+    end do
+    close (ich)
+
+    !> allocate memory space
+    width = width+10
+    allocate (self%input(nlines),source=repeat(" ",width))
+    self%nlines = nlines
+
+    !> Open file from the beginning and read into memory
+    open (newunit=ich,file=fname)
+    k = 0
+    do
+      read (ich,'(a)',iostat=io) atmp
+      if (io /= 0) exit  !> EOF
+      atmp = adjustl(atmp)
+
+      !> ignore coord lines, CREST will write those
+      if (trackcoord.and.atmp(1:1) == '*') then
+        trackcoord = .false.
+        cycle
+      end if
+      if (atmp(1:1).eq.'*' .and. index(atmp,'xyz ') .ne. 0) then
+        trackcoord = .true.
+        cycle
+      end if
+      if (atmp(1:1).eq.'*' .and. index(atmp,'xyzfile') .ne. 0) cycle
+
+      if (atmp(1:1) .eq. '!'.and.index(atmp,'bohr') .ne. 0) then
+        j = index(atmp,'bohr')
+        atmp(j:j+3) = '    '
+      end if
+
+      k = k+1
+      if (atmp(1:1) .eq. '!'.and..not.gotengrad) then
+        atmp = trim(atmp)//' EnGrad'
+        gotengrad = .true.
+      end if
+      self%input(k) = trim(atmp)
+
+    end do
+    close (ich)
+  end subroutine read_orca_input
+
+!========================================================================================!
+
+  subroutine write_orca_input(self,fname,mol,chrg,mult)
+    implicit none
+    class(orca_input),intent(in) :: self
+    character(len=*),intent(in) :: fname
+    type(coord),intent(in) :: mol
+    integer,intent(in) :: chrg
+    integer,intent(in) :: mult
+    integer :: ich,i,j,k,l
+
+    if(.not.allocated(self%input))then
+      write (stderr,'(3a)') '**ERROR** Please provide an ORCA input template!'
+      error stop
+    endif
+
+    open (newunit=ich,file=fname)
+    do i=1,self%nlines
+      write(ich,'(a)') trim(self%input(i))
+    enddo
+    write(ich,*)
+    write(ich,'(a,1x,i0,1x,i0,a)') '*xyz',chrg,mult,'  # charge and multiplicity (2S+1)'
+    do i=1,mol%nat
+      write(ich,'(a2,3F25.15)') asym(mol%at(i)),mol%xyz(1:3,i)*autoaa
+    enddo
+    write(ich,'("*")')
+    close (ich)
+
+  end subroutine write_orca_input
+
+!========================================================================================!
+!========================================================================================!
+end module orca_type
Index: src/legacy_algos/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nset(dir \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\nlist(APPEND srcs\n  \"${dir}/acidbase.f90\"\n  \"${dir}/confscript2_main.f90\"\n  \"${dir}/confscript2_misc.f90\"\n  \"${dir}/confscript3.f90\"\n  \"${dir}/confopt.f90\"\n  \"${dir}/cregen_old.f90\"\n  \"${dir}/deprotonate.f90\"\n  \"${dir}/flexi.f90\"\n  \"${dir}/ligands.f90\"\n  \"${dir}/normmd.f90\"\n  \"${dir}/pka.f90\"\n  \"${dir}/protonate.f90\"\n  \"${dir}/reactor.f90\"\n  \"${dir}/relaxensemble.f90\"\n  \"${dir}/stereoisomers.f90\"\n  \"${dir}/tautomerize.f90\"\n  \"${dir}/trialmd_legacy.f90\"\n)\n\nset(srcs ${srcs} PARENT_SCOPE)\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/CMakeLists.txt b/src/legacy_algos/CMakeLists.txt
--- a/src/legacy_algos/CMakeLists.txt	
+++ b/src/legacy_algos/CMakeLists.txt	
@@ -34,6 +34,7 @@
   "${dir}/stereoisomers.f90"
   "${dir}/tautomerize.f90"
   "${dir}/trialmd_legacy.f90"
+  "${dir}/zsort.f90"
 )
 
 set(srcs ${srcs} PARENT_SCOPE)
Index: src/calculator/lwoniom.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/lwoniom.F90 b/src/calculator/lwoniom.F90
new file mode 100644
--- /dev/null	
+++ b/src/calculator/lwoniom.F90	
@@ -0,0 +1,263 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2023 Patryk Wesołowski, Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+module lwoniom_module
+  use crest_parameters
+  use strucrd
+#ifdef WITH_LWONIOM
+  use lwoniom_interface
+#endif
+  implicit none
+  private
+
+#ifndef WITH_LWONIOM
+  !> this is a placeholder if no lwONIOM module is used!
+  type :: lwoniom_input
+    integer :: id = 0
+  end type lwoniom_input
+  type :: lwoniom_data
+    integer :: id = 0
+    integer :: calcids(2,2)
+    integer :: nfrag = 0
+    integer :: ncalcs = 0
+  end type lwoniom_data
+#endif
+
+  !> if compiled without(!!!) -DWITH_LWONIOM=true this will export
+  !> the placeholder from above. Otherwise it will RE-export
+  !> the types from lwoniom_interface
+  public :: lwoniom_input,lwoniom_data
+
+  public :: ONIOM_read_toml
+ 
+  public :: ONIOM_update_geo
+
+  public :: ONIOM_associate_mol
+
+  public :: ONIOM_get_fraggrad
+  
+  public :: ONIOM_engrad
+
+!========================================================================================!
+!========================================================================================!
+contains  !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
+
+
+  subroutine ONIOM_read_toml(tomlfile,nat,at,xyz,ONIOM_data)
+!********************************************
+!* Read the [lwoniom] block from a toml file
+!********************************************
+    implicit none
+    !> INPUT
+    character(len=*),intent(in) :: tomlfile
+    integer,intent(in) :: nat
+    integer,intent(in) :: at(:)
+    real(wp),intent(in) :: xyz(:,:)
+    type(lwoniom_data),intent(out) :: ONIOM_data
+    type(lwoniom_input),allocatable :: ONIOM_input
+#ifdef WITH_LWONIOM
+    allocate(ONIOM_input)
+    call lwoniom_parse_inputfile(tomlfile,ONIOM_input,required = .false., natoms=nat)
+    ONIOM_input%at = at
+    ONIOM_input%xyz = xyz*autoaa !> ONIOM_input needs to stor coords in Angstroem rather than bohr
+    call lwoniom_new_calculator( ONIOM_input, ONIOM_data ) !> because this converts to Bohr
+    deallocate(ONIOM_input)
+    call ONIOM_data%dump_fragments()
+#else
+    call ONIOM_compile_error()
+#endif
+  end subroutine ONIOM_read_toml
+
+
+!========================================================================================!
+
+
+  subroutine ONIOM_update_geo(ONIOM,mol,mollist,cmap)
+!**********************************************************
+!* Update all fragments of a previously set up ONIOM setup
+!**********************************************************
+    implicit none
+    !> INPUT
+    type(lwoniom_data),intent(inout) :: ONIOM
+    type(coord),intent(in)  :: mol
+    type(coord),intent(inout),optional :: mollist(ONIOM%ncalcs)
+    integer,intent(in),optional :: cmap(ONIOM%ncalcs) !> calculation index mapping
+    integer :: i,highlow,fragid,j
+#ifdef WITH_LWONIOM
+    call ONIOM%update( mol%xyz )  !> no point charge version
+
+    !> optional, update a given list of coord-type molecules (the fragments)
+    if(present(mollist).and.present(cmap))then
+      !do i=1,ONIOM%nfrag
+      ! call ONIOM_get_mol(ONIOM,i,mollist(i))
+      !enddo
+      do i=1,ONIOM%ncalcs
+          j = cmap(i)
+          call ONIOM_get_mapping(j, ONIOM%calcids, highlow, fragid)
+          !write(*,*) fragid, highlow
+          call ONIOM_get_mol(ONIOM,fragid,mollist(i),highlow)
+      enddo
+    endif
+#else
+    call ONIOM_compile_error()
+#endif
+  end subroutine ONIOM_update_geo
+
+
+!========================================================================================!
+
+  subroutine ONIOM_engrad(ONIOM,mol,energy,gradient)
+!**********************************************
+!* reconstruct ONIOM energy and gradient
+!* energy and gradient is additive to whatever
+!* is saved there already
+!**********************************************
+    implicit none
+    !> INPUT
+    type(lwoniom_data),intent(inout) :: ONIOM
+    type(coord),intent(in)  :: mol
+
+    real(wp),intent(inout) :: energy
+    real(wp),intent(inout) :: gradient(3,mol%nat)
+    integer :: i,l
+#ifdef WITH_LWONIOM
+    call lwoniom_singlepoint(mol%nat,ONIOM,energy,gradient)
+#else
+    call ONIOM_compile_error()
+#endif
+  end subroutine ONIOM_engrad
+
+
+
+
+!========================================================================================!
+
+  subroutine ONIOM_get_mol(ONIOM,F,mol,highlow)
+!*****************************************
+!* transfer data from fragment F into mol
+!*****************************************
+    implicit none
+    !> INPUT
+    type(lwoniom_data),intent(inout) :: ONIOM
+    type(coord),intent(inout)  :: mol
+    integer,intent(in) :: F 
+    integer,intent(in),optional :: highlow
+    integer :: natf   
+#ifdef WITH_LWONIOM
+    if(F > ONIOM%nfrag ) error stop 'ONIOM fragment mismatch'
+
+    natf =  ONIOM%fragment(F)%nat +  ONIOM%fragment(F)%nlink
+    if(mol%nat /=  natf) call mol%deallocate()
+
+    mol%nat = natf
+    !if(present(highlow) .and. (ONIOM%fragment(F)%replace_at))then
+    !  if(highlow .eq. 1)then
+    !     mol%at = reshape( [ONIOM%fragment(F)%at_high,ONIOM%fragment(F)%linkat], [natf])
+    !  else if(highlow.eq.2)then
+    !     mol%at = reshape( [ONIOM%fragment(F)%at_low,ONIOM%fragment(F)%linkat], [natf])
+    !  endif  
+    !else
+    mol%at = reshape( [ONIOM%fragment(F)%at,ONIOM%fragment(F)%linkat], [natf])
+    !endif
+    mol%xyz = reshape( [ONIOM%fragment(F)%xyz,ONIOM%fragment(F)%linkxyz], [3,natf]) 
+    
+#else
+    call ONIOM_compile_error()
+#endif
+  end subroutine ONIOM_get_mol
+
+!=========================================================================================!
+
+  subroutine ONIOM_get_fraggrad(ONIOM,F,gradient,highlow,energy)
+!********************************************
+!* get high or low level PROJECTED gradient
+!* for fragment F, (optionally) with the
+!* entire ONIOM energy.
+!********************************************
+    implicit none
+    !> INPUT
+    type(lwoniom_data),intent(inout) :: ONIOM
+    integer,intent(in) :: F
+    real(wp),intent(out) :: gradient(:,:)
+    integer,intent(in) :: highlow
+    real(wp),intent(out),optional :: energy
+    integer :: natf,root_id
+    gradient = 0.0_wp 
+#ifdef WITH_LWONIOM
+    if(F > ONIOM%nfrag ) error stop 'ONIOM fragment mismatch'
+    select case(highlow)
+    case(1)
+       gradient = ONIOM%fragment(F)%gradient_high
+    case default
+       gradient = ONIOM%fragment(F)%gradient_low
+    end select
+    if(present(energy))then
+       root_id = ONIOM%root_id
+       energy = ONIOM%fragment(root_id)%energy_qq
+    endif
+#else
+    call ONIOM_compile_error()
+#endif
+  end subroutine ONIOM_get_fraggrad
+
+!========================================================================================!
+
+  subroutine ONIOM_associate_mol(mol,molptr)
+    implicit none
+    type(coord),target :: mol
+    type(coord),pointer,intent(out) :: molptr
+    molptr => mol
+  end subroutine ONIOM_associate_mol
+
+
+!========================================================================================!
+
+  subroutine ONIOM_get_mapping(id, calcids, highlow, fragid)
+     implicit none
+     integer,intent(in) :: id !> calculation ID in CREST
+     integer,intent(in) :: calcids(:,:) !> mappings form calculator setup
+     integer,intent(out) :: highlow,fragid
+     integer :: i,j,k,l
+     highlow = 0
+     fragid = 0
+     iloop : do i=1,size(calcids,2)
+       do j=1,2
+         if( calcids(j,i) == id)then
+           highlow = j
+           fragid = i
+           exit iloop
+         endif
+       enddo
+     enddo iloop
+   end subroutine ONIOM_get_mapping
+
+!========================================================================================!
+
+  subroutine ONIOM_compile_error()
+    write (stdout,*) 'Error: Compiled without lwONIOM support!'
+    write (stdout,*) 'Use -DWITH_LWONIOM=true in the setup to enable this function'
+    error stop
+  end subroutine ONIOM_compile_error
+
+!========================================================================================!
+!========================================================================================!
+end module lwoniom_module
+
Index: src/legacy_algos/confscript3.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!----------------------------------------------------------------------------------------------------\n! CREST modus 3: MDOPT\n!----------------------------------------------------------------------------------------------------\nsubroutine mdopt(env,tim)\n     use crest_data\n     use iomod\n     use strucrd, only: rdensembleparam,rdensemble\n     implicit none\n     \n     type(systemdata) :: env\n     type(timer)     :: tim\n     character(len=256) :: tmpname\n     character(len=128) :: newname\n\n     integer :: iz2,nall\n\n     associate( ensemblename => env%ensemblename)\n\n!---- start timer\n      call tim%start(1,'MDOPT')\n\n!---- output file name\n      newname=ensemblefile !'crest_ensemble.xyz'\n      if(env%optpurge) newname='crest_optpurge.xyz'\n\n!---- which file to optimize?\n      tmpname=trim(ensemblename)\n      if(index(tmpname,'none selected').ne.0)then\n         write(*,*) 'No file selected with \"--mdopt\" option!'\n         error stop\n      endif\n      call rdensembleparam(tmpname,iz2,nall)\n\n!---- Small Header\n      if(any((/-9224,-9225/)==env%properties))then\n          continue\n      else\n      write(*,*)\n      if(.not.env%optpurge)then\n      write(*,'(5x,''======================================='')')\n      write(*,'(5x,''|               M D O P T             |'')')\n      write(*,'(5x,''======================================='')')\n      write(*,'(3x,''Optimization along trajectory (or ensemble).'')')\n      else\n      write(*,'(5x,''======================================='')')\n      write(*,'(5x,''|          O P T - P U R G E          |'')')\n      write(*,'(5x,''======================================='')')\n      write(*,'(4x,''Optimization along ensemble to crosscheck'')')\n      write(*,'(4x,''convergence into the same PES minima.'')')\n      endif\n      write(*,*)\n      endif\n      write(*,'(1x,a,a)')'Input file: ','<'//trim(tmpname)//'>'\n      write(*,'(1x,a,i0,a)')'Containing ',nall,' structures.'\n      if(env%optpurge)then\n          call copy(trim(tmpname),trim(tmpname)//'.backup')\n          write(*,'(1x,a)')'Saved backup of input file.'\n      endif\n\n!---- Do the optimization\n      call MDopt_para(env,trim(tmpname),0)\n\n!---- printout and copy\n      call rename('OPTIM'//'/'//'opt.xyz',trim(newname))\n      write(*,'(1x,a,1x,a)') 'Optimized ensemble on file','<'//trim(newname)//'>'\n!---- clean up\n      call rmrf('OPTIM')\n\n!--- purge identicals\n      if(env%optpurge)then\n      env%ensemblename = newname\n      env%confgo = .true.\n      call newcregen(env,9)\n      call cleanpurge(tmpname,env%ethrpurge) !applied to original file!\n      endif\n\n!---- get the timing\n      call tim%stop(1)\n      end associate\ncontains\nsubroutine cleanpurge(fname,ethr)\n    use crest_parameters\n    use strucrd\n    implicit none\n    character(len=*) :: fname\n    integer :: nall,nat\n    integer,allocatable :: groups(:)\n    integer :: ngrps\n    integer :: ich,i,j,ich2,jref\n    real(wp),allocatable :: xyz(:,:,:)\n    integer,allocatable :: at(:)\n    real(wp),allocatable :: er(:)\n    real(wp) :: elast,ediff,ethr\n    character(len=*),parameter :: newfile = 'crest_ensemble.xyz'\n    logical,allocatable :: track(:)\n    logical :: paste\n\n    call rdensembleparam(fname,nat,nall)\n    allocate(xyz(3,nat,nall),at(nat),er(nall))\n    call rdensemble(fname,nat,nall,at,xyz,er)\n\n    open(newunit=ich,file='.groups') !written by newcregen(env,9)\n    read(ich,*) nall,ngrps\n    allocate(groups(nall))\n    do i=1,nall\n      read(ich,*) j,groups(i)\n    enddo\n    close(ich,status='delete')\n\n    write(*,'(/,1x,a,1x,a)') 'Check duplicate info and energy windows (ETHR):'\n    allocate(track(nall), source=.false.)\n    !-- write new ensemble\n    open(newunit=ich,file=newfile)\n    open(newunit=ich2,file='.duplicates')\n    do i=1,ngrps\n      paste=.true.\n      elast = 0.0_wp\n      do j=1,nall\n        if(groups(j)==i)then  \n          if(paste)then  \n           !call wrxyz(ich,nat,at,xyz(:,:,j),er(j))\n           track(j) = .true.\n           paste=.false.\n           jref=j\n           elast = er(j)\n          else\n           ediff = (er(j)-elast)*autokcal\n           if(ediff.lt.ethr)then\n            write(*,'(1x,a,i0,a)') 'Structure ',j,' was discarded'   \n            track(j) = .false.\n            write(ich2,*) j,jref\n           else \n             !call wrxyz(ich,nat,at,xyz(:,:,j),er(j))\n             track(j) = .true.\n           endif\n           elast=er(j)\n          endif\n        endif\n      enddo\n    enddo\n    !-- write the ensemble\n    do j=1,nall\n      if(track(j))then\n       call wrxyz(ich,nat,at,xyz(:,:,j),er(j))\n      endif\n    enddo\n    close(ich2)\n    close(ich)\n    write(*,'(/,1x,a,1x,a)') 'Unique structures written to file','<'//newfile//'>'\n    write(*,'(1x,a,1x,a)') 'Duplicative structures in file','<'//trim(fname)//'>'\n    write(*,'(1x,a)') ' have been documented in hidden file <.duplicates>'\n\n    deallocate(er,at,xyz)\n    return\nend subroutine cleanpurge\nend subroutine mdopt\n\n!----------------------------------------------------------------------------------------------------\n! CREST modus 4: SCREEN\n!----------------------------------------------------------------------------------------------------\nsubroutine screen(env,tim)\n     use crest_parameters\n     use crest_data\n     use iomod\n     use strucrd, only: rdensembleparam,rdensemble\n     implicit none\n     \n     type(systemdata) :: env\n     type(timer)      :: tim\n     character(len=256) :: tmpname,newname\n\n     integer :: iz2,nall,nremain\n\n     character(len=128) :: inpnam,outnam\n     character(len=512) :: thispath,filename\n\n     real(wp) :: ewinbackup,rthrbackup\n\n     call getcwd(thispath)\n\n     ewinbackup=env%ewin\n     rthrbackup=env%rthr\n\n!---- start timer\n      call tim%start(1,'SCREEN')\n\n!---- output file name\n      newname=ensemblefile !'crest_ensemble.xyz'\n\n!---- which file to optimize?\n      \n      tmpname=trim(env%ensemblename)\n      if(index(tmpname,'none selected').ne.0)then\n         write(*,*) 'No file slected with \"--screen\" option!'\n         error stop\n      endif\n      call rdensembleparam(tmpname,iz2,nall)\n\n!---- Small Header\n      write(*,*)\n      write(*,'(5x,''======================================='')')\n      write(*,'(5x,''|              S C R E E N            |'')')\n      write(*,'(5x,''======================================='')')\n      write(*,'(1x,''Multilevel optimization and structure screening.'')')\n      write(*,*)\n      write(*,'(1x,a,a)')'Input file: ','<'//trim(tmpname)//'>'\n      write(*,'(1x,a,i0,a)')'Containing ',nall,' structures.'\n      write(*,*)\n!---- Multilevel job calls start here\n        \n        call smallhead('1. crude pre-optimization')\n        call checkname_xyz(crefile,inpnam,outnam)\n        call MDopt_para(env,trim(tmpname),1)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        env%ewin=ewinbackup*4.0d0\n        env%rthr=rthrbackup*2.0d0\n    !---using cregen to sort the optimized structures\n        call checkname_xyz(crefile,inpnam,outnam)\n        call confg_chk3(env)\n    !--- only in the first ste  the input file is overwritten with the sorted file\n        call remove(inpnam)\n        call rename(outnam,inpnam)\n    !-----\n        call remaining_in(trim(inpnam),env%ewin,nremain)\n         env%ewin=ewinbackup\n         env%rthr=rthrbackup\n        call rmrf('OPTIM')\n        write(*,*)\n!--- then vloose optimization\n        call smallhead('2. optimization with loose thresholds')\n        call checkname_xyz(crefile,inpnam,outnam)\n        call MDopt_para(env,trim(inpnam),2)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        env%ewin=ewinbackup*2.0d0\n        call confg_chk3(env)\n        call remaining_in(trim(inpnam),env%ewin,nremain)\n        env%ewin=ewinbackup\n        env%rthr=rthrbackup\n        write(*,*)\n!--- lastly vtight optimization\n        call smallhead('3. optimization with very tight thresholds')\n        call checkname_xyz(crefile,inpnam,outnam)\n        call MDopt_para(env,trim(inpnam),0)\n        filename=trim(thispath)//'/'//trim(outnam)\n        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))\n        call confg_chk3(env)\n        call checkname_xyz(crefile,inpnam,outnam)\n        call remaining_in(trim(inpnam),env%ewin,nremain)\n        call rmrf('OPTIM')\n        write(*,*)\n      \n!---- printout\n      call catdel('cregen.out.tmp')\n      write(*,*)\n      write(*,'(1x,a,1x,a)') 'Final ensemble on file','<'//trim(newname)//'>'\n\n      call rename(conformerfile,trim(newname))\n  \n \n!---- clean up\n      call screen_cleanup\n\n!---- get the timing\n      call tim%stop(1)\nend subroutine screen\n\n!-----------------------------------------------------------------------------------------------------\n! MTD sample: for a given ensemble file perform 2 (short) MTDs on each structure and optimize along\n! the collected trajectories\n!\n! WIP\n!-----------------------------------------------------------------------------------------------------\nsubroutine MTDsample(env,tim)\n    use crest_parameters\n    use crest_data\n    use iomod\n    use strucrd\n    implicit none\n    type(systemdata) :: env\n    type(timer)      :: tim\n    type(ensemble) :: ens\n    character(len=512) :: thispath\n    character(len=:),allocatable :: subdirname\n    character(len=128) :: mtddir\n    character(len=:),allocatable :: coordname\n    integer :: r\n    integer :: i,l\n    logical :: ex\n    real(wp) :: mdtime\n\n        associate( nat => env%nat, hmass => env%hmass, mdtemp => env%mdtemp,    &\n         & mdstep => env%mdstep, shake => env%shake, mddumpxyz => env%mddumpxyz, &\n         & mdskip => env%mdskip, mddump => env%mddump )\n\n\n    inquire(file=env%ensemblename,exist=ex)\n    if(ex)then\n        call ens%open(env%ensemblename)\n    else\n       error stop 'Ensemble file does not exist!'\n    endif\n\n    call md_length_setup(env)  !set the MD length according to a flexibility measure\n    mdtime=env%mdtime\n\n    ens%xyz = ens%xyz / bohr  !to bohr so we can write coords\n\n    call tim%start(5,'MTDsample')\n    call getcwd(thispath)\n    subdirname='MTDSAMPLE'\n    r = makedir(subdirname)\n    call chdir(subdirname)\n\n    do i=1,ens%nall\n       write(mtddir,'(a,i0)')'MTD',i\n       coordname=trim(mtddir)//'/'//'coord'\n       call wrc0(coordname,ens%nat,ens%at,ens%xyz(1:3,1:ens%nat,i))\n       if(env%gfnver=='--gff')then\n          l = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(mtddir)//'/'//'gfnff_topo')\n       endif\n       call setMDrun2(coordname,hmass,mdtime,mdtemp,mdstep,shake,mddumpxyz, &\n      &             mdskip,mddump,-1,env%cts)\n\n       call env%wrtCHRG(trim(mtddir))\n    enddo\n\n\n    call chdir(thispath)\n    call tim%stop(5)\n\n    end associate\n    return\nend subroutine MTDsample\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/confscript3.f90 b/src/legacy_algos/confscript3.f90
--- a/src/legacy_algos/confscript3.f90	
+++ b/src/legacy_algos/confscript3.f90	
@@ -17,87 +17,88 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-!----------------------------------------------------------------------------------------------------
+!----------------------------------------------------------------------------------------
 ! CREST modus 3: MDOPT
-!----------------------------------------------------------------------------------------------------
-subroutine mdopt(env,tim)
-     use crest_data
-     use iomod
-     use strucrd, only: rdensembleparam,rdensemble
-     implicit none
-     
-     type(systemdata) :: env
-     type(timer)     :: tim
-     character(len=256) :: tmpname
-     character(len=128) :: newname
+!----------------------------------------------------------------------------------------
+subroutine mdopt_legacy(env,tim)
+  use crest_data
+  use iomod
+  use strucrd,only:rdensembleparam,rdensemble
+  use utilities
+  implicit none
+
+  type(systemdata) :: env
+  type(timer)     :: tim
+  character(len=256) :: tmpname
+  character(len=128) :: newname
 
-     integer :: iz2,nall
+  integer :: iz2,nall
 
-     associate( ensemblename => env%ensemblename)
+  associate (ensemblename => env%ensemblename)
 
 !---- start timer
-      call tim%start(1,'MDOPT')
+    call tim%start(1,'MDOPT')
 
 !---- output file name
-      newname=ensemblefile !'crest_ensemble.xyz'
-      if(env%optpurge) newname='crest_optpurge.xyz'
+    newname = ensemblefile !'crest_ensemble.xyz'
+    if (env%optpurge) newname = 'crest_optpurge.xyz'
 
 !---- which file to optimize?
-      tmpname=trim(ensemblename)
-      if(index(tmpname,'none selected').ne.0)then
-         write(*,*) 'No file selected with "--mdopt" option!'
-         error stop
-      endif
-      call rdensembleparam(tmpname,iz2,nall)
+    tmpname = trim(ensemblename)
+    if (index(tmpname,'none selected') .ne. 0) then
+      write (*,*) 'No file selected with "--mdopt" option!'
+      error stop
+    end if
+    call rdensembleparam(tmpname,iz2,nall)
 
 !---- Small Header
-      if(any((/-9224,-9225/)==env%properties))then
-          continue
-      else
-      write(*,*)
-      if(.not.env%optpurge)then
-      write(*,'(5x,''======================================='')')
-      write(*,'(5x,''|               M D O P T             |'')')
-      write(*,'(5x,''======================================='')')
-      write(*,'(3x,''Optimization along trajectory (or ensemble).'')')
+    if (any((/-9224,-9225/) == env%properties)) then
+      continue
+    else
+      write (*,*)
+      if (.not.env%optpurge) then
+        write (*,'(5x,''======================================='')')
+        write (*,'(5x,''|               M D O P T             |'')')
+        write (*,'(5x,''======================================='')')
+        write (*,'(3x,''Optimization along trajectory (or ensemble).'')')
       else
-      write(*,'(5x,''======================================='')')
-      write(*,'(5x,''|          O P T - P U R G E          |'')')
-      write(*,'(5x,''======================================='')')
-      write(*,'(4x,''Optimization along ensemble to crosscheck'')')
-      write(*,'(4x,''convergence into the same PES minima.'')')
-      endif
-      write(*,*)
-      endif
-      write(*,'(1x,a,a)')'Input file: ','<'//trim(tmpname)//'>'
-      write(*,'(1x,a,i0,a)')'Containing ',nall,' structures.'
-      if(env%optpurge)then
-          call copy(trim(tmpname),trim(tmpname)//'.backup')
-          write(*,'(1x,a)')'Saved backup of input file.'
-      endif
+        write (*,'(5x,''======================================='')')
+        write (*,'(5x,''|          O P T - P U R G E          |'')')
+        write (*,'(5x,''======================================='')')
+        write (*,'(4x,''Optimization along ensemble to crosscheck'')')
+        write (*,'(4x,''convergence into the same PES minima.'')')
+      end if
+      write (*,*)
+    end if
+    write (*,'(1x,a,a)') 'Input file: ','<'//trim(tmpname)//'>'
+    write (*,'(1x,a,i0,a)') 'Containing ',nall,' structures.'
+    if (env%optpurge) then
+      call copy(trim(tmpname),trim(tmpname)//'.backup')
+      write (*,'(1x,a)') 'Saved backup of input file.'
+    end if
 
 !---- Do the optimization
-      call MDopt_para(env,trim(tmpname),0)
+    call MDopt_para(env,trim(tmpname),0)
 
 !---- printout and copy
-      call rename('OPTIM'//'/'//'opt.xyz',trim(newname))
-      write(*,'(1x,a,1x,a)') 'Optimized ensemble on file','<'//trim(newname)//'>'
+    call rename('OPTIM'//'/'//'opt.xyz',trim(newname))
+    write (*,'(1x,a,1x,a)') 'Optimized ensemble on file','<'//trim(newname)//'>'
 !---- clean up
-      call rmrf('OPTIM')
+    call rmrf('OPTIM')
 
 !--- purge identicals
-      if(env%optpurge)then
+    if (env%optpurge) then
       env%ensemblename = newname
       env%confgo = .true.
       call newcregen(env,9)
       call cleanpurge(tmpname,env%ethrpurge) !applied to original file!
-      endif
+    end if
 
 !---- get the timing
-      call tim%stop(1)
-      end associate
+    call tim%stop(1)
+  end associate
 contains
-subroutine cleanpurge(fname,ethr)
+  subroutine cleanpurge(fname,ethr)
     use crest_parameters
     use strucrd
     implicit none
@@ -115,242 +116,173 @@
     logical :: paste
 
     call rdensembleparam(fname,nat,nall)
-    allocate(xyz(3,nat,nall),at(nat),er(nall))
+    allocate (xyz(3,nat,nall),at(nat),er(nall))
     call rdensemble(fname,nat,nall,at,xyz,er)
 
-    open(newunit=ich,file='.groups') !written by newcregen(env,9)
-    read(ich,*) nall,ngrps
-    allocate(groups(nall))
-    do i=1,nall
-      read(ich,*) j,groups(i)
-    enddo
-    close(ich,status='delete')
+    open (newunit=ich,file='.groups') !written by newcregen(env,9)
+    read (ich,*) nall,ngrps
+    allocate (groups(nall))
+    do i = 1,nall
+      read (ich,*) j,groups(i)
+    end do
+    close (ich,status='delete')
 
-    write(*,'(/,1x,a,1x,a)') 'Check duplicate info and energy windows (ETHR):'
-    allocate(track(nall), source=.false.)
+    write (*,'(/,1x,a,1x,a)') 'Check duplicate info and energy windows (ETHR):'
+    allocate (track(nall),source=.false.)
     !-- write new ensemble
-    open(newunit=ich,file=newfile)
-    open(newunit=ich2,file='.duplicates')
-    do i=1,ngrps
-      paste=.true.
+    open (newunit=ich,file=newfile)
+    open (newunit=ich2,file='.duplicates')
+    do i = 1,ngrps
+      paste = .true.
       elast = 0.0_wp
-      do j=1,nall
-        if(groups(j)==i)then  
-          if(paste)then  
-           !call wrxyz(ich,nat,at,xyz(:,:,j),er(j))
-           track(j) = .true.
-           paste=.false.
-           jref=j
-           elast = er(j)
+      do j = 1,nall
+        if (groups(j) == i) then
+          if (paste) then
+            !call wrxyz(ich,nat,at,xyz(:,:,j),er(j))
+            track(j) = .true.
+            paste = .false.
+            jref = j
+            elast = er(j)
           else
-           ediff = (er(j)-elast)*autokcal
-           if(ediff.lt.ethr)then
-            write(*,'(1x,a,i0,a)') 'Structure ',j,' was discarded'   
-            track(j) = .false.
-            write(ich2,*) j,jref
-           else 
-             !call wrxyz(ich,nat,at,xyz(:,:,j),er(j))
-             track(j) = .true.
-           endif
-           elast=er(j)
-          endif
-        endif
-      enddo
-    enddo
+            ediff = (er(j)-elast)*autokcal
+            if (ediff .lt. ethr) then
+              write (*,'(1x,a,i0,a)') 'Structure ',j,' was discarded'
+              track(j) = .false.
+              write (ich2,*) j,jref
+            else
+              !call wrxyz(ich,nat,at,xyz(:,:,j),er(j))
+              track(j) = .true.
+            end if
+            elast = er(j)
+          end if
+        end if
+      end do
+    end do
     !-- write the ensemble
-    do j=1,nall
-      if(track(j))then
-       call wrxyz(ich,nat,at,xyz(:,:,j),er(j))
-      endif
-    enddo
-    close(ich2)
-    close(ich)
-    write(*,'(/,1x,a,1x,a)') 'Unique structures written to file','<'//newfile//'>'
-    write(*,'(1x,a,1x,a)') 'Duplicative structures in file','<'//trim(fname)//'>'
-    write(*,'(1x,a)') ' have been documented in hidden file <.duplicates>'
+    do j = 1,nall
+      if (track(j)) then
+        call wrxyz(ich,nat,at,xyz(:,:,j),er(j))
+      end if
+    end do
+    close (ich2)
+    close (ich)
+    write (*,'(/,1x,a,1x,a)') 'Unique structures written to file','<'//newfile//'>'
+    write (*,'(1x,a,1x,a)') 'Duplicative structures in file','<'//trim(fname)//'>'
+    write (*,'(1x,a)') ' have been documented in hidden file <.duplicates>'
 
-    deallocate(er,at,xyz)
+    deallocate (er,at,xyz)
     return
-end subroutine cleanpurge
-end subroutine mdopt
+  end subroutine cleanpurge
+end subroutine mdopt_legacy
 
-!----------------------------------------------------------------------------------------------------
+!----------------------------------------------------------------------------------------
 ! CREST modus 4: SCREEN
-!----------------------------------------------------------------------------------------------------
-subroutine screen(env,tim)
-     use crest_parameters
-     use crest_data
-     use iomod
-     use strucrd, only: rdensembleparam,rdensemble
-     implicit none
-     
-     type(systemdata) :: env
-     type(timer)      :: tim
-     character(len=256) :: tmpname,newname
+!----------------------------------------------------------------------------------------
+subroutine screen_legacy(env,tim)
+  use crest_parameters
+  use crest_data
+  use iomod
+  use strucrd,only:rdensembleparam,rdensemble
+  use utilities
+  implicit none
+
+  type(systemdata) :: env
+  type(timer)      :: tim
+  character(len=256) :: tmpname,newname
 
-     integer :: iz2,nall,nremain
+  integer :: iz2,nall,nremain
 
-     character(len=128) :: inpnam,outnam
-     character(len=512) :: thispath,filename
+  character(len=128) :: inpnam,outnam
+  character(len=512) :: thispath,filename
 
-     real(wp) :: ewinbackup,rthrbackup
+  real(wp) :: ewinbackup,rthrbackup
 
-     call getcwd(thispath)
+  call getcwd(thispath)
 
-     ewinbackup=env%ewin
-     rthrbackup=env%rthr
+  ewinbackup = env%ewin
+  rthrbackup = env%rthr
 
 !---- start timer
-      call tim%start(1,'SCREEN')
+  call tim%start(1,'SCREEN')
 
 !---- output file name
-      newname=ensemblefile !'crest_ensemble.xyz'
+  newname = ensemblefile !'crest_ensemble.xyz'
 
 !---- which file to optimize?
-      
-      tmpname=trim(env%ensemblename)
-      if(index(tmpname,'none selected').ne.0)then
-         write(*,*) 'No file slected with "--screen" option!'
-         error stop
-      endif
-      call rdensembleparam(tmpname,iz2,nall)
+
+  tmpname = trim(env%ensemblename)
+  if (index(tmpname,'none selected') .ne. 0) then
+    write (*,*) 'No file slected with "--screen" option!'
+    error stop
+  end if
+  call rdensembleparam(tmpname,iz2,nall)
 
 !---- Small Header
-      write(*,*)
-      write(*,'(5x,''======================================='')')
-      write(*,'(5x,''|              S C R E E N            |'')')
-      write(*,'(5x,''======================================='')')
-      write(*,'(1x,''Multilevel optimization and structure screening.'')')
-      write(*,*)
-      write(*,'(1x,a,a)')'Input file: ','<'//trim(tmpname)//'>'
-      write(*,'(1x,a,i0,a)')'Containing ',nall,' structures.'
-      write(*,*)
+  write (*,*)
+  write (*,'(5x,''======================================='')')
+  write (*,'(5x,''|              S C R E E N            |'')')
+  write (*,'(5x,''======================================='')')
+  write (*,'(1x,''Multilevel optimization and structure screening.'')')
+  write (*,*)
+  write (*,'(1x,a,a)') 'Input file: ','<'//trim(tmpname)//'>'
+  write (*,'(1x,a,i0,a)') 'Containing ',nall,' structures.'
+  write (*,*)
 !---- Multilevel job calls start here
-        
-        call smallhead('1. crude pre-optimization')
-        call checkname_xyz(crefile,inpnam,outnam)
-        call MDopt_para(env,trim(tmpname),1)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        env%ewin=ewinbackup*4.0d0
-        env%rthr=rthrbackup*2.0d0
-    !---using cregen to sort the optimized structures
-        call checkname_xyz(crefile,inpnam,outnam)
-        call confg_chk3(env)
-    !--- only in the first ste  the input file is overwritten with the sorted file
-        call remove(inpnam)
-        call rename(outnam,inpnam)
-    !-----
-        call remaining_in(trim(inpnam),env%ewin,nremain)
-         env%ewin=ewinbackup
-         env%rthr=rthrbackup
-        call rmrf('OPTIM')
-        write(*,*)
+
+  call smallhead('1. crude pre-optimization')
+  call checkname_xyz(crefile,inpnam,outnam)
+  call MDopt_para(env,trim(tmpname),1)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  env%ewin = ewinbackup*4.0d0
+  env%rthr = rthrbackup*2.0d0
+  !---using cregen to sort the optimized structures
+  call checkname_xyz(crefile,inpnam,outnam)
+  call confg_chk3(env)
+  !--- only in the first ste  the input file is overwritten with the sorted file
+  call remove(inpnam)
+  call rename(outnam,inpnam)
+  !-----
+  call remaining_in(trim(inpnam),env%ewin,nremain)
+  env%ewin = ewinbackup
+  env%rthr = rthrbackup
+  call rmrf('OPTIM')
+  write (*,*)
 !--- then vloose optimization
-        call smallhead('2. optimization with loose thresholds')
-        call checkname_xyz(crefile,inpnam,outnam)
-        call MDopt_para(env,trim(inpnam),2)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        env%ewin=ewinbackup*2.0d0
-        call confg_chk3(env)
-        call remaining_in(trim(inpnam),env%ewin,nremain)
-        env%ewin=ewinbackup
-        env%rthr=rthrbackup
-        write(*,*)
+  call smallhead('2. optimization with loose thresholds')
+  call checkname_xyz(crefile,inpnam,outnam)
+  call MDopt_para(env,trim(inpnam),2)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  env%ewin = ewinbackup*2.0d0
+  call confg_chk3(env)
+  call remaining_in(trim(inpnam),env%ewin,nremain)
+  env%ewin = ewinbackup
+  env%rthr = rthrbackup
+  write (*,*)
 !--- lastly vtight optimization
-        call smallhead('3. optimization with very tight thresholds')
-        call checkname_xyz(crefile,inpnam,outnam)
-        call MDopt_para(env,trim(inpnam),0)
-        filename=trim(thispath)//'/'//trim(outnam)
-        call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
-        call confg_chk3(env)
-        call checkname_xyz(crefile,inpnam,outnam)
-        call remaining_in(trim(inpnam),env%ewin,nremain)
-        call rmrf('OPTIM')
-        write(*,*)
-      
+  call smallhead('3. optimization with very tight thresholds')
+  call checkname_xyz(crefile,inpnam,outnam)
+  call MDopt_para(env,trim(inpnam),0)
+  filename = trim(thispath)//'/'//trim(outnam)
+  call rename('OPTIM'//'/'//'opt.xyz',trim(filename))
+  call confg_chk3(env)
+  call checkname_xyz(crefile,inpnam,outnam)
+  call remaining_in(trim(inpnam),env%ewin,nremain)
+  call rmrf('OPTIM')
+  write (*,*)
+
 !---- printout
-      call catdel('cregen.out.tmp')
-      write(*,*)
-      write(*,'(1x,a,1x,a)') 'Final ensemble on file','<'//trim(newname)//'>'
+  call catdel('cregen.out.tmp')
+  write (*,*)
+  write (*,'(1x,a,1x,a)') 'Final ensemble on file','<'//trim(newname)//'>'
 
-      call rename(conformerfile,trim(newname))
-  
- 
+  call rename(conformerfile,trim(newname))
+
 !---- clean up
-      call screen_cleanup
+  call screen_cleanup
 
 !---- get the timing
-      call tim%stop(1)
-end subroutine screen
-
-!-----------------------------------------------------------------------------------------------------
-! MTD sample: for a given ensemble file perform 2 (short) MTDs on each structure and optimize along
-! the collected trajectories
-!
-! WIP
-!-----------------------------------------------------------------------------------------------------
-subroutine MTDsample(env,tim)
-    use crest_parameters
-    use crest_data
-    use iomod
-    use strucrd
-    implicit none
-    type(systemdata) :: env
-    type(timer)      :: tim
-    type(ensemble) :: ens
-    character(len=512) :: thispath
-    character(len=:),allocatable :: subdirname
-    character(len=128) :: mtddir
-    character(len=:),allocatable :: coordname
-    integer :: r
-    integer :: i,l
-    logical :: ex
-    real(wp) :: mdtime
-
-        associate( nat => env%nat, hmass => env%hmass, mdtemp => env%mdtemp,    &
-         & mdstep => env%mdstep, shake => env%shake, mddumpxyz => env%mddumpxyz, &
-         & mdskip => env%mdskip, mddump => env%mddump )
-
-
-    inquire(file=env%ensemblename,exist=ex)
-    if(ex)then
-        call ens%open(env%ensemblename)
-    else
-       error stop 'Ensemble file does not exist!'
-    endif
-
-    call md_length_setup(env)  !set the MD length according to a flexibility measure
-    mdtime=env%mdtime
-
-    ens%xyz = ens%xyz / bohr  !to bohr so we can write coords
-
-    call tim%start(5,'MTDsample')
-    call getcwd(thispath)
-    subdirname='MTDSAMPLE'
-    r = makedir(subdirname)
-    call chdir(subdirname)
-
-    do i=1,ens%nall
-       write(mtddir,'(a,i0)')'MTD',i
-       coordname=trim(mtddir)//'/'//'coord'
-       call wrc0(coordname,ens%nat,ens%at,ens%xyz(1:3,1:ens%nat,i))
-       if(env%gfnver=='--gff')then
-          l = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(mtddir)//'/'//'gfnff_topo')
-       endif
-       call setMDrun2(coordname,hmass,mdtime,mdtemp,mdstep,shake,mddumpxyz, &
-      &             mdskip,mddump,-1,env%cts)
-
-       call env%wrtCHRG(trim(mtddir))
-    enddo
-
-
-    call chdir(thispath)
-    call tim%stop(5)
-
-    end associate
-    return
-end subroutine MTDsample
-
+  call tim%stop(1)
+end subroutine screen_legacy
 
Index: .github/workflows/build.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>name: CI\non: [push, pull_request]\n\nenv:\n  BUILD_DIR: _build\n  XTB_VERSION: 6.5.0\n\njobs:\n  intel-meson-build:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu-20.04]\n        fc: [ifort]\n        cc: [icc]\n    env:\n      FC: ${{ matrix.fc }}\n      CC: ${{ matrix.cc }}\n#      APT_PACKAGES: >-\n#        intel-oneapi-compiler-fortran-2022.2.1\n#        intel-oneapi-compiler-dpcpp-cpp-and-cpp-classic-2022.2.1\n#        intel-oneapi-mkl-2022.2.1\n#        intel-oneapi-mkl-devel-2022.2.1\n      APT_PACKAGES: >-\n        intel-oneapi-compiler-fortran\n        intel-oneapi-compiler-dpcpp-cpp-and-cpp-classic\n        intel-oneapi-mkl\n        intel-oneapi-mkl-devel\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Setup Python\n      uses: actions/setup-python@v1\n      with:\n        python-version: 3.x\n\n    - name: Add Intel repository\n      if: contains(matrix.os, 'ubuntu')\n      run: |\n        wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS-2023.PUB\n        sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS-2023.PUB\n        rm GPG-PUB-KEY-INTEL-SW-PRODUCTS-2023.PUB\n        echo \"deb https://apt.repos.intel.com/oneapi all main\" | sudo tee /etc/apt/sources.list.d/oneAPI.list\n        sudo apt-get update\n\n    - name: Install Intel oneAPI compiler\n      if: contains(matrix.os, 'ubuntu')\n      run: |\n        sudo apt-get install ${{ env.APT_PACKAGES }}\n        source /opt/intel/oneapi/setvars.sh\n        printenv >> $GITHUB_ENV\n\n    - name: Install meson\n      run: pip3 install meson==0.63.3 ninja\n\n    - name: Configure meson build\n      run: meson setup ${{ env.BUILD_DIR }} --prefix=/\n\n    - name: Build project\n      run: ninja -C ${{ env.BUILD_DIR }}\n\n    - name: Install package\n      run: |\n        meson install -C ${{ env.BUILD_DIR }} --no-rebuild\n        tar cJvf crest-latest.tar.xz --directory=${{ env.BUILD_DIR }} crest\n      env:\n        DESTDIR: ${{ env.PWD }}/_dist\n\n    - name: Upload binary\n      if: github.event_name == 'push'\n      uses: actions/upload-artifact@v2\n      with:\n        name: crest-latest.tar.xz\n        path: crest-latest.tar.xz\n\n    - name: Add crest to path\n      run: |\n        echo ${{ env.PWD }}/_dist/bin >> $GITHUB_PATH\n\n    - name: Download xtb\n      uses: i3h/download-release-asset@v1\n      with:\n        owner: grimme-lab\n        repo: xtb\n        tag: v${{ env.XTB_VERSION }}\n        file: '/xtb-${{ env.XTB_VERSION }}-linux-x86_64\\.tar\\.xz/'\n\n    - name: Add xtb to path\n      run: |\n        tar xvf xtb-*.tar.xz\n        echo ${{ env.PWD }}/xtb-${{ env.XTB_VERSION }}/bin >> $GITHUB_PATH\n\n#    - name: Run example 0\n#      run: |\n#        bash run.sh\n#      working-directory: examples/expl-0\n\n\n#  continuous-delivery:\n#    if: github.event_name == 'push'\n#    runs-on: ubuntu-latest\n#    needs:\n#      - intel-meson-build\n#\n#    env:\n#      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n#      RELEASE_TAG: latest\n#      OUTPUT_INTEL: crest-latest.tar.xz\n#\n#    steps:\n#    - uses: actions/checkout@v2\n#\n#    - name: Install github-release\n#      run: |\n#        go install github.com/github-release/github-release@latest\n#        echo \"GOPATH=$(go env GOPATH)\" >> $GITHUB_ENV\n#        echo \"$(go env GOPATH)/bin\" >> $GITHUB_PATH\n#\n#    - name: Set environment variables\n#      run: |\n#        echo \"GITHUB_USER=$( echo ${{ github.repository }} | cut -d/ -f1 )\" >> $GITHUB_ENV\n#        echo \"GITHUB_REPO=$( echo ${{ github.repository }} | cut -d/ -f2 )\" >> $GITHUB_ENV\n#\n#    - name: Move/Create continuous tag\n#      run: |\n#        git tag --force ${{ env.RELEASE_TAG }} ${{ github.sha }}\n#        git push --tags --force\n#\n#    - name: Get Time\n#      run: echo \"TIME=$(date -u '+%Y/%m/%d, %H:%M')\" >> $GITHUB_ENV\n#\n#    - name: Check continuous release status\n#      run: |\n#        if ! github-release info -t ${{ env.RELEASE_TAG }} > /dev/null 2>&1; then\n#          echo \"RELEASE_COMMAND=release\" >> $GITHUB_ENV\n#        else\n#          echo \"RELEASE_COMMAND=edit\" >> $GITHUB_ENV\n#        fi\n#\n#    - name: Setup continuous release\n#      run: >-\n#        github-release ${{ env.RELEASE_COMMAND }}\n#        --tag ${{ env.RELEASE_TAG }}\n#        --name \"Continous release version\"\n#        --description \"$DESCRIPTION\"\n#        --pre-release\n#      env:\n#        DESCRIPTION: |\n#          Created on ${{ env.TIME }} UTC by @${{ github.actor }} with commit ${{ github.sha }}.\n#          This is an automated distribution of the latest CREST version. \n#          This version is only minimally tested and may be unstable or even crash. \n#          Use with caution!\n#          https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n#\n#    - name: Download Artifacts\n#      uses: actions/download-artifact@v2\n#      with:\n#        path: ${{ github.workspace }} # This will download all files\n#\n#    - name: Create SHA256 checksum\n#      run: |\n#        cd ${{ env.OUTPUT_INTEL }}\n#        sha256sum ${{ env.OUTPUT_INTEL }} > sha256.txt\n#\n#    - name: Add crest-latest to release tag\n#      run: >-\n#        github-release upload\n#        --tag ${{ env.RELEASE_TAG }}\n#        --replace\n#        --name ${{ env.OUTPUT_INTEL }}\n#        --file ${{ env.OUTPUT_INTEL }}/${{ env.OUTPUT_INTEL }}\n#\n#    - name: Add SHA256 checksums to release tag\n#      run: >-\n#        github-release upload\n#        --tag ${{ env.RELEASE_TAG }}\n#        --replace\n#        --name sha256.txt\n#        --file ${{ env.OUTPUT_INTEL }}/sha256.txt\n#                                                     \n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
--- a/.github/workflows/build.yml	
+++ b/.github/workflows/build.yml	
@@ -23,10 +23,15 @@
 #        intel-oneapi-mkl-2022.2.1
 #        intel-oneapi-mkl-devel-2022.2.1
       APT_PACKAGES: >-
-        intel-oneapi-compiler-fortran
-        intel-oneapi-compiler-dpcpp-cpp-and-cpp-classic
-        intel-oneapi-mkl
-        intel-oneapi-mkl-devel
+        intel-oneapi-compiler-fortran-2022.2.1
+        intel-oneapi-compiler-dpcpp-cpp-and-cpp-classic-2022.2.1
+        intel-oneapi-mkl-2022.2.1
+        intel-oneapi-mkl-devel-2022.2.1
+#      APT_PACKAGES: >-
+#        intel-oneapi-compiler-fortran
+#        intel-oneapi-compiler-dpcpp-cpp-and-cpp-classic
+#        intel-oneapi-mkl
+#        intel-oneapi-mkl-devel
 
     steps:
     - name: Checkout code
@@ -56,6 +61,13 @@
     - name: Install meson
       run: pip3 install meson==0.63.3 ninja
 
+    - name: Git Sumbodules (including tblite patch)
+      run: |
+        git submodule update --init
+        cd subprojects/tblite
+        git apply ../packagefiles/tblite/tblite_patch.patch
+        cd ../../
+
     - name: Configure meson build
       run: meson setup ${{ env.BUILD_DIR }} --prefix=/
 
Index: src/calculator/subprocess_engrad.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/subprocess_engrad.f90 b/src/calculator/subprocess_engrad.f90
new file mode 100644
--- /dev/null	
+++ b/src/calculator/subprocess_engrad.f90	
@@ -0,0 +1,52 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!> module subprocess_engrad
+!> RE-EXPORTS of subprocess engrad routines
+
+!=========================================================================================!
+
+module subprocess_engrad
+  use generic_sc
+  use xtb_sc
+  use turbom_sc
+  use orca_sc
+  implicit none
+  !>--- private module variables and parameters
+  private
+
+  !>--- generic subrpocess (run.sh)
+  public :: generic_engrad
+
+  !>--- xtb subprocess
+  public :: xtb_engrad
+
+  !>--- Turbomole-style subprocesses
+  public :: turbom_engrad
+
+  !>--- ORCA subprocesses
+  public :: ORCA_engrad
+
+!=========================================================================================!
+!=========================================================================================!
+contains    !> MODULE PROCEDURES START HERE
+!=========================================================================================!
+!=========================================================================================!
+
+end module subprocess_engrad
Index: src/legacy_algos/cregen_old.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!===============================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Stefan Grimme, Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!===============================================================================!\n\n!===============================================================================!\n! THIS IS THE OLD VERSION OF CREGEN AND IS ONLY PRESENT FOR LEGACY SUPPORT\n! SEE newcregen.f90 FOR THE ACTUAL ROUTINE USED PER DEFAULT\n!===============================================================================!\n\nsubroutine cregen2(env)\n      use iso_fortran_env, only : wp => real64, sp => real32, idp => int64\n      use crest_data\n      use crest_parameters, only: bohr\n      use ls_rmsd\n      use iomod\n      use strucrd, only: rdnat,rdcoord,wrc0,i2e,e2i\n      use axis_module\n   !$ use omp_lib\n      implicit none\n      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n\n      real(wp),allocatable :: xyz(:,:,:),e(:),p(:),er(:),c1(:,:),c2(:,:)\n      real(wp),allocatable :: c1r(:,:),c2r(:,:)\n      real(wp),allocatable :: xyznew(:,:,:),tmp(:,:),tmp3(:,:),enuc(:)\n      real(wp),allocatable :: edum(:),dist(:,:,:),tmp2(:),cn(:),cn0(:) \n      real(wp),allocatable :: sd(:,:),rot(:,:),roth(:,:),metric(:,:),jfake(:)\n      real(sp),allocatable :: rmat(:)\n      integer,allocatable  :: at(:),ind(:),double(:),group(:),idum(:),ind2(:)\n      integer,allocatable  :: atr(:)\n      integer,allocatable  :: relat(:,:),equiv(:,:,:),molvec(:)\n      integer,allocatable  :: pair(:),pre(:),nb(:,:),elist(:,:),flist(:,:)\n      integer,allocatable  :: jnd(:),sames(:)\n      logical,allocatable  :: vis(:)\n      real(wp),allocatable :: xx(:),pg(:),rcov(:)\n      real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:), ydum(:)  ! rmsd dummy stuff\n      integer,allocatable:: iref(:),dgen(:),glist(:,:),nmract(:)\n      character(len=40),allocatable :: origin(:),originnew(:)\n      integer,allocatable :: timetag(:)\n\n      real(wp) :: autokcal,beta,eav,A,T,rthr,s,g\n      real(wp) :: ss,ethr,de,dr,bthr\n      real(wp) :: elow,ewin,pthr,eref,athr,r\n      real(wp) :: dum\n      real(wp) :: rij(3),cnorm,erj\n      !real*8 :: gdum(3,3),Udum(3,3),xdum(3), ydum(3)  ! rmsd dummy stuff\n      real(wp), external :: rotdiff,shortest_distance\n\n      parameter (autokcal=627.509541d0)\n\n      integer :: i,j,k,l,m,nall,n,ig,ng,nall2\n      integer :: m1,m2,s1,s2,maxg,current,ndoub\n      integer :: molcount0,j1,iat,k2,m1end\n      integer :: kk,memb,irr,ir,nr,jj,nall_old\n      integer :: TID, nproc\n      integer :: ich,ich2,io,ich3,rednat\n      integer, external :: lin\n      integer*8, external :: lina,linr\n      integer(idp) :: klong\n      integer(idp),allocatable :: rmatmap1(:)\n      integer,allocatable :: rmatmap2(:),includeRMSD(:)\n\n      character(len=80) :: atmp,btmp,oname,fname,cname\n      character(len=3) :: a3            \n      character(len=512) :: outfile\n\n      logical :: debug,heavy,l1,l2,ex,newfile,anal,rmsdchk\n      logical :: fail\n      logical :: substruc\n      logical :: ttag\n      logical, external :: distcheck,equalrot,equalrotall\n\n      settingNames: associate( crestver => env%crestver, confgo => env%confgo, &\n      &             methautocorr => env%methautocorr, printscoords => env%printscoords,  &\n      &             ensemblename => env%ensemblename, compareens => env%compareens,      &\n      &             elowest => env%elowest, ENSO => env%ENSO, subRMSD => env%subRMSD,    &\n      &             trackorigin => env%trackorigin, autothreads => env%autothreads,      &\n      &             omp => env%omp, MAXRUN => env%MAXRUN, threads => env%threads)\n      rednat = env%rednat\n      allocate(includeRMSD(env%nat))\n      includeRMSD = env%includeRMSD\n\n      thresholdNames: associate( cgf => env%cgf, thresholds => env%thresholds)\n\n      outfile='cregen.out.tmp'\n      if(cgf(6))outfile='tmp'\n\n!------ the entire cregen output is printed to a seperate file\n      call remove(outfile)\n      if(confgo.and. .not.(env%properties.eq. -2))then\n       ich=6\n      else\n        open(newunit=ich, file=outfile)\n      endif      \n\n!---- small header\n      write(ich,'(''-------------------------------------'')')\n      write(ich,'(''CREGEN - CONFORMER SYMMETRY ANALYSIS'')')\n      write(ich,'(''-------------------------------------'')')\n\n\n      call remove('LOWER_FOUND')\n      \n      allocate(rcov(94),gdum(3,3),Udum(3,3),xdum(3),ydum(3),nmract(100))\n      call setrcov(rcov)\n\n!---- setting the threads for OMP parallel usage\n      if(autothreads)then\n         call ompautoset(threads,4,omp,MAXRUN,0) !mode=4 --> Program intern Threads max\n!$OMP PARALLEL PRIVATE(TID)\n      TID = OMP_GET_THREAD_NUM()\n      IF (TID .EQ. 0) THEN\n         nproc = OMP_GET_NUM_THREADS()\n         write(ich,*) '============================='\n         write(ich,*) ' # threads =', nproc\n         write(ich,*) '============================='\n      END IF\n!$OMP END PARALLEL \n      endif\n!=====================================================================================!\n      ewin = env%ewin      !ensemble energy window in kcal\n      rthr = env%rthr      ! RMSD thr in Ang\n      ethr = env%ethr      ! E threshold in kcal\n      bthr = thresholds(4) ! rot const  thr  !legacy \n      athr = env%athr      ! to det. int. rotation. equal atoms for NMR, CRITICAL!\n      pthr = env%pthr      ! population thr\n\n      T    = env%tboltz  ! Temperature   \n\n      debug  =cgf(1)\n      newfile=cgf(2)\n      anal   =cgf(3)\n      heavy  =cgf(4) !compare only heavy atoms + OH with RMSD\n      rmsdchk=cgf(5)\n\n      end associate thresholdNames\n\n      nmract = 0\n\n      substruc=.false.\n\n!======================================================================================!\n\n      if(.not.rmsdchk) rthr = bthr  ! use rot thr for doubles check\n\n      beta  =1./(T*8.314510/4.184/1000.+1.d-14)\n\n      fname=trim(ensemblename)\n      if(confgo.and.(index(trim(fname),'none selected').eq.0))then\n        fname=trim(ensemblename)\n        oname=trim(ensemblename)//'.sorted'\n        write(ich,*) 'input  file name : ',trim(fname)\n        write(ich,*) 'output file name : ',trim(oname)\n        cname=ensemblefile !'crest_ensemble.xyz'\n        if(env%fullcre)then\n           ensemblename=trim(oname)\n        endif\n      else\n        call checkname_xyz(crefile,fname,oname)\n        write(ich,*) 'input  file name : ',trim(fname)\n        write(ich,*) 'output file name : ',trim(oname)\n        cname=conformerfile\n      endif\n      \n\n      nall=1\n      open(unit=1,file=fname)\n 10   read(1,*,end=100) n\n      read(1,'(a)') btmp\n      do i=1,n\n      read(1,'(a)') btmp\n      enddo\n      nall=nall+1\n      goto 10\n100   nall=nall-1\n      if(nall.lt.1)then\n         !stop 'read error'\n         write(*,*) 'no new structures. continue.'\n         return\n      endif\n\n!-----------------------------------------------------------------------------------------\n\n      if(rednat.ne.n .and. subRMSD) substruc=.true.\n\n\n      write(ich,'('' number of atoms                :'',i6)')n\n      if(substruc)then\n      write(ich,'('' atoms included in RMSD         :'',i6)')rednat\n      endif\n      write(ich,'('' number of points on xyz files  :'',i6)')nall\n      write(ich,'('' RMSD threshold                 :'',f9.4)')rthr\n      write(ich,'('' Bconst threshold               :'',f9.4)')bthr\n      write(ich,'('' population threshold           :'',f9.4)')pthr\n      write(ich,'('' conformer energy window  /kcal :'',f9.4)')ewin\n\n\n      allocate(at(n),c1(3,n),c2(3,n),cn0(n),cn(n),molvec(n))\n      allocate(c1r(3,rednat),c2r(3,rednat),atr(rednat))\n\n      call rdcoord('coord',n,at,c1)\n      call mrec(molcount0,c1,n,at,molvec)\n      write(ich,'('' # fragment in coord            :'',i6)')molcount0\n\n      if(substruc)then\n        call cpincluded(n,rednat,c1,c1r,includeRMSD)\n        k=1\n        do i=1,n\n          if(includeRMSD(i).gt.0)then\n           atr(k)=at(i)\n           k=k+1\n          endif\n        enddo \n        call ncoord(rednat,rcov,atr,c1r,cn0,500.0d0)\n      else\n        call ncoord(n,rcov,at,c1,cn0,500.0d0)\n      endif\n\n!c read file\n      allocate(xx(10),iref(nall))\n\n!--- determine the reliable points on the ensemble file\n!    coord-file is the reference. Hence best use an optimized \n      rewind 1\n      iref=0\n!===================================================================!\n      if(.not.substruc)then\n!===================================================================!          \n      do j=1,nall\n         read(1,*) k\n         read(1,'(a)') btmp\n         call readl(btmp,xx,k)\n         erj=xx(1)            ! from GMD ensemble i.e. in Eh\n         do i=1,n\n            read(1,*)a3,c2(1:3,i)\n            if(j.eq.1) at(i) = e2i(a3)\n         enddo\n         c1(1:3,1:n)=c2(1:3,1:n)/bohr\n         l1=distcheck(n,c1)  ! distance check\n         cnorm=sum(abs(c1))\n         if(abs(erj).gt.1.d-6.and.cnorm.gt.1.d-6.and.l1) &\n      &  call ncoord(n,rcov,at,c1,cn,500.0d0)    ! further check for reactions based on CN\n         k2=0        \n         do i=1,n\n            if(.not.(cn0(i).gt.0))cycle\n            !if(abs((cn(i)-cn0(i)))/cn0(i).gt.0.3) k2=1       \n         enddo\n         if(k2.eq.1.or. &\n         &  abs(erj).lt.1.d-6.or. &\n         &  cnorm.lt.1.d-6.or. &\n         &  (.not.l1) ) &\n         &  then \n            write(ich,*) 'removing structure',j !,k2,er(j),cnorm,l1\n            iref(j)=1\n         endif\n      enddo\n!===================================================================!\n      else  !  n /= rednat (only selected atoms contribute\n!===================================================================!\n      do j=1,nall\n         read(1,*) k\n         read(1,'(a)') btmp\n         call readl(btmp,xx,k)\n         erj=xx(1)            ! from GMD ensemble i.e. in Eh\n         l=1\n         do i=1,n\n            if(includeRMSD(i).gt.0)then  \n              read(1,*)a3,c2r(1:3,l)\n              if(j.eq.1) atr(l) = e2i(a3)\n              l=l+1\n            else\n              read(1,'(a)') btmp\n            endif\n         enddo\n         c1r(1:3,1:rednat)=c2r(1:3,1:rednat)/bohr\n         \n         l1=distcheck(rednat,c1r)  ! distance check\n         cnorm=sum(abs(c1r))\n         if(abs(erj).gt.1.d-6.and.cnorm.gt.1.d-6.and.l1) &\n      &  call ncoord(rednat,rcov,atr,c1r,cn,500.0d0)    ! further check for reactions based on CN\n         k2=0\n         do i=1,rednat\n            !if(abs((cn(i)-cn0(i)))/cn0(i).gt.0.3) k2=1\n         enddo\n         if(k2.eq.1.or. &\n         &  abs(erj).lt.1.d-6.or. &\n         &  cnorm.lt.1.d-6.or. &\n         &  (.not.l1) ) &\n         &  then\n            write(ich,*) 'removing structure',j !,k2,er(j),cnorm,l1\n            iref(j)=1\n         endif\n       enddo\n!==================================================================!\n       endif\n!==================================================================!       \n    !---------\n    ! iref is 0 for structures that are ok \n    ! and 1 for 'broken' structures.\n    !--------\n      nall_old=nall\n      nall=nall-sum(iref(1:nall))\n      nall2=nall\n      write(ich,'('' number of reliable points      :'',i6)')nall    \n\n      allocate(xyz(3,n,nall),er(nall),            &\n     &         p(nall),e(nall),ind(nall),double(nall),tmp(3,nall),      &\n     &         xyznew(3,n,nall),tmp2(n),jnd(n),sames(nall),ind2(nall),  &\n     &         group(0:nall),idum(nall),edum(nall),                     &\n     &         relat(0:n,n),enuc(nall),tmp3(3,nall),                    &\n     &         jfake(n*(n+1)/2),sd(n,n),rot(3,nall),roth(3,nall),metric(n,n), &\n     &         vis(n),pre(n),pair(n*(n+1)/2),nb(200,n),elist(n,n),flist(n,n))\n\n\n      !array for tracking the origin\n      if(trackorigin)then      \n         allocate(origin(nall),originnew(nall))\n         if(env%entropic)then\n           allocate(timetag(nall))\n         endif\n      endif\n\n!---- only use the reliable points\n!!!\n! THE ENSEMBLE FILE IS READ HERE\n!!!\n      jj=0\n      rewind 1\n      do j=1,nall_old\n         if(iref(j).eq.0) jj=jj+1\n         read(1,*) k\n         read(1,'(a)') btmp\n         call readl(btmp,xx,k)\n         if(iref(j).eq.0)then\n          er(jj)=xx(1)    \n          if(trackorigin)then\n             call getorigin(trim(btmp),origin(jj))\n          endif\n          do i=1,n\n            read(1,*)a3,xyz(1:3,i,jj)\n          enddo\n         else\n          do i=1,n\n            read(1,*)a3,rij(1:3)\n          enddo\n         endif\n      enddo\n      close(1)\n\n!---sort\n!!!\n! ind array is used to track the order\n!!!\n      do i=1,nall\n         ind(i)=i\n      enddo\n      call Qsort(er,1,nall,ind) ! sort for E \n      elow=er(1)\n\n      do i=1,nall\n         xyznew(1:3,1:n,i)=xyz(1:3,1:n,ind(i))\n      enddo\n\n      do i=1,nall\n         xyz(1:3,1:n,i)=xyznew(1:3,1:n,i)\n      enddo\n    \n      !--- for the origin tracking. The arrays conatin a lable form which step the structure was obtained\n      if(trackorigin)then\n        do i=1,nall\n         originnew(i)=origin(ind(i))\n        enddo\n        origin=originnew\n      endif\n      !if(trackorigin .and. env%entropic)then !check if we have valid time tags for entropy mode\n      !  atmp=origin(1)\n      !  if(atmp(1:1)=='t')then\n      !      ttag=.true.\n      !  else\n            ttag=.false.\n      !  endif\n      !endif\n\n!---to CMA\n      do i=1,nall\n         c1(1:3,1:n)=xyz(1:3,1:n,i)\n         call axis(n,at,c1,c2,rot(1:3,i))   !-- this does the CMA trafo, and gives rot.const. MHz    \n         !write(*,'(i5,2x,3f10.2)') i,rot(1:3,i) !-- rotational constant printout\n         xyz(1:3,1:n,i)=c2(1:3,1:n)\n      enddo\n      if(substruc)then  !-- we have to do it again for the reduced mode, i.e., if atoms are excluded from the comparison\n         do i=1,nall\n            c1(1:3,1:n)=xyz(1:3,1:n,i)\n            call cpincluded(n,rednat,c1,c1r,includeRMSD)\n            call axis(rednat,atr,c1r,c2r,rot(1:3,i))\n         enddo\n      endif\n\n      if(.not.env%allrot .and. .not.rmsdchk)then  !-- not needed by default\n      rot = rot /dble(n)**2  !-- normalize such that it can be used instead of the RMSD\n      endif\n\n!--------\n      if(env%esort) then    !-- just resort the input and make a cut (if inquired by cmd)\n        open(unit=2,file=oname)                        \n        do i=1,nall\n           if((er(i)-elow)*autokcal.gt.ewin) goto 999\n           c2(1:3,1:n)=xyz(1:3,1:n,i)\n           write(2,'(2x,i0)') n\n           if(.not.trackorigin)then\n             write(2,'(2x,f18.8)') er(i)\n           else\n             write(2,'(2x,f18.8,4x,a)') er(i),'!'//trim(origin(i)) \n           endif\n           do j=1,n\n              write(2,'(1x,a2,1x,3f18.8)')i2e(at(j),'nc'),c2(1:3,j)\n           enddo\n        enddo\n 999    close(2)\n        write(ich,*) i-1,' out of ',nall,' taken'\n        write(ich,*) 'normal resort termination of confg'\n        goto 666\n      endif\n!--------\n      inquire(file='.tmpxtbmodef',exist=ex)\n      if(ex)then\n       open(unit=66,file='.tmpxtbmodef')\n       read(66,*) i\n       read(66,*) eref\n       close(66)\n      else\n       eref=er(1)\n      endif\n      if(crestver.eq.1)then\n        write(ich,*)'reference state (Hessian) Etot :',eref\n      else\n        write(ich,*)'reference state Etot :',eref\n      endif\n!---get RMSD\n  !========================================================!\n  !--- crucial point: rmat is huge. VERY huge.\n      !klong=nall\n      !klong=klong*(nall+1)\n      !klong=klong/2\n      !write(*,*) nall,klong\n\n  !--- for large ensembles the size of rmat can be largley reduced\n  !    but this requires additional tracking and counting.\n  !    It will be worth it, however.\n      allocate(rmatmap1(nall),rmatmap2(nall))\n      klong=0\n      do i=1,nall\n         rmatmap1(i)=klong\n         l1=.true.\n         do j=1,i-1\n            !er(j) should always be smaller than er(i) because of presorting\n            de=(er(i)-er(j))*autokcal\n\n            if(de.lt.ethr)then\n                klong=klong+1\n                if(l1)then\n                    rmatmap2(i)=j\n                    l1=.false.\n                endif\n            endif\n          enddo\n      enddo   \n\n      allocate(rmat(klong))\n      rmat=0\n  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n      if(rmsdchk)then\n  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n      write(*,'(1x,a)') 'running RMSDs...'\n      if(.not.substruc)then !regular case\n      klong=0    \n      do i=1,nall\n         c1(1:3,1:n)=xyz(1:3,1:n,i)\n!$OMP PARALLEL PRIVATE ( j,klong,c2,xdum,ydum,Udum,gdum,dum,de) &\n!$OMP SHARED ( i,c1,rmat,n,xyz,rmatmap1,rmatmap2,er,ethr)\n!$OMP DO \n         do j=1,i-1\n           de=(er(i)-er(j))*autokcal\n           if(de.lt.ethr)then\n                c2(1:3,1:n)=xyz(1:3,1:n,j)\n                call rmsd(n,c1,c2,0,Udum,xdum,ydum,dum,.false.,gdum) ! all atoms\n               ! klong=lina(j,i)\n                klong=linr(rmatmap1(i),rmatmap2(i),j)\n                !$omp critical\n                rmat(klong) = real(dum, 4)\n                !$omp end critical\n            endif\n         enddo\n!$OMP END DO\n!$OMP END PARALLEL\n      enddo\n!--- substruc\n      else  ! n /= rednat\n      do i=1,nall\n         c1(1:3,1:n)=xyz(1:3,1:n,i)\n         call cpincluded(n,rednat,c1,c1r,includeRMSD)\n!$OMP PARALLEL PRIVATE ( j,klong,c2,c2r,xdum,ydum,Udum,gdum,dum,de) &\n!$OMP SHARED ( i,c1r,rmat,n,xyz,rednat,includeRMSD,rmatmap1,rmatmap2,er,ethr)\n!$OMP DO \n         do j=1,i-1\n           de=(er(i)-er(j))*autokcal\n           if(de.lt.ethr)then\n               c2(1:3,1:n)=xyz(1:3,1:n,j)\n               call cpincluded(n,rednat,c2,c2r,includeRMSD)\n               call rmsd(rednat,c1r,c2r,0,Udum,xdum,ydum,dum,.false.,gdum) ! all atoms\n               ! klong=lina(j,i)\n               klong=linr(rmatmap1(i),rmatmap2(i),j)\n               !$omp critical\n               rmat(klong) = real(dum, 4)\n               !$omp end critical\n           endif\n         enddo\n!$OMP END DO\n!$OMP END PARALLEL\n      enddo\n      endif\n      write(*,'(1x,a)') 'done.'\n   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n      else   !if rotational constants are used instead of rmsd\n   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n       do i=1,nall\n         do j=1,i-1\n            de=(er(i)-er(j))*autokcal\n            if(de.lt.ethr)then\n            !klong=lina(j,i)\n            klong=linr(rmatmap1(i),rmatmap2(i),j)\n            rmat(klong)=real(rotdiff(i,j,nall,rot), 4)\n            endif\n         enddo\n       enddo\n  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n      endif\n\n!---apply RMSD threshold\n! \"sames\" is used to track conformers (INCLUDING doubles).\n!  IMPORTANT: we only have to check for duplicates within the boundaries of ETHR.\n!  This allows for a much smaller RMAT\n      double=0\n      sames=0\n      do i=1,nall\n         do j=1,i-1\n            ! klong=lina(j,i)\n            de=(er(i)-er(j))*autokcal\n            if(de.lt.ethr)then\n              klong = linr(rmatmap1(i),rmatmap2(i),j) \n              dr = rmat(klong)\n            else\n              cycle  \n            endif\n            if(dr.lt.rthr) then\n               double(i)=1  ! i > j, i.e., E(i) > E(j)\n               sames(i)=j\n               !write(*,*) i,j,rmat(k)\n            elseif(dr.lt.2.*rthr) then\n               if(.not.env%allrot)then\n               l1=equalrot(i,j,nall,0.5*bthr,rot)\n               else\n               l1=equalrotall(i,j,nall,bthr,rot)\n               endif\n               if(l1)then !.and.l3) then\n                  double(i)=1  \n                  sames(i)=j\n               endif\n            endif\n         enddo\n      enddo\n      deallocate(rmatmap2,rmatmap1)\n      deallocate(rmat)\n\n!---kick out doubles\n      ndoub = 0\n      do i=1,nall \n         if(double(i).eq.1) then\n            er(i)=1.d+6           !with this high energy the conformer won't be considered later\n            ndoub = ndoub + 1\n         endif\n      enddo\n      write(ich,*)'number of doubles removed by rot/RMSD         :',ndoub\n\n!---rel. energies    \n      do i=2,nall\n         er(i)=(er(i)-er(1))*autokcal\n      enddo\n      er(1)=0\n\n!---keep only the true conformers in final ensemble\n      edum=0\n      tmp=0\n      if(trackorigin) originnew=''\n      m=0\n      do i=1,nall\n         if(er(i).gt.ewin) cycle   !--- discard everything >6kcal/mol\n         m=m+1\n         edum(m)=er(i)\n         xyznew(1:3,1:n,m)=xyz(1:3,1:n,i)\n         tmp   (1:3,m)    =rot(1:3,i)\n         !tmp3  (1:3,m)    =roth(1:3,i)\n         if(trackorigin)then\n            originnew(m)=origin(i)\n         endif\n         ind2(m)=i\n      enddo\n      nall  = m\n      xyz   = xyznew\n      er    = edum\n      rot   = tmp\n      !roth  = tmp3\n      write(ich,*)'total number unique points considered further :',nall \n\n      do k=1,nall\n         c1(1:3,1:n)=xyz(1:3,1:n,k)\n         enuc(k)=0                          \n         do i=1,n-1\n            do j=i+1,n\n               r=(c1(1,i)-c1(1,j))**2 &\n           &    +(c1(2,i)-c1(2,j))**2 &\n           &    +(c1(3,i)-c1(3,j))**2+1.d-12\n               enuc(k)=enuc(k)+at(i)*at(j)/r\n            enddo\n         enddo\n      enddo\n\n!--- IMPORTANT SORTING PROCEDURE\n!    Loop over pre-sorted structure pairs, and check several things:\n      double=0  !--- grouping tensor                                 \n      SORTI : do i=1,nall\n          SORTJ : do j=1,i \n            de=er(i)-er(j)                        !-- energy difference\n            if(.not.env%allrot)then\n              l1=equalrot(i,j,nall,bthr,rot)\n            else\n              l1=equalrotall(i,j,nall,bthr,rot)     !-- rotational constant difference\n            endif\n\n            l2=2.*abs(enuc(i)-enuc(j))/(enuc(i)+enuc(j)).lt.1.d-3  !-- nuclear permutation\n!           k=lin(i,j)\n\n            if(l1.and.l2.and.i.ne.j  &\n           &   .and.double(i).eq.0   &\n           &   .and.abs(de).lt.ethr) then\n               double(i)=j   !-- this means \"structure i is the same conformer as structure j\"\n                             !   for j=i it is 0 because the if statement is skipped.\n               cycle SORTI\n               goto 99\n            endif\n          enddo SORTJ\n 99       continue\n      enddo SORTI\n\n       do i=1,nall\n          call backtrack(double,i,j)\n       enddo\n\n!---assign structures to identical conformers\n      ig=0      !-- total number of \"groups\", i.e. unique conformers\n      group=0   !-- grouping tensor -- which structure belongs to which group\n   !-- first, assign a representative for each new group, and determine how many groups there are\n      do i=1,nall\n         if(double(i).eq.0)then\n            ig=ig+1                            !-- ascending order 1-to-\"total number of groups\"\n            iref(ig)=i                         !-- i=the unique ref.structure in each group\n            group(i)=ig                        !-- assign struc. i to group ig\n         endif\n      enddo\n      ng=ig      !-- number of conformer groups, i.e., unique conformers\n    !-- then, assign all remaining structures to their respective groups\n      !!THE FOLLOWING PART IS WRONG!\n      !k=group(1)\n      !do i=1,nall\n      !   if(group(i).ne.0)then\n      !      k=group(i)\n      !   else\n      !      group(i)=k\n      !   endif\n      !enddo\n      !!THIS SHOULD BE CORRECT!\n      do i=1,nall\n         if(group(i).eq.0)then\n           j=double(i)\n           group(i)=group(j)\n         endif \n      enddo\n\n      !-- repair the group order (can be importent when conformers with very similar energies exist)\n      if(trackorigin .and. env%entropic .and. ttag)then\n        call repairentropic(nall,n,ng,group,xyz,er,trackorigin,originnew)\n        originnew(1) = 't1' !dirty hack, but conceptionally this is rigth -> lowest conformer must be present at the start\n      else\n        call repairorder(nall,n,ng,group,xyz,er,trackorigin,originnew)\n      endif\n     \n      !-- determine # of members in each group (=rotamers)\n      allocate(dgen(nall))\n      dgen=0\n      do i=1,nall\n         dgen(group(i))=dgen(group(i))+1\n      enddo\n\n      allocate(glist(0:nall,ng))\n      glist=0\n      do i=1,ng                                ! det members of indents in each group\n         do j=1,nall\n            if(group(j).eq.i)then\n               glist(0,i)=glist(0,i)+1\n               glist(glist(0,i),i)=j\n            endif\n         enddo\n      enddo\n\n!----\n! ADVANCED TRACKING FOR ENSO\n!---\n      if(ENSO.and.confgo)then\n       do i=1,nall\n         j=ind2(i)\n         !if(i.eq.1.or.group(i-1).ne.group(i))then\n         if(i.ne.1 .and. group(i-1).eq.group(i))then         \n         k=ind2(i-1)\n         sames(i)=k\n         if(k.eq.i)sames(i)=0\n         endif\n       enddo\n       do i=1,nall2\n          j=0\n          call backtrack(sames,i,j)\n       enddo\n       j=sum(sames)\n       open(newunit=ich3,file='cregen.enso')\n       if(j.gt.0)then  !doubles found\n         write(ich3,*) \"DUPLICATES FOUND\"\n         do i=1,nall2\n            if(sames(i).gt.0)then\n            !write(*,*) ind(i),ind(sames(i))\n             write(ich3,*)ind(i),ind(sames(i))\n            endif\n         enddo\n       else\n         write(ich3,*) \"ALL UNIQUE\"\n       endif\n       close(ich3)\n      endif\n\n\n!---distance neighbor list\n      c2(1:3,1:n)=xyz(1:3,1:n,1)/bohr\n      call neighdist(n,at,c2,nb,metric)\n      k=0\n      pair=0\n      do i=1,n-1\n         do j=i+1,n\n!---the shortest bond path\n            current=j\n            dum=shortest_distance(n, i, j, nb, metric, vis, pre)\n            k=0\n            do while (pre(current) /= 0)\n               current = pre(current)\n               k = k + 1\n            end do ! End loop: while precessor(current) /= 0\n            pair(lin(j,i))=k  ! # of bonds between i and j\n         enddo\n      enddo\n\n      allocate(equiv(0:n,n,0:nall))\n      equiv=0\n! (costly) symmetry analyis of all rotamers for NMR. this is complicated stuff also\n! and the end of the program where this is completed...\n      if(anal)then\n      allocate(dist(n,n,nall))\n      do i=1,nall\n         call distance(n,xyz(1,1,i),dist(1,1,i))   ! distance matrix\n         do j=1,n\n            do k=1,n\n               tmp2(k)=dist(k,j,i)*dble(at(k))  ! the distance of j to all atoms * Z to distinguish\n            enddo\n            call qqsort(tmp2,1,n)\n            dist(1:n,j,i)=tmp2(1:n)\n         enddo\n      enddo\n      write(ich,*) 'compare ...'\n      do i=1,ng \n         m=glist(0,i)\n         if(m.lt.2) cycle                      ! det equivalent atoms in each group\n         relat=0\n         do m1=1,m\n!$OMP PARALLEL PRIVATE ( m2, s1, s2 ) SHARED ( relat )\n!$OMP DO \n            do m2=1,m1-1                       ! compare all members \n               s1=glist(m1,i)                  ! struc 1\n               s2=glist(m2,i)                  ! struc 2\n               call compare(n,nall,s1,s2,dist,athr,relat) ! athr is distance vector equivalence threshold\n            enddo\n!$OMP END DO\n!$OMP END PARALLEL\n         enddo\n         equiv(0:n,1:n,i)=relat(0:n,1:n)\n      enddo\n      deallocate(dist)\n! symmetrize result i.e. if iat is in list of jat, jat must be in list of iat\n! done again at the end of this part\n      do i=1,ng \n         do j1=1,n\n            m1=equiv(0,j1,i)\n            do k=1,m1\n               iat=equiv(k,j1,i)\n!              is atom j1 in the list of atom iat?\n               ex=.false.\n               m2=equiv(0,iat,i)\n               do k2=1,m2\n                  if(j1.eq.equiv(k2,iat,i)) ex=.true.\n               enddo\n               if(.not.ex)then\n                  equiv(0,iat,i)=equiv(0,iat,i)+1\n                  equiv(equiv(0,iat,i),iat,i)=j1\n               endif\n            enddo\n         enddo\n      enddo\n\n      do i=1,ng \n        if(sum(equiv(0,1:n,i)).eq.0) cycle     \n        if(debug)write(ich,*)'conformer set ',i\n        memb=glist(0,i)\n        do j=1,n\n           m=equiv(0,j,i)\n           if(m.eq.0) cycle         \n           if(debug)write(ich,'(''atom :'',i4,'' equivalent to '',40i3)') &\n        &  j,(equiv(k,j,i),k=1,m)\n        enddo\n      enddo\n      endif ! symmetry analysis\n\n!---populations\n      call boltz(nall,T,er,p)\n      allocate(pg(ng))\n      do i=1,ng \n         m=glist(0,i)\n         pg(i)=0\n         do j=1,m\n            pg(i)=pg(i)+p(glist(j,i))  !-- sum of pops in a group\n         enddo\n         if(pg(i).gt.pthr) maxg=i\n      enddo\n\n!---output and write\n      c1(1:3,1:n)=xyz(1:3,1:n,1)\n!      write(ich,*) 'full ensemble on file crest_rotamers_*.xyz'\n!      write(ich,*) \n!     .'unique structures in ensemble on crest_conformers.xyz and scoord.*'\n!      write(ich,*)'note: enantiomers are included.'\n      if(.not.trackorigin)then\n        write(ich,*)'  Erel/kcal     Etot      weight/tot conformer  set degen'\n        do i=1,nall\n           if(i.eq.1.or.group(i-1).ne.group(i))then\n           write(ich,'(i5,f8.3,1x,3f11.5,2i5)') &\n     &     i,er(i),er(i)/autokcal+elow,p(i),pg(group(i)), &\n     &     group(i),dgen(group(i))\n           else\n           write(ich,'(i5,f8.3,1x,2f11.5,i5)')i,er(i),er(i)/autokcal+elow,p(i)\n           endif\n        enddo\n      else !trackorigin\n        write(ich,*)'  Erel/kcal     Etot      weight/tot conformer  set degen    origin'\n        do i=1,nall\n           if(i.eq.1.or.group(i-1).ne.group(i))then\n           write(ich,'(i5,f8.3,1x,3f11.5,2i5,5x,a)') &\n     &     i,er(i),er(i)/autokcal+elow,p(i),pg(group(i)), &\n     &     group(i),dgen(group(i)),trim(originnew(i))\n           else\n           write(ich,'(i5,f8.3,1x,2f11.5,26x,a)') &\n     &     i,er(i),er(i)/autokcal+elow,p(i),trim(originnew(i))\n           endif\n        enddo\n      endif\n!---- write a mapping file file for \"-compare\" mode\n      if(compareens)then\n         open(newunit=ich2,file='.cretrack')\n         write(ich2,'(5x,i0)')maxval(group)\n         kk=1\n         do i=2,nall\n            if(group(i-1).ne.group(i))then\n              j=i-1\n              write(ich2,'(1x,i5,1x,i7,1x,i7)')group(j),kk,j    \n              kk=i\n            endif\n            if(i.eq.nall)then\n              write(ich2,'(1x,i5,1x,i7,1x,i7)')group(nall),kk,nall\n            endif\n         enddo\n         close(ich2)\n      endif\n!---write part\n      if(newfile) then\n        open(unit=2,file=oname)\n        do i=1,nall\n           c2(1:3,1:n)=xyz(1:3,1:n,i)\n           call axis(n,at,xyz(:,:,i),c2,xdum)           \n           !--- try to align all conformers the same way\n           call xyzalign(n,c2)\n           write(2,*) n\n           if(.not.trackorigin)then\n           write(2,*) er(i)/autokcal+elow,p(i)\n           else\n           write(2,*) er(i)/autokcal+elow,p(i),'!'//trim(originnew(i))\n           endif\n           do j=1,n\n              write(2,'(1x,a2,1x,3f18.8)')i2e(at(j),'nc'),c2(1:3,j)\n           enddo\n        enddo\n        close(2)\n      endif\n\n!---entropy and G\n      A=0\n      eav=0\n      do i=1,nall\n         A=A+p(i)*log(p(i)+1.d-12)   \n         eav=eav+p(i)*er(i)     \n      enddo\n\n      g = (1./beta)*A\n      s =-1000.*4.184*g/T\n      ss=-1000.*      g/T\n\n      write(ich,'(''T /K                                  :'', F9.2)')T \n      write(ich,'(''E lowest                              :'',f12.5)')elow\n      elowest=elow  ! <--- global access to elow\n      !---- elow printout in between routines\n      if(.not.confgo)then\n      write(*  ,'(1x,''E lowest :'',f12.5)')elow\n      endif\n      write(ich,'(''ensemble average energy (kcal)        :'', F9.3)')eav\n      write(ich,'(''ensemble entropy (J/mol K, cal/mol K) :'',2F9.3)')s,ss\n      write(ich,'(''ensemble free energy (kcal/mol)       : '',F8.3)')g\n      write(ich,'(''population of lowest in %             : '',F8.3)')pg(1)*100.d0\n\n      if((crestver.eq.1).and.(.not.confgo))then\n      if((elow-eref)*autokcal.lt.-0.2)then\n         write(ich,*) '...............................................'\n         write(ich,*) 'WARNING: new (best) energy less than that from '\n         write(ich,*) 'WARNING: preceding Hessian calculation:  '\n         write(ich,*) 'Improved by ', eref-elow, ' Eh or ',(eref-elow)*autokcal, 'kcal'\n         write(ich,*) '...............................................'\n         call touch('LOWER_FOUND')\n      endif\n      endif\n\n! now write the unique structures\n! and the symmetry info for NMR\n      maxg=0\n      do i=1,ng\n         k=glist(1,i) ! take first \n         if(er(k).lt.ewin) maxg=maxg+1\n      enddo\n      write(ich,*)'number of unique conformers for further calc ',maxg\n      write(ich,*)'list of relative energies saved as \"crest.energies\"'\n      open(newunit=ich2,file='crest.energies')\n      do i=1,maxg\n         write(ich2,'(i4,f12.3)') i,er(glist(1,i))\n      enddo\n      close(ich2)\n\n\n\n\n!---NMR part\n      if(anal)then\n   !--- get NMR active nuclei\n      atmp='.anmrrc'  ! <--- name of the .anmrrc written by ENSO\n      call getanmrrc(atmp,fail)\n      if(fail)then  !--- there is no .anmrrc from ENSO\n        write(ich,*)'NMR mode.'\n        nmract=0       ! all nuclei inactive\n        nmract(1) = 1  ! H active\n       !nmract(6) = 1  ! C active\n        nmract(9) = 1  ! F active\n        nmract(15)= 1  ! P active\n      else          !--- there IS a .anmrrc, and it is used.\n         write(ich,*)'NMR mode. Reading <',trim(atmp),'> for atomic NMR data'\n         open(newunit=ich2,file=atmp)\n           read(ich2,'(a)')atmp\n           read(ich2,'(a)')atmp\n           if(index(atmp,'ENSO').ne.0)then\n              read(ich2,'(a)')atmp\n           endif\n           do\n             read(ich2,*,iostat=io)i,xx(1:2),nmract(i)\n             if(io<0) exit\n           enddo\n         close(ich2)\n      endif\n\n\n! inlcude equivalence info from the other conformers as well i.e.\n! assume that all conformers have the same chemical equivalencies\n! the result is put into equiv(:,:,0)\n      equiv(0:n,1:n,0)=equiv(0:n,1:n,1)\n      do i=2,ng\n         do j=1,n\n            m1end=equiv(0,j,0)   ! end of list of lowest\n            do m=1,equiv(0,j,i)  ! list of higher\n               k=equiv(m,j,i)    ! in the one in the higher list\n               do m1=1,m1end\n                  if(equiv(m1,j,0).eq.k) goto 19 !already there?\n               enddo\n               equiv(0,j,0)=equiv(0,j,0)+1 ! append\n               equiv(equiv(0,j,0),j,0)=k\n 19            continue\n            enddo\n         enddo\n      enddo\n\n!cc    this cc commented out code makes equivalencies for all confs seperately\n!cc    do ig=0,ng     ! all conf groups\n!cc    call mkd(ig)   ! make the NMR dir \n!cc    call getname(ig,'anmr_nucinfo',fname)  ! open the file \n!cc    open(unit=3,file=fname)\n      ig=0\n      atmp='anmr_nucinfo'\n      open(unit=3,file=atmp)\n!cc    write(*,'(''::::::::::: conformer group '',i3,'':::::::::::'')')ig\n      write(ich,'(''::::::::::: conformer group all :::::::::::'')')\n      write(3,*) n\n!cccccccccccccccccc\n!c chem eq. first\n!cccccccccccccccccc\n      elist=0\n      !write(*,*) equiv(0,:,ig)\n      if(methautocorr)then\n        call methyl_autocomplete(n,c1/bohr,at,equiv(:,:,ig))\n      endif\n      !write(*,*) equiv(0,:,ig)\n      do i=1,n\n         m=equiv(0,i,ig)   \n         do k=1,m              \n            l=equiv(k,i,ig)\n            elist(l,i)=1\n         enddo\n         elist(i,i)=1\n      enddo\n      do i=1,n\n         do j=1,equiv(0,i,ig)\n            k=equiv(j,i,ig)\n            elist(1:n,k)=elist(1:n,k)+elist(1:n,i)\n         enddo\n      enddo\n!---  prepare write out\n      do i=1,n\n         k=1\n         equiv(1,i,ig)=i\n         elist(i,i)=0\n         do j=1,n\n            if(elist(j,i).ne.0)then\n               k=k+1\n               equiv(k,i,ig)=j               \n            endif\n         enddo\n         equiv(0,i,ig)=k\n      enddo\n      write(ich,*)'chemical equivalencies (mag.active nuclei):'\n      jnd=1\n      do j=1,n\n         m=equiv(0,j,ig)\n         write(3,'(3x,i0,3x,i0)') j, m\n         do l=1,m\n          if(l.ne.m)then\n           write(3,'(1x,i0)',advance='no') equiv(l,j,ig)  ! include the atom ie if there are no equiv.\n          else\n           write(3,'(1x,i0)',advance='yes') equiv(l,j,ig)\n          endif\n         enddo\n         if(nmract(at(j)).eq.0) cycle\n         if(m.gt.1.and.jnd(j).eq.1)then  ! just print\n         write(ich,'(''reference atom'',i4,'' # :'',i2)') equiv(1,j,ig),m\n         do k=1,m\n            jnd(equiv(k,j,ig))=0\n         enddo\n         endif\n      enddo\n!cccccccccccccccccc\n!c mag eq. \n!cccccccccccccccccc\n!c make a check list of atoms for the mag. eq.\n      elist=0\n      flist=1\n      do i=1,n\n         m=equiv(0,i,ig)        ! the following lines fill the equiv list  \n         do k=1,m              \n            l=equiv(k,i,ig)\n            elist(l,i)=1\n         enddo\n         elist(i,i)=1\n      enddo\n      flist=elist\n\n      do i=1,n    \n         m=equiv(0,i,ig)\n         do k=1,m\n            l=equiv(k,i,ig)\n            if(l.eq.i) cycle\n            do j=1,n\n               if(flist(j,i).eq.1.or.nmract(at(j)).eq.0) cycle   ! don't check non-magnetic nuclei\n!c              write(*,*) l,j,pair(lin(i,j)),pair(lin(l,j))      ! and chem. equiv. ones (ie in the same\n               if(pair(lin(i,j)).ne.pair(lin(l,j))) elist(l,i)=0 ! group\n            enddo\n         enddo\n      enddo\n!---  symmetrize \n      do i=1,n\n         k=1\n         equiv(1,i,ig)=i\n         elist(i,i)=0\n         do j=1,n\n            if(elist(j,i).ne.0)then\n               k=k+1\n               equiv(k,i,ig)=j               \n            endif\n         enddo\n         equiv(0,i,ig)=k\n      enddo\n      do i=1,n\n         do j=1,equiv(0,i,ig)\n            k=equiv(j,i,ig)\n            elist(1:n,k)=elist(1:n,k)+elist(1:n,i)\n         enddo\n      enddo\n!---  prepare write out\n      do i=1,n\n         k=1\n         equiv(1,i,ig)=i\n         elist(i,i)=0\n         do j=1,n\n            if(elist(j,i).ne.0)then\n               k=k+1\n               equiv(k,i,ig)=j               \n            endif\n         enddo\n!old     equiv(0,i,ig)=k\n         if(k.gt.2) then\n            equiv(0,i,ig)=k    ! CH3 etc\n         else\n            equiv(0,i,ig)=1    ! this makes CH2-CH2 not mag. equiv. !\n         endif\n      enddo\n      jnd=1\n      write(ich,*)'magnetic equivalencies:'\n      do j=1,n\n         m=equiv(0,j,ig)\n         write(3,*) j, m\n         write(3,'(20i5)') (equiv(l,j,ig),l=1,m)  ! include the atom ie if there are no equiv.\n         if(nmract(at(j)).eq.0) cycle\n         if(m.gt.1.and.jnd(j).eq.1)then  ! just print\n         write(ich,'(''reference atom'',i4,'' # :'',i2)') equiv(1,j,ig),m\n         do k=1,m\n            jnd(equiv(k,j,ig))=0\n         enddo\n         endif\n      enddo\n      close(3)\n\n!cc    enddo  ! next conformer group (ig)\n\n\n!ccccccccccccccccccccc\n!c J averaging matrix\n!ccccccccccccccccccccc\n \n      fname='anmr_rotamer'\n      open(unit=112,file=fname,form='unformatted')\n      !open(unit=112,file=fname)\n      write(112) ng \n\n      jfake=0\n      do ig=1,ng     ! all conf groups\n      nr=glist(0,ig) ! how many rotamers?\n      write(112) nr         \n      do ir=1,nr\n         irr=glist(ir,ig)\n         call distance(n,xyz(1,1,irr),sd)   ! distance matrix\n         c1(1:3,1:n)=xyz(1:3,1:n,irr)\n         call ncoord(n,rcov,at,c1,cn,500.0d0)\n         do i=1,n-1\n            do j=i+1,n\n               jfake(lin(j,i))=cn(i)*cn(j)*sqrt(dble(at(i)*at(j))) &\n          &    /(dble(pair(lin(j,i)))*sd(j,i)**5) ! the approx. \"J\" is topologically equivalent to J\n                                                  ! R^3 was wrong in one case because Hs were artificially paired\n                                                  ! R^5 seems to be save\n            enddo\n         enddo\n!c        call prmat(6,dd,n,n,'J fake') \n         write(112) jfake(1:n*(n+1)/2)        ! read by anmr \n      enddo\n      enddo\n      close(112)\n\n   !--- how many rotamers per conformer   \n      open(newunit=ich3,file='cre_degen')\n      write(ich3,'(3x,i0)') ng\n      do ir=1,ng\n        write(ich3,'(3x,i0,2x,i0)') ir,glist(0,ir)\n      enddo\n      close(ich3) \n\n      !if(env%entropic)then\n      ! if(ttag)then    \n      !  call origin2time(nall,originnew,timetag)\n      ! else\n      !  timetag=1\n      ! endif   \n      !open(newunit=ich3,file='cre_tag')\n      !if(env%mdtime.lt.0.0_wp)then\n      !  write(ich3,'(3x,i0,1x,f10.2)') ng,1.0_wp\n      !else\n      !  write(ich3,'(3x,i0,1x,f10.2)') ng,env%mdtime\n      !endif\n      !do ir=1,ng\n      !  k=glist(1,ir)\n      !  write(ich3,'(3x,i0,2x,i0)') ir,timetag(k)\n      !enddo\n      !close(ich3)\n      !endif    \n\n      endif ! equivalence anal\n!===============================================================!\n      call remove('cre_members')\n      open(newunit=ich3,file='cre_members')\n      write(ich3,'(3x,i0)') ng\n      do i=1,ng\n        k=glist(0,i)\n        write(ich3,'(3x,i5,1x,i10,1x,i10)') &\n      &   k,glist(1,i),glist(k,i)\n      enddo\n      close(ich3)\n\n      open(unit=2,file=trim(cname))\n      open(unit=4,file='crest_best.xyz')\n      do i=1,ng  \n         k=glist(1,i) ! take first \n         if(er(k).ge.ewin) cycle\n         if(i.eq.1.or.printscoords)then   !write a scoord.* for each conformer? ,scoord.1 is always written  \n           call getname1(i,atmp)\n           c2(1:3,1:n)=xyz(1:3,1:n,k)/bohr\n           call wrc0(atmp,n,at,c2)\n         endif\n         write(2,'(2x,i0)') n\n         write(2,'(2x,f18.8)') er(k)/autokcal+elow\n         do j=1,n\n            write(2,'(1x,a2,1x,3f20.10)')i2e(at(j),'nc'),xyz(1:3,j,k)\n         enddo\n         if(i.eq.1)then\n         write(4,'(2x,i0)') n\n         write(4,'(2x,f18.8)') er(k)/autokcal+elow\n         do j=1,n\n            write(4,'(1x,a2,1x,3f20.10)')i2e(at(j),'nc'),xyz(1:3,j,k)\n         enddo\n         endif\n      enddo\n      close(2)\n      close(4)\n\n      !because of \"esort\"-flag these have to be deallocated first\n      deallocate(pg,glist,dgen)\n\n 666  write(ich,*) 'Normal termination.'\n\n      if(.not.confgo) close(ich) !close the output file\n!deallocate all the rest\n      if(trackorigin)then\n         deallocate(originnew,origin)\n      endif\n      deallocate(flist,elist,nb,pair,pre,vis,metric,rot)\n      deallocate(sd,jfake,enuc,equiv,relat,edum)\n      deallocate(idum,group,jnd,tmp2,xyznew,tmp,double)\n      deallocate(ind,e,p,er,xyz,ind2,sames)\n\n      deallocate(iref,xx)\n\n      deallocate(molvec,cn,cn0,c2,c1,at)\n      deallocate(nmract,ydum,xdum,Udum,gdum,rcov)\n\n      end associate settingNames\n   \nend subroutine cregen2\n\n!================================================\n! cpincluded is a small routine to map only\n! the selected atoms from structure c into\n! structure cr, via the array inc (value 1 or 0)\n!================================================\nsubroutine cpincluded(n,nr,c,cr,inc)\n      use iso_fortran_env, only : wp => real64\n      implicit none\n      integer,intent(in) :: n\n      integer,intent(in) :: nr\n      real(wp),intent(in) :: c(3,n)\n      real(wp),intent(out) :: cr(3,nr)\n      integer,intent(in) :: inc(n)\n      integer :: i,k\n      k=1\n      do i=1,n\n        if(inc(i).gt.0)then\n        cr(1:3,k)=c(1:3,i)\n        k=k+1\n        endif\n      enddo\n      return\nend subroutine cpincluded\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n\n\nsubroutine compare(n,nall,s1,s2,dist,athr,relat)\n      implicit none\n      integer :: n,nall,s1,s2\n      integer :: relat(0:n,n)\n      real*8 :: dist(n,n,nall),athr\n\n      integer :: i,j,k\n      real*8 :: rsum,athr2\n      logical :: ok\n\n      athr2=athr*dble(n)\n      do i=1,n\n         do j=1,n\n            if(i.eq.j) cycle\n            rsum=0\n!c           bp=.true.\n            do k=1,n\n               rsum=rsum+abs(dist(k,i,s1)-dist(k,j,s2))\n!c              if(k.ne.i.and.k.ne.j.and.\n!c    .            pair(lin(k,i)).ne.pair(lin(k,j))) then\n!c                 bp=.false. ! check bond path length\n!c                 exit\n!c              endif\n               if(rsum.gt.athr2) goto 99\n            enddo\n!c           if(rsum/n.lt.athr.and.bp) then\n            if(rsum/n.lt.athr       ) then\n               ok=.true.\n               do k=1,relat(0,i)\n                  if(relat(k,i).eq.j) ok=.false.   ! already existing?\n               enddo\n               if(ok)then\n                  relat(0,i)=relat(0,i)+1\n                  relat(relat(0,i),i)=j\n               endif\n            endif\n 99         continue\n         enddo\n      enddo\n\nend subroutine compare\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n\nlogical function distcheck(n,xyz)\n      implicit none\n      real*8,allocatable :: rij(:)\n      integer :: n\n      real*8 :: xyz(3,n)\n      integer i,j\n      distcheck=.true.\n      allocate(rij(3))\n      do i=1,n-1\n         do j=i+1,n\n         rij=xyz(:,j)-xyz(:,i)\n         if(sum(rij*rij).lt.1.d-3) distcheck=.false.\n         enddo\n      enddo\n      deallocate(rij)\n      return\nend function distcheck\n\n\n!==========================================================!\n! bactrack is used to find the element \"val\" of array \"arr\"\n! that contains 0 when the content of each field of arr\n! references another field of it, starting from element i\n!==========================================================!\nrecursive subroutine backtrack(arr,i,val)\n      implicit none\n      integer,intent(in) :: i\n      integer,intent(inout) :: arr(*)\n      integer,intent(out) :: val\n\n      if(arr(i).gt.0)then\n         call backtrack(arr,arr(i),val)\n         arr(i)=val\n      else\n         val=i\n      endif\n\n      return\nend subroutine backtrack\n\n\n!==========================================================!\n! align a structure in space according to the position\n! of the first atom\n!==========================================================!\nsubroutine xyzalign(nat,xyz)\n      use iso_fortran_env, wp => real64\n      use geo, only: rotRz180,rotRx180\n      implicit none\n      integer :: nat\n      real(wp) :: xyz(3,nat)\n      integer :: i\n      if(xyz(1,1).lt.0.0_wp)then\n       do i=1,nat\n         call rotRz180(xyz(1:3,i))\n       enddo\n      endif\n      if(xyz(2,1).lt.0.0_wp)then\n       do i=1,nat\n         call rotRx180(xyz(1:3,i))\n       enddo\n      endif\n      return\nend subroutine xyzalign\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine repairorder(nall,n,ng,order,xyz,er,trackorigin,originnew)\n      use iso_fortran_env, wp => real64\n      implicit none\n      integer :: nall\n      integer :: n,ng\n      integer :: order(0:nall)\n      real(wp) :: xyz(3,n,nall)\n      real(wp) :: er(nall)\n      logical :: trackorigin\n      character(len=40) :: originnew(nall)\n      integer :: i,j,k\n\n      integer,allocatable :: dumorder(:)\n      real(wp),allocatable :: dumxyz(:,:,:)\n      real(wp),allocatable :: dumer(:)\n      character(len=40),allocatable :: dumorig(:)\n\n      allocate(dumorder(nall),dumxyz(3,n,nall),dumer(nall))\n      if(trackorigin)then\n      allocate(dumorig(nall))\n      endif\n      k=0\n      do i=1,ng\n         do j=1,nall  \n            if(order(j).eq.i)then\n            k=k+1     \n            dumorder(k)=order(j)\n            dumxyz(:,:,k)=xyz(:,:,j)\n            dumer(k)=er(j)\n            if(trackorigin)then\n            dumorig(k)=originnew(j)\n            endif\n            endif\n         enddo\n      enddo\n      order(1:nall)=dumorder(1:nall)\n      xyz=dumxyz\n      er=dumer\n      if(trackorigin)then\n      originnew=dumorig\n      endif \n\n      if(trackorigin)then\n      deallocate(dumorig)\n      endif\n      deallocate(dumer,dumxyz,dumorder)\n\n      return\nend subroutine repairorder\n\n!===============================================================================\nsubroutine repairentropic(nall,n,ng,order,xyz,er,trackorigin,originnew)\n      use iso_fortran_env, wp => real64\n      implicit none\n      integer :: nall\n      integer :: n,ng\n      integer :: order(0:nall)\n      real(wp) :: xyz(3,n,nall)\n      real(wp) :: er(nall)\n      logical :: trackorigin\n      character(len=40) :: originnew(nall)\n      integer :: i,j,k,t\n      integer :: tmax\n\n      integer,allocatable :: dumorder(:)\n      real(wp),allocatable :: dumxyz(:,:,:)\n      real(wp),allocatable :: dumer(:)\n      character(len=40),allocatable :: dumorig(:)\n      integer,allocatable :: timetag(:)\n\n      allocate(dumorder(nall),dumxyz(3,n,nall),dumer(nall))\n      allocate(dumorig(nall))\n      allocate(timetag(nall), source=0)\n      if(trackorigin)then\n      call origin2time(nall,originnew,timetag)\n      endif\n      tmax=maxval(timetag,1)\n      k=0\n      ILOOP : do i=1,ng\n        TLOOP : do t=1,tmax\n         JLOOP : do j=1,nall\n            if(order(j).eq.i .and. timetag(j).eq.t)then\n              k=k+1\n              dumorder(k)=order(j)\n              dumxyz(:,:,k)=xyz(:,:,j)\n              dumer(k)=er(j)\n              if(trackorigin)then\n              dumorig(k)=originnew(j)\n              endif\n            else\n              cycle JLOOP\n            endif\n         enddo JLOOP\n        enddo TLOOP\n      enddo ILOOP\n      order(1:nall)=dumorder(1:nall)\n      xyz=dumxyz\n      er=dumer\n      if(trackorigin)then\n      originnew=dumorig\n      endif\n\n      if(trackorigin)then\n      deallocate(timetag)\n      deallocate(dumorig)\n      endif\n      deallocate(dumer,dumxyz,dumorder)\n\n      return\nend subroutine repairentropic\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/cregen_old.f90 b/src/legacy_algos/cregen_old.f90
--- a/src/legacy_algos/cregen_old.f90	
+++ b/src/legacy_algos/cregen_old.f90	
@@ -25,11 +25,13 @@
 subroutine cregen2(env)
       use iso_fortran_env, only : wp => real64, sp => real32, idp => int64
       use crest_data
-      use crest_parameters, only: bohr
+      use crest_parameters, only: bohr,autokcal
       use ls_rmsd
       use iomod
       use strucrd, only: rdnat,rdcoord,wrc0,i2e,e2i
       use axis_module
+      use miscdata, only: rcov
+      use utilities
    !$ use omp_lib
       implicit none
       type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
@@ -46,13 +48,13 @@
       integer,allocatable  :: pair(:),pre(:),nb(:,:),elist(:,:),flist(:,:)
       integer,allocatable  :: jnd(:),sames(:)
       logical,allocatable  :: vis(:)
-      real(wp),allocatable :: xx(:),pg(:),rcov(:)
+      real(wp),allocatable :: xx(:),pg(:)
       real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:), ydum(:)  ! rmsd dummy stuff
       integer,allocatable:: iref(:),dgen(:),glist(:,:),nmract(:)
       character(len=40),allocatable :: origin(:),originnew(:)
       integer,allocatable :: timetag(:)
 
-      real(wp) :: autokcal,beta,eav,A,T,rthr,s,g
+      real(wp) :: beta,eav,A,T,rthr,s,g
       real(wp) :: ss,ethr,de,dr,bthr
       real(wp) :: elow,ewin,pthr,eref,athr,r
       real(wp) :: dum
@@ -60,16 +62,12 @@
       !real*8 :: gdum(3,3),Udum(3,3),xdum(3), ydum(3)  ! rmsd dummy stuff
       real(wp), external :: rotdiff,shortest_distance
 
-      parameter (autokcal=627.509541d0)
-
       integer :: i,j,k,l,m,nall,n,ig,ng,nall2
       integer :: m1,m2,s1,s2,maxg,current,ndoub
       integer :: molcount0,j1,iat,k2,m1end
       integer :: kk,memb,irr,ir,nr,jj,nall_old
       integer :: TID, nproc
       integer :: ich,ich2,io,ich3,rednat
-      integer, external :: lin
-      integer*8, external :: lina,linr
       integer(idp) :: klong
       integer(idp),allocatable :: rmatmap1(:)
       integer,allocatable :: rmatmap2(:),includeRMSD(:)
@@ -115,8 +113,7 @@
 
       call remove('LOWER_FOUND')
       
-      allocate(rcov(94),gdum(3,3),Udum(3,3),xdum(3),ydum(3),nmract(100))
-      call setrcov(rcov)
+      allocate(gdum(3,3),Udum(3,3),xdum(3),ydum(3),nmract(100))
 
 !---- setting the threads for OMP parallel usage
       if(autothreads)then
@@ -786,7 +783,7 @@
       if(anal)then
       allocate(dist(n,n,nall))
       do i=1,nall
-         call distance(n,xyz(1,1,i),dist(1,1,i))   ! distance matrix
+         call distance(n,xyz(:,:,i),dist(:,:,i))   ! distance matrix
          do j=1,n
             do k=1,n
                tmp2(k)=dist(k,j,i)*dble(at(k))  ! the distance of j to all atoms * Z to distinguish
@@ -1194,7 +1191,7 @@
       write(112) nr         
       do ir=1,nr
          irr=glist(ir,ig)
-         call distance(n,xyz(1,1,irr),sd)   ! distance matrix
+         call distance(n,xyz(:,:,irr),sd)   ! distance matrix
          c1(1:3,1:n)=xyz(1:3,1:n,irr)
          call ncoord(n,rcov,at,c1,cn,500.0d0)
          do i=1,n-1
@@ -1294,7 +1291,7 @@
       deallocate(iref,xx)
 
       deallocate(molvec,cn,cn0,c2,c1,at)
-      deallocate(nmract,ydum,xdum,Udum,gdum,rcov)
+      deallocate(nmract,ydum,xdum,Udum,gdum)
 
       end associate settingNames
    
Index: src/calculator/turbom_sc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/turbom_sc.f90 b/src/calculator/turbom_sc.f90
new file mode 100644
--- /dev/null	
+++ b/src/calculator/turbom_sc.f90	
@@ -0,0 +1,368 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2021 - 2022 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!> module turbom_sc
+!> A module containing routines for
+!> system calls to the code that uses Turbomole-like in & output conventions
+!> TODO: for actual turbomole calculations the input files must be copied (cefine)
+
+!=========================================================================================!
+module turbom_sc
+  use iso_fortran_env,only:wp => real64
+  use strucrd
+  use calc_type
+  use iomod,only:makedir,directory_exist,remove,command,checkprog_silent
+  use gradreader_module,only:rd_grad_tm
+  implicit none
+  !>--- private module variables and parameters
+  private
+  integer,parameter :: nf = 6
+  character(len=*),parameter :: oldfiles(nf) = [&
+          & 'energy','ceh.charges','output','.data', &
+          & 'NOT_CONVERGED','gp3restart' ]
+  character(len=*),parameter :: ridft = 'ridft' !> Turbomoles 'ridft'
+  character(len=*),parameter :: xyzn = 'coord'  !> input coords must be in coord
+  character(len=*),parameter :: ef = 'energy'   !> energy will be read from file energy
+  character(len=*),parameter :: gf = 'gradient' !> gradient will be read from file gradient
+
+  public :: turbom_engrad
+
+!========================================================================================!
+!========================================================================================!
+contains  !>--- Module routines start here
+!========================================================================================!
+!========================================================================================!
+
+  subroutine turbom_engrad(mol,calc,energy,grad,iostatus)
+    implicit none
+    type(coord) :: mol
+    type(calculation_settings) :: calc
+
+    real(wp),intent(inout) :: energy
+    real(wp),intent(inout) :: grad(3,mol%nat)
+    integer,intent(out) :: iostatus
+
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
+
+    iostatus = 0
+
+    !>--- setup system call information
+    !$omp critical
+    call turbom_setup(mol,calc)
+    !$omp end critical
+
+    !>--- do the systemcall
+    call initsignal()
+    call command(calc%systemcall,iostatus)
+    if (iostatus /= 0) return
+
+    !>--- read energy and gradient
+    !$omp critical
+    call rd_turbom_engrad(mol,calc,energy,grad,iostatus)
+    !$omp end critical
+    if (iostatus /= 0) return
+
+    !>--- read WBOs?
+    !!$omp critical
+    !call rd_turbom_wbo(mol,calc,iostatus)
+    !!$omp end critical
+    !if (iostatus /= 0) return
+
+    return
+  end subroutine turbom_engrad
+
+!========================================================================================!
+  subroutine turbom_setup(mol,calc)
+    implicit none
+    type(coord) :: mol
+    type(calculation_settings) :: calc
+
+    integer :: l
+    character(len=:),allocatable :: fname
+    character(len=:),allocatable :: cpath
+    character(len=10) :: num
+    integer :: i,j,k,ich,och,io
+    logical :: ex
+
+    call initsignal()
+
+    !>--- set default binary if not present
+    if (.not.allocated(calc%binary)) then
+      calc%binary = ridft
+    end if
+
+    !>--- check for the calculation space
+    if (allocated(calc%calcspace)) then
+      ex = directory_exist(calc%calcspace)
+      if (.not.ex) then
+        io = makedir(trim(calc%calcspace))
+      end if
+      cpath = calc%calcspace
+    else
+      cpath = ''
+    end if
+    !>--- cleanup old files
+    do i = 1,nf
+      call remove(trim(cpath)//sep//trim(oldfiles(i)))
+    end do
+    deallocate (cpath)
+
+    !>--- construct path information and write coord file
+    if (.not.allocated(calc%calcfile)) then
+      if (allocated(calc%calcspace)) then
+        l = len_trim(calc%calcspace)
+        fname = trim(calc%calcspace)
+        if (calc%calcspace(l:l) == sep) then
+          fname = trim(fname)//xyzn
+        else
+          fname = trim(fname)//sep//xyzn
+        end if
+      else
+        fname = xyzn
+      end if
+      calc%calcfile = fname
+    else
+      fname = calc%calcfile
+    end if
+    call mol%write(fname) !> should write a "coord" file, must be called for each SP
+    deallocate (fname)
+
+    !>--- write charge and uhf files
+    if (calc%chrg /= 0) then
+      call touch_chrg_tm(calc,calc%chrg)
+    end if
+    if (calc%uhf /= 0) then
+      call touch_uhf_tm(calc,calc%uhf)
+    endif
+
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+    !>--- if the systemcall was already set up, return
+    if (allocated(calc%systemcall)) return
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+
+    !>--- construct path information for sys-call
+    if (allocated(calc%calcspace)) then
+      calc%systemcall = 'cd '//calc%calcspace//' &&'
+      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%binary)
+    else
+      calc%systemcall = trim(calc%binary)
+    end if
+
+    !>--- check if the binary exists
+    call checkprog_silent(trim(calc%binary),.true.,io)
+    if(io .ne. 0) error stop
+
+    !>--- add other call information
+    calc%systemcall = trim(calc%systemcall)//' '//xyzn
+    !>--- user-set flags
+    if (allocated(calc%other)) then
+      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%other)
+    end if
+
+    !>--- add printout information
+    calc%systemcall = trim(calc%systemcall)//' '//'> output'
+    calc%systemcall = trim(calc%systemcall)//dev0
+
+    return
+  end subroutine turbom_setup
+
+!========================================================================================!
+  subroutine rd_turbom_engrad(mol,calc,energy,grad,iostatus)
+!*****************************************************
+!* subroutine rd_turbom_engrad
+!* read the energy and Cartesian gradient from file
+!* Turbomole-style format is used for this
+!*****************************************************
+    implicit none
+    type(coord) :: mol
+    type(calculation_settings) :: calc
+    real(wp),intent(inout) :: energy
+    real(wp),intent(inout) :: grad(3,mol%nat)
+    integer,intent(out) :: iostatus
+    integer :: n,c
+    real(wp) :: dum
+    character(len=128) :: atmp
+
+    integer :: i,j,k,ich,och,io
+    logical :: ex
+
+    call initsignal()
+
+    iostatus = 0
+    energy = 0.0_wp
+    grad = 0.0_wp
+
+!>--- read the energy file in TM format
+    if (.not.allocated(calc%efile)) then
+      if (allocated(calc%calcspace)) then
+        calc%efile = trim(calc%calcspace)//sep//ef
+      else
+        calc%efile = ef
+      end if
+    end if
+
+    inquire (file=calc%efile,exist=ex)
+    if (.not.ex) then
+      iostatus = 1
+      return
+    end if
+    open (newunit=ich,file=calc%efile)
+    call rd_energy_tm(ich,energy,iostatus)
+    close (ich)
+
+!>--- sometimes we don't want to calculate and read gradients for expensive calculations
+!>--- where we are only interested in the total energy. Hence, reading it can be skipped
+    if (calc%rdgrad) then
+
+      if (.not.allocated(calc%gradfile)) then
+        if (allocated(calc%calcspace)) then
+          calc%gradfile = trim(calc%calcspace)//sep//gf
+        else
+          calc%gradfile = gf
+        end if
+      end if
+
+      inquire (file=calc%gradfile,exist=ex)
+      if (.not.ex) then
+        iostatus = 1
+        return
+      end if
+
+      open (newunit=ich,file=calc%gradfile)
+      call rd_grad_tm(ich,mol%nat,energy,grad,iostatus)
+      close (ich)
+    end if
+
+    return
+  end subroutine rd_turbom_engrad
+
+!========================================================================================!
+!  subroutine rd_turbom_wbo(mol,calc,iostatus)
+!    implicit none
+!    type(coord) :: mol
+!    type(calculation_settings) :: calc
+!    integer,intent(out) :: iostatus
+!
+!    real(wp) :: dum
+!    character(len=:),allocatable :: wbofile
+!    character(len=128) :: atmp
+!
+!    integer :: i,j,k,l,ich,och,io
+!    logical :: ex
+!    call initsignal()
+!
+!    iostatus = 0
+!
+!    if (calc%rdwbo) then
+!      if (allocated(calc%calcspace)) then
+!        wbofile = trim(calc%calcspace)//sep//'wbo'
+!      else
+!        wbofile = 'wbo'
+!      end if
+!    else
+!      return
+!    end if
+!
+!    inquire (file=wbofile,exist=ex)
+!    if (.not.ex) then
+!      iostatus = 1
+!      return
+!    end if
+!
+!    if (allocated(calc%wbo)) deallocate (calc%wbo)
+!    allocate (calc%wbo(mol%nat,mol%nat),source=0.0_wp)
+!
+!    open (newunit=ich,file=wbofile)
+!    do
+!      read (ich,'(a)',iostat=io) atmp
+!      if (io < 0) exit
+!      read (atmp,*) i,j,dum
+!      calc%wbo(i,j) = dum
+!      calc%wbo(j,i) = dum
+!    end do
+!    close (ich)
+!
+!  end subroutine rd_turbom_wbo
+
+!========================================================================================!
+  subroutine touch_chrg_tm(calc,chrg)
+    implicit none
+    type(calculation_settings) :: calc
+    integer,intent(in) :: chrg
+    character(len=:),allocatable :: fname
+    integer :: ich
+    if (allocated(calc%calcspace)) then
+      fname = trim(calc%calcspace)//sep//'.CHRG'
+    else
+      fname = '.CHRG'
+    end if
+    open (newunit=ich,file=fname)
+    write (ich,*) chrg
+    close (ich)
+    deallocate (fname)
+  end subroutine touch_chrg_tm
+
+  subroutine touch_uhf_tm(calc,uhf)
+    implicit none
+    type(calculation_settings) :: calc
+    integer,intent(in) :: uhf
+    character(len=:),allocatable :: fname
+    integer :: ich
+    if (allocated(calc%calcspace)) then
+      fname = trim(calc%calcspace)//sep//'.UHF'
+    else
+      fname = '.UHF'
+    end if
+    open (newunit=ich,file=fname)
+    write (ich,*) uhf
+    close (ich)
+    deallocate (fname)
+  end subroutine touch_uhf_tm
+
+  subroutine rd_energy_tm(ich,energy,iostat)
+!*******************************************
+!* read the 'energy' file
+!* The most current energy should be the 
+!* second entry in the second-to-last line
+!*******************************************
+     implicit none
+     integer,intent(in) :: ich
+     real(wp),intent(out) :: energy
+     integer,intent(out) :: iostat
+     integer :: i,j,nlines,io
+     character(len=126) :: line,oldline
+     real(wp) :: dum(2)
+     energy = 0.0_wp
+     iostat = 1
+     nlines = 0
+     do
+       read (ich,'(a)',iostat=io) line
+       if(io < 0 ) exit !> EOF exit
+       if(index(line,'$end').ne.0)then
+         read(oldline,*) j,energy,dum(1:2)
+         iostat = 0
+       endif
+       oldline = line
+     enddo 
+  end subroutine rd_energy_tm
+ 
+!========================================================================================!
+!========================================================================================!
+end module turbom_sc
Index: src/calculator/orca_sc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/orca_sc.f90 b/src/calculator/orca_sc.f90
new file mode 100644
--- /dev/null	
+++ b/src/calculator/orca_sc.f90	
@@ -0,0 +1,269 @@
+!================================================================================!
+! This file is part of crest.
+!
+! Copyright (C) 2021 - 2023 Philipp Pracht
+!
+! crest is free software: you can redistribute it and/or modify it under
+! the terms of the GNU Lesser General Public License as published by
+! the Free Software Foundation, either version 3 of the License, or
+! (at your option) any later version.
+!
+! crest is distributed in the hope that it will be useful,
+! but WITHOUT ANY WARRANTY; without even the implied warranty of
+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+! GNU Lesser General Public License for more details.
+!
+! You should have received a copy of the GNU Lesser General Public License
+! along with crest.  If not, see <https://www.gnu.org/licenses/>.
+!================================================================================!
+
+!> module orca_sc
+!> A module containing routines for ORCA subrpocess calls
+
+!=========================================================================================!
+module orca_sc
+  use iso_fortran_env,only:wp => real64,stderr => error_unit
+  use strucrd
+  use calc_type
+  use iomod,only:makedir,directory_exist,remove,command
+  implicit none
+  !>--- private module variables and parameters
+  private
+  integer,parameter :: nf = 2
+  character(len=*),parameter :: orcafiles(nf) = [&
+          & 'ORCA.in    ','ORCA.engrad']
+  character(len=3),parameter :: orca = 'orca'
+  character(len=8),parameter :: xyzn = 'ORCA.in'
+  character(len=11),parameter :: gf = 'ORCA.engrad'
+
+  public :: ORCA_engrad
+
+!========================================================================================!
+!========================================================================================!
+contains  !>--- Module routines start here
+!========================================================================================!
+!========================================================================================!
+
+  subroutine ORCA_engrad(mol,calc,energy,grad,iostatus)
+    use iso_fortran_env,only:wp => real64
+    use strucrd
+    use calc_type
+    use iomod,only:makedir,directory_exist,remove
+
+    implicit none
+    type(coord) :: mol
+    type(calculation_settings) :: calc
+
+    real(wp),intent(inout) :: energy
+    real(wp),intent(inout) :: grad(3,mol%nat)
+    integer,intent(out) :: iostatus
+
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
+
+    iostatus = 0
+
+    !>--- setup system call information
+    !$omp critical
+    call ORCA_setup(mol,calc)
+    !$omp end critical
+
+    !>--- do the systemcall
+    call initsignal()
+    call command(calc%systemcall,iostatus)
+    if (iostatus /= 0) return
+
+    !>--- read energy and gradient
+    !$omp critical
+    call rd_ORCA_engrad(mol,calc,energy,grad,iostatus)
+    !$omp end critical
+    if (iostatus /= 0) return
+
+    !>--- read WBOs?
+    !$omp critical
+    call rd_ORCA_wbo(mol,calc,iostatus)
+    !$omp end critical
+    if (iostatus /= 0) return
+
+    return
+  end subroutine ORCA_engrad
+
+!========================================================================================!
+
+  subroutine ORCA_setup(mol,calc)
+!***********************************
+!* Write ORCA inputs, and construct
+!* subprocess call
+!***********************************
+    use iso_fortran_env,only:wp => real64
+    use strucrd
+    use calc_type
+    use iomod,only:makedir,directory_exist,remove
+    implicit none
+    type(coord) :: mol
+    type(calculation_settings) :: calc
+
+    integer :: l
+    character(len=:),allocatable :: fname
+    character(len=:),allocatable :: cpath
+    character(len=10) :: num
+    integer :: i,j,k,ich,och,io
+    logical :: ex
+
+    call initsignal()
+
+    !>--- set default binary if not present
+    if (.not.allocated(calc%binary)) then
+      if(.not.allocated(calc%ORCA%cmd))then
+       write(stdout,'(a)') "**WARNING** ORCA cmd line not specified, falling back to 'orca'"
+       calc%binary = orca
+      else
+       calc%binary = calc%ORCA%cmd
+      endif
+    end if
+
+    !>--- check for the calculation space
+    if (allocated(calc%calcspace)) then
+      ex = directory_exist(calc%calcspace)
+      if (.not.ex) then
+        io = makedir(trim(calc%calcspace))
+      end if
+      cpath = calc%calcspace
+    else
+      cpath = ''
+    end if
+    !>--- cleanup old files
+    do i = 1,nf
+      call remove(trim(cpath)//sep//trim(orcafiles(i)))
+    end do
+    deallocate (cpath)
+
+    !>--- construct path information and write ORCA.in file
+    if (.not.allocated(calc%calcfile)) then
+      if (allocated(calc%calcspace)) then
+        l = len_trim(calc%calcspace)
+        fname = trim(calc%calcspace)
+        if (calc%calcspace(l:l) == sep) then
+          fname = trim(fname)//xyzn
+        else
+          fname = trim(fname)//sep//xyzn
+        end if
+      else
+        fname = xyzn
+      end if
+      calc%calcfile = fname
+    else
+      fname = calc%calcfile
+    end if
+    if(calc%uhf < 1) calc%uhf = 1 !> ORCA uses multiplicity, not n_alpha - n_beta!
+    call calc%ORCA%write(fname,mol,calc%chrg,calc%uhf)
+    deallocate (fname)
+
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+    !>--- if the systemcall was already set up, return
+    if (allocated(calc%systemcall)) return
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+
+    !>--- construct path information for sys-call
+    if (allocated(calc%calcspace)) then
+      calc%systemcall = 'cd '//calc%calcspace//' &&'
+      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%binary)
+    else
+      calc%systemcall = trim(calc%binary)
+    end if
+
+    calc%systemcall = trim(calc%systemcall)//' ORCA.in' 
+       
+    if(calc%ORCA%mpi .and. index(calc%binary,'oversubscribe').eq.0)then
+      calc%systemcall = trim(calc%systemcall)//' --oversubscribe'
+    endif
+
+    !>--- add printout information
+    calc%systemcall = trim(calc%systemcall)//' '//'> ORCA.out'
+    calc%systemcall = trim(calc%systemcall)//trim(dev0)
+
+    !write (*,*) calc%systemcall
+    return
+  end subroutine ORCA_setup
+
+!========================================================================================!
+
+  subroutine rd_ORCA_engrad(mol,calc,energy,grad,iostatus)
+!**************************************************
+!* Read energy and gradient from ORCA output.
+!* ORCA will always write to a .engrad file,
+!* which with our naming conventions should always
+!* be called ORCA.engrad
+!**************************************************
+    use iso_fortran_env,only:wp => real64
+    use strucrd
+    use calc_type
+    use iomod,only:makedir,directory_exist,remove
+    use gradreader_module,only:rd_grad_engrad
+
+    implicit none
+    type(coord) :: mol
+    type(calculation_settings) :: calc
+    real(wp),intent(inout) :: energy
+    real(wp),intent(inout) :: grad(3,mol%nat)
+    integer,intent(out) :: iostatus
+    integer :: n,c
+    real(wp) :: dum
+    character(len=128) :: atmp
+
+    integer :: i,j,k,ich,och,io
+    logical :: ex
+
+    call initsignal()
+
+    iostatus = 0
+
+    if (.not.allocated(calc%gradfile)) then
+      if (allocated(calc%calcspace)) then
+        calc%gradfile = trim(calc%calcspace)//sep//gf
+      else
+        calc%gradfile = gf
+      end if
+    end if
+
+    inquire (file=calc%gradfile,exist=ex)
+    if (.not.ex) then
+      iostatus = 1
+      return
+    end if
+
+    c = 0
+    open (newunit=ich,file=calc%gradfile)
+    call rd_grad_engrad(ich,mol%nat,energy,grad,iostatus)
+    close (ich)
+
+    return
+  end subroutine rd_ORCA_engrad
+
+!========================================================================================!
+
+  subroutine rd_ORCA_wbo(mol,calc,iostatus)
+    implicit none
+    type(coord) :: mol
+    type(calculation_settings) :: calc
+    integer,intent(out) :: iostatus
+
+    real(wp) :: dum
+    character(len=:),allocatable :: wbofile
+    character(len=128) :: atmp
+
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
+    call initsignal()
+    iostatus = 0
+    if(calc%rdwbo)then
+    iostatus = 1
+    write (stderr,'(a)') '**ERROR** ORCA bond order reader not yet implemented'
+    endif
+    return
+  end subroutine rd_ORCA_wbo
+
+!========================================================================================!
+!========================================================================================!
+end module orca_sc
+
Index: src/legacy_algos/meson.build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nsrcs += files(\n  'acidbase.f90',\n  'confscript2_main.f90',\n  'confscript2_misc.f90',\n  'confscript3.f90',\n  'confopt.f90',\n  'cregen_old.f90',\n  'deprotonate.f90',\n  'flexi.f90',\n  'ligands.f90',\n  'normmd.f90',\n  'pka.f90',\n  'protonate.f90',\n  'reactor.f90',\n  'relaxensemble.f90',\n  'stereoisomers.f90',\n  'tautomerize.f90',\n  'trialmd_legacy.f90',\n)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/meson.build b/src/legacy_algos/meson.build
--- a/src/legacy_algos/meson.build	
+++ b/src/legacy_algos/meson.build	
@@ -32,4 +32,5 @@
   'stereoisomers.f90',
   'tautomerize.f90',
   'trialmd_legacy.f90',
+  'zsort.f90',
 )
Index: src/legacy_algos/trialmd_legacy.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\nsubroutine trialMD_legacy(env)\n  use crest_parameters\n  use crest_data\n  use ls_rmsd\n  use iomod\n  implicit none\n\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n\n  integer :: io,Vdumpfreq,counter\n\n  real(wp) :: prefac,alpha,length\n  real(wp) :: perc\n  real(wp) :: rtime\n\n  character(len=512) :: thispath,jobcall\n  character(len=64)  :: dirnam,fname\n  character(len=80)  :: pipe\n\n  real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:),ydum(:)  !rmsd dummy stuff\n\n  logical :: shakefail,mdfail,ex\n  integer :: sysio\n\n  allocate (gdum(3,3),Udum(3,3),xdum(3),ydum(3))\n\n!>--- some settings\n  if (env%autothreads) then\n    !> use maximum number of threads for the xtb   job, with a maximum of 8\n    call ompautoset(env%threads,8,env%omp,env%MAXRUN,8) \n  end if\n\n  call getcwd(thispath)\n\n  dirnam = 'TRIALMD'\n  fname = 'coord'\n\n  prefac = 0.003d0*env%rednat   !Vbias k\n  alpha = 0.5d0             !Vbias alpha\n  Vdumpfreq = 10000         !Vbias dumpfrequency, i.e., never updated !SG\n  length = 1.0d0   !MTD length in ps\n  perc = 0.50d0    !which last percentage of the xtb.trj should be included in the mRMSD calculation?\n  ! 50% = the last half\n\n  pipe = ' > xtb.out 2>/dev/null'\n\n  write (jobcall,'(a,1x,a,1x,a,'' --md '',a,a)') &\n  &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe\n\n  !--- slightly different jobcall for qmdff usage, and check for solvent file\n  if (env%useqmdff) then\n    write (jobcall,'(a,1x,a,1x,a,'' --md --qmdff '',a,a)') &\n    &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe\n\n    inquire (file='solvent',exist=ex)\n    if (.not.ex) then\n      write (stdout,*)\n      write (stdout,*) \"Use of QMDFF was requested by '-qmdff', but there is no solvent file!\"\n      write (stdout,*) \"exit.\"\n      error stop\n    end if\n  end if\n\n!>--- Header\n  write (stdout,*)\n  write (stdout,'(''-------------------------------------'')')\n  write (stdout,'(''Starting a trial MTD to test settings'')')\n  write (stdout,'(''-------------------------------------'')')\n\n!>--- Iterative loop, since it is also tested if the MD runs at all\n  counter = 1\n  iterativ: do\n!>--- Make a dir\n    call rmrf(dirnam)\n    io = makedir(trim(dirnam))\n\n    call copysub('coord',trim(dirnam))\n    call env%wrtCHRG(trim(dirnam))\n    call copysub(env%fixfile,trim(dirnam))\n    if (env%useqmdff) then\n      call copysub('solvent',trim(dirnam))\n    end if\n\n    call chdir(trim(dirnam))\n\n!>--- set up MD\n    call setMDrun2(fname,env%hmass,length,env%mdtemp,env%mdstep,env%shake,env%mddumpxyz, &\n    &             env%mdskip,Vdumpfreq,-1,env%cts)\n    call setMetadyn2(fname,prefac,alpha,100)  ! Metadynamic settings\n\n    !================================!\n    call command(trim(jobcall),sysio)\n    !================================!\n\n    inquire (file='xtbmdok',exist=ex) !this file should only exist if the MTD finished flawlessly\n    call minigrep('xtb.out','SHAKE did not converge',shakefail)\n    call minigrep('xtb.out','MD is unstable, emergency exit',mdfail)\n    if (ex.and..not.shakefail.and..not.mdfail) then\n      call gettime('xtb.out',rtime)\n      call timeestimate(rtime,env%mdtime,env%nmetadyn,env%threads)\n\n!>--- change Dir back\n      call chdir(thispath)\n      exit iterativ\n    else\n      call chdir(thispath)\n      write (stdout,'(1x,''Trial MTD '',i0,'' did not converge!'')') counter\n      if (counter .ge. 6) then\n        write (stdout,'(1x,''Automatic xtb restart failed '',i0,'' times!'')') counter\n        write (stdout,'(1x,''Please try other settings by hand.'')')\n        write (stdout,*)\n        error stop\n      end if\n      counter = counter+1\n      if (env%mdstep == 1.0d0) then\n        write (stdout,'(1x,''Time step can`t be reduced further!'')')\n        write (stdout,'(1x,''Trying to turn SHAKE off...'')')\n        write (stdout,*)\n        env%shake = 0\n        cycle iterativ\n      end if\n      env%mdstep = max(1.0d0, (env%mdstep-1.0d0)) !don't reduce the timestep below 1 fs\n      write (stdout,'(1x,''Reducing the time step to '',f4.1,'' fs and trying again...'')') env%mdstep\n      write (stdout,*)\n    end if\n!>--- End loop\n  end do iterativ\n\n  return\n!=========================================================================================!\ncontains\n!=========================================================================================!\n  subroutine timeestimate(rtime,mdtime,nmetadyn,threads)\n!******************************************\n!* calaculate and print the time estimate\n!******************************************\n    implicit none\n    real(wp)  :: mdtime\n    integer :: nmetadyn\n    integer :: threads\n    real(wp)  :: rtime,rtime2\n    real(wp)  :: w,t\n    character(len=80) :: stime,stime2\n\n    rtime2 = rtime\n\n    rtime = rtime*mdtime             !scale the runtime to the MTD length\n    call time2string(rtime,stime)\n    write (stime2,'(f14.1)') mdtime\n    stime2 = adjustl(stime2)\n    write (stdout,'(1x,a,a,a,a)') 'Estimated runtime for one MTD (',trim(stime2), &\n    &                      ' ps) on a single thread: ',trim(stime)\n\n    if (threads < nmetadyn) then\n      w = float(nmetadyn)/float(threads)\n      t = float(ceiling(w))\n      rtime = rtime*t\n      call time2string(rtime,stime)\n    else if (threads == nmetadyn) then\n      call time2string(rtime,stime)\n    else if (threads > nmetadyn) then\n      w = float(threads)/float(nmetadyn)\n      t = float(floor(w))\n      rtime = rtime/t\n      call time2string(rtime,stime)\n    end if\n\n    write (stdout,'(1x,a,i0,a,i0,a,a)') 'Estimated runtime for a batch of ',nmetadyn, &\n    &                      ' MTDs on ',threads,' threads: ',trim(stime)\n\n  end subroutine timeestimate\n\n  subroutine time2string(rtime,str)\n    implicit none\n    real(wp) :: rtime\n    real(wp) :: hours,minutes,seconds\n    character(len=*) :: str\n\n    hours = aint(rtime/3600d0)\n    minutes = aint((rtime-(3600d0*hours))/60d0)\n    seconds = anint(rtime-(3600d0*hours+minutes*60d0))\n\n    if (hours > 0.0d0) then\n      write (str,'(i0,1x,a,1x,i0,1x,a,1x,i0,1x,a)') &\n      & nint(hours),'h',nint(minutes),'min',nint(seconds),'sec'\n    else if (minutes > 0.0d0) then\n      write (str,'(i0,1x,a,1x,i0,1x,a)') &\n      & nint(minutes),'min',nint(seconds),'sec'\n    else\n      write (str,'(i0,1x,a)') nint(seconds),'sec'\n    end if\n\n    return\n  end subroutine time2string\n\n!========================================================================================!\nend subroutine trialMD_legacy\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/trialmd_legacy.f90 b/src/legacy_algos/trialmd_legacy.f90
--- a/src/legacy_algos/trialmd_legacy.f90	
+++ b/src/legacy_algos/trialmd_legacy.f90	
@@ -21,6 +21,7 @@
   use crest_data
   use ls_rmsd
   use iomod
+  use utilities
   implicit none
 
   type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
@@ -45,7 +46,7 @@
 !>--- some settings
   if (env%autothreads) then
     !> use maximum number of threads for the xtb   job, with a maximum of 8
-    call ompautoset(env%threads,8,env%omp,env%MAXRUN,8) 
+    call ompautoset(env%threads,8,env%omp,env%MAXRUN,8)
   end if
 
   call getcwd(thispath)
@@ -148,6 +149,37 @@
 !=========================================================================================!
 contains
 !=========================================================================================!
+  subroutine gettime(fil,secs)
+!*********************************
+!* Obtain runtime from xtb output
+!*********************************
+    implicit none
+    real(wp) :: secs
+    real(wp) :: floats(10)
+    character(len=*) :: fil
+    character(len=512) :: tmp,tmp2
+    integer :: io,ich,n
+    secs = 0.0d0
+    open (newunit=ich,file=fil)
+    do
+      read (ich,'(a)',iostat=io) tmp
+      if (io < 0) exit
+      if (index(tmp,'finished run on') .ne. 0) then
+        read (ich,'(a)') tmp
+        read (ich,'(a)') tmp
+        read (ich,'(a)') tmp
+        read (ich,'(a)') tmp
+        call rdarg(tmp,'time:',tmp2)
+        call readl(tmp2,floats,n)
+      end if
+    end do
+    secs = secs+floats(2)*86400.0d0  !days to seconds
+    secs = secs+floats(3)*3600.0d0   !hours to seconds
+    secs = secs+floats(4)*60.0d0     !minutes to seconds
+    secs = secs+floats(5)
+    return
+  end subroutine gettime
+
   subroutine timeestimate(rtime,mdtime,nmetadyn,threads)
 !******************************************
 !* calaculate and print the time estimate
Index: .github/workflows/stale.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.github/workflows/stale.yml b/.github/workflows/stale.yml
new file mode 100644
--- /dev/null	
+++ b/.github/workflows/stale.yml	
@@ -0,0 +1,23 @@
+#name: "Close stale issues and PRs"
+#
+#on:
+#  schedule:
+#    # Every day at 00:00
+#    - cron: "0 0 * * *"
+#  workflow_dispatch:
+#
+#jobs:
+#  stale:
+#    runs-on: ubuntu-latest
+#
+#    steps:
+#      - uses: actions/stale@v4.0.0
+#        with:
+#          stale-issue-message: 'This issue had no activity for **3 months**. It will be closed in **1 week** unless there is some new activity. Is this issue already resolved?'
+#          stale-issue-label: 'stale'
+#          exempt-issue-labels: 'bug,enhancement,good first issue'
+#          stale-pr-message: 'This pull request had no activity for **3 months**. It will be closed in **1 week** unless there is some new activity.'
+#          stale-pr-label: 'stale'
+#          days-before-stale: 90
+#          days-before-close: 7
+#          operations-per-run: 200
Index: src/calculator/calculator.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nmodule crest_calculator\n!>--- types and readers\n  use iso_fortran_env,only:wp => real64\n  use strucrd\n  use calc_type\n!>--- potentials and API's\n  use xtb_sc\n  use generic_sc\n  use lj\n  use api_engrad  !> contains many potentials\n!>--- other\n  use constraints\n  use nonadiabatic_module\n!$ use omp_lib\n  implicit none\n!=========================================================================================!\n!>--- private module variables and parameters\n  private\n\n!>--- some constants and name mappings\n  real(wp),parameter :: bohr = 0.52917726_wp\n  real(wp),parameter :: autokcal = 627.509541_wp\n\n!=========================================================================================!\n!>--- RE-EXPORTS of module calc_type\n  public :: calcdata              !> calculator main object\n  public :: calculation_settings  !> different calculation objects (levels) within calcdata\n  public :: jobtype               !> calculation type ID's\n!>--- RE-EXPORT of constraints\n  public :: constraint\n  public :: scantype\n  public :: calc_constraint\n!=========================================================================================!\n\n!>--- public module routines\n  public :: engrad\n  interface engrad\n    module procedure :: engrad_mol\n    module procedure :: engrad_xyz\n  end interface engrad\n\n  public :: calc_eprint\n  interface calc_eprint\n    module procedure :: calc_print_energies\n    module procedure :: calc_print_energies2\n  end interface calc_eprint\n\n  public :: numhess1,numhess2\n  public :: constrhess\n\n!========================================================================================!\n!========================================================================================!\ncontains  !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\n  subroutine engrad_mol(mol,calc,energy,gradient,iostatus)\n!***************************************************************\n!* subroutine engrad\n!* main routine to perform some energy and gradient calculation\n!***************************************************************\n    implicit none\n    type(coord) :: mol\n    type(calcdata) :: calc\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: gradient(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    integer :: i,j,k,l,n,io,nocc\n\n    real(wp) :: dum1,dum2\n    real(wp) :: efix\n    real(wp),allocatable :: grdfix(:,:)\n    real(wp),allocatable :: grdtmp(:,:,:)\n    real(wp),allocatable :: etmp(:)\n\n!==========================================================!\n    call initsignal()\n\n    !>--- reset\n    energy = 0.0_wp\n    gradient(:,:) = 0.0_wp\n!==========================================================!\n    !>--- check for sane input\n    dum1 = sum(mol%xyz) \n    if(dum1.ne.dum1)then !> NaN catch, we don't want to calculate garbage.\n     iostatus = 1        !> For some builds I found this necessary because\n     return              !> OpenMP can get picky...\n    endif\n\n    !>--- Calculation setup\n    n = calc%ncalculations\n\n    !$omp critical\n    if (n > 0) then\n      if (.not. allocated(calc%etmp)) allocate (calc%etmp(n),source=0.0_wp)\n      if (.not. allocated(calc%grdtmp)) allocate (calc%grdtmp(3,mol%nat,n),source=0.0_wp)\n      if (.not. allocated(calc%eweight)) then\n        allocate (calc%eweight(n),source=0.0_wp)\n        do i = 1,n\n          calc%eweight(i) = calc%calcs(i)%weight\n        end do\n      end if\n    end if\n    \n    iostatus = 0\n    dum1 = 1.0_wp\n    dum2 = 1.0_wp\n    calc%etmp = 0.0_wp\n    calc%grdtmp = 0.0_wp\n    !$omp end critical\n\n!==========================================================!\n    !>--- Calculation\n    if (n > 0) then\n\n      !==================================================================================!\n      !>--- loop over all calculations to be done\n      do i = 1,calc%ncalculations\n        select case (calc%calcs(i)%id)\n        case (jobtype%xtbsys)  !>-- xtb system call\n          call xtb_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)\n\n        case (jobtype%generic) !>-- generic script/program call\n          call generic_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)\n\n        case (jobtype%tblite)  !>-- tblite api call\n          call tblite_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)\n\n        case (jobtype%gfn0) !>-- GFN0-xTB api\n          call gfn0_engrad(mol,calc%calcs(i),calc%calcs(i)%g0calc,calc%etmp(i), &\n          &                calc%grdtmp(:,:,i),iostatus)\n\n        case (jobtype%gfn0occ) !>-- Special GFN0-xTB api given orbital population\n          !> note the use of calc%g0calc instead of calc%calcs(i)%g0calc !\n          call gfn0occ_engrad(mol,calc%calcs(i),calc%g0calc,calc%etmp(i), &\n          &                   calc%grdtmp(:,:,i),iostatus)\n \n        case (jobtype%gfnff) !>-- GFN-FF api\n          call gfnff_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)\n\n        case (jobtype%xhcff) !>--- XHCFF-lib \n          call xhcff_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)\n\n        case (99) !-- Lennard-Jones dummy calculation\n          if (allocated(calc%calcs(i)%other)) then\n            read (calc%calcs(i)%other,*) dum1,dum2\n          end if\n          call lj_engrad(mol%nat,mol%xyz,dum1,dum2,calc%etmp(i),calc%grdtmp(:,:,i))\n\n        case default\n          !write (*,*) 'Nothing selected for energy and gradient calculation.'\n          calc%etmp(i) = 0.0_wp\n          calc%grdtmp(:,:,i) = 0.0_wp\n        end select\n        if (iostatus /= 0) then\n          return\n        end if\n      end do\n\n      !==================================================================================!\n      !>--- switch case for what to to with the energies\n      select case (calc%id)\n      case( 0 ) !> the DEFAULT\n      !>--- an option to add multiple energies and gradients accodring to weights\n      !>--- which might be useful for additive contributions   \n        call calc_add_weighted_egrd(n,calc%eweight,calc%etmp,calc%grdtmp, &\n        &                energy,gradient)\n\n      case (1:)\n      !>--- if calc%id is a positive integer, take e+grd from \n      !>--- the respective specified calculation\n        j = calc%id\n        if (j <= calc%ncalculations) then\n          energy = calc%etmp(j)\n          gradient = calc%grdtmp(:,:,j)\n        end if\n\n      case (-1)\n      !>--- if calc%id is equal to -1, we are using the MECP routines:\n      !>--- take non-adiabatic arithmetic mean (of first two calculations)\n        call engrad_mean(mol%nat,calc%ncalculations,calc%etmp,calc%grdtmp, &\n        &                energy,gradient)\n\n      case default \n      !>--- any other case does not return any energy and gradient\n      !>--- from this part  of the calculator. \n      !>--- constraints (see below) will be applied, however.\n      end select\n\n      \n      !>--- printout (to file or stdout)\n      call calc_eprint(calc,energy,calc%etmp)\n    end if\n\n!==========================================================!\n    !>--- Constraints\n    if (calc%nconstraints > 0) then\n      !$omp critical\n      allocate (grdfix(3,mol%nat),source=0.0_wp)\n      !$omp end critical\n      do i = 1,calc%nconstraints\n        efix = 0.0_wp\n        grdfix = 0.0_wp\n        if (calc%cons(i)%type > 0) then\n          !>--- structural constraints\n          call calc_constraint(mol%nat,mol%xyz,calc%cons(i),efix,grdfix)\n        else if (allocated(calc%etmp) .and. allocated(calc%grdtmp)) then\n          !>--- non-adiabatic constraints\n          if (n > 1) then\n            call calc_nonadiabatic_constraint(mol%nat,calc%cons(i),n,calc%etmp,calc%grdtmp,efix,grdfix)\n          else !> this \"else\" is necessary for constrained model hessians\n            efix = 0.0_wp\n            grdfix = 0.0_wp\n          end if\n        end if\n        energy = energy + efix\n        gradient = gradient + grdfix\n      end do\n      !$omp critical\n      deallocate (grdfix)\n      !$omp end critical\n    end if\n\n    return\n  end subroutine engrad_mol\n\n  !>--- wrapper for the engrad_mol routine\n  subroutine engrad_xyz(n,xyz,at,calc,energy,gradient,iostatus)\n    implicit none\n    integer,intent(in) :: n\n    real(wp),intent(in) :: xyz(3,n) ! coordinates should be in Bohr (a.u.)\n    integer,intent(in) :: at(n)\n    type(calcdata) :: calc\n    type(coord) :: mol\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: gradient(3,n)\n    integer,intent(out) :: iostatus\n\n    real(wp) :: dum1,dum2\n\n    mol%nat = n\n    mol%at = at\n    mol%xyz = xyz\n    call engrad_mol(mol,calc,energy,gradient,iostatus)\n\n    return\n  end subroutine engrad_xyz\n\n!========================================================================================!\n!========================================================================================!\n!========================================================================================!\n\n  subroutine numgrad(mol,calc,angrad)\n!*******************************************************\n!* subroutine numgrad\n!* routine to perform a numerical gradient calculation\n!*******************************************************\n    implicit none\n\n    type(coord) :: mol\n    type(calcdata) :: calc\n    real(wp) :: angrad(3,mol%nat)\n    integer :: i,j,k,l,ich,och,io\n\n    real(wp) :: energy,el,er\n    real(wp),allocatable :: grad(:,:)\n    real(wp),allocatable :: numgrd(:,:)\n    real(wp),parameter :: step = 0.00001_wp,step2 = 0.5_wp / step\n\n    allocate (grad(3,mol%nat),source=0.0_wp)\n    allocate (numgrd(3,mol%nat),source=0.0_wp)\n\n    do i = 1,mol%nat\n      do j = 1,3\n        mol%xyz(j,i) = mol%xyz(j,i) + step\n        call engrad(mol%nat,mol%xyz,mol%at,calc,er,grad,io)\n\n        mol%xyz(j,i) = mol%xyz(j,i) - 2 * step\n        call engrad(mol%nat,mol%xyz,mol%at,calc,el,grad,io)\n\n        mol%xyz(j,i) = mol%xyz(j,i) + step\n        numgrd(j,i) = step2 * (er - el)\n      end do\n    end do\n\n    write (*,*) 'Numerical Gradient:'\n    do i = 1,mol%nat\n      write (*,'(3f18.8)') numgrd(1:3,i)\n    end do\n\n    write (*,*)\n    write (*,*) 'Gradient Difference:'\n    do i = 1,mol%nat\n      write (*,'(3f18.8)') numgrd(1:3,i) - angrad(1:3,i)\n    end do\n\n    deallocate (numgrd,grad)\n\n    return\n  end subroutine numgrad\n\n!========================================================================================!\n  subroutine numhess1(nat,at,xyz,calc,hess,io)\n!***************************************************\n!* Calculate and return the Hessian for the\n!* COMBINED energy and gradient from engrad,\n!* including constraints\n!***************************************************\n    implicit none\n\n    integer,intent(in) :: nat\n    integer,intent(in) :: at(nat)\n    real(wp),intent(in) :: xyz(3,nat)\n    type(calcdata) :: calc\n    real(wp),intent(out) :: hess(nat * 3, nat*3)\n    integer,intent(out)  :: io\n\n    type(coord) :: mol !> coord type, so that the input remains unchanged\n    real(wp) :: energy,el,er,hij\n    real(wp),allocatable :: gradr(:,:),gradl(:,:)\n    real(wp),allocatable :: gradr_tmp(:,:,:), gradl_tmp(:,:,:)\n    real(wp),parameter :: step = 0.005_wp,step2 = 0.5_wp / step !0.00001_wp\n    integer :: i,j,k,l,m,ii,jj\n\n    hess = 0.0_wp\n    io = 0\n    mol%nat = nat\n    mol%at = at\n    mol%xyz = xyz\n    \n    allocate (gradr(3,mol%nat),source=0.0_wp) !dummy\n    allocate (gradl(3,mol%nat),source=0.0_wp) !dummy\n\n    do i = 1,mol%nat\n      do j = 1,3\n        ii = (i - 1) * 3 + j\n        gradr = 0.0_wp\n        mol%xyz(j,i) = mol%xyz(j,i) + step\n        call engrad(mol, calc,er,gradr,io)\n\n        gradl = 0.0_wp\n        mol%xyz(j,i) = mol%xyz(j,i) - 2.0_wp * step\n        call engrad(mol, calc,el,gradl,io)\n\n        mol%xyz(j,i) = mol%xyz(j,i) + step\n\n          do k = 1,mol%nat\n            do l = 1,3\n              jj = (k - 1) * 3 + l\n              hess(jj,ii) = (gradr(l,k) - gradl(l,k)) * step2\n            end do\n          end do\n\n      end do\n    end do\n\n    !Symmetrize Hessian\n      do i = 1,nat*3\n        do j = i,nat*3\n          hij = (hess(i,j) + hess(j,i))*0.5_wp \n          hess(i,j) = hij\n          hess(j,i) = hij\n        end do\n      end do\n\n    call engrad(mol,calc,el,gradl,io) !>- to get the gradient of the non-displaced structure\n\n    deallocate (gradl,gradr)\n    call mol%deallocate()\n    return\n  end subroutine numhess1\n\n!========================================================================================!\n  subroutine numhess2(nat,at,xyz,calc,hess,io)\n!***************************************************\n!* Calculate and return the Hessian for EACH of the\n!* calculation levels, but contributions from\n!* constraints are ignored.\n!***************************************************\n    implicit none\n\n    integer,intent(in) :: nat\n    integer,intent(in) :: at(nat)\n    real(wp),intent(in) :: xyz(3,nat)\n    type(calcdata) :: calc\n    real(wp),intent(out) :: hess(nat * 3,nat * 3,calc%ncalculations)\n    integer,intent(out)  :: io\n\n    type(coord) :: mol !> coord type, so that the input remains unchanged\n    real(wp) :: energy,el,er,hij\n    real(wp),allocatable :: gradr(:,:),gradl(:,:)\n    real(wp),allocatable :: gradr_tmp(:,:,:), gradl_tmp(:,:,:)\n    real(wp),parameter :: step = 0.005_wp,step2 = 0.5_wp / step !0.00001_wp\n    integer :: i,j,k,l,m,ii,jj\n\n    hess = 0.0_wp\n    io = 0\n    mol%nat = nat\n    mol%at = at\n    mol%xyz = xyz\n    \n    allocate (gradr(3,mol%nat),source=0.0_wp) !dummy\n    allocate (gradl(3,mol%nat),source=0.0_wp) !dummy\n\n    allocate (gradr_tmp(3,mol%nat,calc%ncalculations),source=0.0_wp)\n    allocate (gradl_tmp(3,mol%nat,calc%ncalculations),source=0.0_wp)\n\n    do i = 1,mol%nat\n      do j = 1,3\n        ii = (i - 1) * 3 + j\n        !gradr = 0.0_wp\n        mol%xyz(j,i) = mol%xyz(j,i) + step\n        call engrad(mol%nat,mol%xyz,mol%at,calc,er,gradr,io)\n\n        gradr_tmp = calc%grdtmp\n\n        !gradl = 0.0_wp\n        mol%xyz(j,i) = mol%xyz(j,i) - 2.0_wp * step\n        call engrad(mol%nat,mol%xyz,mol%at,calc,el,gradl,io)\n\n        gradl_tmp = calc%grdtmp\n\n        mol%xyz(j,i) = mol%xyz(j,i) + step\n\n        do m = 1,calc%ncalculations\n          do k = 1,mol%nat\n            do l = 1,3\n              jj = (k - 1) * 3 + l\n              hess(jj,ii,m) = (gradr_tmp(l,k,m) - gradl_tmp(l,k,m)) * step2\n            end do\n          end do\n        end do\n      end do\n    end do\n\n    !Symmetrize Hessian\n    do m = 1,calc%ncalculations\n      do i = 1,nat*3\n        do j = i,nat*3\n          hij = (hess(i,j,m) + hess(j,i,m))*0.5_wp \n          hess(i,j,m) = hij\n          hess(j,i,m) = hij\n        end do\n      end do\n    end do\n\n    call engrad(mol%nat,mol%xyz,mol%at,calc,el,gradl,io) !>- to get the gradient of the non-displaced s\n\n    deallocate (gradl_tmp,gradr_tmp)\n    deallocate (gradl,gradr)\n    call mol%deallocate()\n    return\n  end subroutine numhess2\n\n\n!========================================================================================!\n  subroutine constrhess(nat,at,xyz,calc,phess)\n!*********************************************************\n!* subroutine constrhess\n!* routine to perform a numerical Hessian calculation\n!* but ONLY include contributions of the constraints.\n!*\n!* phess is the packed Hessian on which the constraint\n!* contributions are added.\n!*********************************************************\n    implicit none\n\n    integer,intent(in) :: nat\n    integer,intent(in) :: at(nat)\n    real(wp),intent(in) :: xyz(3,nat)\n    type(calcdata),intent(in) :: calc\n    real(wp),intent(inout) :: phess((nat * 3) * ((nat * 3) + 1) / 2)\n\n    type(calcdata) :: dummycalc\n    integer :: tc_backup\n    real(wp) :: energy,el,er\n    real(wp),allocatable :: hess(:,:)\n    logical :: consgeo\n    integer :: i,j,k,n3,io\n\n    if (calc%nconstraints <= 0) return\n    !>--- skip if only nonadiabatic constraints\n\n    dummycalc = calc !> new dummy calculation\n    dummycalc%id = -1000  !> set to something arbitrary so that only constraints are considered\n    dummycalc%ncalculations = 0\n    dummycalc%pr_energies = .false.\n    n3 = nat * 3\n    allocate (hess(n3,n3),source=0.0_wp)\n\n    call numhess1(nat,at,xyz,dummycalc,hess,io)\n\n    k = 0\n    do i = 1,n3\n      do j = 1,i\n        k = k + 1\n        phess(k) = phess(k) + 0.5_wp * (hess(j,i) + hess(i,j))\n      end do\n    end do\n\n    deallocate (hess)\n    return\n  end subroutine constrhess\n\n!==========================================================================================!\n  subroutine calc_print_energies(calc,energy,energies)\n    implicit none\n    type(calcdata) :: calc\n    real(wp) :: energy\n    real(wp) :: energies(:)\n    integer :: i,j,l\n    character(len=20) :: atmp\n    character(len=:),allocatable :: btmp\n\n    if (.not. calc%pr_energies) return\n    btmp = ''\n    write (atmp,'(f20.12)') energy\n    btmp = btmp//atmp\n    l = size(energies,1)\n    do i = 1,l\n      write (atmp,'(f20.12)') energies(i)\n      btmp = btmp//atmp\n    end do\n    write (calc%eout_unit,'(a)') btmp\n    deallocate (btmp)\n    return\n  end subroutine calc_print_energies\n\n!==========================================================================================!\n  subroutine calc_print_energies2(calc,energy,energies,chnl)\n    implicit none\n    type(calcdata) :: calc\n    real(wp) :: energy\n    real(wp) :: energies(:)\n    integer :: chnl\n    integer :: i,j,l\n    character(len=20) :: atmp\n    character(len=:),allocatable :: btmp\n    btmp = ''\n    write (atmp,'(f20.12)') energy\n    btmp = btmp//atmp\n    l = size(energies,1)\n    do i = 1,l\n      write (atmp,'(f20.12)') energies(i)\n      btmp = btmp//atmp\n    end do\n    write (chnl,'(a)') btmp\n    deallocate (btmp)\n    return\n  end subroutine calc_print_energies2\n\n\n!==========================================================================================!\n  subroutine calc_add_weighted_egrd(ncalc,weights,energies,gradients,e,grd)\n!***************************************************************************\n!* A subroutine that adds (further) energies and gradients to\n!* e and grd, according to given weights.\n!* Might be useful for additive contributions or schemes like QMMM or ONIOM\n!***************************************************************************\n    implicit none\n    !> INPUT\n    integer,intent(in) :: ncalc\n    real(wp),intent(in) :: weights(ncalc)\n    real(wp),intent(in) :: energies(ncalc)\n    real(wp),intent(in) :: gradients(:,:,:)\n    !> OUTPUT\n    real(wp),intent(inout) :: e\n    real(wp),intent(inout) :: grd(:,:)\n    !> LOCAL\n    integer :: i\n    do i=1,ncalc\n       e = e + weights(i)*energies(i)\n       grd(:,:) = grd(:,:) + weights(i)*gradients(:,:,i)\n    enddo \n  end subroutine calc_add_weighted_egrd\n\n!==========================================================================================!\n!==========================================================================================!\nend module crest_calculator\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/calculator.F90 b/src/calculator/calculator.F90
--- a/src/calculator/calculator.F90	
+++ b/src/calculator/calculator.F90	
@@ -19,27 +19,23 @@
 
 module crest_calculator
 !>--- types and readers
-  use iso_fortran_env,only:wp => real64
+  use iso_fortran_env,only:wp => real64,int64
   use strucrd
   use calc_type
 !>--- potentials and API's
-  use xtb_sc
-  use generic_sc
+  use subprocess_engrad !> driver exports for subprocesses
   use lj
   use api_engrad  !> contains many potentials
 !>--- other
   use constraints
   use nonadiabatic_module
+  use lwoniom_module
 !$ use omp_lib
   implicit none
 !=========================================================================================!
 !>--- private module variables and parameters
   private
 
-!>--- some constants and name mappings
-  real(wp),parameter :: bohr = 0.52917726_wp
-  real(wp),parameter :: autokcal = 627.509541_wp
-
 !=========================================================================================!
 !>--- RE-EXPORTS of module calc_type
   public :: calcdata              !> calculator main object
@@ -51,17 +47,19 @@
   public :: calc_constraint
 !=========================================================================================!
 
+!>--- global engrad call counter
+  integer(int64),public :: engrad_total = 0
+
 !>--- public module routines
   public :: engrad
   interface engrad
     module procedure :: engrad_mol
-    module procedure :: engrad_xyz
   end interface engrad
+  public :: numgrad
 
   public :: calc_eprint
   interface calc_eprint
     module procedure :: calc_print_energies
-    module procedure :: calc_print_energies2
   end interface calc_eprint
 
   public :: numhess1,numhess2
@@ -76,52 +74,66 @@
   subroutine engrad_mol(mol,calc,energy,gradient,iostatus)
 !***************************************************************
 !* subroutine engrad
-!* main routine to perform some energy and gradient calculation
+!* Main routine to perform some energy and gradient calculation
+!*
+!* If anything needs to be allocated we must avoid doing it
+!* locally and do it in calcdata instead. This is to avoid
+!* overhead generated by the allocation, which can be massive
+!* for thousands of energy+gradient calls.
 !***************************************************************
     implicit none
-    type(coord) :: mol
+    type(coord),target :: mol
     type(calcdata) :: calc
     real(wp),intent(inout) :: energy
     real(wp),intent(inout) :: gradient(3,mol%nat)
     integer,intent(out) :: iostatus
-
     integer :: i,j,k,l,n,io,nocc
-
     real(wp) :: dum1,dum2
     real(wp) :: efix
-    real(wp),allocatable :: grdfix(:,:)
-    real(wp),allocatable :: grdtmp(:,:,:)
-    real(wp),allocatable :: etmp(:)
-
-!==========================================================!
-    call initsignal()
+    type(coord),pointer :: molptr
+    integer :: pnat
+    logical :: useONIOM
 
-    !>--- reset
+!>--- reset
+    call initsignal()
     energy = 0.0_wp
     gradient(:,:) = 0.0_wp
-!==========================================================!
-    !>--- check for sane input
-    dum1 = sum(mol%xyz) 
-    if(dum1.ne.dum1)then !> NaN catch, we don't want to calculate garbage.
-     iostatus = 1        !> For some builds I found this necessary because
-     return              !> OpenMP can get picky...
-    endif
+
+!**********************************
+!>--- check for sane input
+!**********************************
+    dum1 = sum(mol%xyz)
+    if (dum1 .ne. dum1) then !> NaN catch, we don't want to calculate garbage.
+      iostatus = 1           !> For some builds I found this necessary because
+      return                 !> OpenMP can get picky...
+    end if
 
-    !>--- Calculation setup
+!>--- Calculation setup
     n = calc%ncalculations
 
     !$omp critical
     if (n > 0) then
-      if (.not. allocated(calc%etmp)) allocate (calc%etmp(n),source=0.0_wp)
-      if (.not. allocated(calc%grdtmp)) allocate (calc%grdtmp(3,mol%nat,n),source=0.0_wp)
-      if (.not. allocated(calc%eweight)) then
+      if (.not.allocated(calc%etmp)) allocate (calc%etmp(n),source=0.0_wp)
+      if (.not.allocated(calc%grdtmp)) allocate (calc%grdtmp(3,mol%nat,n),source=0.0_wp)
+      if (.not.allocated(calc%eweight)) then
         allocate (calc%eweight(n),source=0.0_wp)
         do i = 1,n
           calc%eweight(i) = calc%calcs(i)%weight
         end do
       end if
+      !>--- count the engrad call
+      engrad_total = engrad_total+1
+    end if
+
+!>--- update ONIOM geometries
+    useONIOM = allocated(calc%ONIOM)
+    if (useONIOM) then
+      if (.not.allocated(calc%ONIOMmols)) then
+        allocate (calc%ONIOMmols(calc%ONIOM%ncalcs))
+      end if
+      call ONIOM_update_geo(calc%ONIOM,mol,calc%ONIOMmols,calc%ONIOMmap)
     end if
-    
+
     iostatus = 0
     dum1 = 1.0_wp
     dum2 = 1.0_wp
@@ -129,143 +141,228 @@
     calc%grdtmp = 0.0_wp
     !$omp end critical
 
-!==========================================================!
-    !>--- Calculation
+!**************************************
+!>--- Calculation of potentials
+!**************************************
     if (n > 0) then
+      if (calc%id > 0.and.calc%id > n) error stop 'Invalid calculator setup'
 
-      !==================================================================================!
-      !>--- loop over all calculations to be done
+!==================================================================================!
+!>--- loop over all calculations to be done
       do i = 1,calc%ncalculations
-        select case (calc%calcs(i)%id)
-        case (jobtype%xtbsys)  !>-- xtb system call
-          call xtb_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)
-
-        case (jobtype%generic) !>-- generic script/program call
-          call generic_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)
 
-        case (jobtype%tblite)  !>-- tblite api call
-          call tblite_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)
+        !> skip through calculations we do not want
+        if (calc%calcs(i)%refine_lvl /= calc%refine_stage) cycle
 
-        case (jobtype%gfn0) !>-- GFN0-xTB api
-          call gfn0_engrad(mol,calc%calcs(i),calc%calcs(i)%g0calc,calc%etmp(i), &
-          &                calc%grdtmp(:,:,i),iostatus)
-
-        case (jobtype%gfn0occ) !>-- Special GFN0-xTB api given orbital population
-          !> note the use of calc%g0calc instead of calc%calcs(i)%g0calc !
-          call gfn0occ_engrad(mol,calc%calcs(i),calc%g0calc,calc%etmp(i), &
-          &                   calc%grdtmp(:,:,i),iostatus)
- 
-        case (jobtype%gfnff) !>-- GFN-FF api
-          call gfnff_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)
-
-        case (jobtype%xhcff) !>--- XHCFF-lib 
-          call xhcff_engrad(mol,calc%calcs(i),calc%etmp(i),calc%grdtmp(:,:,i),iostatus)
-
-        case (99) !-- Lennard-Jones dummy calculation
-          if (allocated(calc%calcs(i)%other)) then
-            read (calc%calcs(i)%other,*) dum1,dum2
-          end if
-          call lj_engrad(mol%nat,mol%xyz,dum1,dum2,calc%etmp(i),calc%grdtmp(:,:,i))
+        !> Assign the molecule (necessary for ONIOM stuff)
+        if (calc%calcs(i)%ONIOM_id /= 0) then
+          !j = calc%calcs(i)%ONIOM_id
+          j = calc%ONIOMrevmap(i)
+          call ONIOM_associate_mol(calc%ONIOMmols(j),molptr)
+        else
+          molptr => mol
+        end if
+        pnat = molptr%nat
+
+        !> also skip through if only one level was requested
+        if (calc%id > 0.and.i .ne. calc%id.and..not.useONIOM) cycle
+        if (.not.calc%calcs(i)%active) cycle
 
-        case default
-          !write (*,*) 'Nothing selected for energy and gradient calculation.'
-          calc%etmp(i) = 0.0_wp
-          calc%grdtmp(:,:,i) = 0.0_wp
-        end select
+        !==========================================!
+        !> the actual potential call
+        !==========================================!
+        call potential_core(molptr,calc,i,iostatus)
+        !==========================================!
+        !==========================================!
+
         if (iostatus /= 0) then
           return
         end if
       end do
-
-      !==================================================================================!
-      !>--- switch case for what to to with the energies
+!==================================================================================!
+
+!***************************************************
+!>--- Select energy and gradient construction
+!***************************************************
+      !>--- for ONIOM calculations, copy gradients to right positions
+      !>--- and project with Jacobian
+      !$omp critical
+      if (useONIOM) then
+        call calc_ONIOM_projection(calc)
+      end if
+      !$omp end critical
+
       select case (calc%id)
-      case( 0 ) !> the DEFAULT
-      !>--- an option to add multiple energies and gradients accodring to weights
-      !>--- which might be useful for additive contributions   
+      case (0) !> the DEFAULT
+        !>--- an option to add multiple energies and gradients accodring to weights
+        !>--- which might be useful for additive contributions
         call calc_add_weighted_egrd(n,calc%eweight,calc%etmp,calc%grdtmp, &
         &                energy,gradient)
 
+        !$omp critical
+        if (useONIOM) then
+          call ONIOM_engrad(calc%ONIOM,mol,energy,gradient)
+        end if
+        !$omp end critical
+
       case (1:)
-      !>--- if calc%id is a positive integer, take e+grd from 
-      !>--- the respective specified calculation
+        !>--- if calc%id is a positive integer, take e+grd from
+        !>--- the respective specified calculation
         j = calc%id
         if (j <= calc%ncalculations) then
-          energy = calc%etmp(j)
-          gradient = calc%grdtmp(:,:,j)
+          if (useONIOM.and.calc%calcs(j)%ONIOM_id /= 0) then
+            k = calc%calcs(j)%ONIOM_id
+            l = calc%calcs(j)%ONIOM_highlowroot
+            call ONIOM_get_fraggrad(calc%ONIOM,k,gradient,l,energy)
+          else
+            energy = calc%etmp(j)
+            gradient = calc%grdtmp(:,:,j)
+          end if
         end if
 
       case (-1)
-      !>--- if calc%id is equal to -1, we are using the MECP routines:
-      !>--- take non-adiabatic arithmetic mean (of first two calculations)
+        if (useONIOM) then
+          write (stdout,'(a)') '**ERROR** MECP routines currently incompatible with ONIOM'
+          error stop
+        end if
+        !>--- if calc%id is equal to -1, we are using the MECP routines:
+        !>--- take non-adiabatic arithmetic mean (of first two calculations)
         call engrad_mean(mol%nat,calc%ncalculations,calc%etmp,calc%grdtmp, &
         &                energy,gradient)
 
-      case default 
-      !>--- any other case does not return any energy and gradient
-      !>--- from this part  of the calculator. 
-      !>--- constraints (see below) will be applied, however.
+      case default
+        !>--- any other case does not return any energy and gradient
+        !>--- from this part  of the calculator.
+        !>--- constraints (see below) will be applied, however.
       end select
 
-      
       !>--- printout (to file or stdout)
       call calc_eprint(calc,energy,calc%etmp)
     end if
 
-!==========================================================!
-    !>--- Constraints
+!**********************************************
+!>--- Constraints
+!**********************************************
     if (calc%nconstraints > 0) then
       !$omp critical
-      allocate (grdfix(3,mol%nat),source=0.0_wp)
+      if (.not.allocated(calc%grdfix)) then
+        allocate (calc%grdfix(3,mol%nat),source=0.0_wp)
+      end if
       !$omp end critical
       do i = 1,calc%nconstraints
         efix = 0.0_wp
-        grdfix = 0.0_wp
-        if (calc%cons(i)%type > 0) then
+        calc%grdfix = 0.0_wp
+        if (calc%cons(i)%type >= 0) then
           !>--- structural constraints
-          call calc_constraint(mol%nat,mol%xyz,calc%cons(i),efix,grdfix)
-        else if (allocated(calc%etmp) .and. allocated(calc%grdtmp)) then
+          call calc_constraint(mol%nat,mol%xyz,calc%cons(i),efix,calc%grdfix)
+
+        else if (allocated(calc%etmp).and.allocated(calc%grdtmp)) then
           !>--- non-adiabatic constraints
           if (n > 1) then
-            call calc_nonadiabatic_constraint(mol%nat,calc%cons(i),n,calc%etmp,calc%grdtmp,efix,grdfix)
+            call calc_nonadiabatic_constraint(mol%nat,calc%cons(i),n,calc%etmp,calc%grdtmp, &
+            &    efix,calc%grdfix)
           else !> this "else" is necessary for constrained model hessians
             efix = 0.0_wp
-            grdfix = 0.0_wp
+            calc%grdfix = 0.0_wp
           end if
         end if
-        energy = energy + efix
-        gradient = gradient + grdfix
+        energy = energy+efix
+        gradient = gradient+calc%grdfix
       end do
-      !$omp critical
-      deallocate (grdfix)
-      !$omp end critical
     end if
 
+!**********************************************
+!>--- Frozen atoms
+!**********************************************
+    call calc%freezegrad(gradient)
+
     return
   end subroutine engrad_mol
 
-  !>--- wrapper for the engrad_mol routine
-  subroutine engrad_xyz(n,xyz,at,calc,energy,gradient,iostatus)
+!========================================================================================!
+!========================================================================================!
+!========================================================================================!
+
+  subroutine potential_core(molptr,calc,id,iostatus)
+!***************************************************************
+!* subroutine porential_core
+!*
+!* wrapped main potential calls.
+!* enrgies and gradients are saved to calc
+!* id is used to select the calculation
+!***************************************************************
     implicit none
-    integer,intent(in) :: n
-    real(wp),intent(in) :: xyz(3,n) ! coordinates should be in Bohr (a.u.)
-    integer,intent(in) :: at(n)
-    type(calcdata) :: calc
-    type(coord) :: mol
-
-    real(wp),intent(inout) :: energy
-    real(wp),intent(inout) :: gradient(3,n)
-    integer,intent(out) :: iostatus
-
+    type(coord),intent(in)       :: molptr
+    type(calcdata),intent(inout) :: calc
+    integer,intent(in)           :: id
+    integer,intent(out)          :: iostatus
+    integer :: pnat
     real(wp) :: dum1,dum2
 
-    mol%nat = n
-    mol%at = at
-    mol%xyz = xyz
-    call engrad_mol(mol,calc,energy,gradient,iostatus)
+    if (id > calc%ncalculations) return
+
+    pnat = molptr%nat
+
+    !>--- select the calculation type
+    select case (calc%calcs(id)%id)
+
+    case (jobtype%xtbsys)
+      !> xtb system call
+      call xtb_engrad(molptr,calc%calcs(id),calc%etmp(id),calc%grdtmp(:,1:pnat,id),iostatus)
 
-    return
-  end subroutine engrad_xyz
+    case (jobtype%generic)
+      !> generic script/program call
+      call generic_engrad(molptr,calc%calcs(id),calc%etmp(id),calc%grdtmp(:,1:pnat,id),iostatus)
+
+    case (jobtype%tblite)
+      !> tblite api call
+      call tblite_engrad(molptr,calc%calcs(id),calc%etmp(id),calc%grdtmp(:,1:pnat,id),iostatus)
+
+    case (jobtype%gfn0)
+      !> GFN0-xTB api
+      call gfn0_engrad(molptr,calc%calcs(id),calc%calcs(id)%g0calc,calc%etmp(id), &
+      &                calc%grdtmp(:,1:pnat,id),iostatus)
+
+    case (jobtype%gfn0occ)
+      !> Special GFN0-xTB api given orbital population
+      !> note the use of calc%g0calc instead of calc%calcs(id)%g0calc !
+      call gfn0occ_engrad(molptr,calc%calcs(id),calc%g0calc,calc%etmp(id), &
+      &                   calc%grdtmp(:,1:pnat,id),iostatus)
+
+    case (jobtype%gfnff)
+      !> GFN-FF api
+      call gfnff_engrad(molptr,calc%calcs(id),calc%etmp(id),calc%grdtmp(:,1:pnat,id),iostatus)
+
+    case (jobtype%xhcff)
+      !> XHCFF-lib
+      call xhcff_engrad(molptr,calc%calcs(id),calc%etmp(id),calc%grdtmp(:,1:pnat,id),iostatus)
+
+    case (jobtype%turbomole)
+      !> Turbomole-style SPs
+      call turbom_engrad(molptr,calc%calcs(id),calc%etmp(id),calc%grdtmp(:,1:pnat,id),iostatus)
+
+    case (jobtype%orca)
+      !> ORCA-style SPs
+      call orca_engrad(molptr,calc%calcs(id),calc%etmp(id),calc%grdtmp(:,1:pnat,id),iostatus)
+
+    case (jobtype%lj) 
+      !> Lennard-Jones potential calculation
+      if (allocated(calc%calcs(id)%other)) then
+        read (calc%calcs(id)%other,*) dum1,dum2
+      else
+        dum1 = 1.0_wp
+        dum2 = 1.0_wp   
+      end if
+      call lj_engrad(molptr%nat,molptr%xyz*autoaa,dum1,dum2, &
+      &              calc%etmp(id),calc%grdtmp(:,1:pnat,id))
+      calc%grdtmp(:,:,id) = calc%grdtmp(:,:,id)*autoaa
+
+    case default
+      calc%etmp(id) = 0.0_wp
+      calc%grdtmp(:,:,id) = 0.0_wp
+    end select
+
+  end subroutine potential_core
 
 !========================================================================================!
 !========================================================================================!
@@ -286,33 +383,34 @@
     real(wp) :: energy,el,er
     real(wp),allocatable :: grad(:,:)
     real(wp),allocatable :: numgrd(:,:)
-    real(wp),parameter :: step = 0.00001_wp,step2 = 0.5_wp / step
+    real(wp),parameter :: step = 0.00001_wp,step2 = 0.5_wp/step
 
     allocate (grad(3,mol%nat),source=0.0_wp)
     allocate (numgrd(3,mol%nat),source=0.0_wp)
 
     do i = 1,mol%nat
       do j = 1,3
-        mol%xyz(j,i) = mol%xyz(j,i) + step
-        call engrad(mol%nat,mol%xyz,mol%at,calc,er,grad,io)
+        mol%xyz(j,i) = mol%xyz(j,i)+step
+        call engrad(mol,calc,er,grad,io)
 
-        mol%xyz(j,i) = mol%xyz(j,i) - 2 * step
-        call engrad(mol%nat,mol%xyz,mol%at,calc,el,grad,io)
+        mol%xyz(j,i) = mol%xyz(j,i)-2*step
+        call engrad(mol,calc,el,grad,io)
 
-        mol%xyz(j,i) = mol%xyz(j,i) + step
-        numgrd(j,i) = step2 * (er - el)
+        mol%xyz(j,i) = mol%xyz(j,i)+step
+        numgrd(j,i) = step2*(er-el)
       end do
     end do
 
-    write (*,*) 'Numerical Gradient:'
+    write (stdout,*)
+    write (stdout,*) 'Numerical Gradient:'
     do i = 1,mol%nat
       write (*,'(3f18.8)') numgrd(1:3,i)
     end do
 
-    write (*,*)
-    write (*,*) 'Gradient Difference:'
+    write (stdout,*)
+    write (stdout,*) 'Gradient Difference:'
     do i = 1,mol%nat
-      write (*,'(3f18.8)') numgrd(1:3,i) - angrad(1:3,i)
+      write (stdout,'(3f18.8)') numgrd(1:3,i)-angrad(1:3,i)
     end do
 
     deallocate (numgrd,grad)
@@ -333,14 +431,14 @@
     integer,intent(in) :: at(nat)
     real(wp),intent(in) :: xyz(3,nat)
     type(calcdata) :: calc
-    real(wp),intent(out) :: hess(nat * 3, nat*3)
+    real(wp),intent(out) :: hess(nat*3,nat*3)
     integer,intent(out)  :: io
 
     type(coord) :: mol !> coord type, so that the input remains unchanged
     real(wp) :: energy,el,er,hij
     real(wp),allocatable :: gradr(:,:),gradl(:,:)
-    real(wp),allocatable :: gradr_tmp(:,:,:), gradl_tmp(:,:,:)
-    real(wp),parameter :: step = 0.005_wp,step2 = 0.5_wp / step !0.00001_wp
+    real(wp),allocatable :: gradr_tmp(:,:,:),gradl_tmp(:,:,:)
+    real(wp),parameter :: step = 0.005_wp,step2 = 0.5_wp/step !0.00001_wp
     integer :: i,j,k,l,m,ii,jj
 
     hess = 0.0_wp
@@ -348,41 +446,41 @@
     mol%nat = nat
     mol%at = at
     mol%xyz = xyz
-    
+
     allocate (gradr(3,mol%nat),source=0.0_wp) !dummy
     allocate (gradl(3,mol%nat),source=0.0_wp) !dummy
 
     do i = 1,mol%nat
       do j = 1,3
-        ii = (i - 1) * 3 + j
+        ii = (i-1)*3+j
         gradr = 0.0_wp
-        mol%xyz(j,i) = mol%xyz(j,i) + step
-        call engrad(mol, calc,er,gradr,io)
+        mol%xyz(j,i) = mol%xyz(j,i)+step
+        call engrad(mol,calc,er,gradr,io)
 
         gradl = 0.0_wp
-        mol%xyz(j,i) = mol%xyz(j,i) - 2.0_wp * step
-        call engrad(mol, calc,el,gradl,io)
+        mol%xyz(j,i) = mol%xyz(j,i)-2.0_wp*step
+        call engrad(mol,calc,el,gradl,io)
 
-        mol%xyz(j,i) = mol%xyz(j,i) + step
+        mol%xyz(j,i) = mol%xyz(j,i)+step
 
-          do k = 1,mol%nat
-            do l = 1,3
-              jj = (k - 1) * 3 + l
-              hess(jj,ii) = (gradr(l,k) - gradl(l,k)) * step2
-            end do
-          end do
+        do k = 1,mol%nat
+          do l = 1,3
+            jj = (k-1)*3+l
+            hess(jj,ii) = (gradr(l,k)-gradl(l,k))*step2
+          end do
+        end do
 
       end do
     end do
 
     !Symmetrize Hessian
-      do i = 1,nat*3
-        do j = i,nat*3
-          hij = (hess(i,j) + hess(j,i))*0.5_wp 
-          hess(i,j) = hij
-          hess(j,i) = hij
-        end do
-      end do
+    do i = 1,nat*3
+      do j = i,nat*3
+        hij = (hess(i,j)+hess(j,i))*0.5_wp
+        hess(i,j) = hij
+        hess(j,i) = hij
+      end do
+    end do
 
     call engrad(mol,calc,el,gradl,io) !>- to get the gradient of the non-displaced structure
 
@@ -404,14 +502,14 @@
     integer,intent(in) :: at(nat)
     real(wp),intent(in) :: xyz(3,nat)
     type(calcdata) :: calc
-    real(wp),intent(out) :: hess(nat * 3,nat * 3,calc%ncalculations)
+    real(wp),intent(out) :: hess(nat*3,nat*3,calc%ncalculations)
     integer,intent(out)  :: io
 
     type(coord) :: mol !> coord type, so that the input remains unchanged
     real(wp) :: energy,el,er,hij
     real(wp),allocatable :: gradr(:,:),gradl(:,:)
-    real(wp),allocatable :: gradr_tmp(:,:,:), gradl_tmp(:,:,:)
-    real(wp),parameter :: step = 0.005_wp,step2 = 0.5_wp / step !0.00001_wp
+    real(wp),allocatable :: gradr_tmp(:,:,:),gradl_tmp(:,:,:)
+    real(wp),parameter :: step = 0.005_wp,step2 = 0.5_wp/step !0.00001_wp
     integer :: i,j,k,l,m,ii,jj
 
     hess = 0.0_wp
@@ -419,7 +517,7 @@
     mol%nat = nat
     mol%at = at
     mol%xyz = xyz
-    
+
     allocate (gradr(3,mol%nat),source=0.0_wp) !dummy
     allocate (gradl(3,mol%nat),source=0.0_wp) !dummy
 
@@ -428,26 +526,26 @@
 
     do i = 1,mol%nat
       do j = 1,3
-        ii = (i - 1) * 3 + j
+        ii = (i-1)*3+j
         !gradr = 0.0_wp
-        mol%xyz(j,i) = mol%xyz(j,i) + step
-        call engrad(mol%nat,mol%xyz,mol%at,calc,er,gradr,io)
+        mol%xyz(j,i) = mol%xyz(j,i)+step
+        call engrad(mol,calc,er,gradr,io)
 
         gradr_tmp = calc%grdtmp
 
         !gradl = 0.0_wp
-        mol%xyz(j,i) = mol%xyz(j,i) - 2.0_wp * step
-        call engrad(mol%nat,mol%xyz,mol%at,calc,el,gradl,io)
+        mol%xyz(j,i) = mol%xyz(j,i)-2.0_wp*step
+        call engrad(mol,calc,el,gradl,io)
 
         gradl_tmp = calc%grdtmp
 
-        mol%xyz(j,i) = mol%xyz(j,i) + step
+        mol%xyz(j,i) = mol%xyz(j,i)+step
 
         do m = 1,calc%ncalculations
           do k = 1,mol%nat
             do l = 1,3
-              jj = (k - 1) * 3 + l
-              hess(jj,ii,m) = (gradr_tmp(l,k,m) - gradl_tmp(l,k,m)) * step2
+              jj = (k-1)*3+l
+              hess(jj,ii,m) = (gradr_tmp(l,k,m)-gradl_tmp(l,k,m))*step2
             end do
           end do
         end do
@@ -458,14 +556,14 @@
     do m = 1,calc%ncalculations
       do i = 1,nat*3
         do j = i,nat*3
-          hij = (hess(i,j,m) + hess(j,i,m))*0.5_wp 
+          hij = (hess(i,j,m)+hess(j,i,m))*0.5_wp
           hess(i,j,m) = hij
           hess(j,i,m) = hij
         end do
       end do
     end do
 
-    call engrad(mol%nat,mol%xyz,mol%at,calc,el,gradl,io) !>- to get the gradient of the non-displaced s
+    call engrad(mol,calc,el,gradl,io) !>- to get the gradient of the non-displaced s
 
     deallocate (gradl_tmp,gradr_tmp)
     deallocate (gradl,gradr)
@@ -473,7 +571,6 @@
     return
   end subroutine numhess2
 
-
 !========================================================================================!
   subroutine constrhess(nat,at,xyz,calc,phess)
 !*********************************************************
@@ -490,7 +587,7 @@
     integer,intent(in) :: at(nat)
     real(wp),intent(in) :: xyz(3,nat)
     type(calcdata),intent(in) :: calc
-    real(wp),intent(inout) :: phess((nat * 3) * ((nat * 3) + 1) / 2)
+    real(wp),intent(inout) :: phess((nat*3)*((nat*3)+1)/2)
 
     type(calcdata) :: dummycalc
     integer :: tc_backup
@@ -506,7 +603,7 @@
     dummycalc%id = -1000  !> set to something arbitrary so that only constraints are considered
     dummycalc%ncalculations = 0
     dummycalc%pr_energies = .false.
-    n3 = nat * 3
+    n3 = nat*3
     allocate (hess(n3,n3),source=0.0_wp)
 
     call numhess1(nat,at,xyz,dummycalc,hess,io)
@@ -514,8 +611,8 @@
     k = 0
     do i = 1,n3
       do j = 1,i
-        k = k + 1
-        phess(k) = phess(k) + 0.5_wp * (hess(j,i) + hess(i,j))
+        k = k+1
+        phess(k) = phess(k)+0.5_wp*(hess(j,i)+hess(i,j))
       end do
     end do
 
@@ -524,16 +621,20 @@
   end subroutine constrhess
 
 !==========================================================================================!
-  subroutine calc_print_energies(calc,energy,energies)
+  subroutine calc_print_energies(calc,energy,energies,chnl)
     implicit none
-    type(calcdata) :: calc
-    real(wp) :: energy
-    real(wp) :: energies(:)
+    type(calcdata),intent(inout) :: calc
+    real(wp),intent(in) :: energy
+    real(wp),intent(in) :: energies(:)
+    integer,intent(in),optional :: chnl
     integer :: i,j,l
     character(len=20) :: atmp
     character(len=:),allocatable :: btmp
+    logical :: ex
 
-    if (.not. calc%pr_energies) return
+    if (.not.present(chnl)) then
+      if (.not.calc%pr_energies) return
+    end if
     btmp = ''
     write (atmp,'(f20.12)') energy
     btmp = btmp//atmp
@@ -542,41 +643,20 @@
       write (atmp,'(f20.12)') energies(i)
       btmp = btmp//atmp
     end do
-    write (calc%eout_unit,'(a)') btmp
+    if (present(chnl)) then
+      write (chnl,'(a)') btmp
+    else
+      write (calc%eout_unit,'(a)') btmp
+    end if
     deallocate (btmp)
     return
   end subroutine calc_print_energies
 
-!==========================================================================================!
-  subroutine calc_print_energies2(calc,energy,energies,chnl)
-    implicit none
-    type(calcdata) :: calc
-    real(wp) :: energy
-    real(wp) :: energies(:)
-    integer :: chnl
-    integer :: i,j,l
-    character(len=20) :: atmp
-    character(len=:),allocatable :: btmp
-    btmp = ''
-    write (atmp,'(f20.12)') energy
-    btmp = btmp//atmp
-    l = size(energies,1)
-    do i = 1,l
-      write (atmp,'(f20.12)') energies(i)
-      btmp = btmp//atmp
-    end do
-    write (chnl,'(a)') btmp
-    deallocate (btmp)
-    return
-  end subroutine calc_print_energies2
-
-
 !==========================================================================================!
   subroutine calc_add_weighted_egrd(ncalc,weights,energies,gradients,e,grd)
 !***************************************************************************
 !* A subroutine that adds (further) energies and gradients to
 !* e and grd, according to given weights.
-!* Might be useful for additive contributions or schemes like QMMM or ONIOM
 !***************************************************************************
     implicit none
     !> INPUT
@@ -589,12 +669,41 @@
     real(wp),intent(inout) :: grd(:,:)
     !> LOCAL
     integer :: i
-    do i=1,ncalc
-       e = e + weights(i)*energies(i)
-       grd(:,:) = grd(:,:) + weights(i)*gradients(:,:,i)
-    enddo 
+    do i = 1,ncalc
+      e = e+weights(i)*energies(i)
+      grd(:,:) = grd(:,:)+weights(i)*gradients(:,:,i)
+    end do
   end subroutine calc_add_weighted_egrd
 
+!==========================================================================================!
+
+  subroutine calc_ONIOM_projection(calc)
+!*******************************************
+!* Iterate through the ONIOM data and
+!* place the correct energies and gradients
+!*******************************************
+    implicit none
+    type(calcdata),intent(inout) :: calc
+    integer :: n,i,j,k,l,l1,l2
+    integer :: natp,trunat
+#ifdef WITH_LWONIOM
+    if (allocated(calc%ONIOM).and.calc%ncalculations > 0) then
+      trunat = maxval(calc%ONIOMmols(:)%nat)
+      do i = 1,calc%ONIOM%nfrag
+        l1 = calc%ONIOM%calcids(1,i)
+        l2 = calc%ONIOM%calcids(2,i)
+        !j = calc%calcs(l1)%ONIOM_id
+        natp = calc%ONIOMmols(l1)%nat
+
+        call calc%ONIOM%fragment(i)%gradient_distribution(  &
+        &    calc%etmp(l1),calc%grdtmp(1:3,1:natp,l1), &
+        &    calc%etmp(l2),calc%grdtmp(1:3,1:natp,l2))
+        call calc%ONIOM%fragment(i)%jacobian(trunat)
+      end do
+    end if
+#endif
+  end subroutine calc_ONIOM_projection
+
 !==========================================================================================!
 !==========================================================================================!
 end module crest_calculator
Index: src/algos/setuptest.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\nsubroutine trialMD_calculator(env)\n  use crest_parameters\n  use crest_data\n  use crest_calculator\n  use dynamics_module\n  use strucrd\n  use iomod\n  implicit none\n\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n\n  integer :: io,Vdumpfreq,counter\n  real(wp) :: prefac,alpha,length\n  real(wp) :: rtime,tstep\n  integer :: shakemode,maxiter\n\n  character(len=512) :: thispath\n  character(len=80)  :: trajectory,atmp\n\n  logical :: shakefail,mdfail,ex,pr\n  type(coord) :: mol,molstart\n  type(mddata) :: MD,MDSTART\n  type(mtdpot) :: MTD\n  type(timer) :: profiler\n\n  character(len=*),parameter :: dirnam = 'TRIALMD'\n\n!>--- OMP settings (should be set to 1 to simulate max parallelization)\n  if (env%autothreads) then\n    call ompautoset(env%threads,8,env%omp,env%MAXRUN,8)\n  end if\n\n  call getcwd(thispath)\n\n!>--- Make a dir\n  call rmrf(dirnam)\n  io = makedir(trim(dirnam))\n\n!>--- set up mol and MD calculator\n  prefac = 0.003d0*env%rednat !> Vbias k\n  alpha = 0.5d0         !> Vbias alpha\n  !Vdumpfreq = 10000     !> Vbias dumpfrequency, i.e., never updated !SG\n\n  call env%ref%to(molstart)\n  MDSTART = env%mddat         !> env%mddat should already be set up at this point\n  MDSTART%length_ps = 1.0_wp  !> we want only a short simulaton\n  MDSTART%length_steps = 0    !> to zero so it will be calculated automatically\n  MDSTART%dumpstep = 20.0_wp  !> fs dump step to trajectory file, so we end up with 50 structures\n  MDSTART%sdump = 0           !> also zero to reset\n  if(allocated(env%ref%wbo))then  !> should be allocated from main program\n    MDSTART%shk%wbo = env%ref%wbo\n  endif\n  !MDSTART%printstep = 10\n\n  MTD%kpush = prefac\n  MTD%alpha = alpha\n  MTD%mtdtype = cv_rmsd\n  MTD%cvdump_fs = 550.0_wp\n  call MDSTART%add(MTD)\n\n  pr = .false. !> supress stdout printout of MD\n\n!>--- Header\n  write (stdout,*)\n  call smallhead('Starting trial MTD to test settings')\n\n!>--- Iterative loop, since it is also tested if the MD runs at all\n  counter = 1\n  maxiter = 6\n  tstep = MDSTART%tstep\n  shakemode = MDSTART%shk%shake_mode\n  call profiler%init(maxiter)\n  iterativ: do\n\n!>--- Restore initial starting geometry\n    mol = molstart\n!>--- Modify MD output trajectory\n    MD = MDSTART\n    MD%tstep = tstep\n    MD%shk%shake_mode = shakemode\n    MD%shake = (shakemode > 0)\n    write(trajectory,'(\"crest_trial_md_\",i0,\".trj\")') counter\n    MD%trajectoryfile = trim(dirnam)//sep//trim(trajectory)\n\n!>--- And run it\n    io = 1\n    !================================!\n    call profiler%start(counter)\n    call dynamics(mol,MD,env%calc,pr,io)\n    call profiler%stop(counter)\n    !================================!\n\n    if (io == 0) then\n      write (atmp,'(1x,\"Trial MTD \",i0,\" runtime (\",f3.1,\" ps)\")') counter,MD%length_ps\n      call profiler%write_timing(stdout,counter,trim(atmp))\n      exit iterativ\n\n    else\n\n      write (stdout,'(1x,\"Trial MTD \",i0,\" did not converge!\")') counter\n      if (counter >= maxiter) then\n        write (stdout,'(1x,\"Automatic MD restart failed \",i0,\" times!\")') counter\n        write (stdout,'(1x,\"Please try other settings manually.\")')\n        write (stdout,*)\n        error stop\n      end if\n      counter = counter+1\n\n      if (tstep <= 1.0d0.and.shakemode > 0) then\n        write (stdout,'(1x,\"Time step can´t be reduced further!\")')\n        write (stdout,'(1x,\"Trying to turn SHAKE off ...\")')\n        write (stdout,*)\n        shakemode = 0\n        cycle iterativ\n\n      else if (tstep <= 1.0d0.and.shakemode == 0) then\n        write (stdout,'(1x,\"Automatic MTD settings check failed!\")')\n        write (stdout,'(1x,\"Please try other settings manually.\")')\n        error stop\n      end if\n\n      !> don't reduce the timestep below 1 fs automatically\n      tstep = max(1.0d0, (tstep-1.0d0))\n      write (stdout,'(1x,\"Reducing the time step to \",f4.1,\" fs and trying again ...\")') tstep\n      write (stdout,*)\n    end if\n!>--- End loop\n  end do iterativ\n\n!>--- transfer final settings to global settings\n  env%mdstep = MD%tstep\n  env%mddat%tstep = MD%tstep\n  env%shake = shakemode\n  env%mddat%shk%shake_mode = shakemode\n  env%mddat%shake = (shakemode > 0)\n\n!>--- If we succeded and exited the above loop, estimate runtime for multiple MTDs\n  rtime = profiler%get(counter)\n  call timeestimate(rtime,env%mdtime,env%nmetadyn,env%threads)\n\n  return\n!=========================================================================================!\ncontains\n!=========================================================================================!\n  subroutine timeestimate(rtime,mdtime,nmetadyn,threads)\n!******************************************\n!* calaculate and print the time estimate\n!******************************************\n    implicit none\n    real(wp)  :: mdtime\n    integer :: nmetadyn\n    integer :: threads\n    real(wp)  :: rtime,rtime2\n    real(wp)  :: w,t\n    character(len=80) :: stime,stime2\n\n    rtime2 = rtime\n\n    rtime = rtime*mdtime             !scale the runtime to the MTD length\n    call time2string(rtime,stime)\n    write (stime2,'(f14.1)') mdtime\n    stime2 = adjustl(stime2)\n    write (stdout,'(1x,a,a,a,a)') 'Estimated runtime for one MTD (',trim(stime2), &\n    &                      ' ps) on a single thread: ',trim(stime)\n\n    if (threads < nmetadyn) then\n      w = float(nmetadyn)/float(threads)\n      t = float(ceiling(w))\n      rtime = rtime*t\n      call time2string(rtime,stime)\n    else if (threads == nmetadyn) then\n      call time2string(rtime,stime)\n    else if (threads > nmetadyn) then\n      w = float(threads)/float(nmetadyn)\n      t = float(floor(w))\n      rtime = rtime/t\n      call time2string(rtime,stime)\n    end if\n\n    write (stdout,'(1x,a,i0,a,i0,a,a)') 'Estimated runtime for a batch of ',nmetadyn, &\n    &                      ' MTDs on ',threads,' threads: ',trim(stime)\n\n  end subroutine timeestimate\n\n  subroutine time2string(rtime,str)\n    implicit none\n    real(wp) :: rtime\n    real(wp) :: hours,minutes,seconds\n    character(len=*) :: str\n\n    hours = aint(rtime/3600d0)\n    minutes = aint((rtime-(3600d0*hours))/60d0)\n    seconds = anint(rtime-(3600d0*hours+minutes*60d0))\n\n    if (hours > 0.0d0) then\n      write (str,'(i0,1x,a,1x,i0,1x,a,1x,i0,1x,a)') &\n      & nint(hours),'h',nint(minutes),'min',nint(seconds),'sec'\n    else if (minutes > 0.0d0) then\n      write (str,'(i0,1x,a,1x,i0,1x,a)') &\n      & nint(minutes),'min',nint(seconds),'sec'\n    else\n      write (str,'(i0,1x,a)') nint(seconds),'sec'\n    end if\n\n    return\n  end subroutine time2string\n\n!========================================================================================!\nend subroutine trialMD_calculator\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/setuptest.f90 b/src/algos/setuptest.f90
--- a/src/algos/setuptest.f90	
+++ b/src/algos/setuptest.f90	
@@ -16,7 +16,25 @@
 ! You should have received a copy of the GNU Lesser General Public License
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
+
+!> The following contains routines that are run in the automatic
+!> setup of CREST to check for consistent settings.
+!> First is the trialMD calculator that can automatically adjust the timestep
+!> Second is the initial geometry optimization with topology check
+
+!========================================================================================!
+!========================================================================================!
+!> Routines for checking metadynamics settings (timestep & shake, mostly)
+!========================================================================================!
+!========================================================================================!
 subroutine trialMD_calculator(env)
+!*****************************************************
+!* subroutine trialMD_calculator
+!* Runs a short metadynamics simulation and, in case
+!* the simulation terminates with error, tries to
+!* adjust the time step and tries again. Up to a
+!* maximum of 6 tries.
+!*****************************************************
   use crest_parameters
   use crest_data
   use crest_calculator
@@ -41,11 +59,15 @@
   type(mtdpot) :: MTD
   type(timer) :: profiler
 
+  type(calcdata) :: tmpcalc
+  real(wp) :: energy
+  real(wp),allocatable :: grd(:,:)
+
   character(len=*),parameter :: dirnam = 'TRIALMD'
 
 !>--- OMP settings (should be set to 1 to simulate max parallelization)
   if (env%autothreads) then
-    call ompautoset(env%threads,8,env%omp,env%MAXRUN,8)
+    call ompautoset(env%threads,8,env%omp,env%MAXRUN,1)
   end if
 
   call getcwd(thispath)
@@ -65,9 +87,19 @@
   MDSTART%length_steps = 0    !> to zero so it will be calculated automatically
   MDSTART%dumpstep = 20.0_wp  !> fs dump step to trajectory file, so we end up with 50 structures
   MDSTART%sdump = 0           !> also zero to reset
-  if(allocated(env%ref%wbo))then  !> should be allocated from main program
+  if (allocated(env%ref%wbo)) then  !> should be allocated from main program
+    MDSTART%shk%wbo = env%ref%wbo
+  else !> otherwise, obtain from scratch
+    tmpcalc = env%calc
+    mol = molstart
+    tmpcalc%calcs(1)%rdwbo = .true. !> obtain WBOs
+    allocate(grd(3,mol%nat))
+    call engrad(mol,tmpcalc,energy,grd,io)
+    call move_alloc(tmpcalc%calcs(1)%wbo, env%ref%wbo)
+    deallocate(grd)
+    call tmpcalc%reset()
     MDSTART%shk%wbo = env%ref%wbo
-  endif
+  end if
   !MDSTART%printstep = 10
 
   MTD%kpush = prefac
@@ -97,7 +129,7 @@
     MD%tstep = tstep
     MD%shk%shake_mode = shakemode
     MD%shake = (shakemode > 0)
-    write(trajectory,'("crest_trial_md_",i0,".trj")') counter
+    write (trajectory,'("crest_trial_md_",i0,".trj")') counter
     MD%trajectoryfile = trim(dirnam)//sep//trim(trajectory)
 
 !>--- And run it
@@ -222,6 +254,154 @@
 
     return
   end subroutine time2string
-
 !========================================================================================!
 end subroutine trialMD_calculator
+
+!========================================================================================!
+!========================================================================================!
+!> Routines to check topology behaviour upon optimization of input
+!========================================================================================!
+!========================================================================================!
+subroutine trialOPT_calculator(env)
+!**********************************************************
+!* subroutine trialOPT_calculator
+!* A new calculator-based implementation of xtbopt_legacy
+!* Performs a geometry optimization of the structure
+!* saved to env%ref and checks for changes in the topology
+!*
+!* requires to have env%ref and env%calc initialized
+!**********************************************************
+  use crest_parameters
+  use crest_data
+  use crest_calculator
+  use optimize_module
+  implicit none
+  !> INPUT
+  type(systemdata),intent(inout) :: env
+  !> LOCAL
+  type(coord) :: mol,molopt
+  type(calcdata) :: tmpcalc
+  integer :: io
+  real(wp) :: energy
+  real(wp),allocatable :: grd(:,:)
+  logical :: success,pr,wr
+
+!>--- get all available threads
+  call ompset_max(env%threads)
+
+!>--- small header
+  write (stdout,*)
+  call smallhead('Initial Geometry Optimization')
+
+!>--- setup
+  call env%ref%to(mol)
+  call env%ref%to(molopt)
+  allocate(grd(3,mol%nat), source=0.0_wp)
+  tmpcalc = env%calc  !> create copy of calculator
+  tmpcalc%optlev = -1 !> set loose convergence thresholds 
+
+!>--- perform geometry optimization
+  pr = .false. !> stdout printout
+  wr = .true.  !> write crestopt.log
+  call optimize_geometry(mol,molopt,tmpcalc,energy,grd,pr,wr,io)
+
+!>--- check success 
+  success = (io == 0)
+  call trialOPT_warning(env,molopt,success)
+
+  deallocate(grd) 
+end subroutine trialOPT_calculator
+
+!========================================================================================!
+subroutine trialOPT_warning(env,mol,success)
+!*******************************************************
+!* subroutine trialOPT_warning
+!* Processes the trialOPT status and, if successfull,
+!* overwrites env%ref with the opt. structure
+!* If the checks fail, CREST is stopped by this routine
+!*******************************************************
+  use crest_parameters
+  use crest_data
+  use strucrd
+  use utilities
+  implicit none
+  type(systemdata),intent(inout) :: env
+  type(coord),intent(in) :: mol  !> optimized geometry to be checked
+  logical,intent(in) :: success  !> status of geometry optimization
+  integer :: ntopo
+  integer,allocatable :: topo(:)
+  logical,allocatable :: changed(:)
+  integer(dp) :: i  !> revlin expects int64 input
+  integer :: j,k,l
+  logical :: tchange
+
+  if (.not.success) then
+    write (stdout,*)
+    write (stdout,*) ' Initial geometry optimization failed!'
+    write (stdout,*) ' Please check your input.'
+    error stop
+  end if
+  write (stdout,*) 'Geometry successfully optimized.'
+!---- if necessary, check if the topology has changed!
+  if (allocated(env%ref%topo)) then
+    ntopo = mol%nat*(mol%nat+1)/2
+    allocate (topo(ntopo))
+    allocate (changed(mol%nat),source=.false.)
+    call quicktopo(mol%nat,mol%at,mol%xyz,ntopo,topo)
+    do i = 1,ntopo
+      if (topo(i) .ne. env%ref%topo(i)) then
+        tchange = .true.
+        call revlin(i,k,l)
+        changed(k) = .true.
+        changed(l) = .true.
+      end if
+    end do
+    if (tchange) then
+      write (stdout,*)
+      write (stdout,'(1x,a)') '*WARNING* Change in topology detected!'
+      write (stdout,'(1x,a)') 'Topology change compared to the input affects atoms:'
+      do i = 1,mol%nat
+        if (changed(i)) then
+          write (stdout,'(1x,i0,"(",a,")")',advance='no') i,trim(i2e(mol%at(i),'nc'))
+        end if
+      end do
+      write (stdout,*)
+
+!>--- either update the topology (see option B below)
+      if (.not.env%reftopo) then
+        write (stdout,'(1x,a)') 'Taking new topology as reference and continue ...'
+        env%ref%topo = topo
+
+!>--- or abort the run
+      else
+        write (stdout,*)
+        call smallhead('* READ THE FOLLOWING CAREFULLY *')
+        write (stdout,'(1x,a)') 'A topology change was seen in the initial geometry optimization.'
+        write (stdout,'(1x,a,a,a)') 'This could be an artifact of the chosen theory level (e.g. xTB).'
+        if (env%legacy) then
+          write (stdout,'(1x,a)') 'You can check the optimization trajectory in the "xtbopt.log" file.'
+        else
+          write (stdout,'(1x,a)') 'You can check the optimization trajectory in the "crestopt.log" file.'
+        end if
+        write (stdout,'(1x,a)') 'Try either of these options:'
+        write (stdout,'(/,4x,a)') 'A) Pre-optimize your input seperately and use the optimized'
+        write (stdout,'(4x,a)') '   structure as input for CREST. (Only recommended if structure is intact)'
+        write (stdout,'(/,4x,a)') 'B) Restart the same CREST call as before, but ignore the topology change'
+        write (stdout,'(4x,a)') '   by using the "--noreftopo" keyword. (May produce artifacts)'
+        write (stdout,'(/,4x,a)') 'C) Fix the initial input geometry by introducing bond length constraints'
+        write (stdout,'(4x,a)') '   or by using a method with fixed topology (e.g. GFN-FF).'
+        write (stdout,*)
+        error stop 'safety termination of CREST'
+      end if
+    end if
+  end if
+
+!>--- If all checks succeded, update reference with optimized geometry
+  env%ref%nat = mol%nat
+  env%ref%at = mol%at
+  env%ref%xyz = mol%xyz
+
+end subroutine trialOPT_warning
+
+!========================================================================================!
+!========================================================================================!
Index: src/legacy_algos/normmd.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!--------------------------------------------------------------------------------------------\n! A single NORMMD run (bzw. its setup)\n!--------------------------------------------------------------------------------------------\nsubroutine normalMD(fname,env,nr,newtemp,newtime)\n         use crest_parameters\n         use crest_data\n         use iomod\n         use strucrd, only: wrc0\n         implicit none\n\n         type(systemdata) :: env\n         real(wp) :: newtemp\n         real(wp) :: newtime\n         character(len=*)  :: fname\n         character(len=256) :: basename,dirname\n         character(len=512) :: tmppath,thispath\n\n         integer :: r,nr\n\n         real(wp) :: k,alpha\n\n!---- some settings\n         basename='NORMMD'  !base name of the directories\n\n         call getcwd(thispath)              !current dir= thispath\n         write(dirname,'(a,i0)')trim(basename),nr\n         tmppath=trim(dirname)\n         call rmrf(tmppath)            !clear old directory\n         r = makedir(trim(tmppath))    !make new directory\n\n         call rename(trim(fname),trim(tmppath)//'/'//'coord')\n         call env%wrtCHRG(trim(tmppath))   \n         call copysub(env%fixfile,trim(tmppath))\n         if(env%useqmdff)then\n            call copysub('solvent',trim(tmppath))\n         endif\n\n         if(env%staticmtd)then\n             r = sylnk(trim(thispath)//'/'//env%mtdstaticfile,trim(tmppath)//'/'//env%mtdstaticfile)\n         endif\n\n\n         call chdir(trim(tmppath))  !switch to working directory\n!---- do stuff here\n         call setMDrun2('coord',env%hmass,newtime,newtemp,env%mdstep,env%shake, &\n         &    env%mddumpxyz,env%mdskip,env%mddump,-1,env%cts)\n\n         if(env%staticmtd)then\n             k=env%rednat*0.0025d0\n             alpha = 1.0d0\n             call setstaticmtd('coord',k,alpha,env%emtd%mtdramp, &\n             &    env%nstatic,env%mtdstaticfile,'')\n         endif\n  \n         call chdir(thispath)  !go back to orgiginal directory  \n\nend subroutine normalMD\n\n!--------------------------------------------------------------------------------------------\n! Run several normal MDs on the lowermost conformers\n!--------------------------------------------------------------------------------------------\nsubroutine normalMD_para_OMP(env,lconf,ntemps)\n         use crest_parameters\n         use crest_data\n         use iomod\n         use strucrd, only: wrc0,rdensembleparam,rdensemble\n         implicit none\n\n         type(systemdata) :: env\n\n         integer :: lconf,ntemps,tot\n\n         integer :: i,j,k\n         integer :: TOTAL,vz,io\n         real(wp) :: time\n         character(len=512) :: thispath,tmppath\n         character(len=512) :: jobcall\n         character(len=80)  :: fname,pipe,inpnam,outnam,sname\n\n         integer :: nat\n         integer :: iz2\n         integer,allocatable :: at(:)\n         real(wp),allocatable :: xyz(:,:,:),eread(:),scoords(:,:,:)\n         real(wp),allocatable :: temperatures(:),temperatures2(:)\n\n         integer :: nclustbackup\n\n         real(wp) :: newtemp\n\n         nat = env%nat\n\n         if(.not.env%entropic)then    \n      !--- by default the MDs are started on the (so far) lowest conformers.      \n            call rdensembleparam(conformerfile,iz2,TOTAL)\n            allocate(xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))\n            call rdensemble(conformerfile,iz2,TOTAL,at,xyz,eread)\n            if(env%staticmtd)then\n               env%mtdstaticfile=conformerfile\n               env%nstatic=lconf\n            endif\n         else \n            if(env%staticmtd)then\n                call rdensembleparam(conformerfile,iz2,TOTAL)\n                lconf = min(nint(float(TOTAL)*0.1d0),lconf)\n            endif \n      !--- for more diversity use PCA/K-means clusters as seeds             \n            nclustbackup = env%maxcluster\n            env%nclust = lconf\n            call create_anmr_dummy(nat)\n            call CCEGEN(env,.true.,conformerfile)\n            call remove('anmr_nucinfo')\n            env%nclust = nclustbackup\n            call rdensembleparam(clusterfile,iz2,TOTAL)\n            allocate(xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))\n            call rdensemble(clusterfile,iz2,TOTAL,at,xyz,eread)\n            if(env%staticmtd)then\n                env%mtdstaticfile=clusterfile\n                env%nstatic=TOTAL\n            endif\n         endif\n         if(TOTAL.lt.lconf)then\n            lconf=TOTAL                 !if there are less conformers than lconf, use only that much\n         endif\n         allocate(scoords(3,nat,lconf))\n         scoords=xyz(:,:,1:lconf)/bohr\n         deallocate(eread,xyz)\n\n\n!---- some settings\n           \n         tot = lconf * ntemps  !total number of MDs\n\n         if(env%autothreads)then\n            call ompautoset(env%threads,7,env%omp,env%MAXRUN,tot) !set the global OMP/MKL variables for the xtb jobs\n         endif\n\n         if(env%nmdtemp.lt.0.0d0)then\n           newtemp=400.00d0 \n         else\n           newtemp=env%nmdtemp\n         endif\n\n\n         \n         allocate(temperatures2(tot),temperatures(ntemps))\n         temperatures(1)=newtemp\n         do i=2,ntemps\n            j=i-1\n            if(env%entropic) then\n               temperatures(i)=temperatures(j) + 200.0_wp\n            else\n               temperatures(i)=temperatures(j) + 100.0_wp   !each MD 100K higher\n            endif\n         enddo\n\n         if(env%entropic)then\n             time=env%mdtime * 0.25d0 !shorter for entropy mode\n         else\n             time=env%mdtime * 0.5d0 !half the time of each MTD run\n         endif\n\n         call getcwd(thispath)\n\n         fname='coord'\n         pipe=' > xtb.out 2>/dev/null'\n\n         write(jobcall,'(a,1x,a,1x,a,'' --md '',a,1x,a,a)') &\n         &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe\n      !--- slightly different jobcall for QMDFF usage\n         if(env%useqmdff)then\n           write(jobcall,'(a,1x,a,1x,a,'' --md --qmdff'',a,1x,a,a)') &\n           &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe\n         endif\n\n\n!---- Small Header\n       write(*,'(''-----------------------------------------------'')')\n       if(env%staticmtd)then\n          write(*,'(''Additional static MTDs on lowest '',i0,'' conformer(s)'')')lconf\n       else    \n         if(.not.env%entropic)then\n            write(*,'(''Additional regular MDs on lowest '',i0,'' conformer(s)'')')lconf\n         else\n            write(*,'(''Additional regular MDs on  '',i0,'' conformer(s)'')')lconf\n         endif\n       endif\n       write(*,'(''-----------------------------------------------'')')\n       if(env%staticmtd)then\n           write(*,'(/,\"Using \",i0,\" RMSD bias potentials\")') env%nstatic\n       endif\n\n!---- set up directories\n        call rmrfw('scoord.')\n        k=0\n        do i=1,lconf\n           write(sname,'(a,i0)')'scoord.',i\n           do j=1,ntemps\n           call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop\n           k=k+1\n           newtemp=temperatures(j)\n           temperatures2(k)=newtemp\n           call normalMD(trim(sname),env,k,newtemp,time)\n           enddo\n        enddo\n        deallocate(at,scoords)\n\n      \n!$omp parallel &\n!$omp shared( vz,jobcall,tot,time,env,newtemp,temperatures2 )\n!$omp single\n      do i=1,tot\n         vz=i\n       !$omp task firstprivate( vz ) private( tmppath,io )\n         call initsignal()\n       !$omp critical\n             write(*,'(a,i4,a)') 'Starting MD',vz,' with the settings:'\n             write(*,'(''     MD time /ps        :'',f8.1)')time\n             write(*,'(''     MD Temperature /K  :'',f8.1)')temperatures2(vz)\n             write(*,'(''     dt /fs             :'',f8.1)')env%mdstep\n             write(*,'(''     dumpstep(trj) /fs  :'',i8)')env%mddumpxyz\n       !$omp end critical\n         write(tmppath,'(a,i0)')'NORMMD',vz\n         call command('cd '//trim(tmppath)//' && '//trim(jobcall), io)\n         write(*,'(a,i0,a)')'*MD ',vz,' finished*'\n         call rmrf(trim(tmppath)//'/scoord.*')\n       !$omp end task\n      enddo\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n     if(env%trackorigin)then\n        call set_trj_origins('NORMMD','md')\n     endif\n     call checkname_xyz(crefile,inpnam,outnam)\n     write(*,'('' Appending file '',a,'' with new structures'')')trim(inpnam)\n     call collect_trj_skipfirst('NORMMD',trim(inpnam))  !collect all 'xtb.trj' from the NORMMD directories, but skip the first point! (input structure)\n     write(*,*)\n\n     if(.not.env%keepModef)then\n        call cleanMTD\n     endif\n \n     return\nend subroutine normalMD_para_OMP\n\n!-------------------------------------------------------------------------------!\n! Statical MTD addition to the normal MDs\n! can be used to partially prevent the MD to\n! converge to already known regions of the PES\n!-------------------------------------------------------------------------------!\nsubroutine setstaticmtd(infile,k,alpha,ramp,nset,statfile,atomlist)\n    use crest_parameters\n    use crest_data\n    implicit none\n    character(len=*) :: infile\n    real(wp) :: k\n    real(wp) :: alpha\n    real(wp) :: ramp\n    integer :: nset\n    character(len=*) :: statfile\n    character(len=*) :: atomlist\n    integer :: atlen\n\n    character(len=256) :: atmp\n    integer :: ich,ich2,iost\n\n    open(newunit=ich,file=infile)\n    open(newunit=ich2,file='tmpcoordfile')\n    do\n        read(ich,'(a)',iostat=iost)atmp\n        if(iost < 0)exit\n        if(index(atmp,'$end').ne.0)then\n            cycle\n        else\n            write(ich2,'(a)')trim(atmp)\n        endif\n    enddo\n\n    atlen = len_trim(atomlist)\n \n    write(ich2,'(a)')'$metadyn'\n    write(ich2,'(2x,a,i0)') 'save=',nset\n    write(atmp,'(f12.6)')k\n    write(ich2,'(2x,a,a)') 'kpush=',adjustl(trim(atmp))\n    write(atmp,'(f12.6)') alpha\n    write(ich2,'(2x,a,a)') 'alp=',adjustl(trim(atmp))\n    write(ich2,'(2x,a,a)') 'coord=',trim(statfile)\n    write(ich2,'(2x,a)') 'static=true'\n    if( (ramp-0.03_wp).ne. 0.0_wp)then\n    write(atmp,'(f12.6)') ramp\n    write(ich2,'(2x,a,a)') 'ramp=',adjustl(trim(atmp))\n    endif\n    if(atlen>1)then\n      write(ich2,'(2x,a,1x,a)')'atoms:',trim(atomlist)\n    endif\n    write(ich2,'(a)') '$end'\n\n    close(ich)\n    close(ich2)\n\n    call rename('tmpcoordfile',trim(infile))\n\n    return\nend subroutine setstaticmtd    \n\n!--------------------------------------------------------------------------------------------\n! Run several static MTDs on the lowermost conformers\n!--------------------------------------------------------------------------------------------\nsubroutine entropyMD_para_OMP(env)\n         use crest_parameters\n         use crest_data\n         use iomod\n         use strucrd, only: wrc0,rdensembleparam,rdensemble\n         implicit none\n         type(systemdata) :: env\n         integer :: lconf,tot\n         integer :: i,j,k\n         integer :: TOTAL,vz,io\n         real(wp) :: time\n         character(len=512) :: thispath,tmppath\n         character(len=512) :: jobcall\n         character(len=80)  :: fname,pipe,inpnam,outnam,sname\n         integer :: iz2\n         integer,allocatable :: at(:)\n         real(wp),allocatable :: xyz(:,:,:),eread(:),scoords(:,:,:)\n         real(wp),allocatable :: kprint(:)\n         integer :: nclustbackup\n         real(wp) :: newtemp\n         real(wp) :: kpush,alpha\n         logical :: ex\n         associate( nat => env%nat)\n      !--- use PCA/K-means clusters as seeds             \n         nclustbackup = env%maxcluster\n\n         !--- first the structures that are used as bias\n         env%nclust = env%emtd%nbias\n         call create_anmr_dummy(nat)\n         call smallhead('determining bias structures')\n         call CCEGEN(env,.false.,conformerfile)\n         call rdensembleparam(clusterfile,iz2,TOTAL)\n         if(TOTAL<1)then\n             call copy('crest_best.xyz',clusterfile)\n             TOTAL=1\n         endif\n         write(*,'(1x,i0,a)')TOTAL,' structures were selected'\n         write(*,'(1x,a,/)') 'done.' \n         env%mtdstaticfile=\"crest_bias.xyz\"\n         env%nstatic=TOTAL\n         call rename(clusterfile,env%mtdstaticfile)\n\n         !--- then get the input structures\n         env%nclust = env%emtd%nMDs\n         call smallhead('determining MTD seed structures')\n         call CCEGEN(env,.false.,conformerfile)\n         call rdensembleparam(clusterfile,iz2,TOTAL)\n         write(*,'(1x,i0,a)')TOTAL,' structures were selected'\n         write(*,'(1x,a,/)')'done.'\n         !--- cleanup\n         call remove('anmr_nucinfo')\n         env%nclust = nclustbackup\n\n         allocate(xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))\n         call rdensemble(clusterfile,iz2,TOTAL,at,xyz,eread)\n         lconf=TOTAL                \n         tot=TOTAL\n         allocate(scoords(3,nat,lconf))\n         scoords=xyz(:,:,1:lconf)/bohr\n         deallocate(eread,xyz)\n\n!---- some settings\n           \n         if(env%autothreads)then\n            call ompautoset(env%threads,7,env%omp,env%MAXRUN,tot) !set the global OMP/MKL variables for the xtb jobs\n         endif\n\n      !--- Temperature        \n         newtemp=env%nmdtemp\n      !--- Runtime   \n         time=env%mdtime * env%emtd%lenfac \n      !--- kpush & alpha   \n         !kpush = env%rednat*env%emtd%kpush\n         kpush = env%emtd%katoms * env%emtd%kpush\n         alpha = env%emtd%alpha\n\n         call getcwd(thispath)\n\n         fname='coord'\n         pipe=' > xtb.out 2>/dev/null'\n\n         write(jobcall,'(a,1x,a,1x,a,'' --md '',a,1x,a,a)') &\n         &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe\n\n!---- Small Header\n       write(*,'(''-----------------------------------------------'')')\n       write(*,'(''Additional static MTDs on lowest '',i0,'' conformer(s)'')')lconf\n       write(*,'(''-----------------------------------------------'')')\n       if(env%staticmtd)then\n           write(*,'(/,\"Using \",i0,\" RMSD bias potentials\")') env%nstatic\n       endif\n\n!---- track kpush for printout\n       j=tot*env%emtd%nklist\n       allocate(kprint(j))\n        \n!---- set up directories\n        call rmrfw('scoord.')\n        k=0\n        do i=1,lconf\n           if(env%emtd%nklist>1)then\n              do j=1,env%emtd%nklist\n                write(sname,'(a,i0)')'scoord.',i\n                call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop\n                kpush = env%emtd%klist(j) * env%emtd%katoms \n                k=k+1\n                call entropyMD(trim(sname),env,k,newtemp,time,kpush,alpha)\n                kprint(k) = kpush\n              enddo\n           else\n              write(sname,'(a,i0)')'scoord.',i\n              call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop\n              k=k+1    \n              call entropyMD(trim(sname),env,k,newtemp,time,kpush,alpha)\n              kprint(k) = kpush\n           endif\n        enddo\n        deallocate(at,scoords)\n\n        tot = k\n\n!$omp parallel &\n!$omp shared( vz,jobcall,tot,time,env,newtemp )\n!$omp single\n      do i=1,tot\n         vz=i\n       !$omp task firstprivate( vz ) private( tmppath,io,ex )\n         call initsignal()\n       !$omp critical\n             write(*,'(a,i4,a)') 'Starting MTD',vz,' with the settings:'\n             write(*,'(''     MD time /ps        :'',f8.1)')time\n             write(*,'(''     MD Temperature /K  :'',f8.1)')newtemp\n             write(*,'(''     dt /fs             :'',f8.1)')env%mdstep\n             write(*,'(''     dumpstep(trj) /fs  :'',i8)')env%mddumpxyz\n             write(*,'(''     Vbias factor k /Eh :'',f8.4)')kprint(vz)\n             write(*,'(''     Vbias exp α /bohr⁻²:'',f8.2)')alpha\n       !$omp end critical\n         write(tmppath,'(a,i0)')'STATICMTD',vz\n         call command('cd '//trim(tmppath)//' && '//trim(jobcall), io)\n         inquire(file=trim(tmppath)//'/'//'xtb.trj',exist=ex)\n         if(.not.ex .or. io.ne.0)then\n         write(*,'(a,i0,a)')'*Warning: static MTD ',vz,' seemingly failed (no xtb.trj)*'\n         call command('cp -r '//trim(tmppath)//' FAILEDMTD')\n         else\n         write(*,'(a,i0,a)')'*static MTD ',vz,' finished*'\n         endif\n         call rmrf(trim(tmppath)//'/'//'scoord.*')\n       !$omp end task\n      enddo\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n     deallocate(kprint)\n\n     if(env%trackorigin)then\n        call set_trj_origins('STATICMTD','smtd')\n     endif\n     call checkname_xyz(crefile,inpnam,outnam)\n     write(*,'('' Appending file '',a,'' with new structures'')')trim(inpnam)\n     call collect_trj_skipfirst('STATICMTD',trim(inpnam))  !collect all 'xtb.trj' from the NORMMD directories, but skip the first point! (input structure)\n     write(*,*)\n\n     if(.not.env%keepModef)then\n        call cleanMTD\n     endif\n \n     end associate\n\nend subroutine entropyMD_para_OMP\n\n!--------------------------------------------------------------------------------------------\n! A single NORMMD run (bzw. its setup)\n!--------------------------------------------------------------------------------------------\nsubroutine entropyMD(fname,env,nr,newtemp,newtime,k,alpha)\n         use crest_parameters\n         use crest_data\n         use iomod\n         use strucrd, only: wrc0\n         implicit none\n\n         type(systemdata) :: env\n         real(wp) :: newtemp\n         real(wp) :: newtime\n         character(len=*)  :: fname\n         character(len=256) :: basename,dirname\n         character(len=512) :: tmppath,thispath\n\n         integer :: r,nr\n\n         real(wp) :: k,alpha\n\n!---- some settings\n         basename='STATICMTD'  !base name of the directories\n\n         call getcwd(thispath)              !current dir= thispath\n         write(dirname,'(a,i0)')trim(basename),nr\n         tmppath=trim(dirname)\n         call rmrf(tmppath)            !clear old directory\n         r = makedir(trim(tmppath))    !make new directory\n\n         call rename(trim(fname),trim(tmppath)//'/'//'coord')\n         call env%wrtCHRG(trim(tmppath))   \n         call copysub(env%fixfile,trim(tmppath))\n         if(env%gfnver=='--gff')then\n!            r = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(tmppath)//'/'//'gfnff_topo')\n         endif\n\n         r = sylnk(trim(thispath)//'/'//env%mtdstaticfile,trim(tmppath)//'/'//env%mtdstaticfile)\n\n         call chdir(trim(tmppath))  !switch to working directory\n!---- do stuff here\n         call setMDrun2('coord',env%hmass,newtime,newtemp,env%mdstep,env%shake, &\n         &    env%mddumpxyz,env%mdskip,env%mddump,-1,env%cts)\n\n!--- static MTD settings     \n         call setstaticmtd('coord',k,alpha,env%emtd%mtdramp,env%nstatic, &\n         &    env%mtdstaticfile,env%emtd%atomlist)\n  \n!--- back to original DIR        \n         call chdir(thispath)\n\n         return\nend subroutine entropyMD\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/normmd.f90 b/src/legacy_algos/normmd.f90
--- a/src/legacy_algos/normmd.f90	
+++ b/src/legacy_algos/normmd.f90	
@@ -21,57 +21,57 @@
 ! A single NORMMD run (bzw. its setup)
 !--------------------------------------------------------------------------------------------
 subroutine normalMD(fname,env,nr,newtemp,newtime)
-         use crest_parameters
-         use crest_data
-         use iomod
-         use strucrd, only: wrc0
-         implicit none
+  use crest_parameters
+  use crest_data
+  use iomod
+  use strucrd,only:wrc0
+  use utilities
+  implicit none
 
-         type(systemdata) :: env
-         real(wp) :: newtemp
-         real(wp) :: newtime
-         character(len=*)  :: fname
-         character(len=256) :: basename,dirname
-         character(len=512) :: tmppath,thispath
+  type(systemdata) :: env
+  real(wp) :: newtemp
+  real(wp) :: newtime
+  character(len=*)  :: fname
+  character(len=256) :: basename,dirname
+  character(len=512) :: tmppath,thispath
 
-         integer :: r,nr
+  integer :: r,nr
 
-         real(wp) :: k,alpha
+  real(wp) :: k,alpha
 
 !---- some settings
-         basename='NORMMD'  !base name of the directories
+  basename = 'NORMMD'  !base name of the directories
 
-         call getcwd(thispath)              !current dir= thispath
-         write(dirname,'(a,i0)')trim(basename),nr
-         tmppath=trim(dirname)
-         call rmrf(tmppath)            !clear old directory
-         r = makedir(trim(tmppath))    !make new directory
+  call getcwd(thispath)              !current dir= thispath
+  write (dirname,'(a,i0)') trim(basename),nr
+  tmppath = trim(dirname)
+  call rmrf(tmppath)            !clear old directory
+  r = makedir(trim(tmppath))    !make new directory
 
-         call rename(trim(fname),trim(tmppath)//'/'//'coord')
-         call env%wrtCHRG(trim(tmppath))   
-         call copysub(env%fixfile,trim(tmppath))
-         if(env%useqmdff)then
-            call copysub('solvent',trim(tmppath))
-         endif
+  call rename(trim(fname),trim(tmppath)//'/'//'coord')
+  call env%wrtCHRG(trim(tmppath))
+  call copysub(env%fixfile,trim(tmppath))
+  if (env%useqmdff) then
+    call copysub('solvent',trim(tmppath))
+  end if
 
-         if(env%staticmtd)then
-             r = sylnk(trim(thispath)//'/'//env%mtdstaticfile,trim(tmppath)//'/'//env%mtdstaticfile)
-         endif
+  if (env%staticmtd) then
+    r = sylnk(trim(thispath)//'/'//env%mtdstaticfile,trim(tmppath)//'/'//env%mtdstaticfile)
+  end if
 
-
-         call chdir(trim(tmppath))  !switch to working directory
+  call chdir(trim(tmppath))  !switch to working directory
 !---- do stuff here
-         call setMDrun2('coord',env%hmass,newtime,newtemp,env%mdstep,env%shake, &
-         &    env%mddumpxyz,env%mdskip,env%mddump,-1,env%cts)
+  call setMDrun2('coord',env%hmass,newtime,newtemp,env%mdstep,env%shake, &
+  &    env%mddumpxyz,env%mdskip,env%mddump,-1,env%cts)
 
-         if(env%staticmtd)then
-             k=env%rednat*0.0025d0
-             alpha = 1.0d0
-             call setstaticmtd('coord',k,alpha,env%emtd%mtdramp, &
-             &    env%nstatic,env%mtdstaticfile,'')
-         endif
-  
-         call chdir(thispath)  !go back to orgiginal directory  
+  if (env%staticmtd) then
+    k = env%rednat*0.0025d0
+    alpha = 1.0d0
+    call setstaticmtd('coord',k,alpha,env%emtd%mtdramp, &
+    &    env%nstatic,env%mtdstaticfile,'')
+  end if
+
+  call chdir(thispath)  !go back to orgiginal directory
 
 end subroutine normalMD
 
@@ -79,188 +79,184 @@
 ! Run several normal MDs on the lowermost conformers
 !--------------------------------------------------------------------------------------------
 subroutine normalMD_para_OMP(env,lconf,ntemps)
-         use crest_parameters
-         use crest_data
-         use iomod
-         use strucrd, only: wrc0,rdensembleparam,rdensemble
-         implicit none
+  use crest_parameters
+  use crest_data
+  use iomod
+  use strucrd,only:wrc0,rdensembleparam,rdensemble
+  use utilities
+  implicit none
 
-         type(systemdata) :: env
+  type(systemdata) :: env
 
-         integer :: lconf,ntemps,tot
+  integer :: lconf,ntemps,tot
 
-         integer :: i,j,k
-         integer :: TOTAL,vz,io
-         real(wp) :: time
-         character(len=512) :: thispath,tmppath
-         character(len=512) :: jobcall
-         character(len=80)  :: fname,pipe,inpnam,outnam,sname
+  integer :: i,j,k
+  integer :: TOTAL,vz,io
+  real(wp) :: time
+  character(len=512) :: thispath,tmppath
+  character(len=512) :: jobcall
+  character(len=80)  :: fname,pipe,inpnam,outnam,sname
 
-         integer :: nat
-         integer :: iz2
-         integer,allocatable :: at(:)
-         real(wp),allocatable :: xyz(:,:,:),eread(:),scoords(:,:,:)
-         real(wp),allocatable :: temperatures(:),temperatures2(:)
+  integer :: nat
+  integer :: iz2
+  integer,allocatable :: at(:)
+  real(wp),allocatable :: xyz(:,:,:),eread(:),scoords(:,:,:)
+  real(wp),allocatable :: temperatures(:),temperatures2(:)
 
-         integer :: nclustbackup
+  integer :: nclustbackup
 
-         real(wp) :: newtemp
+  real(wp) :: newtemp
 
-         nat = env%nat
+  nat = env%nat
 
-         if(.not.env%entropic)then    
-      !--- by default the MDs are started on the (so far) lowest conformers.      
-            call rdensembleparam(conformerfile,iz2,TOTAL)
-            allocate(xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))
-            call rdensemble(conformerfile,iz2,TOTAL,at,xyz,eread)
-            if(env%staticmtd)then
-               env%mtdstaticfile=conformerfile
-               env%nstatic=lconf
-            endif
-         else 
-            if(env%staticmtd)then
-                call rdensembleparam(conformerfile,iz2,TOTAL)
-                lconf = min(nint(float(TOTAL)*0.1d0),lconf)
-            endif 
-      !--- for more diversity use PCA/K-means clusters as seeds             
-            nclustbackup = env%maxcluster
-            env%nclust = lconf
-            call create_anmr_dummy(nat)
-            call CCEGEN(env,.true.,conformerfile)
-            call remove('anmr_nucinfo')
-            env%nclust = nclustbackup
-            call rdensembleparam(clusterfile,iz2,TOTAL)
-            allocate(xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))
-            call rdensemble(clusterfile,iz2,TOTAL,at,xyz,eread)
-            if(env%staticmtd)then
-                env%mtdstaticfile=clusterfile
-                env%nstatic=TOTAL
-            endif
-         endif
-         if(TOTAL.lt.lconf)then
-            lconf=TOTAL                 !if there are less conformers than lconf, use only that much
-         endif
-         allocate(scoords(3,nat,lconf))
-         scoords=xyz(:,:,1:lconf)/bohr
-         deallocate(eread,xyz)
+  if (.not.env%entropic) then
+    !--- by default the MDs are started on the (so far) lowest conformers.
+    call rdensembleparam(conformerfile,iz2,TOTAL)
+    allocate (xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))
+    call rdensemble(conformerfile,iz2,TOTAL,at,xyz,eread)
+    if (env%staticmtd) then
+      env%mtdstaticfile = conformerfile
+      env%nstatic = lconf
+    end if
+  else
+    if (env%staticmtd) then
+      call rdensembleparam(conformerfile,iz2,TOTAL)
+      lconf = min(nint(float(TOTAL)*0.1d0),lconf)
+    end if
+    !--- for more diversity use PCA/K-means clusters as seeds
+    nclustbackup = env%maxcluster
+    env%nclust = lconf
+    call create_anmr_dummy(nat)
+    call CCEGEN(env,.true.,conformerfile)
+    call remove('anmr_nucinfo')
+    env%nclust = nclustbackup
+    call rdensembleparam(clusterfile,iz2,TOTAL)
+    allocate (xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))
+    call rdensemble(clusterfile,iz2,TOTAL,at,xyz,eread)
+    if (env%staticmtd) then
+      env%mtdstaticfile = clusterfile
+      env%nstatic = TOTAL
+    end if
+  end if
+  if (TOTAL .lt. lconf) then
+    lconf = TOTAL                 !if there are less conformers than lconf, use only that much
+  end if
+  allocate (scoords(3,nat,lconf))
+  scoords = xyz(:,:,1:lconf)/bohr
+  deallocate (eread,xyz)
 
-
 !---- some settings
-           
-         tot = lconf * ntemps  !total number of MDs
+
+  tot = lconf*ntemps  !total number of MDs
 
-         if(env%autothreads)then
-            call ompautoset(env%threads,7,env%omp,env%MAXRUN,tot) !set the global OMP/MKL variables for the xtb jobs
-         endif
+  if (env%autothreads) then
+    call ompautoset(env%threads,7,env%omp,env%MAXRUN,tot) !set the global OMP/MKL variables for the xtb jobs
+  end if
 
-         if(env%nmdtemp.lt.0.0d0)then
-           newtemp=400.00d0 
-         else
-           newtemp=env%nmdtemp
-         endif
+  if (env%nmdtemp .lt. 0.0d0) then
+    newtemp = 400.00d0
+  else
+    newtemp = env%nmdtemp
+  end if
 
-
-         
-         allocate(temperatures2(tot),temperatures(ntemps))
-         temperatures(1)=newtemp
-         do i=2,ntemps
-            j=i-1
-            if(env%entropic) then
-               temperatures(i)=temperatures(j) + 200.0_wp
-            else
-               temperatures(i)=temperatures(j) + 100.0_wp   !each MD 100K higher
-            endif
-         enddo
+  allocate (temperatures2(tot),temperatures(ntemps))
+  temperatures(1) = newtemp
+  do i = 2,ntemps
+    j = i-1
+    if (env%entropic) then
+      temperatures(i) = temperatures(j)+200.0_wp
+    else
+      temperatures(i) = temperatures(j)+100.0_wp   !each MD 100K higher
+    end if
+  end do
 
-         if(env%entropic)then
-             time=env%mdtime * 0.25d0 !shorter for entropy mode
-         else
-             time=env%mdtime * 0.5d0 !half the time of each MTD run
-         endif
+  if (env%entropic) then
+    time = env%mdtime*0.25d0 !shorter for entropy mode
+  else
+    time = env%mdtime*0.5d0 !half the time of each MTD run
+  end if
 
-         call getcwd(thispath)
+  call getcwd(thispath)
 
-         fname='coord'
-         pipe=' > xtb.out 2>/dev/null'
+  fname = 'coord'
+  pipe = ' > xtb.out 2>/dev/null'
 
-         write(jobcall,'(a,1x,a,1x,a,'' --md '',a,1x,a,a)') &
-         &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe
-      !--- slightly different jobcall for QMDFF usage
-         if(env%useqmdff)then
-           write(jobcall,'(a,1x,a,1x,a,'' --md --qmdff'',a,1x,a,a)') &
-           &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe
-         endif
+  write (jobcall,'(a,1x,a,1x,a,'' --md '',a,1x,a,a)') &
+  &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe
+  !--- slightly different jobcall for QMDFF usage
+  if (env%useqmdff) then
+    write (jobcall,'(a,1x,a,1x,a,'' --md --qmdff'',a,1x,a,a)') &
+    &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe
+  end if
 
-
 !---- Small Header
-       write(*,'(''-----------------------------------------------'')')
-       if(env%staticmtd)then
-          write(*,'(''Additional static MTDs on lowest '',i0,'' conformer(s)'')')lconf
-       else    
-         if(.not.env%entropic)then
-            write(*,'(''Additional regular MDs on lowest '',i0,'' conformer(s)'')')lconf
-         else
-            write(*,'(''Additional regular MDs on  '',i0,'' conformer(s)'')')lconf
-         endif
-       endif
-       write(*,'(''-----------------------------------------------'')')
-       if(env%staticmtd)then
-           write(*,'(/,"Using ",i0," RMSD bias potentials")') env%nstatic
-       endif
+  write (*,'(''-----------------------------------------------'')')
+  if (env%staticmtd) then
+    write (*,'(''Additional static MTDs on lowest '',i0,'' conformer(s)'')') lconf
+  else
+    if (.not.env%entropic) then
+      write (*,'(''Additional regular MDs on lowest '',i0,'' conformer(s)'')') lconf
+    else
+      write (*,'(''Additional regular MDs on  '',i0,'' conformer(s)'')') lconf
+    end if
+  end if
+  write (*,'(''-----------------------------------------------'')')
+  if (env%staticmtd) then
+    write (*,'(/,"Using ",i0," RMSD bias potentials")') env%nstatic
+  end if
 
 !---- set up directories
-        call rmrfw('scoord.')
-        k=0
-        do i=1,lconf
-           write(sname,'(a,i0)')'scoord.',i
-           do j=1,ntemps
-           call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop
-           k=k+1
-           newtemp=temperatures(j)
-           temperatures2(k)=newtemp
-           call normalMD(trim(sname),env,k,newtemp,time)
-           enddo
-        enddo
-        deallocate(at,scoords)
+  call rmrfw('scoord.')
+  k = 0
+  do i = 1,lconf
+    write (sname,'(a,i0)') 'scoord.',i
+    do j = 1,ntemps
+      call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop
+      k = k+1
+      newtemp = temperatures(j)
+      temperatures2(k) = newtemp
+      call normalMD(trim(sname),env,k,newtemp,time)
+    end do
+  end do
+  deallocate (at,scoords)
 
-      
 !$omp parallel &
 !$omp shared( vz,jobcall,tot,time,env,newtemp,temperatures2 )
 !$omp single
-      do i=1,tot
-         vz=i
-       !$omp task firstprivate( vz ) private( tmppath,io )
-         call initsignal()
-       !$omp critical
-             write(*,'(a,i4,a)') 'Starting MD',vz,' with the settings:'
-             write(*,'(''     MD time /ps        :'',f8.1)')time
-             write(*,'(''     MD Temperature /K  :'',f8.1)')temperatures2(vz)
-             write(*,'(''     dt /fs             :'',f8.1)')env%mdstep
-             write(*,'(''     dumpstep(trj) /fs  :'',i8)')env%mddumpxyz
-       !$omp end critical
-         write(tmppath,'(a,i0)')'NORMMD',vz
-         call command('cd '//trim(tmppath)//' && '//trim(jobcall), io)
-         write(*,'(a,i0,a)')'*MD ',vz,' finished*'
-         call rmrf(trim(tmppath)//'/scoord.*')
-       !$omp end task
-      enddo
+  do i = 1,tot
+    vz = i
+    !$omp task firstprivate( vz ) private( tmppath,io )
+    call initsignal()
+    !$omp critical
+    write (*,'(a,i4,a)') 'Starting MD',vz,' with the settings:'
+    write (*,'(''     MD time /ps        :'',f8.1)') time
+    write (*,'(''     MD Temperature /K  :'',f8.1)') temperatures2(vz)
+    write (*,'(''     dt /fs             :'',f8.1)') env%mdstep
+    write (*,'(''     dumpstep(trj) /fs  :'',i8)') env%mddumpxyz
+    !$omp end critical
+    write (tmppath,'(a,i0)') 'NORMMD',vz
+    call command('cd '//trim(tmppath)//' && '//trim(jobcall),io)
+    write (*,'(a,i0,a)') '*MD ',vz,' finished*'
+    call rmrf(trim(tmppath)//'/scoord.*')
+    !$omp end task
+  end do
 !$omp taskwait
 !$omp end single
 !$omp end parallel
 
-     if(env%trackorigin)then
-        call set_trj_origins('NORMMD','md')
-     endif
-     call checkname_xyz(crefile,inpnam,outnam)
-     write(*,'('' Appending file '',a,'' with new structures'')')trim(inpnam)
-     call collect_trj_skipfirst('NORMMD',trim(inpnam))  !collect all 'xtb.trj' from the NORMMD directories, but skip the first point! (input structure)
-     write(*,*)
+  if (env%trackorigin) then
+    call set_trj_origins('NORMMD','md')
+  end if
+  call checkname_xyz(crefile,inpnam,outnam)
+  write (*,'('' Appending file '',a,'' with new structures'')') trim(inpnam)
+  call collect_trj_skipfirst('NORMMD',trim(inpnam))  !collect all 'xtb.trj' from the NORMMD directories, but skip the first point! (input structure)
+  write (*,*)
 
-     if(.not.env%keepModef)then
-        call cleanMTD
-     endif
- 
-     return
+  if (.not.env%keepModef) then
+    call cleanMTD
+  end if
+
+  return
 end subroutine normalMD_para_OMP
 
 !-------------------------------------------------------------------------------!
@@ -269,231 +265,232 @@
 ! converge to already known regions of the PES
 !-------------------------------------------------------------------------------!
 subroutine setstaticmtd(infile,k,alpha,ramp,nset,statfile,atomlist)
-    use crest_parameters
-    use crest_data
-    implicit none
-    character(len=*) :: infile
-    real(wp) :: k
-    real(wp) :: alpha
-    real(wp) :: ramp
-    integer :: nset
-    character(len=*) :: statfile
-    character(len=*) :: atomlist
-    integer :: atlen
+  use crest_parameters
+  use crest_data
+  implicit none
+  character(len=*) :: infile
+  real(wp) :: k
+  real(wp) :: alpha
+  real(wp) :: ramp
+  integer :: nset
+  character(len=*) :: statfile
+  character(len=*) :: atomlist
+  integer :: atlen
 
-    character(len=256) :: atmp
-    integer :: ich,ich2,iost
+  character(len=256) :: atmp
+  integer :: ich,ich2,iost
 
-    open(newunit=ich,file=infile)
-    open(newunit=ich2,file='tmpcoordfile')
-    do
-        read(ich,'(a)',iostat=iost)atmp
-        if(iost < 0)exit
-        if(index(atmp,'$end').ne.0)then
-            cycle
-        else
-            write(ich2,'(a)')trim(atmp)
-        endif
-    enddo
+  open (newunit=ich,file=infile)
+  open (newunit=ich2,file='tmpcoordfile')
+  do
+    read (ich,'(a)',iostat=iost) atmp
+    if (iost < 0) exit
+    if (index(atmp,'$end') .ne. 0) then
+      cycle
+    else
+      write (ich2,'(a)') trim(atmp)
+    end if
+  end do
 
-    atlen = len_trim(atomlist)
- 
-    write(ich2,'(a)')'$metadyn'
-    write(ich2,'(2x,a,i0)') 'save=',nset
-    write(atmp,'(f12.6)')k
-    write(ich2,'(2x,a,a)') 'kpush=',adjustl(trim(atmp))
-    write(atmp,'(f12.6)') alpha
-    write(ich2,'(2x,a,a)') 'alp=',adjustl(trim(atmp))
-    write(ich2,'(2x,a,a)') 'coord=',trim(statfile)
-    write(ich2,'(2x,a)') 'static=true'
-    if( (ramp-0.03_wp).ne. 0.0_wp)then
-    write(atmp,'(f12.6)') ramp
-    write(ich2,'(2x,a,a)') 'ramp=',adjustl(trim(atmp))
-    endif
-    if(atlen>1)then
-      write(ich2,'(2x,a,1x,a)')'atoms:',trim(atomlist)
-    endif
-    write(ich2,'(a)') '$end'
+  atlen = len_trim(atomlist)
+
+  write (ich2,'(a)') '$metadyn'
+  write (ich2,'(2x,a,i0)') 'save=',nset
+  write (atmp,'(f12.6)') k
+  write (ich2,'(2x,a,a)') 'kpush=',adjustl(trim(atmp))
+  write (atmp,'(f12.6)') alpha
+  write (ich2,'(2x,a,a)') 'alp=',adjustl(trim(atmp))
+  write (ich2,'(2x,a,a)') 'coord=',trim(statfile)
+  write (ich2,'(2x,a)') 'static=true'
+  if ((ramp-0.03_wp) .ne. 0.0_wp) then
+    write (atmp,'(f12.6)') ramp
+    write (ich2,'(2x,a,a)') 'ramp=',adjustl(trim(atmp))
+  end if
+  if (atlen > 1) then
+    write (ich2,'(2x,a,1x,a)') 'atoms:',trim(atomlist)
+  end if
+  write (ich2,'(a)') '$end'
 
-    close(ich)
-    close(ich2)
+  close (ich)
+  close (ich2)
 
-    call rename('tmpcoordfile',trim(infile))
+  call rename('tmpcoordfile',trim(infile))
 
-    return
-end subroutine setstaticmtd    
+  return
+end subroutine setstaticmtd
 
 !--------------------------------------------------------------------------------------------
 ! Run several static MTDs on the lowermost conformers
 !--------------------------------------------------------------------------------------------
 subroutine entropyMD_para_OMP(env)
-         use crest_parameters
-         use crest_data
-         use iomod
-         use strucrd, only: wrc0,rdensembleparam,rdensemble
-         implicit none
-         type(systemdata) :: env
-         integer :: lconf,tot
-         integer :: i,j,k
-         integer :: TOTAL,vz,io
-         real(wp) :: time
-         character(len=512) :: thispath,tmppath
-         character(len=512) :: jobcall
-         character(len=80)  :: fname,pipe,inpnam,outnam,sname
-         integer :: iz2
-         integer,allocatable :: at(:)
-         real(wp),allocatable :: xyz(:,:,:),eread(:),scoords(:,:,:)
-         real(wp),allocatable :: kprint(:)
-         integer :: nclustbackup
-         real(wp) :: newtemp
-         real(wp) :: kpush,alpha
-         logical :: ex
-         associate( nat => env%nat)
-      !--- use PCA/K-means clusters as seeds             
-         nclustbackup = env%maxcluster
+  use crest_parameters
+  use crest_data
+  use iomod
+  use strucrd,only:wrc0,rdensembleparam,rdensemble
+  use utilities
+  implicit none
+  type(systemdata) :: env
+  integer :: lconf,tot
+  integer :: i,j,k
+  integer :: TOTAL,vz,io
+  real(wp) :: time
+  character(len=512) :: thispath,tmppath
+  character(len=512) :: jobcall
+  character(len=80)  :: fname,pipe,inpnam,outnam,sname
+  integer :: iz2
+  integer,allocatable :: at(:)
+  real(wp),allocatable :: xyz(:,:,:),eread(:),scoords(:,:,:)
+  real(wp),allocatable :: kprint(:)
+  integer :: nclustbackup
+  real(wp) :: newtemp
+  real(wp) :: kpush,alpha
+  logical :: ex
+  associate (nat => env%nat)
+    !--- use PCA/K-means clusters as seeds
+    nclustbackup = env%maxcluster
 
-         !--- first the structures that are used as bias
-         env%nclust = env%emtd%nbias
-         call create_anmr_dummy(nat)
-         call smallhead('determining bias structures')
-         call CCEGEN(env,.false.,conformerfile)
-         call rdensembleparam(clusterfile,iz2,TOTAL)
-         if(TOTAL<1)then
-             call copy('crest_best.xyz',clusterfile)
-             TOTAL=1
-         endif
-         write(*,'(1x,i0,a)')TOTAL,' structures were selected'
-         write(*,'(1x,a,/)') 'done.' 
-         env%mtdstaticfile="crest_bias.xyz"
-         env%nstatic=TOTAL
-         call rename(clusterfile,env%mtdstaticfile)
+    !--- first the structures that are used as bias
+    env%nclust = env%emtd%nbias
+    call create_anmr_dummy(nat)
+    call smallhead('determining bias structures')
+    call CCEGEN(env,.false.,conformerfile)
+    call rdensembleparam(clusterfile,iz2,TOTAL)
+    if (TOTAL < 1) then
+      call copy('crest_best.xyz',clusterfile)
+      TOTAL = 1
+    end if
+    write (*,'(1x,i0,a)') TOTAL,' structures were selected'
+    write (*,'(1x,a,/)') 'done.'
+    env%mtdstaticfile = "crest_bias.xyz"
+    env%nstatic = TOTAL
+    call rename(clusterfile,env%mtdstaticfile)
 
-         !--- then get the input structures
-         env%nclust = env%emtd%nMDs
-         call smallhead('determining MTD seed structures')
-         call CCEGEN(env,.false.,conformerfile)
-         call rdensembleparam(clusterfile,iz2,TOTAL)
-         write(*,'(1x,i0,a)')TOTAL,' structures were selected'
-         write(*,'(1x,a,/)')'done.'
-         !--- cleanup
-         call remove('anmr_nucinfo')
-         env%nclust = nclustbackup
+    !--- then get the input structures
+    env%nclust = env%emtd%nMDs
+    call smallhead('determining MTD seed structures')
+    call CCEGEN(env,.false.,conformerfile)
+    call rdensembleparam(clusterfile,iz2,TOTAL)
+    write (*,'(1x,i0,a)') TOTAL,' structures were selected'
+    write (*,'(1x,a,/)') 'done.'
+    !--- cleanup
+    call remove('anmr_nucinfo')
+    env%nclust = nclustbackup
 
-         allocate(xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))
-         call rdensemble(clusterfile,iz2,TOTAL,at,xyz,eread)
-         lconf=TOTAL                
-         tot=TOTAL
-         allocate(scoords(3,nat,lconf))
-         scoords=xyz(:,:,1:lconf)/bohr
-         deallocate(eread,xyz)
+    allocate (xyz(3,env%nat,TOTAL),at(nat),eread(TOTAL))
+    call rdensemble(clusterfile,iz2,TOTAL,at,xyz,eread)
+    lconf = TOTAL
+    tot = TOTAL
+    allocate (scoords(3,nat,lconf))
+    scoords = xyz(:,:,1:lconf)/bohr
+    deallocate (eread,xyz)
 
 !---- some settings
-           
-         if(env%autothreads)then
-            call ompautoset(env%threads,7,env%omp,env%MAXRUN,tot) !set the global OMP/MKL variables for the xtb jobs
-         endif
+
+    if (env%autothreads) then
+      call ompautoset(env%threads,7,env%omp,env%MAXRUN,tot) !set the global OMP/MKL variables for the xtb jobs
+    end if
 
-      !--- Temperature        
-         newtemp=env%nmdtemp
-      !--- Runtime   
-         time=env%mdtime * env%emtd%lenfac 
-      !--- kpush & alpha   
-         !kpush = env%rednat*env%emtd%kpush
-         kpush = env%emtd%katoms * env%emtd%kpush
-         alpha = env%emtd%alpha
+    !--- Temperature
+    newtemp = env%nmdtemp
+    !--- Runtime
+    time = env%mdtime*env%emtd%lenfac
+    !--- kpush & alpha
+    !kpush = env%rednat*env%emtd%kpush
+    kpush = env%emtd%katoms*env%emtd%kpush
+    alpha = env%emtd%alpha
 
-         call getcwd(thispath)
+    call getcwd(thispath)
 
-         fname='coord'
-         pipe=' > xtb.out 2>/dev/null'
+    fname = 'coord'
+    pipe = ' > xtb.out 2>/dev/null'
 
-         write(jobcall,'(a,1x,a,1x,a,'' --md '',a,1x,a,a)') &
-         &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe
+    write (jobcall,'(a,1x,a,1x,a,'' --md '',a,1x,a,a)') &
+    &     trim(env%ProgName),trim(fname),trim(env%gfnver),trim(env%solv),pipe
 
 !---- Small Header
-       write(*,'(''-----------------------------------------------'')')
-       write(*,'(''Additional static MTDs on lowest '',i0,'' conformer(s)'')')lconf
-       write(*,'(''-----------------------------------------------'')')
-       if(env%staticmtd)then
-           write(*,'(/,"Using ",i0," RMSD bias potentials")') env%nstatic
-       endif
+    write (*,'(''-----------------------------------------------'')')
+    write (*,'(''Additional static MTDs on lowest '',i0,'' conformer(s)'')') lconf
+    write (*,'(''-----------------------------------------------'')')
+    if (env%staticmtd) then
+      write (*,'(/,"Using ",i0," RMSD bias potentials")') env%nstatic
+    end if
 
 !---- track kpush for printout
-       j=tot*env%emtd%nklist
-       allocate(kprint(j))
-        
+    j = tot*env%emtd%nklist
+    allocate (kprint(j))
+
 !---- set up directories
-        call rmrfw('scoord.')
-        k=0
-        do i=1,lconf
-           if(env%emtd%nklist>1)then
-              do j=1,env%emtd%nklist
-                write(sname,'(a,i0)')'scoord.',i
-                call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop
-                kpush = env%emtd%klist(j) * env%emtd%katoms 
-                k=k+1
-                call entropyMD(trim(sname),env,k,newtemp,time,kpush,alpha)
-                kprint(k) = kpush
-              enddo
-           else
-              write(sname,'(a,i0)')'scoord.',i
-              call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop
-              k=k+1    
-              call entropyMD(trim(sname),env,k,newtemp,time,kpush,alpha)
-              kprint(k) = kpush
-           endif
-        enddo
-        deallocate(at,scoords)
+    call rmrfw('scoord.')
+    k = 0
+    do i = 1,lconf
+      if (env%emtd%nklist > 1) then
+        do j = 1,env%emtd%nklist
+          write (sname,'(a,i0)') 'scoord.',i
+          call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop
+          kpush = env%emtd%klist(j)*env%emtd%katoms
+          k = k+1
+          call entropyMD(trim(sname),env,k,newtemp,time,kpush,alpha)
+          kprint(k) = kpush
+        end do
+      else
+        write (sname,'(a,i0)') 'scoord.',i
+        call wrc0(trim(sname),nat,at,scoords(:,:,i)) !has to be in the inner loop
+        k = k+1
+        call entropyMD(trim(sname),env,k,newtemp,time,kpush,alpha)
+        kprint(k) = kpush
+      end if
+    end do
+    deallocate (at,scoords)
 
-        tot = k
+    tot = k
 
 !$omp parallel &
 !$omp shared( vz,jobcall,tot,time,env,newtemp )
 !$omp single
-      do i=1,tot
-         vz=i
-       !$omp task firstprivate( vz ) private( tmppath,io,ex )
-         call initsignal()
-       !$omp critical
-             write(*,'(a,i4,a)') 'Starting MTD',vz,' with the settings:'
-             write(*,'(''     MD time /ps        :'',f8.1)')time
-             write(*,'(''     MD Temperature /K  :'',f8.1)')newtemp
-             write(*,'(''     dt /fs             :'',f8.1)')env%mdstep
-             write(*,'(''     dumpstep(trj) /fs  :'',i8)')env%mddumpxyz
-             write(*,'(''     Vbias factor k /Eh :'',f8.4)')kprint(vz)
-             write(*,'(''     Vbias exp α /bohr⁻²:'',f8.2)')alpha
-       !$omp end critical
-         write(tmppath,'(a,i0)')'STATICMTD',vz
-         call command('cd '//trim(tmppath)//' && '//trim(jobcall), io)
-         inquire(file=trim(tmppath)//'/'//'xtb.trj',exist=ex)
-         if(.not.ex .or. io.ne.0)then
-         write(*,'(a,i0,a)')'*Warning: static MTD ',vz,' seemingly failed (no xtb.trj)*'
-         call command('cp -r '//trim(tmppath)//' FAILEDMTD')
-         else
-         write(*,'(a,i0,a)')'*static MTD ',vz,' finished*'
-         endif
-         call rmrf(trim(tmppath)//'/'//'scoord.*')
-       !$omp end task
-      enddo
+    do i = 1,tot
+      vz = i
+      !$omp task firstprivate( vz ) private( tmppath,io,ex )
+      call initsignal()
+      !$omp critical
+      write (*,'(a,i4,a)') 'Starting MTD',vz,' with the settings:'
+      write (*,'(''     MD time /ps        :'',f8.1)') time
+      write (*,'(''     MD Temperature /K  :'',f8.1)') newtemp
+      write (*,'(''     dt /fs             :'',f8.1)') env%mdstep
+      write (*,'(''     dumpstep(trj) /fs  :'',i8)') env%mddumpxyz
+      write (*,'(''     Vbias factor k /Eh :'',f8.4)') kprint(vz)
+      write (*,'(''     Vbias exp α /bohr⁻²:'',f8.2)') alpha
+      !$omp end critical
+      write (tmppath,'(a,i0)') 'STATICMTD',vz
+      call command('cd '//trim(tmppath)//' && '//trim(jobcall),io)
+      inquire (file=trim(tmppath)//'/'//'xtb.trj',exist=ex)
+      if (.not.ex.or.io .ne. 0) then
+        write (*,'(a,i0,a)') '*Warning: static MTD ',vz,' seemingly failed (no xtb.trj)*'
+        call command('cp -r '//trim(tmppath)//' FAILEDMTD')
+      else
+        write (*,'(a,i0,a)') '*static MTD ',vz,' finished*'
+      end if
+      call rmrf(trim(tmppath)//'/'//'scoord.*')
+      !$omp end task
+    end do
 !$omp taskwait
 !$omp end single
 !$omp end parallel
 
-     deallocate(kprint)
+    deallocate (kprint)
 
-     if(env%trackorigin)then
-        call set_trj_origins('STATICMTD','smtd')
-     endif
-     call checkname_xyz(crefile,inpnam,outnam)
-     write(*,'('' Appending file '',a,'' with new structures'')')trim(inpnam)
-     call collect_trj_skipfirst('STATICMTD',trim(inpnam))  !collect all 'xtb.trj' from the NORMMD directories, but skip the first point! (input structure)
-     write(*,*)
+    if (env%trackorigin) then
+      call set_trj_origins('STATICMTD','smtd')
+    end if
+    call checkname_xyz(crefile,inpnam,outnam)
+    write (*,'('' Appending file '',a,'' with new structures'')') trim(inpnam)
+    call collect_trj_skipfirst('STATICMTD',trim(inpnam))  !collect all 'xtb.trj' from the NORMMD directories, but skip the first point! (input structure)
+    write (*,*)
 
-     if(.not.env%keepModef)then
-        call cleanMTD
-     endif
- 
-     end associate
+    if (.not.env%keepModef) then
+      call cleanMTD
+    end if
+
+  end associate
 
 end subroutine entropyMD_para_OMP
 
@@ -501,52 +498,53 @@
 ! A single NORMMD run (bzw. its setup)
 !--------------------------------------------------------------------------------------------
 subroutine entropyMD(fname,env,nr,newtemp,newtime,k,alpha)
-         use crest_parameters
-         use crest_data
-         use iomod
-         use strucrd, only: wrc0
-         implicit none
+  use crest_parameters
+  use crest_data
+  use iomod
+  use strucrd,only:wrc0
+  use utilities
+  implicit none
 
-         type(systemdata) :: env
-         real(wp) :: newtemp
-         real(wp) :: newtime
-         character(len=*)  :: fname
-         character(len=256) :: basename,dirname
-         character(len=512) :: tmppath,thispath
+  type(systemdata) :: env
+  real(wp) :: newtemp
+  real(wp) :: newtime
+  character(len=*)  :: fname
+  character(len=256) :: basename,dirname
+  character(len=512) :: tmppath,thispath
 
-         integer :: r,nr
+  integer :: r,nr
 
-         real(wp) :: k,alpha
+  real(wp) :: k,alpha
 
 !---- some settings
-         basename='STATICMTD'  !base name of the directories
+  basename = 'STATICMTD'  !base name of the directories
 
-         call getcwd(thispath)              !current dir= thispath
-         write(dirname,'(a,i0)')trim(basename),nr
-         tmppath=trim(dirname)
-         call rmrf(tmppath)            !clear old directory
-         r = makedir(trim(tmppath))    !make new directory
+  call getcwd(thispath)              !current dir= thispath
+  write (dirname,'(a,i0)') trim(basename),nr
+  tmppath = trim(dirname)
+  call rmrf(tmppath)            !clear old directory
+  r = makedir(trim(tmppath))    !make new directory
 
-         call rename(trim(fname),trim(tmppath)//'/'//'coord')
-         call env%wrtCHRG(trim(tmppath))   
-         call copysub(env%fixfile,trim(tmppath))
-         if(env%gfnver=='--gff')then
+  call rename(trim(fname),trim(tmppath)//'/'//'coord')
+  call env%wrtCHRG(trim(tmppath))
+  call copysub(env%fixfile,trim(tmppath))
+  if (env%gfnver == '--gff') then
 !            r = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(tmppath)//'/'//'gfnff_topo')
-         endif
+  end if
 
-         r = sylnk(trim(thispath)//'/'//env%mtdstaticfile,trim(tmppath)//'/'//env%mtdstaticfile)
+  r = sylnk(trim(thispath)//'/'//env%mtdstaticfile,trim(tmppath)//'/'//env%mtdstaticfile)
 
-         call chdir(trim(tmppath))  !switch to working directory
+  call chdir(trim(tmppath))  !switch to working directory
 !---- do stuff here
-         call setMDrun2('coord',env%hmass,newtime,newtemp,env%mdstep,env%shake, &
-         &    env%mddumpxyz,env%mdskip,env%mddump,-1,env%cts)
+  call setMDrun2('coord',env%hmass,newtime,newtemp,env%mdstep,env%shake, &
+  &    env%mddumpxyz,env%mdskip,env%mddump,-1,env%cts)
 
-!--- static MTD settings     
-         call setstaticmtd('coord',k,alpha,env%emtd%mtdramp,env%nstatic, &
-         &    env%mtdstaticfile,env%emtd%atomlist)
-  
-!--- back to original DIR        
-         call chdir(thispath)
+!--- static MTD settings
+  call setstaticmtd('coord',k,alpha,env%emtd%mtdramp,env%nstatic, &
+  &    env%mtdstaticfile,env%emtd%atomlist)
+
+!--- back to original DIR
+  call chdir(thispath)
 
-         return
+  return
 end subroutine entropyMD
Index: src/legacy_algos/reactor.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2020 Stefan Grimme\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n!===================================================================!\n! This file contains routines related to the xtb nano-reactor, \n! first published in S. Grimme, JCTC, 2019, 15, 2847-2862.\n!===================================================================!\n\n!======================================================!\n! main routine for the nanoreactor\n!======================================================!\nsubroutine reactor(env, tim)\n  use crest_parameters, only: wp, bohr\n  use crest_data\n  use iomod\n  use zdata\n  use strucrd, only: rdensembleparam,rdensemble\n  implicit none\n\n  interface\n    subroutine analyse_fragments(molvec, molvecSize, totalFragCount, atomsPerFragCount)\n      implicit none\n      integer, intent(in):: molvecSize\n      integer, dimension(molvecSize), intent(in):: molvec\n      integer, intent(out):: totalFragCount\n      integer, dimension(:), allocatable, intent(out):: atomsPerFragCount\n    end subroutine analyse_fragments\n  end interface\n\n  !-- Forward declarations\n  logical:: are_zequals_different\n\n  type(systemdata):: env    ! MAIN STORAGE OS SYSTEM DATA\n  type(timer):: tim\n\n  !--- declarations by Tim\n\n  ! DECLARATIONS\n  ! for purpose of variables look at the lines where they are used\n  character(len=100):: trjFile = \"xtb.trj\"\n  integer:: nat              ! <-- nat\n  integer:: snapCount              ! <-- nstr\n\n  ! ensemble variables\n  real(wp), dimension(:,:,:), allocatable:: file_xyz\n  real(wp), dimension(:), allocatable    :: energy\n  integer, dimension(:), allocatable    :: iat   ! <-- Ordnungszahlen der Atome\n  integer:: allocStat\n\n  ! mrec variables\n  integer:: molcount, i\n  integer, dimension(:), allocatable  :: molvec  ! <-- assing atom number to fragment\n\n  ! zgrp and zequal variables\n  integer:: j, k, l\n  integer, dimension(:,:), allocatable:: molvecs  ! dimesion(nat, nall)\n  type(zequal), dimension(:), allocatable:: zequals\n  integer:: fragCount\n  integer, dimension(:), allocatable:: atomsPerFragCount\n  type(zgrp), dimension(:), allocatable:: zgrps\n\n  ! variables for comparison of all zequals\n  logical, dimension(:), allocatable:: taken\n  type(zequal):: zequal_ref\n\n\n  real(wp),allocatable :: bonds(:,:)\n  integer,allocatable :: nghref(:),ngh(:)\n  integer :: nghdim\n\n  integer :: ndirs\n\n  !--- start timer\n  call tim%start(1, 'nano reactor')\n  call prreactorhd()\n\n\n\n  !--- 1. set up reactor metadynamics\n  !    wall-potential, mass density, simulation length\n\n\n  !--- 2. run the metadynamics\n\n\n  !--- 3. read the trajectory and analyze it \n  !    get fragments, fragment charges, etc.\n  write(*,*)\"Trajectory file: \", trim(trjFile)\n\n  ! get counts of atoms and structures\n  call rdensembleparam(trjFile, nat, snapCount)\n  write(*,*)\n  write(*,*)\"Number of atoms      = \", nat\n  write(*,*)\"Number of snapshots  = \", snapCount\n\n  ! prepare array for next step\n  allocate(file_xyz(3, nat, snapCount), stat = allocStat)\n  allocate(energy(snapCount), stat = allocStat)\n  allocate(iat(nat), stat = allocStat)\n\n  ! fill those arrays with their respective values\n  call rdensemble(trjFile, nat, snapCount, iat, file_xyz, energy)\n  !print *, \"\"\n  !print *, \"File xyz      = \", file_xyz(:, 1, 1:3)\n  !print *, \"Atomic number = \", iat\n  !print *, \"Energy        = \", energy(1:3)\n\n  ! prepare further arrays\n  ! molvecs will hold all molvec for all snapshots\n  allocate(molvecs(nat, snapCount), stat = allocStat)\n  allocate(molvec(nat), stat = allocStat)\n  allocate(zequals(snapCount), stat = allocStat)\n\n  ! get molvec\n  file_xyz = file_xyz/bohr\n  do i = 1, snapCount\n    call mrec(molcount, file_xyz(1:3, 1:nat, i), nat, iat, molvec)\n    molvecs(:, i) = molvec(:)\n\n    ! counts total number of fragments in a snapshot and how many atoms each fragment has (latter outputed as vector)\n    call analyse_fragments(molvec, nat, fragCount, atomsPerFragCount) \n\n    ! zgrps is array; holds all zgrps for one snapshot\n    ! write atomnumbers in their respective zgrp\n    allocate(zgrps(fragCount))\n    do j = 1, fragCount\n      call zgrps(j)%allocate(atomsPerFragCount(j))\n      l = 1\n      do k = 1, nat\n        if (molvec(k) == j) then\n          zgrps(j)%mem(l) = k\n          l = l+1\n        end if\n      end do\n    end do\n\n    ! sort zgrps, so that the zgrps are sorted by their first atoms position number in ascending order\n    call sort_zgrps(zgrps, fragCount)\n\n    ! zqeuals is array with so many zqeual objects as there are snapshots\n    ! filling all parameters of the zequal object\n    call zequals(i)%allocate(nat)\n    zequals(i)%ng = fragCount\n    zequals(i)%grp(:fragCount) = zgrps\n    zequals(i)%ord = molvec\n    call zequals(i)%geteng\n\n    ! some printing to check, that all variables are doing fine\n    !print *, \"\"\n    !print *, \"i = \", i\n    !print *, \"Molcount            = \", molcount\n    !! print *, \"Molvec              = \", molvec\n    !print *, \"Molvecs(i)          = \", molvecs(:, i)\n    !print *, \"Number of fragments = \", fragCount\n    !print *, \"Atoms per fragment  = \", atomsPerFragCount\n\n    !print *, \"\"\n    !print *, \"<ZQEUAL VARS>\"\n    !print *, \"Number of groups        = \", zequals(i)%ng\n    !print *, \"Grp more than 1 nuclei  = \", zequals(i)%eng\n    !print *, \"Group order = \", zequals(i)%ord\n    !print *, \"Groups\"\n    !do j = 1, fragCount\n    !  print *, \"j      = \", j\n    !  print *, \"Groups = \", zgrps(j)%mem\n    !  print *, \"\"\n    !end do\n\n    deallocate(atomsPerFragCount)\n    deallocate(zgrps)\n  end do\n\n\n  ! <Comparing all Zeuqal objects>\n  allocate(taken(snapCount), source=.FALSE.)\n  taken(1) = .TRUE.\n  call update_zequal_ref(zequals(1), zequal_ref)\n  nghdim=nat*(nat+1)/2\n  allocate(bonds(nat,nat))\n  allocate(ngh(nghdim),nghref(nghdim))\n  call reactorneighbours(nat,iat,file_xyz(1:3,1:nat,1),bonds,nghdim,nghref)\n\n  do j = 2, snapCount\n    taken(j) = are_zequals_different(zequal_ref, zequals(j))\n    if (taken(j)) then\n      call update_zequal_ref(zequals(j), zequal_ref)\n    else\n      call reactorneighbours(nat,iat,file_xyz(1:3,1:nat,j),bonds,nghdim,ngh)\n      call arrcomp(nghdim,nghref,nghdim,ngh,taken(j))\n      taken(j) = .not.taken(j)\n      if(taken(j)) nghref = ngh\n    end if\n  End do\n\n  print *, \"\"\n  print *, \"<Comparing structures>\"\n  print *, \"Taken = \", taken\n\n  write(*,'(1x,i0,a,i0,a)')count(taken(:)),' of ',snapCount,' taken.'\n\n  ! </Comparing all Zeuqal objects>\n  !--- 4. optimize the fragments\n  if(env%restartopt)then\n    call reactorreopt(env,nat,iat,snapCount,file_xyz,taken,zequals,ndirs)\n    call collectproducts('OPTIM','TMPFRG',ndirs,'crest_products.xyz',env%riso)\n  endif\n\n  deallocate(nghref,ngh,bonds)\n  deallocate(taken)\n  deallocate(zequals)\n  deallocate(molvec)\n  deallocate(iat)\n  deallocate(energy)\n  deallocate(file_xyz)\n\n  !--- stop timer\n  call tim%stop(1)   \n\n  return\nend subroutine reactor\n\n!======================================================!\n! subroutine reactor_setup\n!   read in coordinates from \"coord\" file and calculate\n!   a standard ellipsoide potential.\n!   The ellipsoide axes then have to be scaled to \n!   fit the required reactor density\n!======================================================!\nsubroutine reactor_setup(env)\n  use crest_parameters, only: wp\n  use crest_data\n  use iomod\n  use filemod\n  use atmasses\n  use strucrd, only: rdnat,rdcoord,wrc0\n  use axis_module \n  implicit none\n  type(systemdata):: env    ! MAIN STORAGE OS SYSTEM DATA\n  integer:: nat                   !# of atoms\n  integer, allocatable  :: at(:)    !atom types\n  real(wp), allocatable:: xyz(:,:)  ! coordinates\n  real(wp):: rabc(3)  ! axes of the ellipsoide potential\n  real(wp) :: mass\n  real(wp) :: dens       !density\n  real(wp) :: dum\n  integer :: j\n  character(len = 256):: atmp,btmp\n  type(filetype):: f\n\n  call remove(\"rcontrol\")\n  call f%open(\"rcontrol\")\n\n  !---------------------------\n  if(env%preactormtd)then\n    write(*,'(/,1x,a)') 'Metadynamics settings:'\n    call f%write(\"$md\")\n    write(btmp,'(f12.2)')env%mdtime\n    write(*,'(1x,a,a,a)')'Simulation time: ',trim(adjustl(btmp)),' ps'\n    write(atmp, '(\"time=\",a)') trim(adjustl(btmp))\n    call f%write(trim(atmp))\n    write(btmp,'(f12.1)')1.0d0\n    write(atmp, '(\"step=\",a)')trim(adjustl(btmp))\n    call f%write(trim(atmp))\n    write(atmp, '(\"shake=\",i0)')0\n    call f%write(trim(atmp))\n\n    call f%write('$set')\n    write(atmp,'(2x,a,2x,i0)')'mddump',2000\n    call f%write(trim(atmp))\n\n    call f%write('$metadyn')\n    write(atmp, '(\"save=\",i0)') env%metadlist(1)\n    call f%write(trim(atmp))\n    write(btmp,'(f12.6)')env%metadfac(1)*env%nat\n    write(*,'(1x,a,a,a)') 'Vbias (k): ',trim(adjustl(btmp)),' Eh'\n    write(atmp, '(\"kpush=\",a)') adjustl(trim(btmp))\n    call f%write(trim(atmp))\n    write(btmp,'(f12.6)')env%metadexp(1)\n    write(*,'(1x,a,a,a)') 'Vbias (α): ',trim(adjustl(btmp)),' Bohr⁻²'\n    write(atmp, '(\"alp=\",a)')adjustl(trim(btmp))\n    call f%write(trim(atmp))\n\n  endif\n\n  !-------------------------\n  if(env%preactorpot)then\n    write(*,'(/,1x,a)') \"Generating spherical logfermi potential:\"\n    !-- read coord\n    call rdnat('coord',nat)\n    allocate(at(nat), xyz(3, nat))\n    call rdcoord('coord',nat, at, xyz)\n\n    !--- CMA trafo\n    call axistrf(nat,nat,at,xyz)\n\n    !--- get the \"box\"\n    do j=1,3\n       rabc(j)=maxval(xyz(j,1:nat))-minval(xyz(j,1:nat))\n    enddo\n    dum=maxval(rabc)\n    rabc(1:3)=dum\n\n    !-- scale wall potential for given input density\n    mass = molweight(nat, at)\n    call reactor_pot(rabc, mass, env%rdens, dens)\n\n    write(*,'(1x,a,f9.3,a)') 'Spherical cavity radius : ',rabc(1),' Bohr' \n    write(*,'(1x,a,f9.1,a)') 'Logfermi temperature    : ',env%tempfermi,' K'\n\n    !-- write CMA coords\n    call wrc0('coord',nat, at, xyz)\n\n    !-- write xtb input file\n    call f%write(\"$wall\")\n    call f%write(\"  potential=logfermi\")\n    write(atmp, '(\"  sphere:\",1x,g0,\",\",1x,\"all\")') rabc(1)\n    call f%write(trim(atmp))\n    write(atmp, '(f16.1)')env%tempfermi\n    atmp = '  temp='//trim(adjustl(atmp))\n    call f%write(trim(atmp))\n    deallocate(at, xyz)\n  endif\n\n  if(f%nlines .gt.1)then\n    call f%write('$end')\n    write(*,'(/,1x,a)') 'Base settings written to file <rcontrol>'\n  endif    \n  call f%clearblanks\n  call f%flushclose\n  \n  return\nend subroutine reactor_setup\n\n!======================================================!\n! subroutine reactor_pot\n!   scale a standard-ellipsoide potential to the\n!   the required density\n!======================================================!\nsubroutine reactor_pot(ax, wei, densref, dens)\n  use crest_parameters, only: wp, bohr\n  implicit none\n  real(wp), intent(inout):: ax(3)\n  real(wp), intent(in)    :: wei\n  real(wp), intent(in)    :: densref\n  real(wp), intent(out)   :: dens\n\n  real(wp):: scal\n  real(wp) :: mass\n\n  real(wp),parameter :: pi43  = 3.1415926540_wp*(4.0_wp/3.0_wp)\n  real(wp),parameter :: pi    = 3.1415926540_wp\n  real(wp),parameter :: third = 1.0_wp/3.0_wp\n\n  dens = 0.0_wp\n\n  !-- Volume of ellipsoide: 4/3 * π * a*b*c\n  !vol = pi43*ax(1) * ax(2) * ax(3)\n\n  !-- weight\n  mass = wei *1.66053886E-27\n\n  !-- unscaled density\n  dens = mass/(ax(1)*ax(2)*ax(3))\n\n  !-- transform into g/cm³   \n  dens = dens * ( 0.001d0 / (1.0d-30*bohr**3.0d0))\n  !dens=0.001*mass/(1.0d-30*ax(1)*ax(2)*ax(3)*bohr**3)\n\n   write(*, '(1x, a, f8.2,a)')'Reactor density (unscaled):',dens,' g/cm³'\n\n!   return\n\n  if(densref .lt. 0.0d0)then\n    !-- return unscaled potential\n    ax = ax*1.0d0      \n    return\n  endif\n\n  !-- get scaling factor of the axes = (ρ/ρ_ref)^(1/3)\n  scal = (dens/densref) ** third\n\n  !-- apply scaling\n  ax = ax*scal\n  !vol = pi43*ax(1) * ax(2) * ax(3)\n  dens=0.001*mass/(1.0d-30*ax(1)*ax(2)*ax(3)*bohr**3)\n    \n  write(*, '(1x, a, f8.2,a)')'Reactor density (from input):',dens,' g/cm³'\n\n\n  return\nend subroutine reactor_pot\n\n\n! ### TIM'S PROCEDURES ###\n\nsubroutine analyse_fragments(molvec, molvecSize, totalFragCount, atomsPerFragCount)\n  !!! counts total number of fragments in one snapshot and counts how many atoms each fragment has\n  implicit none\n\n  integer, intent(in):: molvecSize\n  integer, dimension(molvecSize), intent(in):: molvec\n  integer, intent(out):: totalFragCount\n  integer, dimension(:), allocatable, intent(out):: atomsPerFragCount\n  integer:: i, ii\n\n  totalFragCount = maxval(molvec)\n  allocate(atomsPerFragCount(totalFragCount), source = 0)\n\n  do i = 1, molvecSize\n    ii = molvec(i)\n    atomsPerFragCount(ii) = atomsPerFragCount(ii) + 1\n  end do\n\n  return\nend subroutine analyse_fragments\n\nfunction are_zequals_different(zequal_1, zequal_2) result(different)\n  ! TRUE : zequal objects are different\n  ! FALSE: zequal objects are equal\n\n  use zdata\n\n  implicit none\n\n  !-- Forward declarations\n  logical:: are_1d_int_arrays_different\n\n  logical:: different\n  type(zequal), intent(in):: zequal_1, zequal_2\n\n  different = .TRUE.\n\n  !-- Compare total number of zgrps\n  ! if (zequal_1%ng /= zequal_2%ng) then\n  !   return\n  ! End if\n\n  !-- Compare number of zgrps with only one atom\n  ! if (zequal_1%eng /= zequal_2%eng) then\n  !   return\n  ! End if\n\n  !-- Compare mapping of atoms onto zgrps\n  if (are_1d_int_arrays_different(zequal_1%ord, zequal_1%nat, zequal_2%ord, zequal_2%nat)) then\n    return\n  End if\n\n  !-- Compare grps\n  ! if (size(zequal_1%grp) /= size(zequal_2%grp)) then\n  !   return\n  ! else\n  !   do i = 1, zequal_1%ng\n  !     if (are_zgrps_different(zequal_1%grp(i), zequal_2%grp(i))) then\n  !       return\n  !     End if\n  !   End do\n  ! end if\n\n  different = .FALSE.\n  return\nEnd function are_zequals_different\n\nsubroutine update_zequal_ref(src, dest)\n  use zdata\n\n  implicit none\n\n  type(zequal), intent(in):: src\n  type(zequal), intent(out):: dest\n\n  call dest%allocate(src%nat)\n  dest%ng  = src%ng\n  dest%grp = src%grp\n  dest%ord = src%ord\n  call dest%geteng\nEnd subroutine update_zequal_ref\n\nfunction are_1d_int_arrays_different(arr_1, arr_1_dim, arr_2, arr_2_dim) result(different)\n  implicit none\n\n  logical:: different\n  integer, intent(in):: arr_1_dim, arr_2_dim\n  integer, dimension(arr_1_dim), intent(in):: arr_1\n  integer, dimension(arr_2_dim), intent(in):: arr_2\n\n  different = .TRUE.\n\n  if (size(arr_1) == size(arr_2)) then\n    if (all(arr_1 .eq. arr_2)) then\n      different = .FALSE.\n    end if\n  end if\n\n  return\nend function are_1d_int_arrays_different\n\nfunction are_zgrps_different(zgrp_1, zgrp_2) result(different)\n  use zdata\n\n  implicit none\n\n  ! Forward declarations\n  logical:: are_1d_int_arrays_different\n\n  logical:: different\n  type(zgrp), intent(in):: zgrp_1, zgrp_2\n\n  different = .TRUE.\n\n  if (.NOT. are_1d_int_arrays_different(zgrp_1%mem, zgrp_1%nm, zgrp_2%mem, zgrp_2%nm)) then\n    different = .FALSE.\n  End if\n\n  return\nend function are_zgrps_different\n\nsubroutine sort_zgrps(zgrps, zgrps_dim)\n  use zdata\n\n  implicit none\n\n  integer, intent(in):: zgrps_dim\n  type(zgrp), dimension(zgrps_dim), intent(inout):: zgrps\n  integer:: i, j, comp, comp_pos\n\n  do i = 1, zgrps_dim-1\n    comp = zgrps(i)%mem(1)\n    comp_pos = i\n    do j = 2, zgrps_dim\n      if (comp > zgrps(j)%mem(1)) then\n        comp = zgrps(j)%mem(1)\n        comp_pos = j\n      End if\n    End do\n    if (comp_pos /= i) then\n      call swap_pair(zgrps, zgrps_dim, i, comp_pos)\n    End if\n  End do\nEnd subroutine sort_zgrps\n\nsubroutine swap_pair(zgrps, zgrps_dim, pos1, pos2)\n  use zdata\n\n  implicit none\n\n  integer, intent(in):: zgrps_dim\n  type(zgrp), dimension(zgrps_dim), intent(inout):: zgrps\n  integer, intent(in):: pos1, pos2\n  type(zgrp):: temp_zgrp\n\n  temp_zgrp = zgrps(pos1)\n  zgrps(pos1) = zgrps(pos2)\n  zgrps(pos2) = temp_zgrp\n  return\nEnd subroutine swap_pair\n\n\n!===============================================================!\n! get a neighbour list as an array\n!===============================================================!\nsubroutine reactorneighbours(nat,at,xyz,bond,ndim,ngh)\n    use crest_parameters, only: wp, sp\n    implicit none\n    integer,intent(in) :: nat\n    integer,intent(in) :: at(nat)\n    real(wp),intent(in) :: xyz(3,nat)\n    integer,intent(in) :: ndim\n    real(wp),intent(inout) :: bond(nat,nat)\n    integer,intent(out) :: ngh(ndim)  !neighbour list, one dimensional\n\n    real(wp) :: rcov(94)\n    real(wp),allocatable :: cn(:)\n    integer :: i,j,k,l\n    integer :: icn,lin\n    real(wp) :: rcn,rcn2\n\n    ngh=0 !reset\n    call setrcov(rcov)\n    allocate(cn(nat))\n    call xcoord2(nat,at,xyz,rcov,cn,800.0_wp,bond) \n\n    do i=1,nat\n      rcn=floor(cn(i))\n      rcn2= cn(i) - rcn\n      if(rcn2.gt. 0.6d0)then\n         icn=nint(cn(i))\n      else\n         icn=nint(rcn)\n      endif\n      if(icn.ge.6)cycle !skip highly coordinated molecules\n      do k=1,icn\n         j=maxloc(bond(:,i),1)\n         bond(j,i)=0.0d0\n         l=lin(j,i)\n         ngh(l) = 1  !atoms i and j are neighbours\n      enddo\n    enddo\n\n    deallocate(cn)\n    return\nend subroutine reactorneighbours\n\n!===============================================================!\n! Write directories for post optimization\n!===============================================================!\nsubroutine reactorreopt(env,nat,at,nall,xyz,taken,frags,ndirs)\n    use crest_parameters, only: wp, bohr\n    use crest_data\n    use zdata\n    use iomod\n    use strucrd, only: wrxyz\n    implicit none\n    type(systemdata) :: env\n    integer,intent(in) :: nat\n    integer,intent(in) :: at(nat)\n    integer,intent(in) :: nall\n    real(wp),intent(in) :: xyz(3,nat,nall) !should be in Bohr\n    logical,intent(in) :: taken(nall)\n    type(zequal),intent(in) :: frags(nall)\n    integer,intent(out) :: ndirs\n\n    !real(wp),allocatable :: chrgs(:,:)\n    integer :: i,j,k,l,m,n\n    integer :: io\n    logical,allocatable :: mask(:)\n\n    character(len=512) :: thispath,optpath\n    character(len=256) :: ctmp\n\n    character(len=:),allocatable :: xnam\n    character(len=:),allocatable :: xnam2\n    character(len=1024) :: jobcall\n\n    write(*,*)\n   !---- get current path\n    call getcwd(thispath)\n\n    xnam='struc.xyz'\n    ndirs = 0\n   !--- maybe for a future version we want atom charces from SPs\n    !call smallhead('singlepoints on taken structures')\n    !optpath='CHARGESP'\n    !call rmrf(optpath)\n    !io = makedir(trim(optpath))\n    !call chdir(trim(optpath))\n    !call getcwd(optpath)\n    !do i=1,nall\n    ! if(taken(i))then\n    !   ndirs=ndirs+1\n    !   write(ctmp,'(a,i0)')'TMPCHRG',ndirs\n    !   io = makedir(trim(ctmp))\n    !   if(env%chrg .ne. 0)then\n    !     open(newunit=ich,file=trim(ctmp)//'/'//'.CHRG')\n    !      write(ich,*)env%chrg\n    !     close(ich)\n    !   endif\n    !   if(env%uhf .ne. 0)then\n    !     open(newunit=ich,file=trim(ctmp)//'/'//'.UHF')\n    !      write(ich,*)env%uhf\n    !    close(ich)\n    !   endif    \n    !   open(newunit=ich,file=trim(ctmp)//'/'//xnam)\n    !   call wrxyz(ich,nat,at,xyz(:,:i)*bohr) \n    !   close(ich)\n    ! else  \n    !   cycle\n    ! endif\n    !enddo\n    !--- SPs would go here\n    !--- read 'charges' file afterwards\n    !    allocate(chrgs(nat,nall)) ...etc.\n    call chdir(trim(thispath)) !go back\n\n   !--- Otherwise, do the fragments\n    write(*,*)\n    call smallhead('optimization of fragments')\n    allocate(mask(nat))\n    ndirs = 0 !reset\n    optpath='OPTIM'\n    call rmrf(optpath)\n    io = makedir(trim(optpath))\n    call chdir(trim(optpath))\n    call getcwd(optpath)\n    ILOOP : do i=1,nall\n      if(taken(i))then\n          k=frags(i)%ng\n          JLOOP : do j=1,k\n            l=frags(i)%grp(j)%nm\n            if(l.le.1)cycle !cycle single atoms\n            ndirs=ndirs+1\n            write(ctmp,'(a,i0)')'TMPFRG',ndirs\n            io = makedir(trim(ctmp))\n    !--- currently the charge for all systems is assumed = 0 (neutral)\n           mask=.false.\n           do m=1,l\n            n=frags(i)%grp(j)%mem(m)\n            mask(n)=.true.\n           enddo\n           xnam2=trim(ctmp)//'/'//xnam\n           call wrxyz(xnam2,nat,at,xyz(:,:,i)*bohr,mask)\n          enddo JLOOP\n      else\n          cycle\n      endif\n    enddo ILOOP\n    deallocate(mask)\n\n    ! setting the threads for correct parallelization\n    if(env%autothreads)then\n        call ompautoset(env%threads,7,env%omp,env%MAXRUN,ndirs) \n    endif\n    write(*,'(1x,''Starting optimization of reactor products'')')\n    write(*,'(1x,i0,'' jobs to do.'')')ndirs\n\n    write(jobcall,'(a,1x,a,1x,a,1x,a)')trim(env%ProgName),xnam, &\n   &  trim(env%gfnver),'--opt >xtb.out 2>>xtb.out'\n    !write(*,*)'Syscall would is:'\n    !write(*,*) trim(jobcall)\n    call opt_OMP_loop(ndirs,'TMPFRG',jobcall,env%niceprint)\n    write(*,'(/,1x,a)') 'done.'\n    call chdir(trim(thispath)) !return\n\n    return\nend subroutine reactorreopt\n\n\nsubroutine collectproducts(optdir,base,ndirs,oname,iso)\n    use crest_parameters, only: wp, bohr\n    use iomod\n    use strucrd, only: wrxyz,rdnat,rdcoord\n    implicit none\n    character(len=*),intent(in) :: optdir\n    character(len=*),intent(in) :: base\n    integer,intent(in) :: ndirs\n    character(len=*),intent(in) :: oname\n    character(len=:),allocatable :: path\n    logical :: iso\n\n    logical :: ex\n    integer :: i,k\n    integer :: ich\n    integer :: natiso\n    character(len=256) :: atmp\n\n    real(wp),allocatable :: xyz(:,:)\n    integer,allocatable :: at(:)\n    character(len=40),allocatable :: sumformulas(:)\n    character(len=40) :: sumform\n    real(wp),allocatable :: energies(:)\n    integer,allocatable :: nats(:)\n    logical,allocatable :: taken(:)\n\n    real(wp) :: de\n    real(wp),parameter :: ethr = 0.05_wp  !energy threshold for same structure\n    real(wp),parameter :: autokcal = 627.509541_wp\n\n    allocate(sumformulas(ndirs))\n    allocate(energies(ndirs), source= 0.0_wp)\n    allocate(nats(ndirs), source = 0)\n    allocate(taken(ndirs), source=.false.)\n\n    inquire(file=oname,exist=ex)\n    if(ex) call remove(oname)\n    open(newunit=ich,file=oname)\n    \n    path=''\n    do i=1,ndirs\n       write(atmp,'(a,i0)')base,i\n       path=optdir//'/'//trim(atmp)//'/'//'xtbopt.xyz'\n       inquire(file=path,exist=ex)\n       if(.not.ex) cycle !maybe some optimizations failed. they are cycled through.\n       call rdnat(path,nats(i))\n       if(i==1)natiso=nats(i)\n       allocate(xyz(3,nats(i)),at(nats(i)))\n       call rdcoord(path,nats(i),at,xyz,energies(i))\n\n       sumformulas(i) = sumform(nats(i),at)\n\n       !--- check for duplicates based on composition and total energy difference\n       taken(i) = .true.\n       do k=1,i-1\n          if(.not.taken(k))cycle\n          if(nats(i).ne.nats(k)) cycle\n          if(trim(sumformulas(i))==trim(sumformulas(k)))then\n            de=(energies(i)-energies(k))*autokcal\n            if(abs(de).le.ethr) taken(i)=.false.\n          else\n            cycle\n          endif\n       enddo\n       !--- exclude non-isomers?\n       if(iso)then\n           if(nats(i).ne.natiso) taken(i)=.false. \n       endif\n\n       !--- if the structure was taken, write it to the collective ensemble\n       if(taken(i))then\n        call wrxyz(ich,nats(i),at,xyz*bohr,energies(i))\n       endif    \n\n       deallocate(at,xyz)\n    enddo\n    close(ich)\n\n\n    write(*,*)\n    call smallhead('reactor products summary')\n    k=0\n    write(*,'(1x,a,2x,a,4x,a,8x,a)')'structure','#atoms','Etot','composition'\n    do i=1,ndirs\n       if(taken(i))then\n       k=k+1 \n       write(*,'(1x,i6,3x,i6,1x,f16.8,3x,a)') k,nats(i),energies(i), &\n      & trim(sumformulas(i))     \n       endif\n    enddo\n\n    write(*,*)\n    write(*,'(1x,a,a,a)')'Structures written to file \"',trim(oname),'\"'\n\n    deallocate(taken,nats,energies,sumformulas)\n    return\nend subroutine collectproducts\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_algos/reactor.f90 b/src/legacy_algos/reactor.f90
--- a/src/legacy_algos/reactor.f90	
+++ b/src/legacy_algos/reactor.f90	
@@ -575,6 +575,8 @@
 !===============================================================!
 subroutine reactorneighbours(nat,at,xyz,bond,ndim,ngh)
     use crest_parameters, only: wp, sp
+    use miscdata, only: rcov
+    use utilities
     implicit none
     integer,intent(in) :: nat
     integer,intent(in) :: at(nat)
@@ -583,14 +585,12 @@
     real(wp),intent(inout) :: bond(nat,nat)
     integer,intent(out) :: ngh(ndim)  !neighbour list, one dimensional
 
-    real(wp) :: rcov(94)
     real(wp),allocatable :: cn(:)
     integer :: i,j,k,l
-    integer :: icn,lin
+    integer :: icn
     real(wp) :: rcn,rcn2
 
     ngh=0 !reset
-    call setrcov(rcov)
     allocate(cn(nat))
     call xcoord2(nat,at,xyz,rcov,cn,800.0_wp,bond) 
 
Index: src/timer.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!--------------------------------------------------------------------------------!\n!> The original (unmodified) source code can be found under the GNU LGPL 3.0 license\n!> Copyright (C) 2019-2020 Sebastian Ehlert, Stefan Grimme\n!> at https://github.com/grimme-lab/xtb\n!================================================================================!\nmodule crest_type_timer\n  use iso_fortran_env,only:wp => real64,int64\n  implicit none\n\n  public :: timer\n  private\n\n!=========================================================!\n  type :: timer\n\n    !> number of timers\n    integer,private :: n = 0\n\n    !> printlevel\n    logical,private :: verbose = .false.\n\n    real(wp),private :: totwall = 0.0_wp\n    real(wp),private :: totcpu = 0.0_wp\n    logical,private,allocatable :: running(:)\n    real(wp),private,allocatable :: twall(:)\n    real(wp),private,allocatable :: tcpu(:)\n    character(len=128),private,allocatable :: tag(:)\n    integer :: ltag !> max tag length\n\n  contains\n\n    procedure :: new => allocate_timer\n    procedure :: allocate => allocate_timer\n    procedure :: deallocate => deallocate_timer\n    procedure :: measure => timer_measure\n    procedure :: write_timing\n    procedure :: write => write_all_timings\n    procedure :: get => get_timer\n    procedure,private :: start_timing\n    procedure,private :: stop_timing\n\n    procedure :: init  => allocate_timer\n    procedure :: clear => deallocate_timer\n    procedure :: start => timer_measure\n    procedure :: stop  => timer_measure\n\n  end type timer\n!========================================================!\n \n  integer,parameter,private :: lmax_default = 26 \n\n!========================================================================================!\n!========================================================================================!\ncontains  !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\n!> To initialize timer\n  subroutine allocate_timer(self,n,verbose)\n\n    implicit none\n\n    !> instance of timer\n    class(timer),intent(inout) :: self\n\n    !> number of timers\n    integer,intent(in)           :: n\n\n    !> if verbose\n    logical,intent(in),optional :: verbose\n\n    real(wp) :: time_cpu\n    real(wp) :: time_wall\n\n    call self%deallocate\n\n    ! capture negative values !\n    if (n < 1) return\n\n    self%n = n\n    if (present(verbose)) self%verbose = verbose\n    allocate (self%twall(0:n),source=0.0_wp)\n    allocate (self%tcpu(0:n),source=0.0_wp)\n    allocate (self%running(n),source=.false.)\n    allocate (self%tag(n)); self%tag = ' '\n    self%ltag = 0\n\n    ! launch timer !\n    call self%start_timing(0)\n\n  end subroutine allocate_timer\n\n!========================================================================================!\n  subroutine deallocate_timer(self)\n!***********************\n!* To deallocate memory\n!***********************\n    implicit none\n\n    !> instance of timer\n    class(timer),intent(inout) :: self\n\n    self%n = 0\n    self%totwall = 0\n    self%totcpu = 0\n    self%verbose = .false.\n    if (allocated(self%twall)) deallocate (self%twall)\n    if (allocated(self%tcpu)) deallocate (self%tcpu)\n    if (allocated(self%running)) deallocate (self%running)\n\n  end subroutine deallocate_timer\n\n!========================================================================================!\n  function get_timer(self,i) result(time)\n!**********************************\n!* To obtain current elapsed time\n!**********************************\n    !> instance of timer\n    class(timer),intent(inout) :: self\n\n    !> if specific timer\n    integer,intent(in),optional :: i\n\n    integer  :: it\n    real(wp) :: tcpu,twall\n    real(wp) :: time\n    logical  :: running\n\n    ! if i is not given, calculate overall elapsed time !\n    if (present(i)) then\n      it = i\n    else\n      it = 0\n    end if\n\n    if (it > 0) then\n      running = self%running(it)\n    else\n      running = .true.\n    end if\n\n    if (running) then\n      call timing(tcpu,twall)\n      time = self%twall(it)+twall\n    else\n      time = self%twall(it)\n    end if\n\n  end function get_timer\n\n!========================================================================================!\n  subroutine write_timing(self,iunit,i,inmsg,verbose)\n!*****************************************\n!* Printout function for a specific timer\n!*****************************************\n    implicit none\n\n    !> instance of timer\n    class(timer),intent(inout) :: self\n\n    !> I/O unit\n    integer,intent(in) :: iunit\n\n    !> index\n    integer,intent(in) :: i\n\n    !> raw message text\n    character(len=*),intent(in),optional :: inmsg\n\n    !> if verbose\n    logical,intent(in),optional :: verbose\n\n    character(len=128) :: msg\n    real(wp) :: cputime,walltime\n    integer(int64) ::  cpudays,cpuhours,cpumins\n    integer(int64) :: walldays,wallhours,wallmins\n    logical :: lverbose\n    integer :: lmax\n\n    ! check if tag should be added !\n    if (present(inmsg)) then\n      msg = inmsg\n      lmax = len_trim(inmsg)\n    else\n      msg = ''\n      msg = self%tag(i)\n      lmax = self%ltag\n    end if\n    lmax = max(lmax,lmax_default)\n\n    ! verbosity settings !\n    if (present(verbose)) then\n      lverbose = verbose\n    else\n      lverbose = self%verbose\n    end if\n\n    !           DAYS   HOURS   MINUTES   SECONDS\n    ! DAYS        1     1/24    1/1440   1/86400\n    ! HOURS      24      1       1/60     1/3600\n    ! MINUTES   1440    60        1        1/60\n    ! SECONDS  86400   3600      60         1\n\n    ! convert elapsed CPU time into days, hours, minutes !\n    cputime = self%tcpu(i)\n    cpudays = int(cputime/86400._wp)\n    cputime = cputime-cpudays*86400._wp\n    cpuhours = int(cputime/3600._wp)\n    cputime = cputime-cpuhours*3600._wp\n    cpumins = int(cputime/60._wp)\n    cputime = cputime-cpumins*60._wp\n\n    ! convert elapsed wall time into days, hours, minutes !\n    walltime = self%twall(i)\n    walldays = int(walltime/86400._wp)\n    walltime = walltime-walldays*86400._wp\n    wallhours = int(walltime/3600._wp)\n    walltime = walltime-wallhours*3600._wp\n    wallmins = int(walltime/60._wp)\n    walltime = walltime-wallmins*60._wp\n\n    !----------!\n    ! printout !\n    !----------!\n    if (lverbose) then\n      write (iunit,'(a)') msg(1:lmax)\n      write (iunit,'(\" * wall-time: \",i5,\" d, \",i2,\" h, \",i2,\" min, \",f6.3,\" sec\")') &\n        walldays,wallhours,wallmins,walltime\n      write (iunit,'(\" *  cpu-time: \",i5,\" d, \",i2,\" h, \",i2,\" min, \",f6.3,\" sec\")') &\n        cpudays,cpuhours,cpumins,cputime\n      write (iunit,'(1x,\"*\",1x,\"ratio c/w:\",1x,f9.3,1x,\"speedup\")') self%tcpu(i)/self%twall(i)\n    else\n      write (iunit,'(a,1x,\"...\",i9,\" min, \",f6.3,\" sec\")') &\n        msg(1:lmax),wallmins,walltime\n    end if\n\n  end subroutine write_timing\n\n!========================================================================================!\n  subroutine write_all_timings(self,iunit,inmsg,verbose)\n!************************************\n!* Printout of all saved timings\n!************************************\n    implicit none\n\n    !> instance of timer\n    class(timer),intent(inout) :: self\n\n    !> I/O unit\n    integer,intent(in) :: iunit\n\n    !> raw message\n    character(len=*),intent(in),optional :: inmsg\n\n    !> verbose?\n    logical,intent(in),optional :: verbose\n\n    character(len=128) :: msg\n    character(len=256) :: atmp\n    real(wp) :: cputime,walltime,partsum,iowall\n    real(wp) :: cpusecs,wallsecs\n    integer  :: i\n    integer(int64) ::  cpudays,cpuhours,cpumins\n    integer(int64) :: walldays,wallhours,wallmins\n    integer :: lmax\n    logical :: verbose_local\n\n    call self%stop_timing(0)\n\n    ! verbose ?\n    if(present(verbose))then\n     verbose_local = verbose\n    else\n     verbose_local = self%verbose\n    endif\n\n    ! check if an external message should be added !\n    if (present(inmsg)) then\n      msg = inmsg//\" (total)\"\n    else\n      msg = \"total time\"\n    end if\n    lmax=len_trim(msg)\n    lmax = max(lmax,self%ltag)\n    lmax = max(lmax,lmax_default)\n\n    !           DAYS   HOURS   MINUTES   SECONDS\n    ! DAYS        1     1/24    1/1440   1/86400\n    ! HOURS      24      1       1/60     1/3600\n    ! MINUTES   1440    60        1        1/60\n    ! SECONDS  86400   3600      60         1\n\n    ! convert overall elapsed CPU time into days, hours, minutes !\n    cputime = self%tcpu(0)\n    cpudays = int(cputime/86400._wp)\n    cputime = cputime-cpudays*86400._wp\n    cpuhours = int(cputime/3600._wp)\n    cputime = cputime-cpuhours*3600._wp\n    cpumins = int(cputime/60._wp)\n    cputime = cputime-cpumins*60._wp\n    cpusecs = cputime\n\n    ! convert overall elapsed wall time into days, hours, minutes !\n    walltime = self%twall(0)\n    walldays = int(walltime/86400._wp)\n    walltime = walltime-walldays*86400._wp\n    wallhours = int(walltime/3600._wp)\n    walltime = walltime-wallhours*3600._wp\n    wallmins = int(walltime/60._wp)\n    walltime = walltime-wallmins*60._wp\n    wallsecs = walltime\n\n    !----------!\n    ! printout !\n    !----------!\n    !if (self%verbose) then\n    !  write (iunit,'(1x,a,\":\")') msg(1:lmax)\n    !  write (iunit,'(\" * wall-time: \",i5,\" d, \",i2,\" h, \",i2,\" min, \",f6.3,\" sec\")') &\n    !    walldays,wallhours,wallmins,walltime\n    !  write (iunit,'(\" *  cpu-time: \",i5,\" d, \",i2,\" h, \",i2,\" min, \",f6.3,\" sec\")') &\n    !    cpudays,cpuhours,cpumins,cputime\n    !  write (iunit,'(1x,\"*\",1x,\"ratio c/w:\",1x,f9.3,1x,\"speedup\")') self%tcpu(0)/self%twall(0)\n    !else\n      write (atmp,'(1x,a,i5,\" d, \",i2,\" h, \",i2,\" min, \",f6.3,\" sec\")') &\n        msg(1:lmax+6),walldays,wallhours,wallmins,walltime\n      write (iunit,'(a)') trim(atmp)\n      if(verbose_local)then\n      write (iunit,'(1x,a)') repeat('-',len_trim(atmp))\n      endif\n    !end if\n\n    ! printout every timer and corresponding speedup !\n    partsum = 0.0_wp\n    do i = 1,self%n\n      walltime = self%twall(i)\n      if(walltime <= 0.0_wp) cycle\n      partsum = partsum + walltime\n      wallmins = int(walltime/60._wp)\n      walltime = walltime-wallmins*60._wp\n      msg = self%tag(i)\n      write (iunit,'(1x,a,1x,\"...\",i9,\" min, \",f6.3,\" sec (\",f7.3,\"%)\")') &\n        msg(1:lmax),wallmins,walltime,100*self%twall(i)/self%twall(0)\n    end do\n    !> everything else is I/O or setup (e.g. loading parametrizations)\n    walltime = self%twall(0) - partsum\n    iowall = walltime\n    wallmins = int(walltime/60._wp)\n    walltime = walltime-wallmins*60._wp\n    msg = 'I/O and setup'\n    write (iunit,'(1x,a,1x,\"...\",i9,\" min, \",f6.3,\" sec (\",f7.3,\"%)\")') &\n    msg(1:lmax),wallmins,walltime,100*iowall/self%twall(0)\n    !> and finally, again the total cpu and wall time\n    if(verbose_local)then\n     write (iunit,'(\" * wall-time: \",i5,\" d, \",i2,\" h, \",i2,\" min, \",f6.3,\" sec\")') &\n        walldays,wallhours,wallmins,wallsecs\n      write (iunit,'(\" *  cpu-time: \",i5,\" d, \",i2,\" h, \",i2,\" min, \",f6.3,\" sec\")') &\n        cpudays,cpuhours,cpumins,cpusecs\n      write (iunit,'(1x,\"*\",1x,\"ratio c/w:\",1x,f9.3,1x,\"speedup\")') self%tcpu(0)/self%twall(0)\n    endif    \n\n\n    write (iunit,'(a)')\n\n  end subroutine write_all_timings\n\n!========================================================================================!\n  subroutine timer_measure(self,i,inmsg)\n!***********************************\n!* Automatic start/stop of timer i\n!***********************************\n    implicit none\n\n    !> instance of timer\n    class(timer),intent(inout) :: self\n\n    !> index\n    integer,intent(in) :: i\n\n    !> raw message text\n    character(len=*),intent(in),optional :: inmsg\n    integer :: l\n\n    ! check if appropriate index is given !\n    if (i > self%n.or.i < 1) return\n\n    ! switcher between start/stop status !\n    if (self%running(i)) then\n      call self%stop_timing(i)\n    else\n      call self%start_timing(i)\n    end if\n\n    ! update status !\n    self%running(i) = .not.self%running(i)\n\n    ! assign tag to specific timer !\n    if (present(inmsg))then\n      self%tag(i) = trim(inmsg)\n      l = len_trim(inmsg)\n    endif\n\n  end subroutine timer_measure\n\n!========================================================================================!\n  subroutine start_timing(self,i)\n!********************\n!* Start timer i\n!********************\n    implicit none\n\n    !> instance of timer\n    class(timer),intent(inout) :: self\n\n    !> index\n    integer,intent(in) :: i\n\n    real(wp) :: time_cpu\n    real(wp) :: time_wall\n\n    call timing(time_cpu,time_wall)\n    self%tcpu(i) = self%tcpu(i)-time_cpu\n    self%twall(i) = self%twall(i)-time_wall\n\n  end subroutine start_timing\n\n!========================================================================================!\n  subroutine stop_timing(self,i)\n!*******************\n!* Stop timer i\n!*******************\n    implicit none\n\n    !> instance of timer\n    class(timer),intent(inout) :: self\n\n    !> index\n    integer,intent(in) :: i\n\n    real(wp) :: time_cpu\n    real(wp) :: time_wall\n\n    call timing(time_cpu,time_wall)\n    self%tcpu(i) = self%tcpu(i)+time_cpu\n    self%twall(i) = self%twall(i)+time_wall\n\n  end subroutine stop_timing\n\n!========================================================================================!\n  subroutine timing(time_cpu,time_wall)\n!********************************************\n!* To retrieve the current CPU and wall time\n!********************************************\n    implicit none\n\n    real(wp),intent(out) :: time_cpu\n    real(wp),intent(out) :: time_wall\n\n    !> current value of system clock (time passed from arbitary point)\n    integer(int64) :: time_count\n\n    !> number of clock ticks per second (conversion factor b/n ticks and seconds)\n    integer(int64) :: time_rate\n    integer(int64) :: time_max\n\n    call system_clock(time_count,time_rate,time_max)\n    call cpu_time(time_cpu)\n\n    ! elapsed time in seconds !\n    time_wall = real(time_count,wp)/real(time_rate,wp)\n\n  end subroutine timing\n\n!========================================================================================!\n!========================================================================================!\nend module crest_type_timer\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/timer.f90 b/src/timer.f90
--- a/src/timer.f90	
+++ b/src/timer.f90	
@@ -56,15 +56,15 @@
     procedure,private :: start_timing
     procedure,private :: stop_timing
 
-    procedure :: init  => allocate_timer
+    procedure :: init => allocate_timer
     procedure :: clear => deallocate_timer
     procedure :: start => timer_measure
-    procedure :: stop  => timer_measure
+    procedure :: stop => timer_measure
 
   end type timer
 !========================================================!
- 
-  integer,parameter,private :: lmax_default = 26 
+
+  integer,parameter,private :: lmax_default = 26
 
 !========================================================================================!
 !========================================================================================!
@@ -129,9 +129,9 @@
 
 !========================================================================================!
   function get_timer(self,i) result(time)
-!**********************************
-!* To obtain current elapsed time
-!**********************************
+!********************************************
+!* To obtain current elapsed time in seconds
+!********************************************
     !> instance of timer
     class(timer),intent(inout) :: self
 
@@ -151,7 +151,7 @@
     end if
 
     if (it > 0) then
-      running = self%running(it)
+    running = self%running(it)
     else
       running = .true.
     end if
@@ -275,21 +275,22 @@
     character(len=128) :: msg
     character(len=256) :: atmp
     real(wp) :: cputime,walltime,partsum,iowall
-    real(wp) :: cpusecs,wallsecs
+    real(wp) :: cpusecs,wallsecs,wallsecs_abs
     integer  :: i
     integer(int64) ::  cpudays,cpuhours,cpumins
     integer(int64) :: walldays,wallhours,wallmins
-    integer :: lmax
+    integer(int64) :: walldays_abs,wallhours_abs,wallmins_abs
+    integer :: lmax,barlen,ll
     logical :: verbose_local
 
     call self%stop_timing(0)
 
     ! verbose ?
-    if(present(verbose))then
-     verbose_local = verbose
+    if (present(verbose)) then
+      verbose_local = verbose
     else
-     verbose_local = self%verbose
-    endif
+      verbose_local = self%verbose
+    end if
 
     ! check if an external message should be added !
     if (present(inmsg)) then
@@ -297,9 +298,13 @@
     else
       msg = "total time"
     end if
-    lmax=len_trim(msg)
+    lmax = len_trim(msg)
     lmax = max(lmax,self%ltag)
     lmax = max(lmax,lmax_default)
+    do i=1,self%n
+      ll = len_trim(self%tag(i))
+      if(ll > lmax) lmax = ll
+    enddo
 
     !           DAYS   HOURS   MINUTES   SECONDS
     ! DAYS        1     1/24    1/1440   1/86400
@@ -320,38 +325,34 @@
     ! convert overall elapsed wall time into days, hours, minutes !
     walltime = self%twall(0)
     walldays = int(walltime/86400._wp)
+    walldays_abs = walldays
     walltime = walltime-walldays*86400._wp
     wallhours = int(walltime/3600._wp)
+    wallhours_abs = wallhours
     walltime = walltime-wallhours*3600._wp
     wallmins = int(walltime/60._wp)
+    wallmins_abs = wallmins
     walltime = walltime-wallmins*60._wp
     wallsecs = walltime
+    wallsecs_abs = wallsecs
 
     !----------!
     ! printout !
     !----------!
-    !if (self%verbose) then
-    !  write (iunit,'(1x,a,":")') msg(1:lmax)
-    !  write (iunit,'(" * wall-time: ",i5," d, ",i2," h, ",i2," min, ",f6.3," sec")') &
-    !    walldays,wallhours,wallmins,walltime
-    !  write (iunit,'(" *  cpu-time: ",i5," d, ",i2," h, ",i2," min, ",f6.3," sec")') &
-    !    cpudays,cpuhours,cpumins,cputime
-    !  write (iunit,'(1x,"*",1x,"ratio c/w:",1x,f9.3,1x,"speedup")') self%tcpu(0)/self%twall(0)
-    !else
-      write (atmp,'(1x,a,i5," d, ",i2," h, ",i2," min, ",f6.3," sec")') &
-        msg(1:lmax+6),walldays,wallhours,wallmins,walltime
-      write (iunit,'(a)') trim(atmp)
-      if(verbose_local)then
-      write (iunit,'(1x,a)') repeat('-',len_trim(atmp))
-      endif
-    !end if
+    write (atmp,'(1x,a,i5," d, ",i2," h, ",i2," min, ",f6.3," sec")') &
+      msg(1:lmax+6),walldays,wallhours,wallmins,walltime
+    write (iunit,'(a)') trim(atmp)
+    if (verbose_local) then
+      barlen = len_trim(atmp)
+      write (iunit,'(1x,a)') repeat('-',barlen)
+    end if
 
     ! printout every timer and corresponding speedup !
     partsum = 0.0_wp
     do i = 1,self%n
       walltime = self%twall(i)
-      if(walltime <= 0.0_wp) cycle
-      partsum = partsum + walltime
+      if (walltime <= 0.0_wp) cycle
+      partsum = partsum+walltime
       wallmins = int(walltime/60._wp)
       walltime = walltime-wallmins*60._wp
       msg = self%tag(i)
@@ -359,25 +360,25 @@
         msg(1:lmax),wallmins,walltime,100*self%twall(i)/self%twall(0)
     end do
     !> everything else is I/O or setup (e.g. loading parametrizations)
-    walltime = self%twall(0) - partsum
+    walltime = self%twall(0)-partsum
     iowall = walltime
     wallmins = int(walltime/60._wp)
     walltime = walltime-wallmins*60._wp
     msg = 'I/O and setup'
     write (iunit,'(1x,a,1x,"...",i9," min, ",f6.3," sec (",f7.3,"%)")') &
-    msg(1:lmax),wallmins,walltime,100*iowall/self%twall(0)
+      msg(1:lmax),wallmins,walltime,100*iowall/self%twall(0)
     !> and finally, again the total cpu and wall time
-    if(verbose_local)then
-     write (iunit,'(" * wall-time: ",i5," d, ",i2," h, ",i2," min, ",f6.3," sec")') &
-        walldays,wallhours,wallmins,wallsecs
+    if (verbose_local) then
+      write (iunit,'(1x,a)') repeat('-',barlen)
+      
+      write (iunit,'(" * wall-time: ",i5," d, ",i2," h, ",i2," min, ",f6.3," sec")') &
+        walldays_abs,wallhours_abs,wallmins_abs,wallsecs_abs
       write (iunit,'(" *  cpu-time: ",i5," d, ",i2," h, ",i2," min, ",f6.3," sec")') &
         cpudays,cpuhours,cpumins,cpusecs
       write (iunit,'(1x,"*",1x,"ratio c/w:",1x,f9.3,1x,"speedup")') self%tcpu(0)/self%twall(0)
-    endif    
+      write (iunit,'(1x,a)') repeat('-',barlen)
+    end if
 
-
-    write (iunit,'(a)')
-
   end subroutine write_all_timings
 
 !========================================================================================!
@@ -411,10 +412,10 @@
     self%running(i) = .not.self%running(i)
 
     ! assign tag to specific timer !
-    if (present(inmsg))then
+    if (present(inmsg)) then
       self%tag(i) = trim(inmsg)
       l = len_trim(inmsg)
-    endif
+    end if
 
   end subroutine timer_measure
 
Index: src/calculator/api_helpers.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nmodule api_helpers\n\n  use iso_fortran_env,only:wp => real64,stdout => output_unit\n  use strucrd\n  use calc_type\n  use iomod,only:makedir,directory_exist,remove\n  !> APIs\n  use tblite_api\n  use gfn0_api\n  use gfnff_api\n!=========================================================================================!\n  implicit none\n  public\n\n!=========================================================================================!\n!=========================================================================================!\ncontains    !> MODULE PROCEDURES START HERE\n!=========================================================================================!\n!=========================================================================================!\n\n!>--- printout routines directed to printout channels\n  subroutine api_print_input_structure(pr,iunit,mol)\n    implicit none\n    !> INPUT\n    logical,intent(in) :: pr\n    integer,intent(in) :: iunit\n    type(coord),intent(in) :: mol\n    !> LOCAL\n    integer :: i\n\n    !> if printing is turned off, return\n    if (.not.pr) return\n\n    !> else, write structure info to the output unit\n    write (iunit,'(a)') '# Input structure (in Ångström)'\n    call mol%append(iunit)\n\n    if(allocated(mol%lat))then\n    write (iunit,'(a)') '# Lattice vectors (in Ångström)'\n    do i=1,3\n     write(iunit,'(3F16.8)') mol%lat(1:3,i)\n    enddo\n    endif\n\n    if(mol%chrg .ne. 0)then\n    write (iunit,'(a)') '# Molecular charge'\n    write(iunit,*) mol%chrg\n    endif\n    write (iunit,*)\n  end subroutine api_print_input_structure\n\n   subroutine api_print_e_grd(pr,iunit,mol,energy,gradient)\n    implicit none\n    !> INPUT\n    logical,intent(in) :: pr\n    integer,intent(in) :: iunit\n    type(coord),intent(in) :: mol\n    real(wp),intent(in) :: energy\n    real(wp),intent(in) :: gradient(3,mol%nat)\n    !> LOCAL\n    real(wp) :: gnorm\n    integer :: i \n\n    !> if printing is turned off, return\n    if (.not.pr) return\n\n    !> else, write e+grd info to the output unit\n    gnorm = sqrt(sum(gradient**2))\n    write(iunit,*)\n    write (iunit,'(a)') '# Total energy and gradient norm'\n    write (iunit,*) energy,gnorm\n    write (iunit,'(a)') '# Gradient'\n    do i=1,mol%nat\n      write (iunit,'(3F20.10)') gradient(1:3,i)\n    enddo    \n    write (iunit,*)\n  end subroutine api_print_e_grd\n\n\n\n!=========================================================================================!\n!>--- tblite helper/setup routines\n  subroutine tblite_init(calc,loadnew)\n    implicit none\n    type(calculation_settings),intent(inout) :: calc\n    logical,intent(out) :: loadnew\n    loadnew = .false.\n    if (.not.allocated(calc%wfn)) then\n      allocate (calc%wfn)\n      loadnew = .true.\n    end if\n    if (.not.allocated(calc%tbcalc)) then\n      allocate (calc%tbcalc)\n      loadnew = .true.\n    end if\n    if (.not.allocated(calc%ctx)) then\n      allocate (calc%ctx)\n      loadnew = .true.\n    end if\n    if (.not.allocated(calc%tbres)) then\n      allocate (calc%tbres)\n      loadnew = .true.\n    end if\n    if (calc%apiclean) loadnew = .true.\n  end subroutine tblite_init\n  subroutine tblite_wbos(calc,mol,iostatus)\n    implicit none\n    type(calculation_settings),intent(inout) :: calc\n    type(coord),intent(in) :: mol\n    integer,intent(out) :: iostatus\n    iostatus = 0\n    if (.not.calc%rdwbo) return\n    if (allocated(calc%wbo)) deallocate (calc%wbo)\n    allocate (calc%wbo(mol%nat,mol%nat),source=0.0_wp)\n    call tblite_getwbos(calc%tbcalc,calc%wfn,calc%tbres,mol%nat,calc%wbo)\n  end subroutine tblite_wbos\n\n!========================================================================================!\n\n!>--- GFN0-xTB helper/setup routines\n  subroutine gfn0_init(calc,g0calc,loadnew)\n    implicit none\n    type(calculation_settings),intent(inout) :: calc\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    logical,intent(out) :: loadnew\n    loadnew = .false.\n    if (.not.allocated(g0calc)) then\n      allocate (g0calc)\n      loadnew = .true.\n    end if\n    if (calc%apiclean) loadnew = .true.\n  end subroutine gfn0_init\n  subroutine gfn0_init2(mol,calc,g0calc)\n    implicit none\n    type(coord),intent(in) :: mol\n    type(calculation_settings),intent(inout) :: calc\n    type(gfn0_data),intent(inout)  :: g0calc\n#ifdef WITH_GFN0\n    if (allocated(calc%solvent).and.allocated(calc%solvmodel)) then\n      call gfn0_addsettings(mol,g0calc,calc%solvent,calc%solvmodel)\n    end if\n    call gfn0_addsettings(mol,g0calc,loadwbo=calc%rdwbo)\n#endif\n  end subroutine gfn0_init2\n  subroutine gfn0_init3(mol,calc,g0calc)\n    implicit none\n    type(coord),intent(in) :: mol\n    type(calculation_settings),intent(inout) :: calc\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    integer :: nel,uhf\n#ifdef WITH_GFN0\n    nel = g0calc%wfn%nel\n    uhf = calc%uhf\n    call g0calc%wfn%refresh_occu(nel,uhf)\n    call gfn0_addsettings(mol,g0calc,etemp=calc%etemp)\n#endif\n  end subroutine gfn0_init3\n  subroutine gfn0_wbos(calc,g0calc,mol,iostatus)\n    implicit none\n    type(calculation_settings),intent(inout) :: calc\n    type(gfn0_data),intent(inout) :: g0calc\n    type(coord),intent(in) :: mol\n    integer,intent(out) :: iostatus\n    iostatus = 0\n#ifdef WITH_GFN0\n    if (.not.calc%rdwbo) return\n    if (allocated(calc%wbo)) deallocate (calc%wbo)\n    allocate (calc%wbo(mol%nat,mol%nat),source=0.0_wp)\n    call gfn0_getwbos(g0calc,mol%nat,calc%wbo)\n#endif\n  end subroutine gfn0_wbos\n\n!========================================================================================!\n\n!>--- GFN0*-xTB setup/helper routines\n  subroutine gfn0occ_init(calc,g0calc,loadnew)\n    implicit none\n    type(calculation_settings),intent(inout) :: calc\n    logical,intent(out) :: loadnew\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    integer :: nel,nao,nlev\n    loadnew = .false.\n#ifdef WITH_GFN0\n    if (.not.allocated(g0calc)) then\n      allocate (g0calc)\n      loadnew = .true.\n    end if\n    if (calc%apiclean) loadnew = .true.\n#endif\n  end subroutine gfn0occ_init\n  subroutine gfn0occ_init2(mol,calc,g0calc)\n    implicit none\n    type(coord),intent(in) :: mol\n    type(calculation_settings),intent(inout) :: calc\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    integer :: nel,nao,nlev\n#ifdef WITH_GFN0\n    if (allocated(calc%solvent).and.allocated(calc%solvmodel)) then\n      call gfn0_addsettings(mol,g0calc,calc%solvent,calc%solvmodel)\n    end if\n    call gfn0_addsettings(mol,g0calc,etemp=calc%etemp,loadwbo=calc%rdwbo)\n#endif\n  end subroutine gfn0occ_init2\n  subroutine gfn0occ_init3(mol,calc,g0calc)\n    implicit none\n    type(coord),intent(in) :: mol\n    type(calculation_settings),intent(inout) :: calc\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    integer :: nel,nao,nlev\n#ifdef WITH_GFN0\n    if (.not.allocated(calc%occ)) then\n      nel = g0calc%wfn%nel\n      nao = g0calc%basis%nao\n      if (allocated(calc%occ)) deallocate (calc%occ)\n      allocate (calc%occ(nao),source=0.0_wp)\n      call gfn0_gen_occ(nel,nao,calc%config,calc%occ)\n    end if\n#endif\n  end subroutine gfn0occ_init3\n\n!========================================================================================!\n\n!>--- GFN-FF setup/helper routines\n  subroutine gfnff_init(calc,loadnew)\n    implicit none\n    type(calculation_settings),intent(inout) :: calc\n    logical,intent(out) :: loadnew\n    integer :: nel,nao,nlev\n    loadnew = .false.\n#ifdef WITH_GFNFF\n    if (.not.allocated(calc%ff_dat)) then\n      allocate (calc%ff_dat)\n      loadnew = .true.\n    end if\n    if (allocated(calc%solvent)) then\n      if (.not.allocated(calc%ff_dat%solvent)) then\n        allocate (calc%ff_dat%solvent,source=trim(calc%solvent))\n        calc%ff_dat%solvent = calc%solvent\n      end if\n    end if\n    if (calc%apiclean) loadnew = .true.\n#endif\n  end subroutine gfnff_init\n  subroutine gfnff_wbos(calc,mol,iostatus)\n    implicit none\n    type(calculation_settings),intent(inout) :: calc\n    type(coord),intent(in) :: mol\n    integer,intent(out) :: iostatus\n    integer :: i,j\n    iostatus = 0\n#ifdef WITH_GFNFF\n    if (.not.calc%rdwbo) return\n    if (allocated(calc%wbo)) deallocate (calc%wbo)\n    allocate (calc%wbo(mol%nat,mol%nat),source=0.0_wp)\n    call gfnff_getwbos(calc%ff_dat,mol%nat,calc%wbo)\n#endif\n  end subroutine gfnff_wbos\n\n\n\n\n!========================================================================================!\n\n!>--- XHCFF setup/helper routines\n  subroutine xhcff_initcheck(calc,loadnew)\n    implicit none\n    type(calculation_settings),intent(inout) :: calc\n    logical,intent(out) :: loadnew\n    loadnew = .false.\n#ifdef WITH_XHCFF\n    if (.not.allocated(calc%xhcff)) then\n      allocate (calc%xhcff)\n      loadnew = .true.\n    end if\n    if (calc%apiclean) loadnew = .true.\n#endif\n  end subroutine xhcff_initcheck\n\n\n!========================================================================================!\nend module api_helpers\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/api_helpers.F90 b/src/calculator/api_helpers.F90
--- a/src/calculator/api_helpers.F90	
+++ b/src/calculator/api_helpers.F90	
@@ -54,21 +54,21 @@
     write (iunit,'(a)') '# Input structure (in Ångström)'
     call mol%append(iunit)
 
-    if(allocated(mol%lat))then
-    write (iunit,'(a)') '# Lattice vectors (in Ångström)'
-    do i=1,3
-     write(iunit,'(3F16.8)') mol%lat(1:3,i)
-    enddo
-    endif
+    if (allocated(mol%lat)) then
+      write (iunit,'(a)') '# Lattice vectors (in Ångström)'
+      do i = 1,3
+        write (iunit,'(3F16.8)') mol%lat(1:3,i)
+      end do
+    end if
 
-    if(mol%chrg .ne. 0)then
-    write (iunit,'(a)') '# Molecular charge'
-    write(iunit,*) mol%chrg
-    endif
+    if (mol%chrg .ne. 0) then
+      write (iunit,'(a)') '# Molecular charge'
+      write (iunit,*) mol%chrg
+    end if
     write (iunit,*)
   end subroutine api_print_input_structure
 
-   subroutine api_print_e_grd(pr,iunit,mol,energy,gradient)
+  subroutine api_print_e_grd(pr,iunit,mol,energy,gradient)
     implicit none
     !> INPUT
     logical,intent(in) :: pr
@@ -78,24 +78,59 @@
     real(wp),intent(in) :: gradient(3,mol%nat)
     !> LOCAL
     real(wp) :: gnorm
-    integer :: i 
+    integer :: i
 
     !> if printing is turned off, return
     if (.not.pr) return
 
     !> else, write e+grd info to the output unit
     gnorm = sqrt(sum(gradient**2))
-    write(iunit,*)
+    write (iunit,*)
     write (iunit,'(a)') '# Total energy and gradient norm'
     write (iunit,*) energy,gnorm
     write (iunit,'(a)') '# Gradient'
-    do i=1,mol%nat
+    do i = 1,mol%nat
       write (iunit,'(3F20.10)') gradient(1:3,i)
-    enddo    
+    end do
     write (iunit,*)
   end subroutine api_print_e_grd
 
-
+!=========================================================================================!
+
+  subroutine api_handle_output(calc,fname,mol,pr)
+    implicit none
+    type(calculation_settings),intent(inout) :: calc
+    character(len=*),intent(in) :: fname
+    type(coord),intent(inout) :: mol
+    logical,intent(out) :: pr
+    character(len=:),allocatable :: cpath
+    logical :: ex
+    integer :: io
+
+    pr = calc%pr
+    if(pr)then
+      inquire (unit=calc%prch,opened=ex)
+      if ((calc%prch .ne. stdout).and.ex) then
+       close (calc%prch)
+      end if
+      if (allocated(calc%calcspace)) then
+        ex = directory_exist(calc%calcspace)
+        if (.not.ex) then
+          io = makedir(trim(calc%calcspace))
+        end if
+        cpath = calc%calcspace//sep//fname
+      else
+        cpath = fname
+      end if
+      if ((calc%prch .ne. stdout)) then
+        !> NOTE: this requires a predifined print channel!
+        open (unit=calc%prch,file=cpath)
+      end if
+      deallocate (cpath)
+      call api_print_input_structure(pr,calc%prch,mol)
+    endif
+
+  end subroutine api_handle_output
 
 !=========================================================================================!
 !>--- tblite helper/setup routines
@@ -104,22 +139,26 @@
     type(calculation_settings),intent(inout) :: calc
     logical,intent(out) :: loadnew
     loadnew = .false.
-    if (.not.allocated(calc%wfn)) then
-      allocate (calc%wfn)
-      loadnew = .true.
-    end if
-    if (.not.allocated(calc%tbcalc)) then
-      allocate (calc%tbcalc)
-      loadnew = .true.
-    end if
-    if (.not.allocated(calc%ctx)) then
-      allocate (calc%ctx)
-      loadnew = .true.
-    end if
-    if (.not.allocated(calc%tbres)) then
-      allocate (calc%tbres)
+    if (.not.allocated(calc%tblite)) then
+      allocate (calc%tblite)
       loadnew = .true.
     end if
+    !if (.not.allocated(calc%tblite%wfn)) then
+    !  allocate (calc%tblite%wfn)
+    !  loadnew = .true.
+    !end if
+    !if (.not.allocated(calc%tblite%calc)) then
+    !  allocate (calc%tblite%calc)
+    !  loadnew = .true.
+    !end if
+    !if (.not.allocated(calc%tblite%ctx)) then
+    !  allocate (calc%tblite%ctx)
+    !  loadnew = .true.
+    !end if
+    !if (.not.allocated(calc%tblite%res)) then
+    !  allocate (calc%tblite%res)
+    !  loadnew = .true.
+    !end if
     if (calc%apiclean) loadnew = .true.
   end subroutine tblite_init
   subroutine tblite_wbos(calc,mol,iostatus)
@@ -131,7 +170,7 @@
     if (.not.calc%rdwbo) return
     if (allocated(calc%wbo)) deallocate (calc%wbo)
     allocate (calc%wbo(mol%nat,mol%nat),source=0.0_wp)
-    call tblite_getwbos(calc%tbcalc,calc%wfn,calc%tbres,mol%nat,calc%wbo)
+    call tblite_getwbos(calc%tblite%calc,calc%tblite%wfn,calc%tblite%res,mol%nat,calc%wbo)
   end subroutine tblite_wbos
 
 !========================================================================================!
@@ -275,6 +314,22 @@
 #endif
   end subroutine gfnff_wbos
 
+!========================================================================================!
+
+!>--- XHCFF setup/helper routines
+  subroutine xhcff_initcheck(calc,loadnew)
+    implicit none
+    type(calculation_settings),intent(inout) :: calc
+    logical,intent(out) :: loadnew
+    loadnew = .false.
+#ifdef WITH_XHCFF
+    if (.not.allocated(calc%xhcff)) then
+      allocate (calc%xhcff)
+      loadnew = .true.
+    end if
+    if (calc%apiclean) loadnew = .true.
+#endif
+  end subroutine xhcff_initcheck
 
 
 
Index: src/calculator/xtb_sc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!====================================================!\n! module xtb_sc\n! A module containing routines for\n! system calls to the xtb code\n!====================================================!\n\nmodule xtb_sc\n\n  use iso_fortran_env,only:wp => real64\n  use strucrd\n  use calc_type\n  use iomod,only:makedir,directory_exist,remove,command\n  implicit none\n\n!=========================================================================================!\n  !--- private module variables and parameters\n  private\n  integer :: i,j,k,l,ich,och,io\n  logical :: ex\n\n  integer,parameter :: nf = 3\n  character(len=*),parameter :: xtbfiles(nf) = [&\n          & 'charges    ','xtbinp.grad','xtbrestart ']\n  character(len=3),parameter :: xtb = 'xtb'\n  character(len=10),parameter :: xyzn = 'xtbinp.xyz'\n  character(len=13),parameter :: gf = 'xtbinp.engrad'\n\n  public :: xtb_engrad\n\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n  subroutine xtb_engrad(mol,calc,energy,grad,iostatus)\n    use iso_fortran_env,only:wp => real64\n    use strucrd\n    use calc_type\n    use iomod,only:makedir,directory_exist,remove\n\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    iostatus = 0\n    \n    !>--- setup system call information\n    !$omp critical\n    call xtb_setup(mol,calc)\n    !$omp end critical\n\n    !>--- do the systemcall\n    call initsignal()\n    call command(calc%systemcall, iostatus)\n    if (iostatus /= 0) return\n\n    !>--- read energy and gradient\n    !$omp critical\n    call rd_xtb_engrad(mol,calc,energy,grad,iostatus)\n    !$omp end critical\n    if (iostatus /= 0) return\n\n    !>--- read WBOs?\n    !$omp critical\n    call rd_xtb_wbo(mol,calc,iostatus)\n    !$omp end critical\n    if (iostatus /= 0) return\n\n    return\n  end subroutine xtb_engrad\n\n!========================================================================================!\n  subroutine xtb_setup(mol,calc)\n    use iso_fortran_env,only:wp => real64\n    use strucrd\n    use calc_type\n    use iomod,only:makedir,directory_exist,remove\n\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    integer :: l\n    character(len=:),allocatable :: fname\n    character(len=:),allocatable :: cpath\n    character(len=10) :: num\n    integer :: i,j,k,ich,och,io\n    logical :: ex\n\n    call initsignal()\n\n    !>--- set default binary if not present\n    if (.not. allocated(calc%binary)) then\n      calc%binary = xtb\n    end if\n\n    !>--- check for the calculation space\n    if (allocated(calc%calcspace)) then\n      ex = directory_exist(calc%calcspace)\n      if (.not. ex) then\n        io = makedir(trim(calc%calcspace))\n      end if\n      cpath = calc%calcspace\n    else\n      cpath = ''\n    end if\n    !>--- cleanup old files\n    do i = 1,nf\n      !write(*,*) trim(cpath)//sep//trim(xtbfiles(i)) \n      call remove(trim(cpath)//sep//trim(xtbfiles(i)))\n    end do\n    deallocate (cpath)\n\n    !>--- construct path information and write coord file\n    if (.not. allocated(calc%calcfile)) then\n      if (allocated(calc%calcspace)) then\n        l = len_trim(calc%calcspace)\n        fname = trim(calc%calcspace)\n        if (calc%calcspace(l:l) == sep) then\n          fname = trim(fname)//xyzn\n        else\n          fname = trim(fname)//sep//xyzn\n        end if\n      else\n        fname = xyzn\n      end if\n      calc%calcfile = fname\n    else\n      fname = calc%calcfile\n    end if\n    call mol%write(fname)\n    deallocate (fname)\n\n    !>--- if the systemcall was already set up, return\n    if (allocated(calc%systemcall)) return\n\n    !>--- construct path information for sys-call\n    if (allocated(calc%calcspace)) then\n      calc%systemcall = 'cd '//calc%calcspace//' &&'\n      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%binary)\n    else\n      calc%systemcall = trim(calc%binary)\n    end if\n\n    !>--- add other call information\n    calc%systemcall = trim(calc%systemcall)//' '//xyzn\n    !>--- chrg and uhf\n    if (calc%chrg .ne. 0) then\n      write (num,'(i0)') calc%chrg\n      calc%systemcall = trim(calc%systemcall)//' '//'--chrg'\n      calc%systemcall = trim(calc%systemcall)//' '//trim(num)\n    end if\n    if (calc%uhf .ne. 0) then\n      write (num,'(i0)') calc%uhf\n      calc%systemcall = trim(calc%systemcall)//' '//'--uhf'\n      calc%systemcall = trim(calc%systemcall)//' '//trim(num)\n    end if\n    !>--- user-set flags\n    if (allocated(calc%other)) then\n      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%other)\n    end if\n    !>--- don't miss the --grad flag!\n    if (index(calc%systemcall,'-grad') .eq. 0) then\n      calc%systemcall = trim(calc%systemcall)//' '//'--grad'\n    end if\n\n    !>--- add printout information\n    calc%systemcall = trim(calc%systemcall)//' '//'> xtb.out'\n    calc%systemcall = trim(calc%systemcall)//dev0\n\n    !write (*,*) calc%systemcall\n    return\n  end subroutine xtb_setup\n\n!========================================================================================!\n! subroutine rd_xtb_engrad\n! read xtb's energy and Cartesian gradient from file\n! xtb's *.engrad format is used for this\n  subroutine rd_xtb_engrad(mol,calc,energy,grad,iostatus)\n    use iso_fortran_env,only:wp => real64\n    use strucrd\n    use calc_type\n    use iomod,only:makedir,directory_exist,remove\n    use gradreader_module, only:rd_grad_engrad\n\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n    integer :: n,c\n    real(wp) :: dum\n    character(len=128) :: atmp\n\n    integer :: i,j,k,ich,och,io\n    logical :: ex\n\n    call initsignal()\n\n    iostatus = 0\n\n    if (.not. allocated(calc%gradfile)) then\n      if (allocated(calc%calcspace)) then\n        calc%gradfile = trim(calc%calcspace)//sep//gf\n      else\n        calc%gradfile = gf\n      end if\n    end if\n\n    inquire (file=calc%gradfile,exist=ex)\n    if (.not. ex) then\n      iostatus = 1\n      return\n    end if\n\n    c = 0\n    open (newunit=ich,file=calc%gradfile)\n    call rd_grad_engrad(ich,mol%nat,energy,grad,iostatus)\n    close (ich)\n\n    return\n  end subroutine rd_xtb_engrad\n!========================================================================================!\n! subroutine rd_xtb_wbo\n! helper routine ro read xtb WBOs\n  subroutine rd_xtb_wbo(mol,calc,iostatus)\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    integer,intent(out) :: iostatus\n    integer :: i,j\n    real(wp) :: dum\n    character(len=:),allocatable :: wbofile\n    character(len=128) :: atmp\n\n    call initsignal()\n\n    iostatus = 0\n\n    if (calc%rdwbo) then\n      if (allocated(calc%calcspace)) then\n        wbofile = trim(calc%calcspace)//sep//'wbo'\n      else\n        wbofile = 'wbo'\n      end if\n    else\n      return\n    end if\n\n    inquire (file=wbofile,exist=ex)\n    if (.not. ex) then\n      iostatus = 1\n      return\n    end if\n\n    if (allocated(calc%wbo)) deallocate (calc%wbo)\n    allocate (calc%wbo(mol%nat,mol%nat),source=0.0_wp)\n\n    open (newunit=ich,file=wbofile)\n    do\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      read (atmp,*) i,j,dum\n      calc%wbo(i,j) = dum\n      calc%wbo(j,i) = dum\n    end do\n    close (ich)\n\n  end subroutine rd_xtb_wbo\n\n!========================================================================================!\nend module xtb_sc\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/xtb_sc.f90 b/src/calculator/xtb_sc.f90
--- a/src/calculator/xtb_sc.f90	
+++ b/src/calculator/xtb_sc.f90	
@@ -17,26 +17,19 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-!====================================================!
-! module xtb_sc
-! A module containing routines for
-! system calls to the xtb code
-!====================================================!
+!> module xtb_sc
+!> A module containing routines for
+!> system calls to the xtb code
 
+!=========================================================================================!
 module xtb_sc
-
   use iso_fortran_env,only:wp => real64
   use strucrd
   use calc_type
   use iomod,only:makedir,directory_exist,remove,command
   implicit none
-
-!=========================================================================================!
-  !--- private module variables and parameters
+  !>--- private module variables and parameters
   private
-  integer :: i,j,k,l,ich,och,io
-  logical :: ex
-
   integer,parameter :: nf = 3
   character(len=*),parameter :: xtbfiles(nf) = [&
           & 'charges    ','xtbinp.grad','xtbrestart ']
@@ -46,7 +39,6 @@
 
   public :: xtb_engrad
 
-
 !========================================================================================!
 !========================================================================================!
 contains  !>--- Module routines start here
@@ -67,8 +59,11 @@
     real(wp),intent(inout) :: grad(3,mol%nat)
     integer,intent(out) :: iostatus
 
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
+
     iostatus = 0
-    
+
     !>--- setup system call information
     !$omp critical
     call xtb_setup(mol,calc)
@@ -76,7 +71,7 @@
 
     !>--- do the systemcall
     call initsignal()
-    call command(calc%systemcall, iostatus)
+    call command(calc%systemcall,iostatus)
     if (iostatus /= 0) return
 
     !>--- read energy and gradient
@@ -115,14 +110,14 @@
     call initsignal()
 
     !>--- set default binary if not present
-    if (.not. allocated(calc%binary)) then
+    if (.not.allocated(calc%binary)) then
       calc%binary = xtb
     end if
 
     !>--- check for the calculation space
     if (allocated(calc%calcspace)) then
       ex = directory_exist(calc%calcspace)
-      if (.not. ex) then
+      if (.not.ex) then
         io = makedir(trim(calc%calcspace))
       end if
       cpath = calc%calcspace
@@ -131,13 +126,13 @@
     end if
     !>--- cleanup old files
     do i = 1,nf
-      !write(*,*) trim(cpath)//sep//trim(xtbfiles(i)) 
+      !write(*,*) trim(cpath)//sep//trim(xtbfiles(i))
       call remove(trim(cpath)//sep//trim(xtbfiles(i)))
     end do
     deallocate (cpath)
 
     !>--- construct path information and write coord file
-    if (.not. allocated(calc%calcfile)) then
+    if (.not.allocated(calc%calcfile)) then
       if (allocated(calc%calcspace)) then
         l = len_trim(calc%calcspace)
         fname = trim(calc%calcspace)
@@ -156,8 +151,10 @@
     call mol%write(fname)
     deallocate (fname)
 
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
     !>--- if the systemcall was already set up, return
     if (allocated(calc%systemcall)) return
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
 
     !>--- construct path information for sys-call
     if (allocated(calc%calcspace)) then
@@ -206,7 +203,7 @@
     use strucrd
     use calc_type
     use iomod,only:makedir,directory_exist,remove
-    use gradreader_module, only:rd_grad_engrad
+    use gradreader_module,only:rd_grad_engrad
 
     implicit none
     type(coord) :: mol
@@ -225,7 +222,7 @@
 
     iostatus = 0
 
-    if (.not. allocated(calc%gradfile)) then
+    if (.not.allocated(calc%gradfile)) then
       if (allocated(calc%calcspace)) then
         calc%gradfile = trim(calc%calcspace)//sep//gf
       else
@@ -234,7 +231,7 @@
     end if
 
     inquire (file=calc%gradfile,exist=ex)
-    if (.not. ex) then
+    if (.not.ex) then
       iostatus = 1
       return
     end if
@@ -254,11 +251,13 @@
     type(coord) :: mol
     type(calculation_settings) :: calc
     integer,intent(out) :: iostatus
-    integer :: i,j
+
     real(wp) :: dum
     character(len=:),allocatable :: wbofile
     character(len=128) :: atmp
 
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
     call initsignal()
 
     iostatus = 0
@@ -274,7 +273,7 @@
     end if
 
     inquire (file=wbofile,exist=ex)
-    if (.not. ex) then
+    if (.not.ex) then
       iostatus = 1
       return
     end if
Index: src/calculator/gradreader.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nmodule gradreader_module\n\n  use iso_fortran_env,only:wp => real64\n  implicit none\n\n!=========================================================================================!\n  !--- private module variables and parameters\n  private\n\n\n   !> Type enumerator\n   type :: enum_filetype\n      integer :: unknown   = 0\n      integer :: engrad    = 1\n      integer :: orca      = 1\n      integer :: turbomole = 2\n   end type enum_filetype\n   type(enum_filetype), parameter :: gradtype = enum_filetype()\n\n\n\n  public :: gradtype\n  public :: conv2gradfmt\n  public :: rd_efile\n  public :: rd_grad_engrad\n  public :: rd_grad_generic\n\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n\n!========================================================================================!\n!> subrotuine rd_grad_engrad\n!> read *.engrad file (used e.g. by xtb and orca)\n!> all comments (#) are ignored\n!> first number read should be number of atoms\n!> followed by 3N lines á 1 float for the gradient\n!>---------------------------------------------------\n  subroutine rd_efile(fname,energy,iostatus)\n    implicit none\n    character(len=*),intent(in) :: fname\n    real(wp),intent(out) :: energy\n    integer,intent(out) :: iostatus\n    integer :: c, iunit, n, i,j\n    character(len=128) :: atmp\n    real(wp) :: dum\n    energy=0.0_wp\n    iostatus = 0\n    open(newunit=iunit,file=fname)\n    read(iunit,*,iostat=iostatus) energy\n    close(iunit)\n  end subroutine rd_efile\n\n\n!========================================================================================!\n!> subrotuine rd_grad_engrad\n!> read *.engrad file (used e.g. by xtb and orca)\n!> all comments (#) are ignored\n!> first number read should be number of atoms\n!> followed by 3N lines á 1 float for the gradient\n!>---------------------------------------------------\n  subroutine rd_grad_engrad(iunit,nat,energy,grad,iostatus)\n    implicit none\n    integer,intent(in) :: iunit\n    integer,intent(in) :: nat\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: grad(3,nat)\n    integer,intent(out) :: iostatus\n    integer :: c, io, n, i,j   \n    character(len=128) :: atmp\n    real(wp) :: dum\n\n    iostatus = 0\n    energy  = 0.0_wp\n    grad(:,:) = 0.0_wp\n\n    c = 0\n    do\n      read (iunit,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      atmp = adjustl(atmp)\n      if (atmp(1:1) == '#') cycle\n      if (c == 0) then\n        read (atmp,*) n\n        if (n /= nat) then\n          iostatus = 2\n          exit\n        end if\n        c = c + 1\n      else if (c == 1) then\n        read (atmp,*) energy\n        c = c + 1\n        cycle\n      else if (c == 2) then\n        backspace (iunit)\n        do i = 1,n\n          do j = 1,3\n            read (iunit,*,iostat=io) dum\n            if (io < 0) then\n              iostatus = 3\n              exit\n            end if\n            grad(j,i) = dum\n          end do\n        end do\n        c = c + 1\n      else if (c >= 3) then\n        exit\n      end if\n    end do\n\n\n    return\n  end subroutine rd_grad_engrad\n\n\n !========================================================================================!\n!> subrotuine rd_grad_engrad\n!> read unspecified gradient file\n!> routine can look for a (case sensitive) keyword after which the gradient is read\n!> NOTE: routine does not provide the energy\n!>---------------------------------------------------\n  subroutine rd_grad_generic(iunit,nat,grad,gradkey,gradfmt,iostatus)\n    implicit none\n    integer,intent(in) :: iunit\n    integer,intent(in) :: nat\n    real(wp),intent(out) :: grad(3,nat)\n    character(len=*),intent(in) :: gradkey\n    integer,intent(in) :: gradfmt\n    integer,intent(out) :: iostatus\n    integer :: c, io, n, i,j\n    character(len=128) :: atmp\n    real(wp) :: dum\n\n    iostatus = 0\n    grad(:,:) = 0.0_wp\n\n    c = 0\n    do\n      read (iunit,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      atmp = adjustl(atmp)\n      if (atmp(1:1) == '#') cycle\n      if (index(atmp,gradkey).ne.0)then\n        c = c + 1\n        if( gradfmt == 0)then\n          call rd_grad_3n(iunit,nat,grad,iostatus)\n        else\n          call rd_grad_n3(iunit,nat,grad,iostatus)\n        endif\n      endif\n      if (c >= 1) then\n        exit\n      end if\n    end do\n\n  end subroutine rd_grad_generic \n   \n\n!========================================================================================!\n!> subrotuine rd_grad_3n/rd_grad_n3\n!> read 3N lines into grad or N lines á 3 entries\n!>---------------------------------------------------\n  subroutine rd_grad_3n(iunit,nat,grad,iostatus)\n    implicit none\n    integer,intent(in) :: iunit\n    integer,intent(in) :: nat\n    real(wp),intent(out) :: grad(3,nat)\n    integer,intent(out) :: iostatus\n    integer :: c, io, n, i,j\n    character(len=128) :: atmp\n    real(wp) :: dum\n\n    iostatus = 0\n    grad(:,:) = 0.0_wp\n\n    c = 0\n    do i = 1,n\n      do j = 1,3\n        read (iunit,*,iostat=io) dum\n        if (io < 0) then\n          iostatus = 3\n          exit\n        end if\n        grad(j,i) = dum\n      end do\n    end do\n\n    return\n  end subroutine rd_grad_3n\n  subroutine rd_grad_n3(iunit,nat,grad,iostatus)\n    implicit none\n    integer,intent(in) :: iunit\n    integer,intent(in) :: nat\n    real(wp),intent(out) :: grad(3,nat)\n    integer,intent(out) :: iostatus\n    integer :: c, io, n, i,j\n    character(len=128) :: atmp\n    real(wp) :: dum(3)\n\n    iostatus = 0\n    grad(:,:) = 0.0_wp\n\n    c = 0\n    do i = 1,n\n      read (iunit,*,iostat=io) dum(1:3)\n      if (io < 0) then\n        iostatus = 3\n        exit\n      end if\n      grad(:,i) = dum(:)\n    end do\n\n    return\n  end subroutine rd_grad_n3\n\n!========================================================================================!\n!> utility function, determine whether to\n!> read 3N lines into grad or N lines á 3 entries\n!>---------------------------------------------------\n  function conv2gradfmt(str) result(ifmt)\n    implicit none\n    character(len=*),intent(in) :: str\n    integer :: ifmt\n    ifmt = 0\n    select case (str)\n    case( '3n','3N' )\n      ifmt = 0\n    case( 'N3','n3','n*3','N*3','n;3','N;3')\n      ifmt = 1\n    case default\n      ifmt = 0  \n    end select\n  end function conv2gradfmt\n\nend module gradreader_module\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/gradreader.f90 b/src/calculator/gradreader.f90
--- a/src/calculator/gradreader.f90	
+++ b/src/calculator/gradreader.f90	
@@ -21,29 +21,25 @@
 
   use iso_fortran_env,only:wp => real64
   implicit none
-
-!=========================================================================================!
   !--- private module variables and parameters
   private
 
-
-   !> Type enumerator
-   type :: enum_filetype
-      integer :: unknown   = 0
-      integer :: engrad    = 1
-      integer :: orca      = 1
-      integer :: turbomole = 2
-   end type enum_filetype
-   type(enum_filetype), parameter :: gradtype = enum_filetype()
+  !> Type enumerator
+  type :: enum_filetype
+    integer :: unknown = 0
+    integer :: engrad = 1
+    integer :: orca = 1
+    integer :: turbomole = 2
+  end type enum_filetype
+  type(enum_filetype),parameter :: gradtype = enum_filetype()
 
-
-
   public :: gradtype
   public :: conv2gradfmt
   public :: rd_efile
   public :: rd_grad_engrad
   public :: rd_grad_generic
-
+  public :: rd_grad_tm
+  public :: write_engrad
 
 !========================================================================================!
 !========================================================================================!
@@ -51,50 +47,81 @@
 !========================================================================================!
 !========================================================================================!
 
+  subroutine write_engrad(fname,energy,grad)
+!***************************************************
+!* subroutine write_engrad
+!* write energy and gradient in the .engrad format
+!***************************************************
+    implicit none
+    character(len=*),intent(in) :: fname
+    real(wp),intent(in) :: energy
+    real(wp),intent(in) :: grad(:,:)
+    integer :: c,ich,n,i,j
+    real(wp) :: dum
+
+    n = size(grad,2)
+    open (newunit=ich,file=fname)
+    write(ich,'(a)') '#'
+    write(ich,'(a)') '# Atoms'
+    write(ich,'(a)') '#'
+    write(ich,'(5x,i0)') n
+    write(ich,'(a)') '#'
+    write(ich,'(a)') '# Energy ( Eh )'
+    write(ich,'(a)') '#'
+    write(ich,'(f25.15)') energy
+    write(ich,'(a)') '#'
+    write(ich,'(a)') '# Gradient ( Eh/a0 )'
+    write(ich,'(a)') '#'
+    do i=1,n
+      do j=1,3
+        write(ich,'(f25.15)') grad(j,i)
+      enddo
+    enddo
+    close (ich)
+  end subroutine write_engrad
 
 !========================================================================================!
-!> subrotuine rd_grad_engrad
-!> read *.engrad file (used e.g. by xtb and orca)
-!> all comments (#) are ignored
-!> first number read should be number of atoms
-!> followed by 3N lines á 1 float for the gradient
-!>---------------------------------------------------
+
   subroutine rd_efile(fname,energy,iostatus)
+!***************************************************
+!* subroutine rd_efile
+!* read the energy from a file containing only that
+!***************************************************
     implicit none
     character(len=*),intent(in) :: fname
     real(wp),intent(out) :: energy
     integer,intent(out) :: iostatus
-    integer :: c, iunit, n, i,j
+    integer :: c,iunit,n,i,j
     character(len=128) :: atmp
     real(wp) :: dum
-    energy=0.0_wp
+    energy = 0.0_wp
     iostatus = 0
-    open(newunit=iunit,file=fname)
-    read(iunit,*,iostat=iostatus) energy
-    close(iunit)
+    open (newunit=iunit,file=fname)
+    read (iunit,*,iostat=iostatus) energy
+    close (iunit)
   end subroutine rd_efile
 
-
 !========================================================================================!
-!> subrotuine rd_grad_engrad
-!> read *.engrad file (used e.g. by xtb and orca)
-!> all comments (#) are ignored
-!> first number read should be number of atoms
-!> followed by 3N lines á 1 float for the gradient
-!>---------------------------------------------------
   subroutine rd_grad_engrad(iunit,nat,energy,grad,iostatus)
+!**************************************************
+!* subrotuine rd_grad_engrad
+!* read *.engrad file (used e.g. by xtb and orca)
+!* all comments (#) are ignored
+!* first number read should be number of atoms
+!* followed by 3N lines á 1 float for the gradient
+!**************************************************
     implicit none
     integer,intent(in) :: iunit
     integer,intent(in) :: nat
     real(wp),intent(out) :: energy
     real(wp),intent(out) :: grad(3,nat)
     integer,intent(out) :: iostatus
-    integer :: c, io, n, i,j   
+    integer :: c,io,n,i,j
     character(len=128) :: atmp
     real(wp) :: dum
 
     iostatus = 0
-    energy  = 0.0_wp
+    energy = 0.0_wp
     grad(:,:) = 0.0_wp
 
     c = 0
@@ -109,10 +136,10 @@
           iostatus = 2
           exit
         end if
-        c = c + 1
+        c = c+1
       else if (c == 1) then
         read (atmp,*) energy
-        c = c + 1
+        c = c+1
         cycle
       else if (c == 2) then
         backspace (iunit)
@@ -126,24 +153,69 @@
             grad(j,i) = dum
           end do
         end do
-        c = c + 1
+        c = c+1
       else if (c >= 3) then
         exit
       end if
     end do
 
-
     return
   end subroutine rd_grad_engrad
 
-
- !========================================================================================!
-!> subrotuine rd_grad_engrad
-!> read unspecified gradient file
-!> routine can look for a (case sensitive) keyword after which the gradient is read
-!> NOTE: routine does not provide the energy
-!>---------------------------------------------------
+!========================================================================================!
+  subroutine rd_grad_tm(iunit,nat,energy,grad,iostatus)
+!**************************************************
+!* subrotuine rd_grad_tm
+!* read a turbomole-type "gradient" file
+!**************************************************
+    implicit none
+    integer,intent(in) :: iunit
+    integer,intent(in) :: nat
+    real(wp),intent(out) :: energy
+    real(wp),intent(out) :: grad(3,nat)
+    integer,intent(out) :: iostatus
+    integer :: c,io,n,i,j
+    character(len=128) :: atmp
+    character(len=20) :: btmp(8)
+    real(wp) :: dum
+    logical :: readblock
+
+    iostatus = 0
+    energy = 0.0_wp
+    grad(:,:) = 0.0_wp
+
+    c = 0
+    readblock = .false.
+    do
+      read (iunit,'(a)',iostat=io) atmp
+      if (io < 0) exit !> EOF exit
+      atmp = adjustl(atmp)
+      if (atmp(1:4) == '$end') readblock = .false.
+      if( readblock ) then      
+        if(index(atmp,'cycle').ne.0)then
+          read(atmp,*) btmp(1:2),j,btmp(3:6),energy,btmp(7:8),dum
+        elseif(c < nat)then !> skip coords
+          c = c + 1  
+        else !> read grad
+          call rd_grad_n3(iunit,nat,grad,iostatus)
+          exit
+        endif
+      endif
+      if (atmp(1:5) == '$grad') readblock = .true.
+    end do
+
+    return
+  end subroutine rd_grad_tm
+
+!========================================================================================!
   subroutine rd_grad_generic(iunit,nat,grad,gradkey,gradfmt,iostatus)
+!**************************************************
+!* subrotuine rd_grad_generic
+!* read unspecified gradient file
+!* routine can look for a (case sensitive) keyword 
+!* after which the gradient is read
+!* NOTE: routine does not provide the energy
+!************************************************** 
     implicit none
     integer,intent(in) :: iunit
     integer,intent(in) :: nat
@@ -151,7 +223,7 @@
     character(len=*),intent(in) :: gradkey
     integer,intent(in) :: gradfmt
     integer,intent(out) :: iostatus
-    integer :: c, io, n, i,j
+    integer :: c,io,n,i,j
     character(len=128) :: atmp
     real(wp) :: dum
 
@@ -164,33 +236,33 @@
       if (io < 0) exit
       atmp = adjustl(atmp)
       if (atmp(1:1) == '#') cycle
-      if (index(atmp,gradkey).ne.0)then
-        c = c + 1
-        if( gradfmt == 0)then
+      if (index(atmp,gradkey) .ne. 0) then
+        c = c+1
+        if (gradfmt == 0) then
           call rd_grad_3n(iunit,nat,grad,iostatus)
         else
           call rd_grad_n3(iunit,nat,grad,iostatus)
-        endif
-      endif
+        end if
+      end if
       if (c >= 1) then
         exit
       end if
     end do
 
-  end subroutine rd_grad_generic 
-   
+  end subroutine rd_grad_generic
 
 !========================================================================================!
-!> subrotuine rd_grad_3n/rd_grad_n3
-!> read 3N lines into grad or N lines á 3 entries
-!>---------------------------------------------------
   subroutine rd_grad_3n(iunit,nat,grad,iostatus)
+!***************************
+!* subrotuine rd_grad_3n
+!* read 3N lines into grad
+!***************************
     implicit none
     integer,intent(in) :: iunit
     integer,intent(in) :: nat
     real(wp),intent(out) :: grad(3,nat)
     integer,intent(out) :: iostatus
-    integer :: c, io, n, i,j
+    integer :: c,io,n,i,j
     character(len=128) :: atmp
     real(wp) :: dum
 
@@ -212,12 +284,16 @@
     return
   end subroutine rd_grad_3n
   subroutine rd_grad_n3(iunit,nat,grad,iostatus)
+!***************************************
+!* subrotuine rd_grad_n3
+!* read gradient as N lines á 3 entries
+!***************************************
     implicit none
     integer,intent(in) :: iunit
     integer,intent(in) :: nat
     real(wp),intent(out) :: grad(3,nat)
     integer,intent(out) :: iostatus
-    integer :: c, io, n, i,j
+    integer :: c,io,n,i,j
     character(len=128) :: atmp
     real(wp) :: dum(3)
 
@@ -238,23 +314,27 @@
   end subroutine rd_grad_n3
 
 !========================================================================================!
-!> utility function, determine whether to
-!> read 3N lines into grad or N lines á 3 entries
-!>---------------------------------------------------
   function conv2gradfmt(str) result(ifmt)
+!*************************************************
+!* utility function, determine whether to
+!* read 3N lines into grad or N lines á 3 entries
+!*************************************************
     implicit none
     character(len=*),intent(in) :: str
     integer :: ifmt
     ifmt = 0
     select case (str)
-    case( '3n','3N' )
+    case ('3n','3N')
       ifmt = 0
-    case( 'N3','n3','n*3','N*3','n;3','N;3')
+    case ('N3','n3','n*3','N*3','n;3','N;3')
       ifmt = 1
     case default
-      ifmt = 0  
+      ifmt = 0
     end select
   end function conv2gradfmt
 
+
+!========================================================================================!
+!========================================================================================!
 end module gradreader_module
 
Index: src/calculator/xhcff.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nmodule xhcff_api\n  use iso_fortran_env,only:wp => real64,stdout => output_unit\n  use strucrd\n#ifdef WITH_XHCFF\n  use xhcff_interface\n#endif\n  implicit none\n  private\n\n#ifndef WITH_XHCFF\n  !> this is a placeholder if no xhcff module is used!\n  type :: xhcff_calculator\n    integer :: id = 0\n  end type xhcff_calculator\n#endif\n\n  public :: xhcff_calculator  !> if compiled without(!!!) -DWITH_XHCFF=true this will export\n                        !> the placeholder from above. Otherwise it will re-export\n                        !> the type from xhcff_interface\n\n\n  public :: xhcff_setup,xhcff_sp,xhcff_print\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n  subroutine xhcff_setup(mol, xhcff, pressure, gridpts, proberad, vdwset, iostatus)\n    implicit none\n    type(coord),intent(in)  :: mol\n    real(wp), intent(in) :: pressure !> pressure\n    integer, intent(in) :: gridpts\n    real(wp), intent(in) :: proberad\n    integer, intent(in) :: vdwset\n    type(xhcff_calculator),intent(inout) :: xhcff\n    integer, intent(inout) :: iostatus\n#ifdef WITH_XHCFF\n    !> initialize XHCFF\n    call xhcff%init(mol%nat,mol%at,mol%xyz, &\n     & pressure, gridpts, proberad, verbose=.false.,vdwset=vdwset,iostat=iostatus)\n\n#else /* WITH_XHCFF */\n    write (stdout,*) 'Error: Compiled without XHCFF-lib support!'\n    write (stdout,*) 'Use -DWITH_XHCFF=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine xhcff_setup\n\n!========================================================================================!\n\n  subroutine xhcff_sp(mol,xhcff,energy,gradient,iostatus)\n!********************************************************\n!* The actual energy+gradient call to xhcff-lib.\n!* Requires the xhcff_calculator object to be set up already.\n!* Note that the original xhcff has no contribution to\n!* the energy, only to the gradient\n!********************************************************\n    implicit none\n    !> INPUT\n    type(coord),intent(in)  :: mol\n    type(xhcff_calculator),intent(inout) :: xhcff\n    !> OUTPUT\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: gradient(3,mol%nat)\n    integer,intent(out) :: iostatus\n    !> LOCAL\n    logical :: fail\n    energy = 0.0_wp\n    gradient = 0.0_wp\n    iostatus = 0\n    fail = .false.\n#ifdef WITH_XHCFF\n!TODO update\n     call xhcff%singlepoint(mol%nat,mol%at,mol%xyz,energy,gradient,iostatus)\n#else\n    write (stdout,*) 'Error: Compiled without XHCFF-lib support!'\n    write (stdout,*) 'Use -DWITH_XHCFF=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine xhcff_sp\n\n!========================================================================================!\n\n  subroutine xhcff_print(iunit,xhcff)\n    implicit none\n    integer,intent(in) :: iunit\n    type(xhcff_calculator),intent(in) :: xhcff\n#ifdef WITH_XHCFF\n    call xhcff%info(iunit)\n#endif\n    return\n  end subroutine xhcff_print\n\n!========================================================================================!\n!========================================================================================!\nend module xhcff_api\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/xhcff.F90 b/src/calculator/xhcff.F90
--- a/src/calculator/xhcff.F90	
+++ b/src/calculator/xhcff.F90	
@@ -46,7 +46,7 @@
 !========================================================================================!
 !========================================================================================!
 
-  subroutine xhcff_setup(mol, xhcff, pressure, gridpts, proberad, vdwset, iostatus)
+  subroutine xhcff_setup(mol, xhcff, pressure, gridpts, proberad, vdwset, pr, iunit, iostatus)
     implicit none
     type(coord),intent(in)  :: mol
     real(wp), intent(in) :: pressure !> pressure
@@ -55,10 +55,12 @@
     integer, intent(in) :: vdwset
     type(xhcff_calculator),intent(inout) :: xhcff
     integer, intent(inout) :: iostatus
+    logical, intent(in) :: pr
+    integer,intent(in) :: iunit
 #ifdef WITH_XHCFF
     !> initialize XHCFF
     call xhcff%init(mol%nat,mol%at,mol%xyz, &
-     & pressure, gridpts, proberad, verbose=.false.,vdwset=vdwset,iostat=iostatus)
+     & pressure, gridpts, proberad, verbose=pr,iunit=iunit,vdwset=vdwset,iostat=iostatus)
 
 #else /* WITH_XHCFF */
     write (stdout,*) 'Error: Compiled without XHCFF-lib support!'
Index: src/calculator/tblite_api.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!====================================================!\n! module tblite_api\n! An interface of CREST to tblite\n!====================================================!\n\nmodule tblite_api\n  use iso_fortran_env,only:wp => real64,stdout => output_unit\n  use strucrd\n#ifdef WITH_TBLITE\n  use mctc_env,only:error_type\n  use mctc_io,only:structure_type,new\n  use tblite_context_type,only:tblite_ctx => context_type\n  use tblite_wavefunction_type,only:wavefunction_type,new_wavefunction\n  use tblite_wavefunction,only:sad_guess,eeq_guess\n  use tblite_xtb_calculator,only:tblite_calculator => xtb_calculator\n  use tblite_xtb_gfn2,only:new_gfn2_calculator\n  use tblite_xtb_gfn1,only:new_gfn1_calculator\n  use tblite_xtb_ipea1,only:new_ipea1_calculator\n  use tblite_xtb_singlepoint,only:xtb_singlepoint\n  use tblite_results,only:tblite_resultstype => results_type\n#endif\n  use wiberg_mayer,only:get_wbo\n  implicit none\n  private\n\n#ifndef WITH_TBLITE\n  !> these are placeholders if no tblite is used!\n  type :: wavefunction_type\n    integer :: id = 0\n  end type wavefunction_type\n  type :: tblite_calculator\n    integer :: id = 0\n  end type tblite_calculator\n  type :: tblite_ctx\n    integer :: unit = stdout\n  end type tblite_ctx\n  type :: tblite_resultstype\n    integer :: id = 0\n  end type tblite_resultstype\n  type :: tblite_solvation_type\n    integer :: id = 0\n  end type tblite_solvation_type\n#endif\n\n  !> Type enumerator\n  type :: enum_tblite_method\n    integer :: unknown = 0\n    integer :: gfn1 = 1\n    integer :: gfn2 = 2\n    integer :: ipea1 = 3\n  end type enum_tblite_method\n  type(enum_tblite_method),parameter,public :: xtblvl = enum_tblite_method()\n\n  !> Conversion factor from Kelvin to Hartree\n  real(wp),parameter :: ktoau = 3.166808578545117e-06_wp\n\n  integer :: verbosity = 0 \n  !> IMPORTANT: tblite is not entirely thread-safe\n  !> if verbosity is >0. We'll have to turn it off.\n  !> At least for statically compiled binaries\n\n  public :: wavefunction_type,tblite_calculator\n  public :: tblite_ctx,tblite_resultstype\n  public :: tblite_setup,tblite_singlepoint,tblite_addsettings\n  public :: tblite_getwbos\n  public :: tblite_add_solv\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n  subroutine tblite_setup(mol,chrg,uhf,lvl,etemp,ctx,wfn,tbcalc)\n    implicit none\n    type(coord),intent(in)  :: mol\n    integer,intent(in)      :: chrg\n    integer,intent(in)      :: uhf\n    integer,intent(in)      :: lvl\n    real(wp),intent(in)     :: etemp\n    type(tblite_ctx)        :: ctx\n    type(wavefunction_type) :: wfn\n    type(tblite_calculator) :: tbcalc\n#ifdef WITH_TBLITE\n    type(structure_type) :: mctcmol\n    type(error_type),allocatable :: error\n\n    real(wp) :: etemp_au,energy\n    real(wp),allocatable :: grad(:,:)\n\n    !>--- make an mctcmol object from mol\n    call tblite_mol2mol(mol,chrg,uhf,mctcmol)\n\n    !>--- select parametrization and set up calculator\n    select case (lvl)\n    case (xtblvl%gfn1)\n      call ctx%message(\"tblite> setting up GFN1-xTB calculation\")\n      call new_gfn1_calculator(tbcalc,mctcmol)\n    case (xtblvl%gfn2)\n      call ctx%message(\"tblite> setting up GFN2-xTB calculation\")\n      call new_gfn2_calculator(tbcalc,mctcmol)\n    case (xtblvl%ipea1)\n      call ctx%message(\"tblite> setting up IPEA1-xTB calculation\")\n      call new_ipea1_calculator(tbcalc,mctcmol)\n    case default\n      call ctx%message(\"Error: Unknown method in tblite!\")\n      error stop\n    end select\n\n    !>-- setup wavefunction object\n    etemp_au = etemp*ktoau\n    call new_wavefunction(wfn,mol%nat,tbcalc%bas%nsh,  &\n    &              tbcalc%bas%nao,1,etemp_au)\n\n#else /* WITH_TBLITE */\n    write (stdout,*) 'Error: Compiled without tblite support!'\n    write (stdout,*) 'Use -DWITH_TBLITE=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine tblite_setup\n\n!========================================================================================!\n\n  subroutine tblite_add_solv(mol,chrg,uhf,ctx,wfn,tbcalc,smodel,solvent)\n#ifdef WITH_TBLITE\n    use tblite_container,only:container_type\n    use tblite_solvation,only:new_solvation,tblite_solvation_type => solvation_type, &\n    &                            solvent_data,get_solvent_data,solvation_input,  &\n    &                            cpcm_input,alpb_input,alpb_solvation\n#endif\n    implicit none\n    type(coord),intent(in)  :: mol\n    integer,intent(in)      :: chrg\n    integer,intent(in)      :: uhf\n    type(tblite_ctx)        :: ctx\n    type(wavefunction_type) :: wfn\n    type(tblite_calculator) :: tbcalc\n    character(len=:),allocatable,intent(in) :: smodel\n    character(len=:),allocatable,intent(in) :: solvent\n#ifdef WITH_TBLITE\n    type(structure_type) :: mctcmol\n    type(error_type),allocatable :: error\n\n    class(container_type),allocatable :: cont\n    class(tblite_solvation_type),allocatable :: solv\n    type(solvation_input),allocatable :: solv_inp\n    type(solvent_data) :: solv_data\n    character(len=:),allocatable :: str\n\n    real(wp) :: etemp_au,energy\n\n    if (.not.allocated(smodel).or..not.allocated(solvent)) then\n      return\n    end if\n\n    !>--- make an mctcmol object from mol\n    call tblite_mol2mol(mol,chrg,uhf,mctcmol)\n\n    call ctx%message(\"tblite> setting up tblite implicit solvation\")\n    !>--- generat solvation parametrization\n    solv_data = get_solvent_data(solvent)\n    if (solv_data%eps <= 0.0_wp) then\n      call ctx%message(\"tblite> Unknown solvent!\")\n      return\n    end if\n    allocate (solv_inp)\n    select case (trim(smodel))\n    case ('gbsa')\n      call ctx%message(\"tblite> using GBSA/\"//solvent)\n      allocate (solv_inp%alpb)\n      solv_inp%alpb = alpb_input(solv_data%eps,alpb=.false.)\n    case ('cpcm')\n      call ctx%message(\"tblite> using CPCM/\"//solvent)\n      allocate (solv_inp%cpcm)\n      solv_inp%cpcm = cpcm_input(solv_data%eps)\n    case ('alpb')\n      call ctx%message(\"tblite> using ALPB/\"//solvent)\n      allocate (solv_inp%alpb)\n      solv_inp%alpb = alpb_input(solv_data%eps,alpb=.true.)\n    case default\n      call ctx%message(\"tblite> Unknown tblite implicit solvation model!\")\n      return\n    end select\n    str = 'tblite> WARNING: implicit solvation energies are not entirely '// &\n    &'consistent with the xtb implementation.'\n    call ctx%message(str)\n\n!>--- add to calculator\n    call new_solvation(solv,mctcmol,solv_inp,error)\n    if (allocated(error)) then\n      call ctx%message(\"tblite> failed to set up tblite implicit solvation!\")\n      return\n    end if\n    call move_alloc(solv,cont)\n    call tbcalc%push_back(cont)\n\n    deallocate (solv_inp)\n\n#else /* WITH_TBLITE */\n    write (stdout,*) 'Error: Compiled without tblite support!'\n    write (stdout,*) 'Use -DWITH_TBLITE=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine tblite_add_solv\n\n!========================================================================================!\n\n  subroutine tblite_singlepoint(mol,chrg,uhf,accuracy,ctx,wfn,tbcalc,energy,gradient,tbres,iostatus)\n    implicit none\n    type(coord),intent(in)   :: mol\n    integer,intent(in)       :: chrg\n    integer,intent(in)       :: uhf\n    real(wp),intent(in)      :: accuracy\n    type(tblite_ctx)         :: ctx\n    type(wavefunction_type)  :: wfn\n    type(tblite_calculator)  :: tbcalc\n    real(wp),intent(out)     :: energy\n    real(wp),intent(out)     :: gradient(3,mol%nat)\n    type(tblite_resultstype) :: tbres\n    integer,intent(out)      :: iostatus\n#ifdef WITH_TBLITE\n    type(structure_type) :: mctcmol\n    type(error_type),allocatable :: error\n    real(wp) :: sigma(3,3)\n\n    iostatus = 0\n    energy = 0.0_wp\n    gradient(:,:) = 0.0_wp\n\n    !>--- make an mctcmol object from mol\n    call tblite_mol2mol(mol,chrg,uhf,mctcmol)\n\n    !>--- call the singlepoint routine\n    call xtb_singlepoint(ctx,mctcmol,tbcalc,wfn,accuracy,energy,gradient, &\n    & sigma,verbosity,results=tbres)\n\n    if (ctx%failed()) then\n      ! Tear down the error stack to send the actual error messages back\n      call ctx%message(\"tblite> Singlepoint calculation failed\")\n      iostatus = 1\n    end if\n\n#else /* WITH_TBLITE */\n    iostatus = 0\n    energy = 0.0_wp\n    gradient(:,:) = 0.0_wp\n    write (stdout,*) 'Error: Compiled without tblite support!'\n    write (stdout,*) 'Use -DWITH_TBLITE=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine tblite_singlepoint\n\n!========================================================================================!\n#ifdef WITH_TBLITE\n  subroutine tblite_mol2mol(mol,chrg,uhf,mctcmol)\n    implicit none\n    !> input & output\n    type(coord) :: mol\n    integer,intent(in) :: chrg\n    integer,intent(in) :: uhf\n    type(structure_type),intent(out) :: mctcmol\n    !> locals\n    real(wp) :: fchrg\n\n    fchrg = real(chrg,wp)\n\n    !>--- make an mctcmol object from mol\n    if (.not.allocated(mol%lat)) then\n      call new(mctcmol,mol%at,mol%xyz,charge=fchrg,uhf=uhf)\n    else\n      call new(mctcmol,mol%at,mol%xyz,charge=fchrg,uhf=uhf,lattice=mol%lat)\n    end if\n\n  end subroutine tblite_mol2mol\n#endif\n!========================================================================================!\n!> tblite_addsettings is used to add other settings from\n!> CRESTs calculation object to the tblite_calculator\n  subroutine tblite_addsettings(tbcalc,maxscc,rdwbo,saveint)\n    implicit none\n    type(tblite_calculator),intent(inout) :: tbcalc\n    integer,intent(in) :: maxscc\n    logical,intent(in) :: rdwbo\n    logical,intent(in) :: saveint\n#ifdef WITH_TBLITE\n    tbcalc%max_iter = maxscc\n    tbcalc%save_integrals = (rdwbo.or.saveint)\n#endif\n  end subroutine tblite_addsettings\n!========================================================================================!\n!> obtain wbos from tblite\n  subroutine tblite_getwbos(tbcalc,wfn,tbres,nat,wbo)\n    implicit none\n    type(tblite_calculator),intent(in) :: tbcalc\n    type(wavefunction_type)  :: wfn\n    type(tblite_resultstype),intent(in) :: tbres\n    integer,intent(in) :: nat\n    real(wp),intent(out) :: wbo(nat,nat)\n\n    wbo = 0.0_wp\n#ifdef WITH_TBLITE\n    call get_wbo(nat,tbcalc%bas%nao,wfn%density, &\n    &         tbres%overlap,tbcalc%bas%ao2at,wbo)\n#endif\n  end subroutine tblite_getwbos\n\n!========================================================================================!\nend module tblite_api\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/tblite_api.F90 b/src/calculator/tblite_api.F90
--- a/src/calculator/tblite_api.F90	
+++ b/src/calculator/tblite_api.F90	
@@ -31,14 +31,10 @@
   use tblite_context_type,only:tblite_ctx => context_type
   use tblite_wavefunction_type,only:wavefunction_type,new_wavefunction
   use tblite_wavefunction,only:sad_guess,eeq_guess
-  use tblite_xtb_calculator,only:tblite_calculator => xtb_calculator
-  use tblite_xtb_gfn2,only:new_gfn2_calculator
-  use tblite_xtb_gfn1,only:new_gfn1_calculator
-  use tblite_xtb_ipea1,only:new_ipea1_calculator
-  use tblite_xtb_singlepoint,only:xtb_singlepoint
+  use tblite_xtb, tblite_calculator => xtb_calculator 
   use tblite_results,only:tblite_resultstype => results_type
 #endif
-  use wiberg_mayer,only:get_wbo
+  use wiberg_mayer,only:get_wbo_rhf
   implicit none
   private
 
@@ -52,6 +48,7 @@
   end type tblite_calculator
   type :: tblite_ctx
     integer :: unit = stdout
+    integer :: verbosity = 0
   end type tblite_ctx
   type :: tblite_resultstype
     integer :: id = 0
@@ -61,6 +58,15 @@
   end type tblite_solvation_type
 #endif
 
+!>--- tblite calculator bundle
+  type :: tblite_data
+    type(wavefunction_type)     :: wfn
+    type(tblite_calculator)     :: calc
+    type(tblite_ctx)            :: ctx
+    type(tblite_resultstype)    :: res
+  end type tblite_data
+  public :: tblite_data
+
   !> Type enumerator
   type :: enum_tblite_method
     integer :: unknown = 0
@@ -106,6 +112,9 @@
 
     real(wp) :: etemp_au,energy
     real(wp),allocatable :: grad(:,:)
+    logical :: pr
+
+    pr = (ctx%verbosity > 0)
 
     !>--- make an mctcmol object from mol
     call tblite_mol2mol(mol,chrg,uhf,mctcmol)
@@ -113,13 +122,13 @@
     !>--- select parametrization and set up calculator
     select case (lvl)
     case (xtblvl%gfn1)
-      call ctx%message("tblite> setting up GFN1-xTB calculation")
+      if(pr) call ctx%message("tblite> setting up GFN1-xTB calculation")
       call new_gfn1_calculator(tbcalc,mctcmol)
     case (xtblvl%gfn2)
-      call ctx%message("tblite> setting up GFN2-xTB calculation")
+      if(pr) call ctx%message("tblite> setting up GFN2-xTB calculation")
       call new_gfn2_calculator(tbcalc,mctcmol)
     case (xtblvl%ipea1)
-      call ctx%message("tblite> setting up IPEA1-xTB calculation")
+      if(pr) call ctx%message("tblite> setting up IPEA1-xTB calculation")
       call new_ipea1_calculator(tbcalc,mctcmol)
     case default
       call ctx%message("Error: Unknown method in tblite!")
@@ -165,6 +174,7 @@
     type(solvation_input),allocatable :: solv_inp
     type(solvent_data) :: solv_data
     character(len=:),allocatable :: str
+    logical :: pr
 
     real(wp) :: etemp_au,energy
 
@@ -172,42 +182,44 @@
       return
     end if
 
+    pr = (ctx%verbosity > 0)
+
     !>--- make an mctcmol object from mol
     call tblite_mol2mol(mol,chrg,uhf,mctcmol)
 
-    call ctx%message("tblite> setting up tblite implicit solvation")
+    if(pr) call ctx%message("tblite> setting up tblite implicit solvation")
     !>--- generat solvation parametrization
     solv_data = get_solvent_data(solvent)
     if (solv_data%eps <= 0.0_wp) then
-      call ctx%message("tblite> Unknown solvent!")
+      if(pr) call ctx%message("tblite> Unknown solvent!")
       return
     end if
     allocate (solv_inp)
     select case (trim(smodel))
     case ('gbsa')
-      call ctx%message("tblite> using GBSA/"//solvent)
+      if(pr) call ctx%message("tblite> using GBSA/"//solvent)
       allocate (solv_inp%alpb)
       solv_inp%alpb = alpb_input(solv_data%eps,alpb=.false.)
     case ('cpcm')
-      call ctx%message("tblite> using CPCM/"//solvent)
+      if(pr) call ctx%message("tblite> using CPCM/"//solvent)
       allocate (solv_inp%cpcm)
       solv_inp%cpcm = cpcm_input(solv_data%eps)
     case ('alpb')
-      call ctx%message("tblite> using ALPB/"//solvent)
+      if(pr) call ctx%message("tblite> using ALPB/"//solvent)
       allocate (solv_inp%alpb)
       solv_inp%alpb = alpb_input(solv_data%eps,alpb=.true.)
     case default
-      call ctx%message("tblite> Unknown tblite implicit solvation model!")
+      if(pr) call ctx%message("tblite> Unknown tblite implicit solvation model!")
       return
     end select
     str = 'tblite> WARNING: implicit solvation energies are not entirely '// &
     &'consistent with the xtb implementation.'
-    call ctx%message(str)
+    if(pr) call ctx%message(str)
 
 !>--- add to calculator
     call new_solvation(solv,mctcmol,solv_inp,error)
     if (allocated(error)) then
-      call ctx%message("tblite> failed to set up tblite implicit solvation!")
+      if(pr) call ctx%message("tblite> failed to set up tblite implicit solvation!")
       return
     end if
     call move_alloc(solv,cont)
@@ -241,10 +253,12 @@
     type(structure_type) :: mctcmol
     type(error_type),allocatable :: error
     real(wp) :: sigma(3,3)
+    logical :: pr
 
     iostatus = 0
     energy = 0.0_wp
     gradient(:,:) = 0.0_wp
+    pr = (ctx%verbosity > 0)
 
     !>--- make an mctcmol object from mol
     call tblite_mol2mol(mol,chrg,uhf,mctcmol)
@@ -255,7 +269,7 @@
 
     if (ctx%failed()) then
       ! Tear down the error stack to send the actual error messages back
-      call ctx%message("tblite> Singlepoint calculation failed")
+      if(pr) call ctx%message("tblite> Singlepoint calculation failed")
       iostatus = 1
     end if
 
@@ -318,7 +332,7 @@
 
     wbo = 0.0_wp
 #ifdef WITH_TBLITE
-    call get_wbo(nat,tbcalc%bas%nao,wfn%density, &
+    call get_wbo_rhf(nat,tbcalc%bas%nao,wfn%density, &
     &         tbres%overlap,tbcalc%bas%ao2at,wbo)
 #endif
   end subroutine tblite_getwbos
Index: src/qcg/solvtool.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 Sebastian Spicher, Christoph Plett, Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n!===================================================================!\n! This file contains routines related to QCG and microsolvation\n!===================================================================!\n!======================================================!\n! main routine\n!======================================================!\nsubroutine crest_solvtool(env, tim)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n   implicit none\n\n   type(systemdata):: env    ! MAIN STORAGE OS SYSTEM DATA\n   type(timer):: tim\n   !> Information about solvent, solute and cluster\n   type(zmolecule) :: solute, solvent, cluster, cluster_backup \n   type(ensemble) :: full_ensemble, solvent_ensemble\n\n   integer :: progress\n   character(len=512) :: thispath\n\n   real(wp), parameter         :: eh = 627.509541d0\n\n!--- Molecule settings\n   solute%nmol = 1\n   solvent%nmol = 1\n   cluster%nmol = 1\n\n   progress = 0\n   call getcwd(thispath)\n\n   !>-----------------------------------\n   call qcg_head()\n   !>-----------------------------------\n!> Check, if xtbiff is present\n   if (env%use_xtbiff) then\n      call check_prog_path_iff(env)\n   else\n      write (*, *)\n      write (*, *) '  The use of the aISS algorithm is requested (recommend).'\n      write (*, *) '  This requires xtb version 6.6.0 or newer.'\n      write (*, *) '  xTB-IFF can still be used with the --xtbiff flag.'\n      write (*, *)\n   end if\n\n!------------------------------------------------------------------------------\n!   Setup\n!------------------------------------------------------------------------------\n\n   call write_qcg_setup(env) !Just an outprint of setup\n   call read_qcg_input(env, solute, solvent) !Reading mol. data and determining r,V,A\n   call qcg_setup(env, solute, solvent)\n   call qcg_restart(env, progress, solute, solvent, cluster, full_ensemble,&\n          & solvent_ensemble, cluster_backup)\n\n!-----------------------------------------------------------------------------\n!   Grow\n!-----------------------------------------------------------------------------\n   if (progress .le. env%qcg_runtype .and. progress .eq. 0) then\n      cluster = solute\n      call qcg_grow(env, solute, solvent, cluster, tim)\n      if (.not. env%cff) then\n         allocate (cluster_backup%at(cluster%nat))\n         allocate (cluster_backup%xyz(3, cluster%nat))\n         cluster_backup = cluster\n      end if\n      progress = progress + 1\n      call chdir(thispath)\n   end if\n\n!------------------------------------------------------------------------------\n!   Ensemble search\n!------------------------------------------------------------------------------\n   if (progress .le. env%qcg_runtype .and. progress .eq. 1) then\n      call print_qcg_ensemble()\n      call qcg_ensemble(env, solute, solvent, cluster, full_ensemble, tim, 'ensemble')\n      progress = progress + 1\n      call chdir(thispath)\n   end if\n\n!------------------------------------------------------------------------------\n!   Solvent cluster generation\n!------------------------------------------------------------------------------\n   if (progress .le. env%qcg_runtype .and. progress .eq. 2) then !esolv\n      call pr_eval_solvent()\n      if (env%cff) then !CFF\n         call qcg_cff(env, solute, solvent, cluster, full_ensemble,&\n                & solvent_ensemble, tim)\n      else !Normal ensemble generation\n         call print_qcg_ensemble()\n         call cluster%deallocate\n         allocate (cluster%at(cluster_backup%nat))\n         allocate (cluster%xyz(3, cluster_backup%nat))\n         cluster = cluster_backup\n         deallocate (cluster_backup%at)\n         deallocate (cluster_backup%xyz)\n         env%solv_md = .true.\n         call qcg_ensemble(env, solute, solvent, cluster, solvent_ensemble,&\n                & tim, 'solvent_ensemble')\n      end if\n      call pr_qcg_esolv()\n      write (*, '(2x,\"|\",9x,F8.2,\" kcal/mol \",12x,\"|\")') &\n             &   full_ensemble%g - solvent_ensemble%g - (solute%energy*eh)\n      write (*, '(2x,''========================================='')')\n      call chdir(thispath)\n      progress = progress + 1\n   end if\n\n!------------------------------------------------------------------------------\n!   Frequency computation and evaluation\n!------------------------------------------------------------------------------\n   if (progress .le. env%qcg_runtype .and. progress .eq. 3) then !gsolv\n      call qcg_freq(env, tim, solute, solvent, full_ensemble, solvent_ensemble)\n      call qcg_eval(env, solute, full_ensemble, solvent_ensemble)\n\n      progress = progress + 1\n   end if\n\n   !<----------------------------------\n!  call tim%stop(2) !stop a timer\n\n!------------------------------------------------------------------------------\n!   Cleanup and deallocation\n!------------------------------------------------------------------------------\n   if (env%scratchdir .ne. 'qcg_tmp') call qcg_cleanup(env)\n   if (.not. env%keepModef) call rmrf('qcg_tmp')\n   call solute%deallocate\n   call solvent%deallocate\n   call cluster%deallocate\n   call full_ensemble%deallocate\n   call solvent_ensemble%deallocate\n   return\nend subroutine crest_solvtool\n\nsubroutine qcg_setup(env, solu, solv)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n   use axis_module\n   implicit none\n\n   type(systemdata):: env\n   type(zmolecule) :: solv, solu\n\n   integer :: io, f, r, v, ich\n   integer :: num_O, num_H, i\n   character(len=*), parameter :: outfmt = '(1x,1x,a,1x,f14.7,a,1x)'\n   logical :: e_there, tmp, used_tmp\n   character(len=512) :: thispath, tmp_grow\n   character(len=40)  :: solv_tmp\n   character(len=80) :: atmp\n\n   call getcwd(thispath)\n\n   inquire (file='./qcg_tmp/solute_properties/solute', exist=tmp)\n   if (tmp) call rmrf('qcg_tmp') !User given scratch dir will be removed anyway after run\n\n   if (env%scratchdir .eq. '') then !check if scratch was not set\n      env%scratchdir = 'qcg_tmp'\n      io = makedir('qcg_tmp')\n   end if\n\n   call copysub('solute', trim(env%scratchdir))\n   call copysub('solvent', env%scratchdir)\n   call env%wrtCHRG(env%scratchdir) !Write .CHRG and .UHF with 3 lines for xtb docking\n   call chdir(env%scratchdir)\n\n   f = makedir('solute_properties')\n   r = makedir('solvent_properties')\n   v = makedir('tmp_grow')\n\n   call chdir('tmp_grow')\n   call getcwd(tmp_grow)\n   call chdir(thispath)\n   call chdir(env%scratchdir)\n\n   call copysub('solute', 'solute_properties')\n   call copysub('.CHRG', 'solute_properties')\n   call copysub('.UHF', 'solute_properties')\n   call copysub('solvent', 'solvent_properties')\n\n   call copysub('.CHRG', tmp_grow)\n   call copysub('.UHF', tmp_grow)\n\n   call remove('solute')\n   call remove('solvent')\n\n   if (.not. env%nopreopt) then\n      write (*, *)\n      write (*, '(2x,''========================================='')')\n      write (*, '(2x,''|            Preoptimization            |'')')\n      write (*, '(2x,''========================================='')')\n   end if\n\n   solv_tmp = env%solv\n   env%solv = ''\n\n!---- Properties solute\n   call chdir('solute_properties')\n   env%ref%nat = solu%nat\n   env%ref%at = solu%at\n   env%ref%xyz = solu%xyz\n\n!---- Geometry preoptimization solute\n   if ((.not. env%nopreopt) .and. (solu%nat /= 1)) then\n      call wrc0('coord', solu%nat, solu%at, solu%xyz) !write coord for xtbopt routine\n      if (env%cts%used) then\n         call wrc0('coord.ref', solu%nat, solu%at, solu%xyz) !write coord for xtbopt routine\n      end if\n!---- coord setup section\n      open (newunit=ich, file='coord')\n      do\n         read (ich, '(a)', iostat=io) atmp\n         if (io < 0) exit\n         if (index(atmp, '$coord') .ne. 0) cycle\n         if (index(atmp(1:1), '$') .ne. 0) then\n            !write(ich,'(a)')'$end'\n            exit\n         end if\n      end do\n      !add constraints (only if given, else the routine returns)\n      call write_cts(ich, env%cts)\n      call write_cts_biasext(ich, env%cts)\n      write (ich, '(a)') '$end'\n      close (ich)\n\n      call xtbopt(env)\n      call rdcoord('coord', solu%nat, solu%at, solu%xyz)\n      call remove('coord')\n   end if\n\n!--- Axistrf\n   call axistrf(solu%nat, solu%nat, solu%at, solu%xyz)\n   call wrc0('solute', solu%nat, solu%at, solu%xyz)\n\n!---- LMO/SP-Computation solute\n   if (env%use_xtbiff) then\n      write (*, *) 'Generating LMOs for solute'\n      call xtb_lmo(env, 'solute')!,solu%chrg)\n   else\n      call xtbsp3(env, 'solute')\n   end if\n\n   call grepval('xtb.out', '| TOTAL ENERGY', e_there, solu%energy)\n   if (.not. e_there) then\n      write (*, *) 'Total Energy of solute not found'\n   else\n      write (*, outfmt) 'Total Energy of solute: ', solu%energy, ' Eh'\n   end if\n\n   if (env%use_xtbiff) then\n      call rename('xtblmoinfo', 'solute.lmo')\n      call copysub('solute.lmo', tmp_grow)\n   else\n      call copysub('solute', tmp_grow)\n   end if\n\n   call chdir(thispath)\n\n! No constraints for solvent possible\n   used_tmp = env%cts%used\n   env%cts%used = .false.\n\n!---- Properties solvent\n   call chdir(env%scratchdir)\n   call chdir('solvent_properties')\n   env%ref%nat = solv%nat\n   env%ref%at = solv%at\n   env%ref%xyz = solv%xyz\n\n!---- Geometry preoptimization solvent\n   if ((.not. env%nopreopt) .and. (solv%nat /= 1)) then\n      call wrc0('coord', solv%nat, solv%at, solv%xyz) !write coord for xtbopt routine\n      call xtbopt(env)\n      call rdcoord('coord', solv%nat, solv%at, solv%xyz)\n      call remove('coord')\n   end if\n   call wrc0('solvent', solv%nat, solv%at, solv%xyz)\n\n!---- LMO-Computation solvent\n   if (env%use_xtbiff) then\n      write (*, *) 'Generating LMOs for solvent'\n      call xtb_lmo(env, 'solvent')!,solv%chrg)\n   else\n      call xtbsp3(env, 'solvent')\n   end if\n\n   call grepval('xtb.out', '| TOTAL ENERGY', e_there, solv%energy)\n   if (.not. e_there) then\n      write (*, '(1x,a)') 'Total Energy of solvent not found'\n   else\n      write (*, outfmt) 'Total energy of solvent:', solv%energy, ' Eh'\n   end if\n\n   if (env%use_xtbiff) then\n      call rename('xtblmoinfo', 'solvent.lmo')\n      call copysub('solvent.lmo', tmp_grow)\n   else\n      call copysub('solvent', tmp_grow)\n   end if\n\n   call chdir(thispath)\n\n!---- Overwriting solute and solvent in original folder\n   call wrc0('solute', solu%nat, solu%at, solu%xyz)\n   call wrc0('solvent', solv%nat, solv%at, solv%xyz)\n\n   num_O = 0\n   num_H = 0\n!--- Check, if water is solvent\n   if (solv%nat .eq. 3) then\n      do i = 1, solv%nat\n         if (solv%at(i) .eq. 8) num_O = num_O + 1\n         if (solv%at(i) .eq. 1) num_H = num_H + 1\n      end do\n   end if\n   if (num_O .eq. 1 .AND. num_H .eq. 2) then\n      env%water = .true.\n      if (.not. env%noconst) env%constrain_solu = .true.\n   end if\n\n   env%solv = solv_tmp\n   env%cts%used = used_tmp\n\nend subroutine qcg_setup\n\nsubroutine read_qcg_input(env, solu, solv)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n   use atmasses\n   implicit none\n\n   type(systemdata)               :: env\n   type(zmolecule), intent(inout) :: solu, solv\n   logical                        :: pr\n   real(wp), parameter             :: amutokg = 1.66053886E-27\n   real(wp), parameter             :: third = 1.0d0/3.0d0\n   integer                        :: i\n   real(wp)                       :: r_solu, r_solv\n\n   pr = .true.\n\n!--- Read in nat, at, xyz\n   call simpletopo_file('solute', solu, .false., .false., '')\n   allocate (solu%xyz(3, solu%nat))\n   call rdcoord('solute', solu%nat, solu%at, solu%xyz)\n   call simpletopo_file('solvent', solv, .false., .false., '')\n   allocate (solv%xyz(3, solv%nat))\n   call rdcoord('solvent', solv%nat, solv%at, solv%xyz)\n\n!--- CMA-Trafo\n   call cma_shifting(solu, solv)\n\n!--- Setting solute charge and uhf to input\n   solu%chrg = env%chrg\n   solu%uhf = env%uhf\n\n!--- Getting r, V, A\n   write (*, *)\n   write (*, *) 'Solute geometry'\n   call get_sphere(.true., solu, .true.) !r,V,A of solute\n   write (*, *) 'Solvent geometry'\n   call get_sphere(.true., solv, .true.) !r,V,A of solvent\n\n   r_solu = solu%vtot**third\n   r_solv = solv%vtot**third\n   write (*, *)\n   write (*, '(2x,''radius of solute    : '',f8.2)') r_solu\n   write (*, '(2x,''radius of solvent   : '',f8.2)') r_solv\n\n!--- Determine masses (for later density computation)\n   do i = 1, solu%nat\n      solu%mass = solu%mass + ams(solu%at(i))\n   end do\n   do i = 1, solv%nat\n      solv%mass = solv%mass + ams(solv%at(i))\n   end do\n   solu%mass = solu%mass*amutokg\n   solv%mass = solv%mass*amutokg\n\nend subroutine read_qcg_input\n\nsubroutine qcg_grow(env, solu, solv, clus, tim)\n   use crest_parameters\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n   implicit none\n\n   type(systemdata)           :: env\n   type(zmolecule)            :: solu, solv, clus\n   type(timer)                :: tim\n\n   integer                    :: minE_pos, m\n   integer                    :: iter = 1\n   integer                    :: i, j, io\n   integer                    :: max_cycle\n   logical                    :: e_there, high_e, success, neg_E\n   real(wp)                   :: etmp(500)\n   real(wp), allocatable       :: e_each_cycle(:)\n   real(wp)                   :: dens, dum, efix\n   real(wp)                   :: e_diff = 0.0_wp\n   real(wp), parameter         :: eh = 627.509541d0\n   real(wp), allocatable       :: E_inter(:)\n   real(wp)                   :: shr = 0.0_wp\n   real(wp)                   :: shr_av = 0.0_wp\n   real(wp)                   :: mean = 0.0_wp\n   real(wp)                   :: mean_old = 0.0_wp\n   real(wp)                   :: mean_diff = 0.0_wp\n   character(len=*), parameter :: outfmt = '(1x,1x,a,1x,f14.7,a,1x)'\n   character(len=512)         :: thispath, resultspath\n   character(len=20)          :: gfnver_tmp\n   integer                    :: ich99, ich15, ich88\n   character(len=LEN(env%solv)) :: solv_tmp\n   logical                    :: gbsa_tmp\n\n   interface\n      subroutine both_ellipsout(fname, n, at, xyz, r1, r2)\n         use iso_fortran_env, only: wp => real64\n         use strucrd, only: i2e\n         implicit none\n\n         integer            :: i, j\n         integer            :: n, at(n)\n         real(wp)           :: dum(3)\n         real(wp)           :: rx, ry, rz\n         real(wp)           :: xyz(3, n), r1(3)\n         real(wp), optional :: r2(3)\n         real               :: x, y, z, f, rr\n         character(len=*)   :: fname\n         integer            :: ich11\n      end subroutine both_ellipsout\n   end interface\n\n   if (env%nsolv .gt. 0) then\n      allocate (e_each_cycle(env%nsolv))\n      allocate (E_inter(env%nsolv))\n   else\n      allocate (e_each_cycle(env%max_solv))\n      allocate (E_inter(env%max_solv))\n   end if\n\n   call tim%start(5, 'Grow')\n\n   call pr_eval_solute()\n   call print_qcg_grow()\n   call getcwd(thispath)\n   io = makedir('grow')\n   call chdir('grow') !Results directory\n\n!--- Output Files\n   open (newunit=ich99, file='qcg_energy.dat')\n   write (ich99, '(i0,2F20.8)') 0, solu%energy, solv%energy\n   open (newunit=ich15, file='qcg_grow.xyz')  ! for molden movie\n   open (newunit=ich88, file='qcg_conv.dat')  ! for convergence check\n   write (ich88, '(''   #   Energy       Run. Aver.   Diff / au.'')')\n\n   call getcwd(resultspath)\n   call chdir(thispath)\n\n   if (env%water) then\n      if (.not. env%user_wscal) then\n         if (solu%nat .lt. 18) then\n            env%potscal = 0.7_wp\n         else\n            env%potscal = 0.8_wp\n         end if\n         write (*, *)\n         write (*, '(2x,''Water as solvent recognized, &\n                 & adjusting scaling factor for outer wall pot to '',F4.2)')&\n                & env%potscal\n         write (*, *)\n      end if\n   end if\n   if (env%constrain_solu) write (*, '(2x,''Constraining solute during Growth '')')\n\n   call get_ellipsoid(env, solu, solv, clus, .true.)\n   call pr_grow_energy()\n\n   if (env%cts%used) call copysub(env%solu_file, env%scratchdir)\n   call chdir(env%scratchdir)\n   if (env%cts%used) call copysub(env%solu_file, 'tmp_grow')\n   call chdir('tmp_grow')\n\n   call ellipsout('solute_cavity.coord', clus%nat, clus%at, clus%xyz, solu%ell_abc)\n   solv%ell_abc = clus%ell_abc\n\n   clus%chrg = solu%chrg\n   clus%uhf = solu%uhf\n\n   if (env%nsolv .gt. 0) then\n      max_cycle = env%nsolv !User set number of solvents to add\n   else\n      max_cycle = env%max_solv !No solvent number set\n   end if\n\n!--------------------------------------------------------\n! Start Loop\n!--------------------------------------------------------\n   do iter = 1, max_cycle\n\n      e_there = .false.\n      success = .false.\n      high_e = .false.\n      neg_E = .false.\n!---- LMO-Computation\n      if (iter .gt. 1) then\n         call get_ellipsoid(env, solu, solv, clus, .false.)\n         if (env%use_xtbiff) then\n            call xtb_lmo(env, 'xtbopt.coord')!,clus%chrg)\n            call grepval('xtb.out', '| TOTAL ENERGY', e_there, clus%energy)\n            if (.not. e_there) then\n               write (*, '(1x,a)') 'Total Energy of cluster LMO computation not found'\n            end if\n            call rename('xtblmoinfo', 'cluster.lmo')\n         end if\n      end if\n\n      call both_ellipsout('twopot_1.coord', clus%nat, clus%at, clus%xyz,&\n             & clus%ell_abc, solu%ell_abc)\n\n      do while (.not. success) !For restart with larger wall pot\n         if (iter .eq. 1) then\n            if (env%use_xtbiff) then\n               call xtb_iff(env, 'solute.lmo', 'solvent.lmo', solu, solv)\n               !solu for nat of core pot. solv for outer ellips\n               call check_iff(neg_E)\n            else\n               call xtb_dock(env, 'solute', 'solvent', solu, solv)\n               call check_dock(neg_E)\n            end if\n\n!!! If Interaction Energy is not negativ and existent, wall pot. too small and increase\n            if (neg_E) then\n               success = .true.\n            else\n               if (env%potscal .lt. 1.0_wp) then\n                  write (*, *) '  Wall Potential too small, increasing size by 5 %'\n                  solv%ell_abc = solv%ell_abc*1.05_wp\n                  env%potscal = env%potscal*1.05_wp\n                  if (env%potscal .gt. 1.0_wp) env%potscal = 1.0_wp\n                  write (*, '(''   New scaling factor '',F4.2)') env%potscal\n               else\n                  success = .true.\n               end if\n            end if\n         else\n            if (env%use_xtbiff) then\n               call xtb_iff(env, 'cluster.lmo', 'solvent.lmo', solu, clus)\n               call check_iff(neg_E)\n            else\n               call xtb_dock(env, 'cluster.coord', 'solvent', solu, clus)\n               call check_dock(neg_E)\n            end if\n\n            if (neg_E) then\n               success = .true.\n            else\n               if (env%potscal .lt. 1.0_wp) then\n                  write (*, *) '  Wall Potential too small, increasing size by 5 %'\n                  clus%ell_abc = clus%ell_abc*1.05_wp\n                  env%potscal = env%potscal*1.05_wp\n                  if (env%potscal .gt. 1.0_wp) env%potscal = 1.0_wp\n                  write (*, '(''   New scaling factor '',F4.2)') env%potscal\n               else\n                  success = .true.\n               end if\n            end if\n         end if\n      end do\n\n!--- Increase cluster size\n      call clus%deallocate\n      clus%nat = clus%nat + solv%nat\n      allocate (clus%at(clus%nat))\n      allocate (clus%xyz(3, clus%nat))\n      clus%nmol = clus%nmol + 1\n\n!--- Select xtb-IFF stucture to proceed\n      if (env%use_xtbiff) then\n         call rdxtbiffE('xtbscreen.xyz', m, clus%nat, etmp) !Get energy of screening\n         minE_pos = minloc(etmp(1:m), dim=1) !Get minimum of those\n         !Read the struc into clus%xyz\n         call rdxmolselec('xtbscreen.xyz', minE_pos, clus%nat, clus%at, clus%xyz) \n      else\n         call rdcoord('best.xyz', clus%nat, clus%at, clus%xyz, clus%energy)\n      end if\n\n      call remove('cluster.coord')\n      call wrc0('cluster.coord', clus%nat, clus%at, clus%xyz)\n      call both_ellipsout('twopot_2.coord', clus%nat, clus%at, clus%xyz,&\n             & clus%ell_abc, solu%ell_abc)\n\n      success = .false.\n\n!--- Cluster restart, if interaction energy not negativ (wall pot. too small)\n      do while (.not. success)\n!--- Cluster optimization\n         if (env%cts%used) then\n            call write_reference(env, solu, clus) !new fixed file\n         end if\n\n         if (env%use_xtbiff) then\n            call opt_cluster(env, solu, clus, 'cluster.coord', .false.)\n            call rdcoord('xtbopt.coord', clus%nat, clus%at, clus%xyz)\n         end if\n\n!--- Interaction energy\n         gfnver_tmp = env%gfnver\n         env%gfnver = env%lmover\n         gbsa_tmp = env%gbsa\n         solv_tmp = env%solv\n         env%gbsa = .false.\n         env%solv = ''\n         call get_interaction_E(env, solu, solv, clus, iter, E_inter)\n         env%gbsa = gbsa_tmp\n         env%solv = solv_tmp\n         if (E_inter(iter) .lt. 0) then\n            success = .true.\n         else\n            if (env%potscal .lt. 1.0_wp) then\n               write (*, *) '  Interaction Energy positiv, increasing outer wall pot by 5 %'\n               clus%ell_abc = clus%ell_abc*1.05_wp\n               env%potscal = env%potscal*1.05_wp\n               if (env%potscal .gt. 1.0_wp) env%potscal = 1.0_wp\n               write (*, '('' New scaling factor '',F4.2)') env%potscal\n            else\n               success = .true.\n            end if\n         end if\n      end do\n      env%gfnver = gfnver_tmp\n\n!--- For output\n      if (env%use_xtbiff) then\n         call grepval('xtb.out', '| TOTAL ENERGY', e_there, clus%energy)\n         call wrc0('optimized_cluster.coord', clus%nat, clus%at, clus%xyz)\n         if (.not. e_there) then\n            write (*, '(1x,a)') 'Total Energy of cluster not found.'\n         end if\n      else\n         !Energy already read from xyz file\n      end if\n      e_each_cycle(iter) = clus%energy\n\n!--- Calclulate fix energy + diff. energy\n      efix = clus%energy/sqrt(float(clus%nat))\n      dum = solu%energy\n      if (iter .gt. 1) dum = e_each_cycle(iter - 1)\n      e_diff = e_diff + eh*(e_each_cycle(iter) - solv%energy - dum)\n      call ellipsout('cluster_cavity.coord', clus%nat, clus%at, clus%xyz, clus%ell_abc)\n      call both_ellipsout('twopot_cavity.coord', clus%nat, clus%at, clus%xyz,&\n             & clus%ell_abc, solu%ell_abc)\n\n!--- Density calculations\n      call get_sphere(.false., clus, .false.) !V, A of new cluster\n      dens = 0.001*(solu%mass + iter*solv%mass)/(1.0d-30*clus%vtot*bohr**3)\n\n!--- Movie file\n      write (ich15, *) clus%nat\n      write (ich15, '('' SCF done '',2F16.8)') eh*(e_each_cycle(iter) - solv%energy - dum)\n      do j = 1, clus%nat\n         write (ich15, '(a,1x,3F24.10)') i2e(clus%at(j)), clus%xyz(1:3, j)*bohr\n      end do\n\n!--- Output\n     ! dist of new mol from solute for output\n      call analyze_cluster(iter, clus%nat, solu%nat, solv%nat, clus%xyz, clus%at, shr_av, shr)\n\n      write (*, '(x,i4,F13.6,1x,f7.2,3x,f8.2,6x,f6.3,3x,f8.3,3x,2f6.1,2x,f8.1,3x,a,x)') &\n            & iter, e_each_cycle(iter), eh*(e_each_cycle(iter) - solv%energy - dum),&\n            & e_diff, dens, efix, shr_av, shr, clus%vtot, trim(optlevflag(env%optlev))\n      write (ich99, '(i4,F20.10,3x,f8.1)') iter, e_each_cycle(iter), clus%vtot\n\n!--- Calculate moving average\n      mean_old = mean\n      do i = 0, iter - 1\n         mean = mean + E_inter(iter - i)\n      end do\n      mean = mean/iter\n      mean_diff = mean - mean_old\n      write (ich88, '(i5,1x,3F13.8)') iter, E_inter(iter)*eh, mean, mean_diff\n\n!--- Check if converged when no nsolv was given\n      if (env%nsolv .eq. 0) then\n         if (abs(mean_diff) .lt. 1.0d-4 .and. iter .gt. 5) then\n            env%nsolv = iter\n            exit\n         end if\n         if (iter .eq. env%max_solv) then\n            write (*, '(1x,''No convergence could be reached upon adding'',1x,i4,1x,&\n                    & ''solvent molecules.'')') env%max_solv\n            write (*, *) ' Proceeding.'\n            env%nsolv = env%max_solv\n            exit\n         end if\n      end if\n!-----------------------------------------------\n! End loop\n!-----------------------------------------------\n   end do\n\n   if (env%nsolv .eq. 0) env%nsolv = iter !if no env%solv was given\n\n   if (env%gfnver .ne. '--gfn2') then\n      gfnver_tmp = env%gfnver\n      env%gfnver = '--gfn2'\n      write (*, '(2x,''Final gfn2 optimization'')')\n      call opt_cluster(env, solu, clus, 'cluster.coord', .false.)\n      call rdcoord('xtbopt.coord', clus%nat, clus%at, clus%xyz)\n      call wrc0('cluster.coord', clus%nat, clus%at, clus%xyz)\n      call grepval('xtb_sp.out', '| TOTAL ENERGY', e_there, clus%energy)\n      if (.not. e_there) then\n         write (*, '(1x,a)') 'Total Energy of cluster not found.'\n      else\n         write (*, '(2x,''Total gfn2-energy of cluster/Eh:'',f20.6)') clus%energy\n      end if\n      env%gfnver = gfnver_tmp\n   end if\n\n   call wrxyz('cluster.xyz', clus%nat, clus%at, clus%xyz*bohr)\n\n!--- One optimization without Wall Potential and with implicit model\n   gfnver_tmp = env%gfnver\n   env%gfnver = '--gfn2'\n   call opt_cluster(env, solu, clus, 'cluster.xyz', .true.)\n   env%gfnver = gfnver_tmp\n   call rename('xtbopt.xyz', 'cluster_optimized.xyz')\n   call copysub('cluster_optimized.xyz', resultspath)\n\n!--- output and files\n   write (*, *)\n   write (*, '(2x,''Growth finished after '',i0,'' solvents added'')') env%nsolv\n   write (*, '(2x,''Results can be found in grow directory'')')\n   write (*, '(2x,''Energy list in file <qcg_energy.dat>'')')\n   write (*, '(2x,''Interaction energy in file <qcg_conv.dat>'')')\n   write (*, '(2x,''Growing process in <qcg_grow.xyz>'')')\n   write (*, '(2x,''Final geometry after grow in <cluster.coord> and <cluster.xyz>'')')\n   write (*, '(2x,''Final geometry optimized without wall potential in <cluster_optimized.xyz>'')')\n   write (*, '(2x,''Potentials and geometry written in <cluster_cavity.coord> and <twopot_cavity.coord>'')')\n\n   close (ich99)\n   close (ich88)\n   close (ich15)\n\n!--- Saving results and cleanup\n   call copysub('cluster.coord', resultspath)\n   call copysub('cluster.xyz', resultspath)\n   call copysub('twopot_cavity.coord', resultspath)\n   call copysub('cluster_cavity.coord', resultspath)\n   call copysub('solute_cavity.coord', resultspath)\n!  call rename('xcontrol','wall_potential')\n   env%constrain_solu = .false.\n   call write_wall(env, solu%nat, solu%ell_abc, clus%ell_abc, 'wall_potential')\n   call copysub('wall_potential', resultspath)\n\n   call chdir(thispath)\n   call chdir(env%scratchdir)\n   if (.not. env%keepModef) call rmrf('tmp_grow')\n\n   deallocate (e_each_cycle, E_inter)\n\n   call tim%stop(5)\n\nend subroutine qcg_grow\n\nsubroutine qcg_ensemble(env, solu, solv, clus, ens, tim, fname_results)\n   use crest_parameters\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n\n   implicit none\n\n   type(systemdata)           :: env\n   type(zmolecule)            :: solu, solv, clus\n   type(ensemble)             :: ens, dum\n   type(timer)                :: tim\n\n   integer                    :: i, j, k\n   integer                    :: io, f, r, ich\n   integer                    :: minpos\n   character(len=512)         :: thispath, resultspath, tmppath, tmppath2\n   character(len=512)         :: scratchdir_tmp\n   character(len=512)         :: jobcall\n   character(len=256)         :: inpnam, outnam\n   character(len=80)          :: fname, pipe, to\n   character(len=*)           :: fname_results\n   character(len=64)          :: comment\n   character(len=20)          :: gfnver_tmp\n   character(len=LEN(env%solv)) :: solv_tmp\n   logical                    :: gbsa_tmp\n   logical                    :: ex, mdfail, e_there\n   logical                    :: checkiso_tmp, cbonds_tmp\n   real(wp), allocatable      :: e_fix(:), e_clus(:)\n   real(wp), parameter         :: eh = 627.509541d0\n   real(wp)                   :: S, H, G, dens, shr, shr_av\n   real(wp)                   :: sasa\n   real(wp)                   :: newtemp, newmdtime, newmdstep, newhmass\n   real(wp)                   :: newmetadlist, newmetadexp, newmetadfac\n   real(wp)                   :: optlev_tmp\n   real(wp)                   :: e0\n   real(wp), allocatable      :: de(:)\n   real(wp), allocatable      :: p(:)\n   integer                    :: ich98, ich65, ich48\n   logical                    :: not_param = .false.\n   type(timer)                :: tim_dum !Dummy timer to avoid double counting\n\n   interface\n      subroutine aver(pr, env, runs, e_tot, S, H, G, sasa, a_present, a_tot)\n         use iso_fortran_env, only: wp => real64\n         use crest_data\n\n         implicit none\n         type(systemdata), intent(in)     :: env\n         integer, intent(in)             :: runs\n         real(wp), intent(inout)         :: e_tot\n         real(wp), intent(in), optional  :: a_tot\n         real(wp), intent(out)           :: S\n         real(wp), intent(out)           :: H\n         real(wp), intent(out)           :: G\n         real(wp), intent(out)           :: sasa\n         logical, intent(in)             :: pr, a_present\n         dimension e_tot(runs)\n         dimension a_tot(runs)\n      end subroutine aver\n   end interface\n\n   if (.not. env%solv_md) then\n      call tim%start(6, 'Solute-Ensemble')\n   else\n      call tim%start(7, 'Solvent-Ensemble')\n   end if\n\n   call tim_dum%init(20)\n\n!--- Setting up directories\n   call getcwd(thispath)\n   f = makedir(fname_results)\n   call chdir(fname_results)\n   call getcwd(resultspath)\n   call chdir(thispath)\n\n!--- Setting defaults\n   env%cts%NCI = .true.  !Activating to have wall pot. written in coord file for xtb\n   optlev_tmp = env%optlev\n   env%optlev = 0.0d0\n   gbsa_tmp = env%gbsa\n   solv_tmp = env%solv\n   env%gbsa = .false.\n   env%solv = ''\n\n!--- Setting up potential constraints\n   allocate (env%cts%pots(10))\n   env%cts%pots = ''\n   write (env%cts%pots(1), '(\"$wall\")')\n   write (env%cts%pots(2), '(2x,\"potential=polynomial\")')\n   write (env%cts%pots(3), '(2x,\"ellipsoid:\",1x,3(g0,\",\",1x),\"all\")') clus%ell_abc\n   if (.not. env%solv_md) write (env%cts%pots(4), '(2x,\"ellipsoid:\",1x,3(g0,\",\",1x),\"1-\",i0)')&\n          & solu%ell_abc, solu%nat\n\n   if (env%cts%used) then\n      call write_reference(env, solu, clus) !new fixed file\n      call copysub(env%fixfile, env%scratchdir)\n   end if\n\n   call chdir(env%scratchdir)\n   scratchdir_tmp = env%scratchdir\n   if (.not. env%solv_md) then\n      io = makedir('tmp_MTD')\n      call copysub('.CHRG', 'tmp_MTD')\n      call copysub('.UHF', 'tmp_MTD')\n      if (env%cts%used) call copysub(env%fixfile, 'tmp_MTD')\n      call chdir('tmp_MTD')\n   else\n      io = makedir('tmp_solv_MTD')\n      call chdir('tmp_solv_MTD')\n   end if\n   call getcwd(tmppath2)\n   call wrc0('crest_input', clus%nat, clus%at, clus%xyz)\n\n   if (env%solv_md) then\n      call wr_cluster_cut('crest_input', solu%nat, solv%nat, env%nsolv,&\n             & 'solute_cut.coord', 'solvent_shell.coord')\n      call remove('crest_input')\n      call copy('solvent_shell.coord', 'crest_input')\n      deallocate (clus%at)\n      deallocate (clus%xyz)\n      call rdnat('solvent_shell.coord', clus%nat)\n      allocate (clus%at(clus%nat), clus%xyz(3, clus%nat))\n      call rdcoord('solvent_shell.coord', clus%nat, clus%at, clus%xyz)\n   end if\n\n   !For newcregen: If env%crestver .eq. crest_solv .and. .not. env%QCG then conffile .eq. .true.\n   env%QCG = .false. \n   call inputcoords(env, 'crest_input')\n   call defaultGF(env)         !Setting MTD parameter\n\n!--- Special constraints for gff to safeguard stability\n   if (env%ensemble_opt .eq. '--gff') then\n      checkiso_tmp = env%checkiso\n      env%checkiso = .true.\n      cbonds_tmp = env%cts%cbonds_md\n      env%cts%cbonds_md = .true.\n      call autoBondConstraint_withEZ('coord', env%forceconst, env%wbofile)\n      call rd_cbonds('bondlengths', env)\n   end if\n\n   gfnver_tmp = env%gfnver\n   write (*, *) '  Method for ensemble search:', env%ensemble_opt\n!  if (env%ens_const) write(*,*) '  Solute fixed during ensemble generation'\n   env%gfnver = env%ensemble_opt  !Setting method for ensemble search\n\n   !----------------------------------------------------------------\n   ! Case selection of normal Crest, MD or MTD\n   !----------------------------------------------------------------\n\n   select case (env%ensemble_method)\n   case (-1:0) !qcgmtd/Crest runtype\n\n      !Defaults\n      if(env%ensemble_method == 0) then\n         if (.not. env%user_dumxyz) then\n            env%mddumpxyz = 200\n         end if\n         if (.not. env%user_mdtime) then\n            env%mdtime = 10.0\n         end if\n      else if(env%ensemble_method == -1) then\n         if (.not. env%user_dumxyz) then\n            env%mddumpxyz = 50\n         end if\n         if (.not. env%user_mdtime) then\n            env%mdtime = 5.0\n         end if\n         env%nmdtemp = 100\n         env%MaxRestart = 6\n      endif\n\n      env%iterativeV2 = .true.  !Safeguards more precise ensemble search\n      write (*, *) 'Starting ensemble cluster generation by CREST routine'\n      call confscript2i(env, tim_dum) !Calling ensemble search\n      call copy('crest_rotamers.xyz', 'crest_rotamers_0.xyz')\n\n   case (1:2) ! Single MD or MTD\n\n      !---- Setting threads\n      if (env%autothreads) then\n         !set the global OMP/MKL variables for the xtb jobs\n         call ompautoset(env%threads, 7, env%omp, env%MAXRUN, 1) \n      end if\n\n      !--- Setting new defaults for MD/MTD in qcg\n      if (env%mdtemp .lt. 0.0d0) then\n         newtemp = 400.00d0\n      else if (.not. env%user_temp) then\n         newtemp = 298.0\n      else\n         newtemp = env%mdtemp\n      end if\n\n      if (.not. env%user_mdtime) then\n         newmdtime = 100.0 !100.0\n      else\n         newmdtime = env%mdtime\n      end if\n\n      if (.not. env%user_dumxyz) then\n         env%mddumpxyz = 1000\n      end if\n\n      if (.not. env%user_mdstep) then\n         if (env%ensemble_opt .ne. '--gff') then\n            newmdstep = 4.0d0\n         else\n            newmdstep = 1.5d0\n         end if\n      else\n         newmdstep = env%mdstep\n      end if\n\n      if (env%ensemble_opt .ne. '--gff') then\n         newhmass = 4.0\n      else\n         newhmass = 5.0\n      end if\n\n      if (.not. allocated(env%metadfac)) then\n         allocate (env%metadfac(1))\n         allocate (env%metadexp(1))\n         allocate (env%metadlist(1))\n      end if\n      newmetadfac = 0.02_wp\n      newmetadexp = 0.1_wp\n      newmetadlist = 10.0_wp\n\n      fname = 'coord'\n      pipe = ' > xtb.out 2>/dev/null'\n\n      !--- Writing constraining file xcontrol\n      !--- Providing xcontrol overwrites constraints in coord file\n\n      open (newunit=ich, file='xcontrol')\n      if (env%cts%NCI) then\n         do i = 1, 10\n            if (trim(env%cts%pots(i)) .ne. '') then\n               write (ich, '(a)') trim(env%cts%pots(i))\n            end if\n         end do\n      end if\n\n      if (.not. env%solv_md) then\n         write (ich, '(a)') '$constrain'\n         write (ich, '(2x,a,i0)') 'atoms: 1-', solu%nat\n         write (ich, '(2x,a)') 'force constant=0.5'\n         write (ich, '(2x,a,a)') 'reference=ref.coord'\n      end if\n\n      write (ich, '(a)') '$md'\n      write (ich, '(2x,a,f10.2)') 'hmass=', newhmass\n      write (ich, '(2x,a,f10.2)') 'time=', newmdtime\n      write (ich, '(2x,a,f10.2)') 'temp=', newtemp\n      write (ich, '(2x,a,f10.2)') 'step=', newmdstep\n      write (ich, '(2x,a,i0)') 'shake=', env%shake\n      write (ich, '(2x,a,i0)') 'dump=', env%mddumpxyz\n      write (ich, '(2x,a)') 'dumpxyz=500.0'\n\n      if (env%ensemble_method .EQ. 2) then\n         write (ich, '(a)') '$metadyn'\n         write (ich, '(2x,a,i0,a,i0)') 'atoms: ', solu%nat + 1, '-', clus%nat\n         write (ich, '(2x,a,f10.2)') 'save=', newmetadlist\n         write (ich, '(2x,a,f10.2)') 'kpush=', newmetadfac\n         write (ich, '(2x,a,f10.2)') 'alp=', newmetadexp\n      end if\n\n      if (env%cts%cbonds_md) call write_cts_CBONDS(ich, env%cts)\n\n      close (ich)\n\n!--- Writing jobcall\n      write (jobcall, '(a,1x,a,1x,a,'' --md --input xcontrol '',a,1x,a,a)') &\n            &     trim(env%ProgName), trim(fname), trim(env%gfnver), trim(env%solv), pipe\n!--- slightly different jobcall for QMDFF usage\n      if (env%useqmdff) then\n         write (jobcall, '(a,1x,a,1x,a,'' --md --input xcontrol --qmdff'',a,1x,a,a)') &\n            &     trim(env%ProgName), trim(fname), trim(env%gfnver), trim(env%solv), pipe\n      end if\n\n!--- MD\n      if (env%ensemble_method .EQ. 1) then\n         call normalMD(fname, env, 1, newtemp, newmdtime)\n         write (*, *) 'Starting MD with the settings:'\n         write (*, '(''     MD time /ps        :'',f8.1)') newmdtime\n         write (*, '(''     MD Temperature /K  :'',f8.1)') newtemp\n         write (*, '(''     dt /fs             :'',f8.1)') newmdstep\n         write (tmppath, '(a,i0)') 'NORMMD1'\n\n         r = makedir(tmppath)\n         call copysub('xcontrol', tmppath)\n         call chdir(tmppath)\n         call copy('coord', 'ref.coord')\n         call chdir(tmppath2)\n\n         call command('cd '//trim(tmppath)//' && '//trim(jobcall), io)\n\n         inquire (file=trim(tmppath)//'/'//'xtb.trj', exist=ex)\n         if (.not. ex .or. io .ne. 0) then\n            write (*, '(a,i0,a)') '*Warning: MD seemingly failed (no xtb.trj)*'\n         else\n            write (*, *) '*MD finished*'\n         end if\n\n         if (env%trackorigin) then\n            call set_trj_origins('NORMMD', 'md')\n         end if\n         call chdir('NORMMD1')\n      end if\n\n!--- MTD\n\n      if (env%ensemble_method .EQ. 2) then\n         call MetaMD(env, 1, newmdtime, env%metadfac(1), env%metadexp(1), &\n            &               env%metadlist(1))\n         write (*, '(a,i4,a)') 'Starting Meta-MD with the settings:'\n         write (*, '(''     MTD time /ps       :'',f8.1)') newmdtime\n         write (*, '(''     dt /fs             :'',f8.1)') newmdstep\n         write (*, '(''     MTD Temperature /K  :'',f8.1)') newtemp\n         write (*, '(''     dumpstep(trj) /fs  :'',i8)') env%mddumpxyz\n         write (*, '(''     Vbias factor k /Eh :'',f8.4)') newmetadfac\n         write (*, '(''     Vbias exp α /bohr⁻²:'',f8.2)') newmetadexp\n\n         write (tmppath, '(a,i0)') 'METADYN1'\n         r = makedir(tmppath)\n         call copysub('xcontrol', tmppath)\n         call chdir(tmppath)\n         call copy('coord', 'ref.coord')\n\n         call chdir(tmppath2)\n\n         call command('cd '//trim(tmppath)//' && '//trim(jobcall), io)\n\n         inquire (file=trim(tmppath)//'/'//'xtb.trj', exist=ex)\n         if (.not. ex .or. io .ne. 0) then\n            write (*, '(a,i0,a)') '*Warning: Meta-MTD seemingly failed (no xtb.trj)*'\n         else\n            write (*, *) '*MTD finished*'\n         end if\n\n         if (env%trackorigin) then\n            call set_trj_origins('METADYN', 'mtd')\n         end if\n\n         call chdir('METADYN1')\n\n      end if\n\n      call rename('xtb.trj', 'crest_rotamers_0.xyz')\n      call copysub('crest_rotamers_0.xyz', tmppath2)\n      call dum%open('crest_rotamers_0.xyz')\n\n!--- M(T)D stability check\n      call minigrep('xtb.out', 'M(T)D is unstable, emergency exit', mdfail)\n      if (dum%nall .eq. 1) then\n         call copysub('xtb.out', resultspath)\n         write (*, *) 'ERROR : M(T)D results only in one structure'\n         if (mdfail) then\n            write (*, *) '        It was unstable'\n         else\n            write (*, *) '        The M(T)D time step might be too large or the M(T)D time too short.'\n         end if\n         call copysub('xtb.out', resultspath)\n         error stop '         Please check the xtb.out file in the ensemble folder'\n      end if\n      if (mdfail) then\n         write (*, *)\n         write (*, *) '   WARNING: The M(T)D was unstable.'\n         write (*, *) '            Please check the xtb.out file in the ensemble folder.'\n         write (*, *)\n         call copysub('xtb.out', resultspath)\n      end if\n      call dum%deallocate\n      call chdir(tmppath2)\n      call wrc0('coord', clus%nat, clus%at, clus%xyz)\n      call inputcoords(env, 'coord') !Necessary\n\n!--- Optimization\n      call print_qcg_opt\n      if (env%gfnver .eq. '--gfn2') call multilevel_opt(env, 99)\n\n   end select\n\n   env%QCG = .true.\n\n!--- Optimization with gfn2 if necessary\n   gfnver_tmp = env%gfnver\n   if (env%gfnver .ne. '--gfn2') then\n      write (*, '(2x,a)') 'GFN2-xTB optimization'\n      env%gfnver = '--gfn2'\n      call rmrf('OPTIM')\n      call multilevel_opt(env, 99)\n   end if\n\n!--- Final optimization without potentials\n   call rmrf('OPTIM')\n   env%optlev = 1.0d0    !Higher precision for less scattering\n   env%cts%NCI = .false.  !Dactivating the wall pot.\n   env%cts%pots = ''\n   deallocate (env%cts%pots)\n   call multilevel_opt(env, 99)\n\n  !Clustering to exclude similar structures if requested with -cluster\n  if (env%properties == 70) then\n    write(*,'(3x,''Clustering the remaining structures'')')\n    call checkname_xyz(crefile,inpnam,outnam)\n    call ccegen(env, .false. , inpnam)\n    call move(trim(clusterfile),trim(outnam))\n  end if\n\n!--- Energy sorting and removal of dublicates\n   env%gbsa = gbsa_tmp\n   env%solv = solv_tmp\n   call newcregen(env, 0)\n   call checkname_xyz(crefile, inpnam, outnam)\n   call copy(inpnam, 'ensemble.xyz')\n   call ens%open('ensemble.xyz') !Read in ensemble\n   call clus%deallocate()\n   clus%nat = ens%nat\n   allocate (clus%at(clus%nat))\n   allocate (clus%xyz(3, clus%nat))\n\n!-------------------------------------------------------------\n!      SP with GBSA model and without wall potentials\n!-------------------------------------------------------------\n\n   !--- Write folder with xyz-coordinates\n   do i = 1, ens%nall\n      call rdxmolselec('ensemble.xyz', i, clus%nat, clus%at, clus%xyz)\n      write (to, '(\"TMPSP\",i0)') i\n      io = makedir(trim(to))\n      call copysub('.UHF', to)\n      call copysub('.CHRG', to)\n      call chdir(to)\n      call wrxyz('cluster.xyz', clus%nat, clus%at, clus%xyz*bohr)\n      call chdir(tmppath2)\n   end do\n   !--- SP\n   write (*, *)\n   call ens_sp(env, 'cluster.xyz', ens%nall, 'TMPSP')\n   !--- Getting energy\n   do i = 1, ens%nall\n      call rdxmolselec('ensemble.xyz', i, clus%nat, clus%at, clus%xyz)\n      write (to, '(\"TMPSP\",i0)') i\n      call chdir(to)\n      call grepval('xtb_sp.out', '| TOTAL ENERGY', e_there, ens%er(i))\n      call chdir(tmppath2)\n   end do\n\n   if (.not. e_there) then\n      write (*, *)\n      write (*, *) 'Energy not found. Error in xTB computations occured'\n      call chdir(to)\n      call minigrep('xtb_sp.out', 'solv_model_loadInternalParam', not_param)\n      call chdir(tmppath2)\n      if (not_param) then\n         write (*, *) '  !!!WARNIG: CHOSEN SOLVENT NOT PARAMETERIZED &\n         & FOR IMPLICIT SOLVATION MODEL!!!'\n         write (*, '(''  CHECK IF '',A,'' IS AVAILABLE IN xTB'')') env%solv\n         write (*, *) '  PLEASE RESTART THE ENSEMBLE GENERATION WITH AVAILABLE&\n                &  PARAMETERIZATION IF YOU NEED ENERGIES'\n         call copysub('crest_conformers.xyz', resultspath)\n         write (*, *) '  The enesemble can be found in the <ensemble> directory&\n                & as <crest_conformers.xyz>'\n         error stop\n      end if\n   end if\n\n   env%gfnver = gfnver_tmp\n   call ens%write('full_ensemble.xyz')\n\n!--- crest_best structure\n   minpos = minloc(ens%er, dim=1)\n   write (to, '(\"TMPSP\",i0)') minpos\n   call chdir(to)\n   call rdxmol('cluster.xyz', clus%nat, clus%at, clus%xyz)\n   call chdir(tmppath2)\n   write (comment, '(F20.8)') ens%er(minpos)\n   inquire (file='crest_best.xyz', exist=ex)\n   if (ex) then\n      call rmrf('crest_best.xyz') !remove crest_best from\n   end if\n   call wrxyz('crest_best.xyz', clus%nat, clus%at, clus%xyz, comment)\n\n!-------------------------------------------------------------\n!      Processing results\n!-------------------------------------------------------------\n\n   allocate (e_fix(ens%nall))\n   allocate (e_clus(ens%nall))\n\n   call pr_ensemble_energy()\n\n   open (newunit=ich98, file='cluster_energy.dat')\n   write (ich98, '(3x,''#'',9x,''Energy [Eh]'',6x,''SASA'')')\n\n!--- Fixation energy of optimization\n   do i = 1, ens%nall\n      call chdir('OPTIM')\n      write (to, '(\"TMPCONF\",i0)') i\n      call chdir(to)\n      call grepval('xtb.out', '         :: add. restraining', e_there, e_fix(i))\n      call chdir(tmppath2)\n\n      call rdxmolselec('full_ensemble.xyz', i, clus%nat, clus%at, clus%xyz)\n      call get_sphere(.false., clus, .false.)\n      dens = 0.001*(solu%mass + env%nsolv*solv%mass)/(1.0d-30*clus%vtot*bohr**3)\n      if (env%solv_md) then\n         call analyze_cluster(env%nsolv - 1, clus%nat, solv%nat, solv%nat, clus%xyz, clus%at, shr_av, shr)\n      else\n         call analyze_cluster(env%nsolv, clus%nat, solu%nat, solv%nat, clus%xyz, clus%at, shr_av, shr)\n      end if\n      write (ich98, '(i4,F20.10,3x,f8.1)') env%nsolv, ens%er(i), clus%atot\n      write (*, '(x,i4,4x,F13.6,2x,f6.3,1x,f8.3,2x,2f6.1,3x,f8.1,3x,a)') &\n            & i, ens%er(i), dens, e_fix(i), shr_av, shr, clus%atot, trim(optlevflag(env%optlev))\n      e_fix(i) = e_fix(i)*eh/sqrt(float(clus%nat))\n   end do\n   close (ich98)\n   call copysub('cluster_energy.dat', resultspath)\n\n!--- Checking Boltzmann weighting\n   write (*, *)\n   call remove('full_ensemble.xyz')\n   call sort_ensemble(ens, ens%er, 'full_ensemble.xyz')\n   e_clus = ens%er*eh\n   call sort_min(ens%nall, 1, 1, e_clus)\n   ens%er = e_clus/eh !Overwrite ensemble energy with sorted one\n   allocate (de(ens%nall), source=0.0d0)\n   allocate (p(ens%nall), source=0.0d0)\n   e0 = e_clus(1)\n   de(1:ens%nall) = (e_clus(1:ens%nall) - e0)\n   call qcg_boltz(env, ens%nall, de, p)\n   k = 0\n   if (.not. env%user_nclust) env%nqcgclust = 0 !Needed for solvent ensemble\n   if (env%nqcgclust .eq. 0) then\n      do i = 1, ens%nall !Count how many are above 10%\n         if ((p(i)) .gt. 0.1) then\n            k = k + 1\n         end if\n      end do\n      if ((k .eq. 0) .or. (k .gt. 10)) then\n         k = 10 !If too many structures are relevant, set it 10\n      else if ((k .lt. 4) .and. (ens%nall .ge. 4)) then\n         k = 4 !If too less structures are relevant, set it 4\n      else if (ens%nall .gt. 0) then \n         k=ens%nall\n      else\n         error stop 'No structure left. Something went wrong.' \n      end if\n      write (*, '(2x,a,1x,i0)') 'Conformers taken:', k\n      env%nqcgclust = k\n   else\n      if (env%nqcgclust .gt. ens%nall) then\n         k = ens%nall !Input larger than remaining structures\n         write (*, '(''Less than '',1x,i0,1x,''structures remain'')') env%nqcgclust\n         write (*, '(''Only '',1x,i0,1x,''structures are taken'')') ens%nall\n         if (env%cff) env%nqcgclust = ens%nall !Only for CFF, else a second qcg_ensemble run starts for solvent\n      else\n         write (*, '(''Taking '',1x,i0,1x,''structures'')') env%nqcgclust\n         k = env%nqcgclust !user input\n      end if\n   end if\n\n   open (newunit=ich65, file='final_ensemble.xyz')\n   do i = 1, k\n      open (newunit=ich48, file='full_population.dat')\n      write (ich48, '(2x, ''cluster'',2x,''E_norm [Eh]'',2x, ''De [kcal]'', 4x, ''p'')')\n      do j = 1, ens%nall\n         if (j .lt. 10) then\n            write (ich48, '(5x,i0,3x,f11.6,5x,f6.4,3x,f6.4)') j, e_clus(j)/eh, de(j), p(j)\n         else\n            write (ich48, '(5x,i0,2x,f11.6,5x,f6.4,3x,f6.4)') j, e_clus(j)/eh, de(j), p(j)\n         end if\n      end do\n      close (ich48)\n\n!--- Take k energetic least structures (written at beginning of file)\n      call rdxmolselec('full_ensemble.xyz', i, clus%nat, clus%at, clus%xyz)\n      call wrxyz(ich65, clus%nat, clus%at, clus%xyz*bohr, ens%er(i))\n   end do\n   close (ich65)\n\n   call ens%deallocate()\n   call ens%open('final_ensemble.xyz')\n   ens%er = e_clus(1:k)/eh\n\n!--- Getting G,S,H\n   write (*, *)\n   write (*, '(2x,''------------------------------------------------------------------------'')')\n   write (*, '(2x,''------------------------------------------------------------------------'')')\n   write (*, '(2x,''Boltz. averaged energy of final cluster:'')')\n   call aver(.true., env, ens%nall, e_clus(1:ens%nall), S, H, G, sasa, .false.)\n   write (*, '(7x,''G /Eh     :'',F14.8)') G/eh\n   write (*, '(7x,''T*S /kcal :'',f8.3)') S\n\n   ens%g = G\n   ens%s = S\n\n   deallocate (e_fix)\n   deallocate (e_clus)\n\n!---Folder management\n   call rename('cregen.out.tmp', 'thermo_data')\n   call copysub('thermo_data', resultspath)\n   call copysub('crest_best.xyz', resultspath)\n   call copysub('cre_members.out', resultspath)\n   call copysub('full_ensemble.xyz', resultspath)\n   call copysub('final_ensemble.xyz', resultspath)\n   call copysub('population.dat', resultspath)\n   call copysub('full_population.dat', resultspath)\n\n!---Deleting ensemble tmp\n   call chdir(thispath)\n   call chdir(env%scratchdir)\n   if (.not. env%keepModef) call rmrf(tmppath2)\n!----Outprint\n   write (*, *)\n   write (*, '(2x,''Ensemble generation finished.'')')\n   write (*, '(2x,''Results can be found in ensemble directory'')')\n   write (*, '(2x,''Lowest energy conformer in file <crest_best.xyz>'')')\n   write (*, '(2x,''List of full ensemble in file <full_ensemble.xyz>'')')\n   write (*, '(2x,''List of used ensemble in file <final_ensemble.xyz>'')')\n   write (*, '(2x,''Thermodynamical data in file <thermo_data>'')')\n   write (*, '(2x,''Population of full ensemble in file <full_population.dat>'')')\n   write (*, '(2x,''Population in file <population.dat>'')')\n\n   env%gfnver = gfnver_tmp\n   env%optlev = optlev_tmp\n   if (env%ensemble_opt .eq. '--gff') then\n      env%cts%cbonds_md = cbonds_tmp\n      env%checkiso = checkiso_tmp\n   end if\n\n   call tim_dum%clear\n\n   if (.not. env%solv_md) then\n      call tim%stop(6)\n   else\n      call tim%stop(7)\n   end if\n\nend subroutine qcg_ensemble\n\nsubroutine qcg_cff(env, solu, solv, clus, ens, solv_ens, tim)\n   use crest_parameters\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n\n   implicit none\n\n   type(systemdata)           :: env\n   type(timer)                :: tim\n   type(zmolecule)            :: solu, solv, clus\n   type(ensemble)             :: solv_ens\n   type(ensemble), intent(in)  :: ens\n\n   integer                    :: i, j, k, iter\n   integer                    :: io, r\n   integer                    :: nsolv, n_ini\n   integer                    :: ipos, dum\n   integer                    :: v_ratio\n   integer                    :: minE_pos, m, nat_tot\n   integer                    :: nat_frag1 !number of atoms larger fragment (=solvent shell)\n   integer                    :: conv(env%nqcgclust + 1)\n   integer                    :: solv_added, minpos\n   character(len=512)         :: thispath, resultspath, tmppath, tmppath2\n   character(len=64)          :: fname_lmo1, fname_lmo2, comment\n   character(len=20)          :: to\n   real(wp), allocatable      :: e_empty(:), inner_ell_abc(:, :)\n   real(wp), allocatable      :: outer_ell_abc(:, :)\n   real(wp), allocatable      :: e_cur(:, :)\n   real(wp)                   :: e_cluster(env%nqcgclust)\n   real(wp), parameter        :: eh = 627.509541d0\n   real(wp)                   :: S, H, G\n   real(wp)                   :: sasa, tmp_optlev\n   real(wp)                   :: etmp(500)\n   real(wp)                   :: e_fix(env%nqcgclust), e_norm(env%nqcgclust)\n   real(wp)                   :: dum_e, de\n   real(wp)                   :: de_tot(env%nqcgclust)\n   real(wp)                   :: shr = 0\n   real(wp)                   :: shr_av = 0\n   real(wp)                   :: dens, atotS\n   logical                    :: ex, skip, e_there\n   logical                    :: all_converged\n   logical, allocatable        :: converged(:), nothing_added(:)\n\n   character(len=20)          :: gfnver_tmp\n   real(wp)                   :: optlev_tmp\n   integer                    :: ich98, ich31\n\n   interface\n      subroutine aver(pr, env, runs, e_tot, S, H, G, sasa, a_present, a_tot)\n         use iso_fortran_env, only: wp => real64\n         use crest_data\n\n         implicit none\n         type(systemdata), intent(in)     :: env\n         integer, intent(in)             :: runs\n         real(wp), intent(inout)         :: e_tot\n         real(wp), intent(in), optional  :: a_tot\n         real(wp), intent(out)           :: S\n         real(wp), intent(out)           :: H\n         real(wp), intent(out)           :: G\n         real(wp), intent(out)           :: sasa\n         logical, intent(in)             :: pr, a_present\n         dimension e_tot(runs)\n         dimension a_tot(runs)\n      end subroutine aver\n   end interface\n\n   call tim%start(8, 'CFF')\n\n   allocate (e_empty(env%nqcgclust))\n   allocate (converged(env%nqcgclust))\n   allocate (nothing_added(env%nqcgclust))\n   allocate (outer_ell_abc(env%nqcgclust, 3))\n   allocate (inner_ell_abc(env%nqcgclust, 3))\n\n   v_ratio = nint(solu%vtot/solv%vtot)\n   allocate (e_cur(env%nsolv + v_ratio, env%nqcgclust), source=0.0d0)\n\n!--- Setting defaults (same as ensemble optimization to have comparable structures)\n   optlev_tmp = env%optlev\n   env%optlev = 1.0d0    !Increaseing percision for ensemble search to minimze scattering\n   gfnver_tmp = env%gfnver\n   env%gfnver = '--gfn2' !CFF always gfn2\n   write (*, *) 'Method for CFF: GFN2-xTB'\n   nothing_added = .false.\n\n   dum = 0\n   converged = .false.\n   all_converged = .false.\n   nat_tot = clus%nat - solu%nat!*env%nqcgclust\n\n   if (solu%vtot/solv%vtot .lt. 1.0d0) then\n      skip = .true.\n   else\n      skip = .false.\n   end if\n\n!--- Folder management\n   call getcwd(thispath)\n   r = makedir('solvent_ensemble')\n   call chdir('solvent_ensemble')\n   call getcwd(resultspath)\n   call chdir(thispath)\n   call chdir(env%scratchdir)\n   call getcwd(tmppath)\n   io = makedir('tmp_CFF')\n   call chdir('tmp_CFF')\n   call getcwd(tmppath2)\n   call chdir(tmppath)\n   call chdir('solvent_properties')\n   if (env%use_xtbiff) then\n      call copysub('solvent.lmo', tmppath2)\n   else\n      call copysub('solvent', tmppath2)\n   end if\n   call chdir(tmppath2)\n\n!--- SP of each cluster\n   call ens%write('ensemble.xyz')\n   do i = 1, env%nqcgclust\n      call rdxmolselec('ensemble.xyz', i, clus%nat, clus%at, clus%xyz)\n      clus%nmol = clus%nat/solv%nat\n      write (to, '(\"TMPCFF\",i0)') i\n      io = makedir(trim(to))\n      if (env%use_xtbiff) then\n         call copysub('solvent.lmo', to)\n      else\n         call copysub('solvent', to)\n      end if\n      call chdir(to)\n      call wrc0('cluster.coord', clus%nat, clus%at, clus%xyz)\n      call wr_cluster_cut('cluster.coord', solu%nat, solv%nat, env%nsolv, 'solute_cut.coord', 'solvent_shell.coord')\n      call xtbsp3(env, 'solvent_shell.coord')\n      call grepval('xtb.out', '| TOTAL ENERGY', ex, e_empty(i))\n      call copy('solvent_shell.coord', 'solvent_cluster.coord')\n      call copy('solvent_cluster.coord', 'filled_cluster.coord')\n      call get_ellipsoid(env, solu, solv, clus, .false.) !solu, to have same cavity to fill solvent in\n      outer_ell_abc(i, 1:3) = clus%ell_abc(1:3)\n      inner_ell_abc(i, 1:3) = solu%ell_abc(1:3)\n      call chdir(tmppath2)\n   end do\n\n   if (skip) write (*, '(2x,''solute smaller than solvent, cff skipped'')')\n\n   clus%nat = clus%nat - solu%nat\n   n_ini = clus%nat\n\n!--- If solvent molecules are added\n   if (.not. skip) then\n      call pr_qcg_fill()\n      write (*, '(2x,''now adding solvents to fill cluster...'')')\n      call pr_fill_energy()\n      write (*, '(2x,''------------------------------------------------------------------------'')')\n      nat_frag1 = env%nsolv*solv%nat\n\n      iter = 0\n!--- Main cycle for addition of solvent molecules\n      convergence: do while (.not. all_converged)\n         k = 0\n         iter = iter + 1\n         !--- Setting array, with only numbers of dirs that are not converged\n         do i = 1, env%nqcgclust\n            if (.not. converged(i)) then\n               k = k + 1\n               conv(k) = i\n               conv(env%nqcgclust + 1) = k !How many jobs are open\n            else\n               cycle\n            end if\n         end do\n         conv(k + 1:env%nqcgclust) = 0\n\n         if (env%use_xtbiff) then\n!----------- LMO computation for solvent cluster---------------------------------------------------\n            call ensemble_lmo(env, 'solvent_cluster.coord', solv, conv(env%nqcgclust + 1),&\n                   & 'TMPCFF', conv)\n!--------------------------------------------------------------------------------------------------\n\n            do i = 1, env%nqcgclust\n               if (.not. converged(i)) then\n                  write (to, '(\"TMPCFF\",i0)') i\n                  call chdir(to)\n                  call rename('xtblmoinfo', 'solvent_cluster.lmo')\n                  call chdir(tmppath2)\n               else\n                  cycle\n               end if\n            end do\n         end if\n\n         call chdir(tmppath2)\n\n         fname_lmo1 = 'solvent_cluster.lmo'\n         fname_lmo2 = 'solvent.lmo'\n\n!--- Solvent addition to the cluster---------------------------------------------\n         if (env%use_xtbiff) then\n            call ensemble_iff(env, outer_ell_abc, nat_frag1, fname_lmo1, fname_lmo2,&\n                    &conv(env%nqcgclust + 1), 'TMPCFF', conv)\n         else\n            call ensemble_dock(env, outer_ell_abc, nat_frag1, 'solvent_cluster.coord',&\n                    &'solvent', clus%nat, solv%nat, conv(env%nqcgclust + 1), 'TMPCFF', conv)\n         end if\n!--------------------------------------------------------------------------------\n\n         nat_frag1 = nat_frag1 + solv%nat\n\n         !--- Increase cluster size\n         deallocate (clus%at)\n         deallocate (clus%xyz)\n         clus%nat = clus%nat + solv%nat\n         allocate (clus%at(clus%nat))\n         allocate (clus%xyz(3, clus%nat))\n         clus%nmol = clus%nmol + 1\n\n         do i = 1, env%nqcgclust\n            if (.not. converged(i)) then\n               write (to, '(\"TMPCFF\",i0)') i\n               call chdir(to)\n               call remove('xtbrestart')\n               call remove('xcontrol')\n\n               if (env%use_xtbiff) then\n                  !--- Select xtb-IFF stucture to proceed\n                  call rdxtbiffE('xtbscreen.xyz', m, clus%nat, etmp) !Get energy of screening\n                  minE_pos = minloc(etmp(1:m), dim=1)            !Get minimum of those\n                  call rdxmolselec('xtbscreen.xyz', minE_pos, clus%nat, clus%at, clus%xyz) !Read the struc into clus%xyz\n                  call wrc0('solvent_cluster.coord', clus%nat, clus%at, clus%xyz)\n               else\n                  call rdcoord('best.xyz', clus%nat, clus%at, clus%xyz, e_cur(iter, i))\n                  call wrc0('solvent_cluster.coord', clus%nat, clus%at, clus%xyz)\n               end if\n\n               !--- Check if converged\n               call fill_take(env, solv%nat, clus%nat, inner_ell_abc(i, 1:3), ipos)\n               if (ipos .eq. 0) then\n                  converged(i) = .true.\n                  write (*, '(2x,''no more solvents can be placed inside cavity of cluster: '',i0)') i\n                  write (*, '(2x,''previous cluster taken...'')')\n                  if (iter .eq. 1) nothing_added(i) = .true.\n               end if\n               call chdir(tmppath2)\n\n            else\n               cycle\n            end if\n         end do\n\n!--- Check, if a structure was converged and iff was not necessary\n         k = 0\n         do i = 1, env%nqcgclust\n            if (.not. converged(i)) then\n               k = k + 1\n               conv(k) = i\n               conv(env%nqcgclust + 1) = k !How many jobs are open\n            else\n               cycle\n            end if\n         end do\n         conv(k + 1:env%nqcgclust) = 0\n\n!      if(env%use_xtbiff) then\n!--- Parallel optimization-------------------------------------------------------------------\n         call cff_opt(.false., env, 'solvent_cluster.coord', n_ini, conv(env%nqcgclust + 1)&\n                 &, 'TMPCFF', conv, nothing_added)\n!----------------------------------------------------------------------------------------------\n!      end if\n\n         do i = 1, env%nqcgclust\n            if (.not. converged(i)) then\n               write (to, '(\"TMPCFF\",i0)') i\n               call chdir(to)\n               if (env%use_xtbiff) then\n                  call copy('xtbopt.coord', 'solvent_cluster.coord')\n                  call grepval('xtb_sp.out', '| TOTAL ENERGY', e_there, e_cur(iter, i))\n               end if\n               dum_e = e_empty(i)\n               if (iter - nsolv .gt. 1) dum_e = e_cur(iter - 1, i)\n               de = eh*(e_cur(iter, i) - solv%energy - dum_e)\n               de_tot(i) = de_tot(i) + de\n               !---- Check if solvent added is repulsive\n               if (de .gt. 0) then\n                  converged(i) = .true.\n                  write (*, '(2x,''adding solvent is repulsive for cluster: '',i0)') i\n                  write (*, '(2x,''previous cluster taken...'')')\n                  if (iter .eq. 1) nothing_added(i) = .true.\n               else !Only if the addition was not repulsive\n                  call copy('solvent_cluster.coord', 'filled_cluster.coord')\n                  write (*, '(i4,5x,i3,1x,F13.6,3x,f7.2,5x,f7.2,4x,a)') &\n                     & iter + env%nsolv, i, e_cur(iter, i), de, de_tot(i),&\n                     & trim(optlevflag(env%optlev))\n               end if\n               call chdir(tmppath2)\n            end if\n         end do\n\n         !--- Check if everything is converged\n         dum = 0\n         do i = 1, env%nqcgclust\n            if (converged(1)) then\n               dum = dum + 1\n            end if\n         end do\n\n         if (dum .eq. env%nqcgclust) then\n            all_converged = .true.\n         else\n            nat_tot = nat_tot + solv%nat\n         end if\n\n         write (*, '(2x,''------------------------------------------------------------------------'')')\n         !--- Or if maximum solvent is added\n         if (iter - nsolv .eq. v_ratio) then\n            write (*, '(2x,''volume filled'')')\n            all_converged = .true.\n            call copy('solvent_cluster.coord', 'filled_cluster.coord')\n         end if\n\n      end do convergence\n\n   end if\n\n   !Now in every TMPPath the final cluster file filled_cluster.coord is present\n\n!---------------------------------------------------------------------\n!     Final Optimization\n!---------------------------------------------------------------------\n\n   tmp_optlev = env%optlev\n   if (env%optlev .lt. 1.0) env%optlev = 1.0d0 !higher accuracy\n\n   if (.not. skip) then\n      call cff_opt(.true., env, 'filled_cluster.coord', n_ini, conv(env%nqcgclust + 1),&\n             & 'TMPCFF', conv, nothing_added)\n   else\n      n_ini = 0 !If this is 0, no constraining will be done (optimization of total system)\n      nothing_added = .true.\n      call cff_opt(.true., env, 'filled_cluster.coord', n_ini, env%nqcgclust, 'TMPCFF',&\n             & conv, nothing_added)\n   end if\n   env%optlev = tmp_optlev\n\n   call pr_ensemble_energy()\n\n   solv_ens%nall = env%nqcgclust\n   solv_ens%nat = nat_tot\n\n!--- Getting results--------------------------------------------------------------\n   open (newunit=ich31, file='crest_rotamers_0.xyz')\n   open (newunit=ich98, file='cluster_energy.dat')\n   write (ich98, '(3x,''#'',11x,''Energy [Eh]'',6x,''SASA'')')\n\n   do i = 1, env%nqcgclust\n      write (to, '(\"TMPCFF\",i0)') i\n      call chdir(to)\n      call copy('xtbopt.coord', 'final_cluster.coord')\n\n!--- Reading structure\n      call clus%deallocate()\n      call rdnat('final_cluster.coord', clus%nat)\n      allocate (clus%at(clus%nat), clus%xyz(3, clus%nat))\n      call rdcoord('final_cluster.coord', clus%nat, clus%at, clus%xyz)\n\n!--- Getting energy and calculating properties\n      call grepval('xtb_sp.out', '| TOTAL ENERGY', e_there, e_cluster(i))\n      call grepval('xtb_sp.out', '         :: add. restraining', e_there, e_fix(i))\n      e_fix(i) = e_fix(i)*eh/sqrt(float(clus%nat))\n      call get_sphere(.false., clus, .false.)\n      if (clus%nat .gt. n_ini) then\n         solv_added = (clus%nat - (n_ini))/solv%nat\n      else\n         solv_added = 0\n      end if\n      dens = 0.001*((clus%nat/solv%nat)*solv%mass)/(1.0d-30*clus%vtot*bohr**3)\n      call analyze_cluster(solv_added, clus%nat, n_ini, solv%nat, clus%xyz, clus%at, shr_av, shr)\n      e_norm(i) = e_cluster(i)*env%nsolv/(clus%nat/solv%nat)\n      atotS = clus%atot*env%nsolv/(clus%nat/solv%nat)\n\n!--- Writing outputfiles\n      write (ich31, '(2x,i0)') clus%nat\n      write (ich31, '(2x,f18.8,2x,a)') e_cluster(i)\n      do j = 1, clus%nat\n         write (ich31, '(1x,a2,1x,3f20.10)') i2e(clus%at(j), 'nc'), clus%xyz(1:3, j)*bohr\n      end do\n\n      write (ich98, '(''No'',i4,F20.10,3x,f8.1)') i, e_norm(i), atotS\n\n!--- Print to screen\n      write (*, '(x,i4,4x,F13.6,2x,f6.3,1x,f8.3,2x,2f6.1,3x,f8.1,3x,a)') &\n              & i, e_norm(i), dens, e_fix(i), shr_av, shr, atotS, trim(optlevflag(env%optlev))\n\n      call chdir(tmppath2)\n   end do\n\n   close (ich98)\n   close (ich31)\n\n   call solv_ens%deallocate()\n   call solv_ens%open('crest_rotamers_0.xyz')\n\n   solv_ens%er = e_cluster\n   call copy('crest_rotamers_0.xyz', 'crest_ensemble.xyz')\n\n!--- crest_best structure\n   minpos = minloc(solv_ens%er, dim=1)\n   write (to, '(\"TMPCFF\",i0)') minpos\n   call chdir(to)\n   call clus%deallocate\n   call rdnat('final_cluster.coord', clus%nat)\n   allocate (clus%at(clus%nat), clus%xyz(3, clus%nat))\n   call rdcoord('final_cluster.coord', clus%nat, clus%at, clus%xyz)\n   clus%xyz = clus%xyz*bohr\n   call chdir(tmppath2)\n   write (comment, '(F20.8)') solv_ens%er(minpos)\n   call wrxyz('crest_best.xyz', clus%nat, clus%at, clus%xyz, comment)\n\n!--- Boltz. average-------------------------------------------------------------------------\n   write (*, *)\n   write (*, '(2x,''------------------------------------------------------------------------'')')\n   write (*, '(2x,''------------------------------------------------------------------------'')')\n   write (*, '(2x,''Boltz. averaged energy of final cluster:'')')\n   e_cluster = solv_ens%er*eh\n   e_norm = e_norm*eh\n   call sort_min(env%nqcgclust, 1, 1, e_norm)\n   call aver(.true., env, solv_ens%nall, e_norm(1:env%nqcgclust), S, H, G, sasa, .false.)\n   write (*, '(7x,''G /Eh     :'',F14.8)') G/eh\n   write (*, '(7x,''T*S /kcal :'',f8.3)') S\n   solv_ens%er = e_norm/eh !normalized energy needed for final evaluation\n\n   solv_ens%g = G\n   solv_ens%s = S\n\n!--- Cleanup\n   call copysub('crest_ensemble.xyz', resultspath)\n   call copysub('cluster_energy.dat', resultspath)\n   call copysub('crest_best.xyz', resultspath)\n   call copysub('population.dat', resultspath)\n   call chdir(tmppath)\n   if (.not. env%keepModef) call rmrf('tmp_CFF')\n   call chdir(thispath)\n\n!--- Printouts\n   write (*, *)\n   write (*, '(2x,''Solvent cluster generation finished.'')')\n   write (*, '(2x,''Results can be found in solvent_cluster directory'')')\n   write (*, '(2x,''Structures in file <crest_ensemble.xyz>'')')\n   write (*, '(2x,''Energies in file <cluster_energy.dat>'')')\n   write (*, '(2x,''Population in file <population.dat>'')')\n\n   env%gfnver = gfnver_tmp\n   env%optlev = optlev_tmp\n\n   deallocate (e_empty)\n   deallocate (converged)\n   deallocate (outer_ell_abc)\n   deallocate (inner_ell_abc)\n\n   call tim%stop(8)\n\nend subroutine qcg_cff\n\nsubroutine qcg_freq(env, tim, solu, solv, solu_ens, solv_ens)\n   use crest_parameters\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n\n   implicit none\n\n   type(systemdata)           :: env\n   type(timer)                :: tim\n   type(zmolecule)            :: solu, solv, clus\n   type(ensemble)             :: solu_ens, solv_ens\n\n   integer                    :: r, io, f, g, h\n   integer                    :: i\n   character(len=512)         :: thispath, resultspath, tmppath, tmppath2\n   character(len=80)          :: to\n   character(len=20)          :: gfnver_tmp\n   real(wp)                   :: optlev_tmp\n   real(wp)                   :: gt(3)\n   real(wp)                   :: ht(3)\n   real(wp)                   :: svib(3)\n   real(wp)                   :: srot(3)\n   real(wp)                   :: stra(3)\n   integer                    :: ich65, ich56, ich33, ich81\n   logical                    :: opt\n\n   call tim%start(9, 'Frequencies')\n\n   call pr_qcg_freq()\n\n!--- Setting defaults (same as ensemble optimization and cff to have comparable structures)\n   optlev_tmp = env%optlev\n   env%optlev = 1.0d0    !Increaseing percision for ensemble search to minimze scattering\n   gfnver_tmp = env%gfnver\n   env%gfnver = env%freqver  !Setting method\n\n!--- Folder management\n   call getcwd(thispath)\n   r = makedir('frequencies')\n   call chdir('frequencies')\n   call getcwd(resultspath)\n   call chdir(thispath)\n   call chdir(env%scratchdir)\n   call getcwd(tmppath)\n   io = makedir('tmp_freq')\n   call copysub('.CHRG', 'tmp_freq')\n   call copysub('.UHF', 'tmp_freq')\n   call chdir('tmp_freq')\n   call getcwd(tmppath2)\n   f = makedir('tmp_solu')\n   call copysub('.CHRG', 'tmp_solu')\n   call copysub('.UHF', 'tmp_solu')\n   g = makedir('tmp_solv')\n   h = makedir('tmp_gas1') !One solute molecule\n   call copysub('.CHRG', 'tmp_gas1')\n   call copysub('.UHF', 'tmp_gas1')\n\n!--- Frequencies solute molecule\n   write (*, *) '  SOLUTE MOLECULE'\n   call chdir('tmp_gas1')\n   call wrc0('solute.coord', solu%nat, solu%at, solu%xyz)\n   call chdir(tmppath2)\n   opt = .false.\n   call ens_freq(env, 'solute.coord', 1, 'tmp_gas', opt)\n   call chdir('tmp_gas1')\n   call rdtherm('xtb_freq.out', ht(3), svib(3), srot(3), stra(3), gt(3))\n   solu%gt = gt(3)\n   solu%ht = ht(3)\n   solu%svib = svib(3)\n   solu%srot = srot(3)\n   solu%stra = stra(3)\n\n   call chdir(tmppath2)\n\n!--- Folder setup for cluster\n   call chdir('tmp_solu')\n   call solu_ens%write('solute_ensemble.xyz')\n\n!--- All cluster are of the same size\n   call clus%deallocate()\n   clus%nat = solu_ens%nat\n   allocate (clus%at(clus%nat))\n   allocate (clus%xyz(3, clus%nat))\n   clus%xyz = 0\n   clus%nmol = env%nsolv + 1 !clus%nat/clus%at\n\n   do i = 1, solu_ens%nall\n      call rdxmolselec('solute_ensemble.xyz', i, clus%nat, clus%at, clus%xyz)\n\n!--- Solute cluster\n      write (to, '(\"TMPFREQ\",i0)') i\n      io = makedir(trim(to))\n      call copysub('.UHF', to)\n      call copysub('.CHRG', to)\n      call chdir(to)\n      open (newunit=ich65, file='cluster.xyz')\n      call wrxyz(ich65, clus%nat, clus%at, clus%xyz*bohr)\n      close (ich65)\n\n      call chdir(tmppath2)\n\n      !--- Solvent cluster (only if cff, than the solvent shell is taken, which was fixed all the time)\n      if (env%cff) then\n         call chdir('tmp_solv')\n         write (to, '(\"TMPFREQ\",i0)') i\n         io = makedir(trim(to))\n         call chdir(to)\n         call wrc0('cluster.coord', clus%nat, clus%at, clus%xyz)\n         call wr_cluster_cut('cluster.coord', solu%nat, solv%nat, env%nsolv,&\n                & 'solute_cut.coord', 'solvent_cut.coord')\n\n         call chdir(tmppath2)\n      end if\n      call chdir('tmp_solu')\n\n   end do\n\n   write (*, *) '  SOLUTE CLUSTER'\n\n!> Frequency calculation\n   opt = .true.\n   call ens_freq(env, 'cluster.xyz', solu_ens%nall, 'TMPFREQ', opt)\n   call chdir(tmppath2)\n\n   write (*, *) '  SOLVENT CLUSTER'\n   if (env%cff) then\n      call chdir('tmp_solv')\n      call ens_freq(env, 'solvent_cut.coord', solu_ens%nall, 'TMPFREQ', opt)\n      call chdir(tmppath2)\n   end if\n\n   call clus%deallocate()\n\n   !--- Frequencies solvent cluster (only, if not cff was used)\n   if (.not. env%cff) then\n      call chdir('tmp_solv')\n      call solv_ens%write('solvent_ensemble.xyz')\n\n      do i = 1, solv_ens%nall\n         write (to, '(\"TMPFREQ\",i0)') i\n         io = makedir(trim(to))\n         call copysub('.UHF', to)\n         call copysub('.CHRG', to)\n         call chdir(to)\n         open (newunit=ich65, file='solv_cluster.xyz')\n         call wrxyz(ich65, solv_ens%nat, solv_ens%at, solv_ens%xyz(:, :, i))\n         close (ich65)\n         call chdir(tmppath2)\n         call chdir('tmp_solv')\n      end do\n!> Frequency calculation\n      call ens_freq(env, 'solv_cluster.xyz', solv_ens%nall, 'TMPFREQ', opt)\n      call chdir(tmppath2)\n   end if\n\n!----------------------------------------------------------------------------\n!   Data read out\n!----------------------------------------------------------------------------\n\n!--- Solute in gas phase\n   write (*, *)\n   write (*, *) '  Solute Gas properties'\n   call pr_freq_energy()\n   open (newunit=ich56, file='solute.dat')\n   call pr_freq_file(56)\n   write (*, '(2x,5f10.2)') ht(3), svib(3), srot(3), stra(3), gt(3)\n   write (ich56, '(2x,5f10.2)') ht(3), svib(3), srot(3), stra(3), gt(3)\n   close (ich56)\n\n!--- Solute cluster\n   write (*, *)\n   write (*, *) '  Solute cluster properties'\n   open (newunit=ich33, file='solute_cluster.dat')\n\n   call chdir('tmp_solu')\n\n   allocate (solu_ens%gt(solu_ens%nall))\n   allocate (solu_ens%ht(solu_ens%nall))\n   allocate (solu_ens%svib(solu_ens%nall))\n   allocate (solu_ens%srot(solu_ens%nall))\n   allocate (solu_ens%stra(solu_ens%nall))\n\n   call pr_freq_energy()\n   call pr_freq_file(ich33)\n\n   do i = 1, solu_ens%nall\n      write (to, '(\"TMPFREQ\",i0)') i\n      call chdir(to)\n      call rdtherm('xtb_freq.out', ht(1), svib(1), srot(1), stra(1), gt(1))\n      write (*, '(2x,i0,2x,5f10.2)') i, ht(1), svib(1), srot(1), stra(1), gt(1)\n      write (ich33, '(2x,i0,2x,5f10.2)') i, ht(1), svib(1), srot(1), stra(1), gt(1)\n      solu_ens%gt(i) = gt(1)\n      solu_ens%ht(i) = ht(1)\n      solu_ens%svib(i) = svib(1)\n      solu_ens%srot(i) = srot(1)\n      solu_ens%stra(i) = stra(1)\n\n      call chdir(tmppath2)\n      call chdir('tmp_solu')\n   end do\n   close (ich33)\n\n!--- Solvent cluster\n   write (*, *)\n   write (*, *) '  Solvent cluster properties'\n   call chdir(tmppath2)\n   open (newunit=ich81, file='solvent_cluster.dat')\n\n   call chdir('tmp_solv')\n\n   allocate (solv_ens%gt(solv_ens%nall))\n   allocate (solv_ens%ht(solv_ens%nall))\n   allocate (solv_ens%svib(solv_ens%nall))\n   allocate (solv_ens%srot(solv_ens%nall))\n   allocate (solv_ens%stra(solv_ens%nall))\n\n   call pr_freq_energy()\n   call pr_freq_file(ich81)\n\n   do i = 1, solv_ens%nall\n      write (to, '(\"TMPFREQ\",i0)') i\n      call chdir(to)\n      call rdtherm('xtb_freq.out', ht(2), svib(2), srot(2), stra(2), gt(2))\n      write (*, '(2x,i0,2x,5f10.2)') i, ht(2), svib(2), srot(2), stra(2), gt(2)\n      write (ich81, '(2x,i0,2x,5f10.2)') i, ht(2), svib(2), srot(2), stra(2), gt(2)\n      solv_ens%gt(i) = gt(2)\n      solv_ens%ht(i) = ht(2)\n      solv_ens%svib(i) = svib(2)\n      solv_ens%srot(i) = srot(2)\n      solv_ens%stra(i) = stra(2)\n      call chdir(tmppath2)\n      call chdir('tmp_solv')\n   end do\n   close (ich81)\n\n!--- Saving results\n   call chdir(tmppath2)\n   call copysub('solute.dat', resultspath)\n   call copysub('solute_cluster.dat', resultspath)\n   call copysub('solvent_cluster.dat', resultspath)\n\n!--- Deleting tmp directory\n   call chdir(tmppath)\n   if (.not. env%keepModef) call rmrf(tmppath2)\n   call chdir(thispath)\n\n   env%gfnver = gfnver_tmp\n   env%optlev = optlev_tmp\n\n   call tim%stop(9)\n\nend subroutine qcg_freq\n\nsubroutine qcg_eval(env, solu, solu_ens, solv_ens)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n\n   implicit none\n\n   type(systemdata)           :: env\n   type(zmolecule)            :: solu\n   type(ensemble)             :: solu_ens, solv_ens\n\n   character(len=512)         :: thispath\n\n   integer                    :: i, j\n   integer                    :: srange\n   integer                    :: freqscal\n   real(wp)                   :: g1(solu_ens%nall)\n   real(wp)                   :: g2(solv_ens%nall)\n   real(wp)                   :: g3\n   real(wp)                   :: Gsolv(20)\n   real(wp)                   :: Hsolv\n   real(wp)                   :: G_solute(20)\n   real(wp)                   :: H_solute\n   real(wp)                   :: G_solvent(20)\n   real(wp)                   :: H_solvent\n   real(wp)                   :: G_mono(20)\n   real(wp)                   :: H_mono\n   real(wp)                   :: S(20)\n   real(wp)                   :: volw\n   real(wp)                   :: sasa\n   real(wp)                   :: dum, dum1, dum2\n   real(wp)                   :: e_solute(solu_ens%nall)\n   real(wp)                   :: e_solvent(solv_ens%nall)\n   real(wp)                   :: scal(20)\n   integer                    :: ich23\n   real(wp), parameter         :: eh = 627.509541d0\n\n   interface\n      subroutine aver(pr, env, runs, e_tot, S, H, G, sasa, a_present, a_tot)\n         use iso_fortran_env, only: wp => real64\n         use crest_data\n\n         implicit none\n         type(systemdata), intent(in)     :: env\n         integer, intent(in)             :: runs\n         real(wp), intent(inout)         :: e_tot\n         real(wp), intent(in), optional  :: a_tot\n         real(wp), intent(out)           :: S\n         real(wp), intent(out)           :: H\n         real(wp), intent(out)           :: G\n         real(wp), intent(out)           :: sasa\n         logical, intent(in)             :: pr, a_present\n         dimension e_tot(runs)\n         dimension a_tot(runs)\n      end subroutine aver\n   end interface\n\n   call pr_eval_eval()\n\n   call getcwd(thispath)\n\n   freqscal = nint(env%freq_scal/0.05)\n   srange = 20\n   do i = 1, srange\n      scal(i) = 0.05*i\n   end do\n\n!--- Solute Cluster\n   !H_solv\n   do i = 1, solu_ens%nall\n      e_solute(i) = solu_ens%er(i)*eh + solu_ens%ht(i)\n   end do\n   call aver(.false., env, solu_ens%nall, e_solute, dum1, H_solute, dum2, sasa, .false.)\n   !G_solv\n   do i = 1, srange\n      do j = 1, solu_ens%nall\n         g1(j) = solu_ens%ht(j) - (env%tboltz*(solu_ens%svib(j) + scal(i)*(solu_ens%srot(j) + solu_ens%stra(j)))/1000)\n         e_solute(j) = solu_ens%er(j)*eh + g1(j)\n      end do\n      call aver(.false., env, solu_ens%nall, e_solute, S(i), dum, G_solute(i), sasa, .false.)\n   end do\n\n!--- Solvent Cluster\n   !H_solv\n   do i = 1, solv_ens%nall\n      e_solvent(i) = solv_ens%er(i)*eh + solv_ens%ht(i)\n   end do\n   call aver(.false., env, solv_ens%nall, e_solvent, dum1, H_solvent, dum2, sasa, .false.)\n\n   !G_solv\n   do i = 1, srange\n      do j = 1, solv_ens%nall\n         g2(j) = solv_ens%ht(j) - &\n                 & (env%tboltz*(solv_ens%svib(j) + scal(i)*(solv_ens%srot(j) + solv_ens%stra(j)))/1000)\n         e_solvent(j) = solv_ens%er(j)*eh + g2(j)\n      end do\n      call aver(.false., env, solv_ens%nall, e_solvent, S(i), dum, G_solvent(i), sasa, .false.)\n   end do\n\n!--- Solute gas phase\n   H_mono = solu%energy*eh + solu%ht\n   do i = 1, srange\n      g3 = solu%ht - (env%tboltz*(solu%svib + scal(i)*(solu%srot + solu%stra))/1000)\n      G_mono(i) = solu%energy*eh + g3\n   end do\n\n   Gsolv(1:20) = G_solute(1:20) - G_solvent(1:20) - G_mono(1:20)\n   Hsolv = H_solute - H_solvent - H_mono\n\n!--- Calculate Volume work and include\n   volw = (env%tboltz*8.31451/1000./4.184)*log(24.47d0*env%tboltz/298.15)\n   Gsolv(1:20) = Gsolv(1:20) - volw\n   Hsolv = Hsolv - volw\n   call pr_eval_1(Gsolv(20), Hsolv)\n   call pr_eval_2(srange, Gsolv, scal)\n   call pr_eval_3(srange, freqscal, env%freq_scal, Gsolv)\n\n! Save Result\n   open (newunit=ich23, file='frequencies/result.dat')\n   write (ich23, '(\"Solvation Free Energy [kcal/mol] :\")')\n   write (ich23, '(f8.2)') Gsolv(freqscal)\n   close (ich23)\n\nend subroutine qcg_eval\n\nsubroutine write_qcg_setup(env)\n   use crest_data\n   use iomod\n   implicit none\n\n   type(systemdata) :: env\n\n   write (*, *)\n   write (*, '(2x,''========================================='')')\n   write (*, '(2x,''|   quantum cluster growth: INPUT       |'')')\n   write (*, '(2x,''========================================='')')\n   write (*, *)\n   select case (env%qcg_runtype)\n   case (0)\n      write (*, '(2x,''QCG: Only Cluster Generation'')')\n   case (1)\n      write (*, '(2x,''QCG: Cluster + Ensemble Generation'')')\n      if (env%ensemble_method .eq. 0) write (*, '(2x,''Ensemble generated via CREST'')')\n      if (env%ensemble_method .eq. 1) write (*, '(2x,''Ensemble generated via MD Simulation'')')\n      if (env%ensemble_method .eq. 2) write (*, '(2x,''Ensemble generated via MetaDynamic'')')\n   case (2)\n      write (*, '(2x,''QCG: Calculation of delta E_solv'')')\n      if (env%ensemble_method .eq. 0) write (*, '(2x,''Ensemble generated via CREST'')')\n      if (env%ensemble_method .eq. 1) write (*, '(2x,''Ensemble generated via MD Simulation'')')\n      if (env%ensemble_method .eq. 2) write (*, '(2x,''Ensemble generated via MetaDynamic'')')\n   case (3)\n      write (*, '(2x,''QCG: Calculation of delta G_solv'')')\n      if (env%ensemble_method .eq. 0) write (*, '(2x,''Ensemble generated via CREST'')')\n      if (env%ensemble_method .eq. 1) write (*, '(2x,''Ensemble generated via MD Simulation'')')\n      if (env%ensemble_method .eq. 2) write (*, '(2x,''Ensemble generated via MetaDynamic'')')\n   case default\n      continue\n   end select\n   write (*, *)\n   write (*, '(2x,''input parameters     '')')\n   write (*, '(2x,''solute                 : '',a)') trim(env%solu_file)\n   write (*, '(2x,''charge                 : '',i0)') env%chrg\n   write (*, '(2x,''uhf                    : '',i0)') env%uhf\n   write (*, '(2x,''solvent                : '',a)') trim(env%solv_file)\n   if (env%nsolv .ne. 0) then\n      write (*, '(2x,''# of solvents to add   : '',i0)') env%nsolv\n   else if (env%nsolv .eq. 0) then\n      write (*, '(2x,''# of solvents to add   : until convergence, but maximal'',1x,i4)') env%max_solv\n   end if\n   if (env%nqcgclust .ne. 0) then\n      write (*, '(2x,''# of cluster generated : '',i0)') env%nqcgclust\n   else\n      write (*, '(2x,''Cluster generated that are above 10 % populated '')')\n   end if\n\n   write (*, '(2x,''# of CPUs used         : '',i0)') env%Threads\n   if (env%solvent .eq. '') then\n      write (*, '(2x,''No gbsa/alpb model''  )')\n   else\n      write (*, '(2x,''Solvation model        : '',a)') env%solvent\n   end if\n   write (*, '(2x,''xtb opt level          : '',a)') trim(optlevflag(env%optlev))\n   write (*, '(2x,''System temperature [K] : '',F5.1)') env%tboltz\n   write (*, '(2x,''RRHO scaling factor    : '',F4.2)') env%freq_scal\n   write (*, *)\n   if (env%use_xtbiff) write (*, '(2x,''Use of xTB-IFF standalone requested'')')\n\nend subroutine write_qcg_setup\n\nsubroutine get_sphere(pr, zmol, r_logical)\n   use crest_parameters, only : wp\n   use zdata\n\n   implicit none\n   type(zmolecule), intent(inout) :: zmol\n   type(zmolecule) :: dum\n   logical        :: pr\n   logical        :: r_logical !Determines wether r is overwritten or not\n   real(wp), parameter :: pi43 = 3.1415926540d0*4.0d0/3.0d0\n   real(wp), parameter :: pi = 3.1415926540d0\n   real(wp), parameter :: third = 1.0d0/3.0d0\n   real(wp), parameter :: bohr = 0.52917726d0\n\n   integer :: i\n   real*8 :: rad(zmol%nat), xyz_tmp(3, zmol%nat)\n   real(wp), allocatable :: rcov(:)\n\n   allocate (rcov(94))\n   rcov = (/ &\n       &  2.18230009, 1.73469996, 3.49559999, 3.09820008, 3.21600008, &\n       &  2.91030002, 2.62249994, 2.48169994, 2.29959989, 2.13739991, &\n       &  3.70819998, 3.48390007, 4.01060009, 3.79169989, 3.50169992, &\n       &  3.31069994, 3.10459995, 2.91479993, 4.24109983, 4.10349989, &\n       &  3.89030004, 3.76419997, 3.72110009, 3.44140005, 3.54620004, &\n       &  3.44210005, 3.43269992, 3.34619999, 3.30080009, 3.23090005, &\n       &  3.95790005, 3.86190009, 3.66249990, 3.52679992, 3.36619997, &\n       &  3.20959997, 4.61759996, 4.47639990, 4.21960020, 4.05970001, &\n       &  3.85960007, 3.75430012, 3.56900001, 3.46230006, 3.39750004, &\n       &  3.35249996, 3.33080006, 3.46199989, 4.26230001, 4.18739986, &\n       &  4.01499987, 3.89010000, 3.73799992, 3.58890009, 5.05670023, &\n       &  5.18139982, 4.62610006, 4.62010002, 4.57019997, 4.52710009, &\n       &  4.48960018, 4.45149994, 4.42339993, 4.12430000, 4.24270010, &\n       &  4.15409994, 4.27939987, 4.24499989, 4.22079992, 4.19859982, &\n       &  4.01300001, 4.24499989, 4.09800005, 3.98550010, 3.89549994, &\n       &  3.74900007, 3.44560003, 3.35249996, 3.25640011, 3.35990000, &\n       &  4.31269979, 4.27640009, 4.11749983, 4.00540018, 3.86439991, &\n       &  3.72160006, 5.07959986, 4.92939997, 4.70429993, 4.42519999, &\n       &  4.45940018, 4.39569998, 4.35389996, 4.43410015/)\n\n   do i = 1, zmol%nat\n      rad(i) = bohr*rcov(zmol%at(i))*1.40 ! scale factor adjusted to rough\n      xyz_tmp(1:3, i) = bohr*zmol%xyz(1:3, i)\n   end do\n\n   dum = zmol\n   dum%xyz = xyz_tmp\n\n   call get_volume(dum, rad)\n\n   zmol%atot = dum%atot/bohr**2\n   zmol%vtot = dum%vtot/bohr**3\n\n   if (r_logical) then\n      zmol%rtot = zmol%vtot*3.0/4.d0/pi\n      zmol%rtot = zmol%rtot**(1.d0/3.d0)\n   end if\n\n   if (pr) then\n      if (r_logical) then\n         write (*, '(2x,''molecular radius (Bohr**1):'',F8.2)') zmol%rtot\n      end if\n      write (*, '(2x,''molecular area   (Bohr**2):'',F8.2)') zmol%atot\n      write (*, '(2x,''molecular volume (Bohr**3):'',F8.2)') zmol%vtot\n   end if\n\n   deallocate (rcov)\nend subroutine get_sphere\n\nsubroutine cma_shifting(solu, solv)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n   use axis_module, only: cma\n   implicit none\n\n   type(zmolecule)    :: solu, solv\n\n   integer            :: i\n\n   call cma(solu%nat, solu%at, solu%xyz, solu%cma)\n   call cma(solv%nat, solv%at, solv%xyz, solv%cma)\n\n   do i = 1, solu%nat\n      solu%xyz(1:3, i) = solu%xyz(1:3, i) - solu%cma(1:3)\n   end do\n   do i = 1, solv%nat\n      solv%xyz(1:3, i) = solv%xyz(1:3, i) - solv%cma(1:3)\n   end do\n\nend subroutine cma_shifting\n\nsubroutine get_ellipsoid(env, solu, solv, clus, pr1)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n   use axis_module\n   implicit none\n\n   type(systemdata)   :: env\n   type(zmolecule)    :: solu, solv, clus\n   type(zmolecule)    :: dummy_solu, dummy_solv\n   real(wp)           :: rabc_solu(3), rabc_solv(3)\n   real(wp)           :: aniso, sola\n   real(wp)           :: rmax_solu, rmax_solv\n   real(wp)           :: boxr, roff, r\n   character(len=10) :: fname\n   logical            :: ex, pr, pr1\n\n   real(wp), parameter :: pi43 = 3.1415926540d0*4.0d0/3.0d0\n   real(wp), parameter :: pi = 3.1415926540d0\n   real(wp), parameter :: third = 1.0d0/3.0d0\n\n   pr = .false. !Outprint deactivated\n\n   fname = 'eaxis.qcg'\n   inquire (file=fname, exist=ex)\n\n   if (pr1) then !First time called\n!--- Moving all coords to the origin (transformation)\n      call axistrf(solu%nat, solu%nat, solu%at, solu%xyz)\n!  call axistrf(solv%nat,solv%nat,solv%at,solv%xyz)  !Not done in original QCG code\n      call axistrf(clus%nat, solu%nat, clus%at, clus%xyz)\n\n!--- Overwrite solute and solvent coord in original file with transformed and optimized ones\n      call wrc0('solute', solu%nat, solu%at, solu%xyz)\n      call wrc0('solvent', solv%nat, solv%at, solv%xyz)\n\n!--- Getting axis\n      write (*, *) 'Solute:'\n      call axis(pr1, solu%nat, solu%at, solu%xyz, solu%eax)\n      write (*, *) 'Solvent:'\n      call axis(pr1, solv%nat, solv%at, solv%xyz, solv%eax)\n      write (*, *)\n   end if\n\n!--- Computing anisotropy factor of solute and solvent\n   sola = sqrt(1.+(solu%eax(1) - solu%eax(3))/((solu%eax(1) + solu%eax(2) + solu%eax(3))/3.))\n   aniso = sqrt(1.+(solv%eax(1) - solv%eax(3))/((solv%eax(1) + solv%eax(2) + solv%eax(3))/3.)) ! =1 for a spherical system\n\n!--- Get maximum intramoleclar distance of solute and solvent\n   call getmaxrad(solu%nat, solu%at, solu%xyz, rmax_solu)\n   call getmaxrad(solv%nat, solv%at, solv%xyz, rmax_solv)\n\n!--- Getting V and A of dummies\n   dummy_solu = solu\n   dummy_solv = solv !Why is dummy_solv%vtot different to solv%vtot\n   call get_sphere(.false., dummy_solu, .false.)\n   call get_sphere(.false., dummy_solv, .false.)\n\n!--- Computation of outer Wall\n   roff = sola*dummy_solu%vtot/1000\n   boxr = ((0.5*aniso*clus%nmol*dummy_solv%vtot + dummy_solu%vtot)/pi43)**third + roff + rmax_solv*0.5 !0.5 both\n   r = (boxr**3/(solu%eax(1)*solu%eax(2)*solu%eax(3)))**third       ! volume of ellipsoid = volume of sphere\n   rabc_solv = solu%eax*r                              ! outer solvent wall\n\n!--- Computation of inner wall\n   roff = sola*dummy_solu%vtot/1000\n   boxr = ((sola*dummy_solu%vtot)/pi43)**third + roff + rmax_solu*0.1 !0.1 before\n   r = (boxr**3/(solu%eax(1)*solu%eax(2)*solu%eax(3)))**third       ! volume of ellipsoid = volume of sphere\n   rabc_solu = solu%eax*r\n   dummy_solu%ell_abc(1) = solu%eax(1)**2/sum((solu%eax(1:3))**2)\n   dummy_solu%ell_abc(2) = solu%eax(2)**2/sum((solu%eax(1:3))**2)\n   dummy_solu%ell_abc(3) = solu%eax(3)**2/sum((solu%eax(1:3))**2)\n   rabc_solu = dummy_solu%ell_abc*r\n\n   solu%aniso = sola\n   solv%aniso = aniso\n   solu%ell_abc = rabc_solu\n   clus%ell_abc = rabc_solv*env%potscal\n\n   if (pr1) then\n      write (*, '(2x,''solvent anisotropy            :'',4f10.3)') aniso\n      write (*, '(2x,''solute anisotropy             :'',4f10.3)') sola\n      write (*, '(2x,''roff inner wall               :'',4f10.3)') roff\n      write (*, '(2x,''solute max dist               :'',4f10.3)') rmax_solu\n      write (*, '(2x,''solvent max dist              :'',4f10.3)') rmax_solv\n      write (*, '(2x,''inner unit axis               :'',3f10.3)') dummy_solu%ell_abc(1:3)\n      write (*, '(2x,''inner ellipsoid/Bohr          :'',3f10.3)') rabc_solu(1:3)\n      write (*, '(2x,''scaling factor outer ellipsoid:'',3f10.3)') env%potscal\n      write (*, '(2x,''outer ellipsoid/Bohr          :'',3f10.3)') clus%ell_abc(1:3)\n      if (env%potscal .gt. 1.0_wp) write &\n           &(*, '(2x,''!!!WARNING: A SCALING FACTOR LARGER 1.0 IS ONLY FOR MICROSOLVATION RECOMMENDED'')')\n      write (*, *)\n   end if\n\nend subroutine get_ellipsoid\n\nsubroutine getmaxrad(n, at, xyz, r)\n   use crest_parameters, only : wp\n   implicit none\n   real(wp) :: xyz(3, n), r\n   integer :: n, at(n)\n\n   real(wp) :: rx, ry, rz, rr\n   integer :: i, j\n   real(wp), allocatable :: rcov(:)\n\n   allocate (rcov(94))\n   rcov = (/ &\n    &  2.18230009, 1.73469996, 3.49559999, 3.09820008, 3.21600008, &\n    &  2.91030002, 2.62249994, 2.48169994, 2.29959989, 2.13739991, &\n    &  3.70819998, 3.48390007, 4.01060009, 3.79169989, 3.50169992, &\n    &  3.31069994, 3.10459995, 2.91479993, 4.24109983, 4.10349989, &\n    &  3.89030004, 3.76419997, 3.72110009, 3.44140005, 3.54620004, &\n    &  3.44210005, 3.43269992, 3.34619999, 3.30080009, 3.23090005, &\n    &  3.95790005, 3.86190009, 3.66249990, 3.52679992, 3.36619997, &\n    &  3.20959997, 4.61759996, 4.47639990, 4.21960020, 4.05970001, &\n    &  3.85960007, 3.75430012, 3.56900001, 3.46230006, 3.39750004, &\n    &  3.35249996, 3.33080006, 3.46199989, 4.26230001, 4.18739986, &\n    &  4.01499987, 3.89010000, 3.73799992, 3.58890009, 5.05670023, &\n    &  5.18139982, 4.62610006, 4.62010002, 4.57019997, 4.52710009, &\n    &  4.48960018, 4.45149994, 4.42339993, 4.12430000, 4.24270010, &\n    &  4.15409994, 4.27939987, 4.24499989, 4.22079992, 4.19859982, &\n    &  4.01300001, 4.24499989, 4.09800005, 3.98550010, 3.89549994, &\n    &  3.74900007, 3.44560003, 3.35249996, 3.25640011, 3.35990000, &\n    &  4.31269979, 4.27640009, 4.11749983, 4.00540018, 3.86439991, &\n    &  3.72160006, 5.07959986, 4.92939997, 4.70429993, 4.42519999, &\n    &  4.45940018, 4.39569998, 4.35389996, 4.43410015/)\n\n   r = 0\n   do i = 1, n - 1\n      do j = i + 1, n\n         rx = xyz(1, i) - xyz(1, j)\n         ry = xyz(2, i) - xyz(2, j)\n         rz = xyz(3, i) - xyz(3, j)\n         rr = sqrt(rx**2 + ry**2 + rz**2) + rcov(at(i)) + rcov(at(j))\n         if (rr .gt. r) r = rr\n      end do\n   end do\n\n   deallocate (rcov)\n\nend subroutine getmaxrad\n\nsubroutine ellipsout(fname, n, at, xyz, r1)\n   use iso_fortran_env, only: wp => real64\n   use strucrd, only: i2e\n   implicit none\n\n   integer            :: i\n   integer            :: n, at(n)\n   real(wp)           :: xyz(3, n), r1(3)\n   real(wp)           :: x, y, z, f, rr\n   character(len=*)   :: fname\n   integer            :: ich11\n\n   open (newunit=ich11, file=fname)\n   write (ich11, '(a)') '$coord'\n   do i = 1, n\n      write (ich11, '(3F24.14,6x,a)') xyz(1, i), xyz(2, i), xyz(3, i), i2e(at(i))\n   end do\n   do i = 1, 500\n      call random_number(x)\n      call random_number(f)\n      if (f .gt. 0.5) x = -x\n      call random_number(y)\n      call random_number(f)\n      if (f .gt. 0.5) y = -y\n      call random_number(z)\n      call random_number(f)\n      if (f .gt. 0.5) z = -z\n      rr = sqrt(x*x + y*y + z*z)\n      x = x*r1(1)/rr\n      y = y*r1(2)/rr\n      z = z*r1(3)/rr\n      write (ich11, '(3F24.14,6x,a2)') x, y, z, 'he'\n   end do\n   write (ich11, '(a)') '$end'\n   close (ich11)\n\nend subroutine ellipsout\n\nsubroutine both_ellipsout(fname, n, at, xyz, r1, r2)\n   use iso_fortran_env, only: wp => real64\n   use strucrd, only: i2e\n   implicit none\n\n   integer            :: i\n   integer            :: n, at(n)\n   real(wp)           :: xyz(3, n), r1(3)\n   real(wp), optional :: r2(3)\n   real(wp)           :: x, y, z, f, rr\n   character(len=*)   :: fname\n   integer            :: ich11\n\n   open (newunit=ich11, file=fname)\n   write (ich11, '(a)') '$coord'\n   do i = 1, n\n      write (ich11, '(3F24.14,6x,a)') xyz(1, i), xyz(2, i), xyz(3, i), i2e(at(i))\n   end do\n   do i = 1, 500\n      call random_number(x)\n      call random_number(f)\n      if (f .gt. 0.5) x = -x\n      call random_number(y)\n      call random_number(f)\n      if (f .gt. 0.5) y = -y\n      call random_number(z)\n      call random_number(f)\n      if (f .gt. 0.5) z = -z\n      rr = sqrt(x*x + y*y + z*z)\n      x = x*r1(1)/rr\n      y = y*r1(2)/rr\n      z = z*r1(3)/rr\n      write (ich11, '(3F24.14,6x,a2)') x, y, z, 'he'\n   end do\n   if (present(r2)) then\n      do i = 1, 100\n         call random_number(x)\n         call random_number(f)\n         if (f .gt. 0.5) x = -x\n         call random_number(y)\n         call random_number(f)\n         if (f .gt. 0.5) y = -y\n         call random_number(z)\n         call random_number(f)\n         if (f .gt. 0.5) z = -z\n         rr = sqrt(x*x + y*y + z*z)\n         x = x*r2(1)/rr\n         y = y*r2(2)/rr\n         z = z*r2(3)/rr\n         write (ich11, '(3F24.14,6x,a2)') x, y, z, 'b'\n      end do\n   end if\n   write (ich11, '(a)') '$end'\n   close (ich11)\n\nend subroutine both_ellipsout\n\nsubroutine get_interaction_E(env, solu, solv, clus, iter, E_inter)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n   implicit none\n\n   type(systemdata)            :: env\n   type(zmolecule), intent(in) :: solu, solv, clus\n   real(wp)                    :: e_cluster, e_solute, e_solvent\n   real(wp)                    :: E_inter(env%nsolv)           ! interaction energy\n   integer                     :: iter\n   logical                     :: e_there\n\n   call remove('cluster.coord')\n\n!--- Prepare input coordinate files\n   call wrc0('cluster.coord', clus%nat, clus%at, clus%xyz)\n   call wr_cluster_cut('cluster.coord', solu%nat, solv%nat, iter, 'solute_cut.coord', 'solvent_cut.coord')\n\n!--- Perform single point calculations and recieve energies\n   call xtbsp3(env, 'solute_cut.coord')\n   call grepval('xtb.out', '| TOTAL ENERGY', e_there, e_solute)\n   if (.not. e_there) write (*, *) 'Solute energy not found'\n   call xtbsp3(env, 'solvent_cut.coord')\n   call grepval('xtb.out', '| TOTAL ENERGY', e_there, e_solvent)\n   if (.not. e_there) write (*, *) 'Solvent energy not found'\n   call xtbsp3(env, 'cluster.coord')\n   call grepval('xtb.out', '| TOTAL ENERGY', e_there, e_cluster)\n   if (.not. e_there) write (*, *) 'Cluster energy not found'\n\n   E_inter(iter) = e_cluster - e_solute - e_solvent\n\nend subroutine get_interaction_E\n\nsubroutine analyze_cluster(nsolv, n, nS, nM, xyz, at, av, last)\n   use iso_fortran_env, only: wp => real64\n   use axis_module, only: cma\n   implicit none\n   real(wp) xyz(3, n)\n   real(wp) av, last\n   integer n, nS, nM, nsolv, at(n)\n   real(wp) xyzM(3, nM)\n   integer atm(nM)\n   real(wp) xyzS(3, nS)\n   integer atS(nS)\n   real(wp) x1(3), x2(3), r\n   integer i, is, ie\n\n   if (nsolv .eq. 1) return\n   xyzS(1:3, 1:nS) = xyz(1:3, 1:nS)\n   atS(1:nS) = at(1:nS)\n   call cma(nS, atS, xyzS, x1)\n\n   av = 0\n   do i = 1, nsolv\n      is = nS + (i - 1)*nM + 1\n      ie = is + nM - 1\n      xyzM(1:3, 1:nM) = xyz(1:3, is:ie)\n      atM(1:nM) = at(is:ie)\n      call cma(nM, atM, xyzM, x2)\n      r = sqrt((x1(1) - x2(1))**2 + (x1(2) - x2(2))**2 + (x1(3) - x2(3))**2)\n      if (i .lt. nsolv) then\n         av = av + r\n      else\n         last = r\n      end if\n   end do\n   av = av/float(nsolv - 1)\nend subroutine analyze_cluster\n\nsubroutine aver(pr, env, runs, e_tot, S, H, G, sasa, a_present, a_tot)\n   use iso_fortran_env, only: wp => real64\n   use crest_data\n\n   implicit none\n!---- Dummy\n   type(systemdata), intent(in)     :: env\n   integer, intent(in)             :: runs\n   real(wp), intent(inout)         :: e_tot\n   real(wp), intent(in), optional  :: a_tot\n   real(wp), intent(out)           :: S\n   real(wp), intent(out)           :: H\n   real(wp), intent(out)           :: G\n   real(wp), intent(out)           :: sasa\n!---- Stack\n   logical, intent(in)             :: pr, a_present\n   integer                         :: j, jmin\n   real(wp)                        :: A\n   real(wp)                        :: e0\n   real(wp), allocatable           :: de(:)\n   real(wp), allocatable           :: p(:)\n   real(wp)                        :: pmax\n   real(wp)                        :: eav\n   real(wp)                        :: area\n   real(wp)                        :: beta\n   real(wp)                        :: temp\n   integer                         :: ich48\n   real(wp), parameter              :: eh = 627.509541d0\n   dimension e_tot(runs)\n   dimension a_tot(runs)\n\n   temp = env%tboltz\n   allocate (de(runs), source=0.0d0)\n   allocate (p(runs), source=0.0d0)\n\n   beta = 1./(temp*8.314510/4.184/1000.+1.d-14)\n   e0 = e_tot(1)\n   de(1:runs) = (e_tot(1:runs) - e0)\n   call qcg_boltz(env, runs, de, p)\n\n   A = 0\n   eav = 0\n   pmax = 0\n   area = 0\n   do j = 1, runs\n      A = A + p(j)*log(p(j) + 1.d-12)\n      eav = eav + p(j)*e_tot(j)\n      if (p(j) .gt. pmax) then\n         pmax = p(j)\n         jmin = j\n      end if\n      if (a_present) area = area + p(j)*a_tot(j)\n   end do\n   sasa = area\n   S = (1./beta)*A\n   H = eav\n   G = eav + S\n   if (pr) then\n      open (newunit=ich48, file='population.dat')\n      write (ich48, '(2x, ''cluster'',2x,''E_norm [Eh]'',2x, ''De [kcal]'', 4x, ''p'')')\n      do j = 1, runs\n         if (j .lt. 10) then\n            write (ich48, '(5x,i0,3x,f11.6,5x,f6.4,3x,f6.4)') j, e_tot(j)/eh, de(j), p(j)\n         else\n            write (ich48, '(5x,i0,2x,f11.6,5x,f6.4,3x,f6.4)') j, e_tot(j)/eh, de(j), p(j)\n         end if\n      end do\n      write (ich48, *)\n      write (ich48, '(''Ensemble free energy [Eh]:'', f20.10)') G/eh\n      close (ich48)\n   end if\n\n   deallocate (de, p)\n\nend subroutine aver\n\nsubroutine qcg_boltz(env, n, e, p)\n   use iso_fortran_env, only: wp => real64\n   use crest_data\n   implicit none\n   type(systemdata), intent(in)    :: env\n   integer, intent(in)              :: n\n   real(wp), intent(in)             :: e(*)\n   real(wp), intent(out)            :: p(*)\n   integer                         :: i\n   real(wp)                        :: temp\n   real(wp)                        :: f, hsum, esum\n\n   temp = env%tboltz\n   f = 8.314*temp/4.184d+3\n   esum = 0\n   do i = 1, n\n      esum = esum + exp(-e(i)/f)\n   end do\n   hsum = 0\n   do i = 1, n\n      p(i) = exp(-e(i)/f)/esum\n   end do\nend subroutine qcg_boltz\n\nsubroutine fill_take(env, n2, n12, rabc, ipos)\n   use iso_fortran_env, only: wp => real64\n   use crest_data\n   use strucrd\n   use axis_module, only: cma\n   implicit none\n\n   type(systemdata)      :: env\n   integer, intent(in)   :: n2, n12\n   real(wp), intent(in)   :: rabc(3)\n   integer, intent(out)  :: ipos\n   integer               :: i, m, n21\n   integer               :: at2(n2), at12(n12)\n   integer               :: counter\n   real(wp)              :: xyz2(3, n2), xyz12(3, n12)\n   real(wp)              :: etmp(100)\n   real(wp)              :: eabc\n   real(wp)              :: cma2(3)\n   real(wp), allocatable  :: dist(:)\n\n   eabc = 0\n   counter = 0\n   n21 = n12 - n2 + 1\n   if (env%use_xtbiff) then\n      call rdxtbiffE('xtbscreen.xyz', m, n12, etmp)\n   else\n      call rdxtbiffE('best.xyz', m, n12, etmp)\n   end if\n\n   allocate (dist(m), source=0.0d0)\n   dist = 0.0d0\n\n   do i = 1, m\n      if (env%use_xtbiff) then\n         call rdxmolselec('xtbscreen.xyz', i, n12, at12, xyz12)\n      else\n         call rdxmolselec('final_structures.xyz', i, n12, at12, xyz12)\n      end if\n\n      at2(1:n2) = at12(n21:n12)\n      xyz2(1:3, 1:n2) = xyz12(1:3, n21:n12)\n      call cma(n2, at2, xyz2, cma2)\n      call calc_dist(cma2, rabc, dist(i), eabc)\n      if (eabc .gt. 1.0d0) then\n         dist(i) = 1.0d42\n         counter = counter + 1\n      end if\n   end do\n\n   ipos = minloc(dist(1:m), dim=1)\n\n   if (counter .eq. m) ipos = 0\n\n   deallocate (dist)\nend subroutine fill_take\n\nsubroutine calc_dist(xyz, rabc, dist, eabc)\n   use iso_fortran_env, only: wp => real64\n   implicit none\n\n   real(wp), intent(in)    :: xyz(3)\n   real(wp), intent(in)    :: rabc(3)\n   real(wp), intent(out)   :: dist\n   real(wp), intent(out)   :: eabc\n   real(wp)                :: center(3), rc(3)\n\n   center = 0.d0\n   rc = (xyz(1:3) - center)\n   dist = norm2(rc)\n   eabc = sum((xyz(1:3)**2)/(rabc(1:3)**2))\nend subroutine calc_dist\n\nsubroutine sort_min(i, j, col, A)\n   use iso_fortran_env, only: wp => real64\n   implicit none\n   integer, intent(in)   :: i, j, col\n   real*8, intent(inout) :: A(i, j)\n   real*8                :: buf(j)\n   integer               :: nsize, irow, krow\n! dimension A(i,j)\n   nsize = i\n\n   do irow = 1, nsize\n      krow = minloc(A(irow:nsize, col), dim=1) + irow - 1\n      buf(:) = A(irow, :)\n      A(irow, :) = A(krow, :)\n      A(krow, :) = buf(:)\n   end do\nend subroutine sort_min\n\nsubroutine sort_ensemble(ens, e_ens, fname)\n   use iso_fortran_env, only: wp => real64\n   use crest_data\n   use strucrd\n   implicit none\n   type(ensemble)       :: ens\n   real(wp)             :: e_ens(ens%nall), dum(ens%nall)\n   character(len=*)     :: fname\n   integer              :: ich\n   integer              :: i, e_min\n\n   dum = e_ens\n\n   open (newunit=ich, file=fname)\n\n   do i = 1, ens%nall\n      e_min = minloc(dum, dim=1)\n      call wrxyz(ich, ens%nat, ens%at, ens%xyz(:, :, e_min), e_ens(e_min))\n      dum(e_min) = 0.0d0\n   end do\n   close (ich)\n\nend subroutine sort_ensemble\n\nsubroutine rdtherm(fname, ht, svib, srot, stra, gt)\n   use iso_fortran_env, only: wp => real64\n   use crest_data\n   use iomod\n\n   implicit none\n! Dummy\n   real(wp), intent(out)  :: ht\n   real(wp), intent(out)  :: gt\n   real(wp), intent(out)  :: svib\n   real(wp), intent(out)  :: srot\n   real(wp), intent(out)  :: stra\n! Stack\n   integer                :: nn\n   integer                :: io\n   integer                :: counter\n   integer                :: hg_line\n   real(wp)               :: xx(20)\n   logical                :: ende\n   character(len=*)       :: fname\n   character(len=128)     :: a\n   real(wp), parameter     :: eh = 627.509541d0\n   integer                :: ich\n\n   ende = .false.\n   counter = 0\n   hg_line = 0\n\n   open (newunit=ich, file=fname)\n   do while (.not. ende)\n      read (ich, '(a)', iostat=io) a\n      if (io .lt. 0) then\n         ende = .true.\n         cycle\n      end if\n      if (index(a, 'G(T)/Eh ') .ne. 0) then\n         hg_line = counter\n      end if\n      if (index(a, '  VIB  ') .ne. 0) then\n         call readl(a, xx, nn)\n         svib = xx(5)\n         if (svib .eq. 0.0d0) then\n            call readl(a, xx, nn)\n            svib = xx(4)\n         end if\n      end if\n      if (index(a, '  ROT  ') .ne. 0) then\n         call readl(a, xx, nn)\n         srot = xx(4)\n      end if\n      if (index(a, '  TR   ') .ne. 0) then\n         call readl(a, xx, nn)\n         stra = xx(4)\n      end if\n      if (counter .eq. hg_line + 2) then\n         call readl(a, xx, nn)\n         ht = xx(3)*eh\n         gt = xx(5)*eh\n      end if\n      counter = counter + 1\n   end do\n   close (ich)\nend subroutine rdtherm\n\nsubroutine pr_freq_file(ich)\n   implicit none\n   integer :: ich\n   write (ich, '(2x,\"#       H(T)       SVIB      SROT       STRA      G(T)\")')\n   write (ich, '(2x,\"     [kcal/mol]    [      cal/mol/K        ]    [kcal/mol]\")')\n   write (ich, '(2x,\"--------------------------------------------------------\")')\nend subroutine pr_freq_file\n\nsubroutine qcg_restart(env, progress, solu, solv, clus, solu_ens, solv_ens, clus_backup)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use iomod\n   use zdata\n   use strucrd\n\n   implicit none\n\n   type(systemdata)           :: env\n   type(zmolecule)            :: solu, solv, clus, clus_backup\n   type(ensemble)             :: solu_ens, solv_ens\n   integer                    :: progress\n\n   integer                    :: i\n   character(len=512)         :: thispath\n   character(len=6)           :: counter\n   character(len=7)           :: counter2\n   character(len=8)           :: counter3\n   logical                    :: grow, solu_ensemble, solv_ensemble\n   logical                    :: solv_cff, solv_present, freq, tmp, ex\n   real(wp), allocatable       :: xyz(:, :)\n   real(wp), parameter         :: eh = 627.509541d0\n\n   grow = .false.\n   solu_ensemble = .false.\n   solv_ensemble = .false.\n   solv_cff = .false.\n   solv_present = .false.\n   freq = .false.\n   tmp = .false.\n\n   inquire (file='./grow/cluster.coord', exist=grow)\n   inquire (file='./ensemble/final_ensemble.xyz', exist=solu_ensemble)\n   inquire (file='./solvent_ensemble/final_ensemble.xyz', exist=solv_ensemble)\n   inquire (file='./solvent_ensemble/crest_ensemble.xyz', exist=solv_cff)\n   inquire (file='./frequencies/result.dat', exist=freq)\n\n   if (solv_cff .or. solv_ensemble) solv_present = .true.\n\n   call getcwd(thispath)\n\n!---------------------------------------------------------------------------------\n!        Check, if everything needed is present\n!---------------------------------------------------------------------------------\n\n   if (freq .and. ((.not. grow) .or. (.not. solu_ensemble) .or. (.not. solv_ensemble))) then\n      progress = 0\n      call rmrf('frequencies')\n      freq = .false.\n   end if\n\n   if (solv_present .and. ((.not. grow) .or. (.not. solu_ensemble))) then\n      progress = 0\n      call rmrf('solvent_ensemble')\n      solv_present = .false.\n      solv_cff = .false.\n      solv_ensemble = .false.\n   end if\n\n   if (solu_ensemble .and. (.not. grow)) then\n      progress = 0\n      call rmrf('ensemble')\n      solu_ensemble = .false.\n   end if\n\n!-------------------------------------------------------------\n!           Data read out\n!-------------------------------------------------------------\n\n!--- Grow process\n   if (grow) then\n      env%qcg_restart = .true.\n      call chdir('grow')\n      call rdnat('cluster.coord', clus%nat)\n      allocate (clus%at(clus%nat), clus%xyz(3, clus%nat))\n      call rdcoord('cluster.coord', clus%nat, clus%at, clus%xyz)\n      clus%nmol = (clus%nat - solu%nat)/solv%nat + 1\n      allocate (xyz(3, clus%nat))\n      xyz = clus%xyz\n      call get_ellipsoid(env, solu, solv, clus, .true.)\n      clus%xyz = xyz !Needed, because get_ellipsoid performs axistransformation and not fitting potential\n      deallocate (xyz)\n\n      if (.not. env%cff) then\n         allocate (clus_backup%at(clus%nat))\n         allocate (clus_backup%xyz(3, clus%nat))\n         clus_backup = clus\n      end if\n\n      if (clus%nmol - 1 .ge. env%nsolv) then\n         progress = 1\n         env%nsolv = clus%nmol - 1\n         write (*, *)\n         write (*, *)\n         write (*, '(''Found cluster with '',i0,'' solvents'')') env%nsolv\n         call chdir(thispath)\n      else\n         error stop 'The found cluster is smaller than nsolv. Please restart the whole computaion by removing the grow directory'\n         !Future implementation continue grow process\n         call chdir(thispath)\n         if (solu_ensemble) call rmrf('ensemble')\n         if (solv_ensemble) call rmrf('solvent_ensemble')\n         if (freq) call rmrf('frequencies')\n         solu_ensemble = .false.\n         solv_ensemble = .false.\n         freq = .false.\n         progress = 0\n      end if\n   end if\n\n!--- Solute Ensemble\n   if (solu_ensemble) then\n      call chdir('ensemble')\n      call solu_ens%open('final_ensemble.xyz')\n      call rdensemble('final_ensemble.xyz', solu_ens%nat, solu_ens%nall, solu_ens%at, solu_ens%xyz, solu_ens%er)\n      env%nqcgclust = solu_ens%nall\n      write (*, '(\"  Ensemble of solute-cluster found.\")')\n      write (*, '(\"  Taking all \", i0, \" structures\")') env%nqcgclust\n      call grepval('population.dat', 'Ensemble free energy [Eh]:', ex, solu_ens%G)\n      solu_ens%G = solu_ens%G*eh\n      write (*, *) 'Solute Ensmeble Free E [kcal/mol]', solu_ens%G\n      call chdir(thispath)\n      progress = 2\n   end if\n\n!--- Solvent Ensemble\n   if (solv_present) then\n      call chdir('solvent_ensemble')\n      write (*, '(\"  Ensemble of solvent-cluster found.\")')\n\n      !--- Case CFF\n      if (solv_cff) then\n         call solv_ens%open('crest_ensemble.xyz')\n         do i = 1, solv_ens%nall\n            if (i .le. 9) then\n               write (counter, '(''No   '',i1)') i\n               call grepval('cluster_energy.dat', counter, ex, solv_ens%er(i))\n            else if (i .le. 99) then\n               write (counter2, '(''No   '',i2)') i\n               call grepval('cluster_energy.dat', counter2, ex, solv_ens%er(i))\n            else\n               write (counter3, '(''No   '',i3)') i\n               call grepval('cluster_energy.dat', counter3, ex, solv_ens%er(i))\n            end if\n            write (*, *) 'Energy of cluster', i, solv_ens%er(i)\n         end do\n      end if\n\n      !--- Case MD/Crest run\n      if (solv_ensemble) then\n         call solv_ens%open('final_ensemble.xyz')\n         call rdensemble('final_ensemble.xyz', solv_ens%nat, solv_ens%nall, solv_ens%at, solv_ens%xyz, solv_ens%er)\n      end if\n      call grepval('population.dat', 'Ensemble free energy [Eh]:', ex, solv_ens%G)\n      solv_ens%G = solv_ens%G*eh\n      write (*, *) 'solvent ensmeble free E [kcal/mol]', solv_ens%G\n      call chdir(thispath)\n      progress = 3\n   end if\n\n!--- Frequencies\n   if (freq) then\n      write (*, *)\n      write (*, *)\n      write (*, *) '  Nothing to do'\n      progress = 4\n   end if\n\nend subroutine qcg_restart\n\nsubroutine qcg_cleanup(env)\n   use crest_data\n\n   implicit none\n\n   type(systemdata)      :: env\n   character(len=280)    :: thispath\n   logical               :: tmp\n\n   call getcwd(thispath)\n   call chdir(env%scratchdir)\n   inquire (file='./solute_properties/solute', exist=tmp)\n   if (tmp) then\n      call rmrf('solute_properties')\n      call rmrf('solvent_properties')\n   end if\n\nend subroutine qcg_cleanup\n\nsubroutine check_prog_path_iff(env)\n   use crest_data\n   use iomod, only: command,checkprog_silent\n   implicit none\n   type(systemdata):: env    ! MAIN STORAGE OS SYSTEM DATA\n   character(len=512)           :: prog\n   character(len=256)           :: str\n   character(len=256)           :: path\n   integer                      :: ios, io\n\n   prog = env%ProgIFF\n   !write (str, '(\"which \",a,\" > \",a,\"_path 2>/dev/null\")') trim(prog), trim(prog)\n   !call command(trim(str), io)\n   !write (str, '(a,\"_path\")') trim(prog)\n   !str = trim(str)\n   !open (unit=27, file=str, iostat=ios)\n   !read (27, '(a)', iostat=ios) path\n   call checkprog_silent( prog, iostat=ios)\n   if (ios .ne. 0) then\n      write (0, *) 'No xtb-IFF found. This is currently required for ', &\n      & 'QCG and available at https:/github.com/grimme-lab/xtbiff/'\n      error stop\n   end if\n\nend subroutine check_prog_path_iff\n\nsubroutine write_reference(env, solu, clus)\n   use iso_fortran_env, wp => real64\n   use crest_data\n   use zdata, only: zmolecule\n   use iomod\n   use strucrd\n\n   implicit none\n   type(systemdata):: env    ! MAIN STORAGE OS SYSTEM DATA\n   type(zmolecule)            :: solu, clus\n   type(zmolecule)            :: ref_mol, ref_clus\n\n   ref_mol = solu\n   call rdcoord(env%solu_file, ref_mol%nat, ref_mol%at, ref_mol%xyz) !original solute coordinates\n   call remove(env%fixfile)\n   ref_clus = clus\n   ref_clus%xyz(1:3, 1:solu%nat) = solu%xyz\n   call wrc0(env%fixfile, ref_clus%nat, ref_clus%at, ref_clus%xyz)\n\nend subroutine write_reference\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/qcg/solvtool.f90 b/src/qcg/solvtool.f90
--- a/src/qcg/solvtool.f90	
+++ b/src/qcg/solvtool.f90	
@@ -36,7 +36,7 @@
    type(zmolecule) :: solute, solvent, cluster, cluster_backup 
    type(ensemble) :: full_ensemble, solvent_ensemble
 
-   integer :: progress
+   integer :: progress,io
    character(len=512) :: thispath
 
    real(wp), parameter         :: eh = 627.509541d0
@@ -52,6 +52,11 @@
    !>-----------------------------------
    call qcg_head()
    !>-----------------------------------
+
+!> Check, if xtb is present
+   call checkprog_silent(env%ProgName,.true.,iostat=io)
+   if(io /= 0 ) error stop
+
 !> Check, if xtbiff is present
    if (env%use_xtbiff) then
       call check_prog_path_iff(env)
@@ -170,7 +175,9 @@
    logical :: e_there, tmp, used_tmp
    character(len=512) :: thispath, tmp_grow
    character(len=40)  :: solv_tmp
-   character(len=80) :: atmp
+   character(len=80)  :: atmp
+   character(len=20)  :: gfnver_tmp
+
 
    call getcwd(thispath)
 
@@ -224,6 +231,11 @@
    env%ref%xyz = solu%xyz
 
 !---- Geometry preoptimization solute
+   if (env%final_gfn2_opt) then !If GFN2 final opt, solute also GFN2 optimized
+      gfnver_tmp = env%gfnver
+      env%gfnver = '--gfn2'
+   end if
+
    if ((.not. env%nopreopt) .and. (solu%nat /= 1)) then
       call wrc0('coord', solu%nat, solu%at, solu%xyz) !write coord for xtbopt routine
       if (env%cts%used) then
@@ -246,7 +258,8 @@
       write (ich, '(a)') '$end'
       close (ich)
 
-      call xtbopt(env)
+      !call xtbopt(env)
+      call trialOPT(env)
       call rdcoord('coord', solu%nat, solu%at, solu%xyz)
       call remove('coord')
    end if
@@ -263,6 +276,10 @@
       call xtbsp3(env, 'solute')
    end if
 
+   if (env%final_gfn2_opt) then !If GFN2 final opt, solute also GFN2 optimized
+      env%gfnver = gfnver_tmp
+   end if
+
    call grepval('xtb.out', '| TOTAL ENERGY', e_there, solu%energy)
    if (.not. e_there) then
       write (*, *) 'Total Energy of solute not found'
@@ -293,7 +310,8 @@
 !---- Geometry preoptimization solvent
    if ((.not. env%nopreopt) .and. (solv%nat /= 1)) then
       call wrc0('coord', solv%nat, solv%at, solv%xyz) !write coord for xtbopt routine
-      call xtbopt(env)
+      !call xtbopt(env)
+      call trialOPT(env)
       call rdcoord('coord', solv%nat, solv%at, solv%xyz)
       call remove('coord')
    end if
@@ -358,9 +376,9 @@
    type(systemdata)               :: env
    type(zmolecule), intent(inout) :: solu, solv
    logical                        :: pr
-   real(wp), parameter             :: amutokg = 1.66053886E-27
-   real(wp), parameter             :: third = 1.0d0/3.0d0
-   integer                        :: i
+   real(wp), parameter            :: amutokg = 1.66053886E-27
+   real(wp), parameter            :: third = 1.0d0/3.0d0
+   integer                        :: i, ich
    real(wp)                       :: r_solu, r_solv
 
    pr = .true.
@@ -403,8 +421,89 @@
    solu%mass = solu%mass*amutokg
    solv%mass = solv%mass*amutokg
 
+!--- If directed docking is requested, it is read in here:
+   if(allocated(env%directed_file)) then
+      if (env%use_xtbiff) error stop 'xTB-IFF does not support directed docking. &
+              &Please use the aISS algorithm of xtb.'
+      call read_directed_input(env)
+   end if
+
+
 end subroutine read_qcg_input
 
+!> Read input for directed docking
+subroutine read_directed_input(env)
+   use iso_fortran_env, wp => real64
+   use crest_data
+   implicit none
+
+   type(systemdata)           :: env
+
+   integer                    :: nlines
+   integer                    :: io, ich, i, i_check
+   integer                    :: index
+   character(len=512)         :: dum
+   character(len=1), parameter :: delim_space = ' ', delim_tab = achar(9)
+
+     open (newunit=ich, file=env%directed_file) 
+        !First check number of lines
+        nlines = 0
+        do
+           read(ich,*,iostat=io)
+           if (io /= 0) exit
+           nlines = nlines + 1
+        end do
+        !Allocate directed list 
+        !First entry is the atom number, Second how many solvents to add to this atom
+        allocate(env%directed_list(nlines,2))
+        allocate(env%directed_number(nlines), source = 0)
+        !Now read lines into directed_list
+        rewind(ich)
+        do i=1, nlines
+           read(ich,'(A)') dum
+           !> Remove leading tab and spaces first
+           dum = adjustl(dum) !Leading spaces are removed
+           index = SCAN(trim(dum), delim_tab) 
+           if (index == 1) then !Leading tab -> remove it
+              dum = dum(2:)
+           end if
+           index = SCAN(trim(dum), delim_space)
+           if (index == 0) then !No space = check for tab
+              index = SCAN(trim(dum), delim_tab)
+           end if
+           if (index == 0) then  !Second value is missing
+              write(*,'(a,1x,i0)') "No second value found in directed list on line", i
+              error stop
+           end if
+           env%directed_list(i, 1) = dum(1:index-1)
+           env%directed_list(i, 2) = dum(index+1:)
+           !Remove multiple spaces
+           env%directed_list(i, 2) = adjustl(env%directed_list(i, 2))
+           !Check, if spaces are still in second argument (e.g. a third number is giveb)
+           index = SCAN(trim(env%directed_list(i, 2)), delim_space)
+           if (index == 0) index = SCAN(trim(dum), delim_tab)
+           if (index /= 0) then
+              write(*,'(a,1x,i0)') "Too many values at line", i
+              error stop
+           end if
+           !> Make array with which solvent molecule at which atom to add
+           read(env%directed_list(i,2), *, iostat=io) env%directed_number(i)
+           env%directed_number(i) = sum(env%directed_number)
+           if (io/= 0) then
+              write(*,'(a,1x,i0)') "Second value is no number in line", i
+              error stop
+           end if
+        end do
+     close(ich)
+     write(*,*) 'Performing directed docking'
+     do i=1, nlines
+        write(*,'(a,1x,a,1x,a,1x,a)') 'Docking', trim(env%directed_list(i,2)),&
+               & 'solvent molecules at', trim(env%directed_list(i,1))
+     end do
+
+end subroutine read_directed_input
+
+
 subroutine qcg_grow(env, solu, solv, clus, tim)
    use crest_parameters
    use crest_data
@@ -728,7 +827,7 @@
 
    if (env%nsolv .eq. 0) env%nsolv = iter !if no env%solv was given
 
-   if (env%gfnver .ne. '--gfn2') then
+   if (env%gfnver .ne. '--gfn2' .and. env%final_gfn2_opt) then
       gfnver_tmp = env%gfnver
       env%gfnver = '--gfn2'
       write (*, '(2x,''Final gfn2 optimization'')')
@@ -748,7 +847,7 @@
 
 !--- One optimization without Wall Potential and with implicit model
    gfnver_tmp = env%gfnver
-   env%gfnver = '--gfn2'
+   if (env%final_gfn2_opt) env%gfnver = '--gfn2'
    call opt_cluster(env, solu, clus, 'cluster.xyz', .true.)
    env%gfnver = gfnver_tmp
    call rename('xtbopt.xyz', 'cluster_optimized.xyz')
@@ -796,7 +895,7 @@
    use iomod
    use zdata
    use strucrd
-
+   use utilities
    implicit none
 
    type(systemdata)           :: env
@@ -1172,15 +1271,17 @@
 
 !--- Optimization
       call print_qcg_opt
-      if (env%gfnver .eq. '--gfn2') call multilevel_opt(env, 99)
+      !if (env%gfnver .eq. '--gfn2') 
+      call multilevel_opt(env, 99)
 
    end select
 
    env%QCG = .true.
 
 !--- Optimization with gfn2 if necessary
-   gfnver_tmp = env%gfnver
-   if (env%gfnver .ne. '--gfn2') then
+      if (env%final_gfn2_opt) then
+      gfnver_tmp = env%gfnver
+!      if (env%gfnver .ne. '--gfn2') then
       write (*, '(2x,a)') 'GFN2-xTB optimization'
       env%gfnver = '--gfn2'
       call rmrf('OPTIM')
@@ -1520,8 +1621,11 @@
    optlev_tmp = env%optlev
    env%optlev = 1.0d0    !Increaseing percision for ensemble search to minimze scattering
    gfnver_tmp = env%gfnver
-   env%gfnver = '--gfn2' !CFF always gfn2
-   write (*, *) 'Method for CFF: GFN2-xTB'
+   if (env%final_gfn2_opt) then
+      env%gfnver = '--gfn2'
+   else
+      env%gfnver = env%ensemble_opt !CFF always with ensemble method
+   end if
    nothing_added = .false.
 
    dum = 0
Index: src/calculator/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nset(dir \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\nlist(APPEND srcs\n  \"${dir}/calculator.F90\"\n  \"${dir}/calc_type.f90\"\n  \"${dir}/constraints.f90\"\n  \"${dir}/gfn0_api.F90\"\n  \"${dir}/gfnff_api.F90\"\n  \"${dir}/lj.f90\"\n  \"${dir}/nonadiabatic.f90\"\n  \"${dir}/tblite_api.F90\"\n  \"${dir}/api_helpers.F90\"\n  \"${dir}/api_engrad.f90\"\n  \"${dir}/gradreader.f90\"\n  \"${dir}/xhcff.F90\"\n  \"${dir}/xtb_sc.f90\"\n  \"${dir}/generic_sc.f90\"\n)\n\nset(srcs ${srcs} PARENT_SCOPE)\n\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/CMakeLists.txt b/src/calculator/CMakeLists.txt
--- a/src/calculator/CMakeLists.txt	
+++ b/src/calculator/CMakeLists.txt	
@@ -23,14 +23,19 @@
   "${dir}/gfn0_api.F90"
   "${dir}/gfnff_api.F90"
   "${dir}/lj.f90"
+  "${dir}/lwoniom.F90"
   "${dir}/nonadiabatic.f90"
   "${dir}/tblite_api.F90"
   "${dir}/api_helpers.F90"
   "${dir}/api_engrad.f90"
   "${dir}/gradreader.f90"
   "${dir}/xhcff.F90"
+  "${dir}/subprocess_types.f90"
   "${dir}/xtb_sc.f90"
+  "${dir}/orca_sc.f90"
   "${dir}/generic_sc.f90"
+  "${dir}/turbom_sc.f90"
+  "${dir}/subprocess_engrad.f90"
 )
 
 set(srcs ${srcs} PARENT_SCOPE)
Index: src/qcg/solvtool_misc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 Christoph Plett, Sebastian Spicher, Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!--------------------------------------------------------------------------------------------\n! A quick single point xtb calculation without wbo\n!--------------------------------------------------------------------------------------------\nsubroutine xtbsp3(env, fname)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   implicit none\n   character(len=*) :: fname\n   type(systemdata) :: env\n   character(len=512) :: jobcall\n   character(*), parameter :: pipe = ' > xtb.out 2> /dev/null'\n   integer :: io\n   call remove('gfnff_topo')\n   call remove('energy')\n   call remove('charges')\n   call remove('xtbrestart')\n!---- setting threads\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, 1) !set the global OMP/MKL variables for the xtb jobs\n   end if\n!---- jobcall\n   write (jobcall, '(a,1x,a,1x,a,'' --sp '',a,1x,a)') &\n   &     trim(env%ProgName), trim(fname), trim(env%gfnver), trim(env%solv), trim(pipe)\n\n   call command(trim(jobcall), io)\n!---- cleanup\n   call remove('energy')\n   call remove('charges')\n   call remove('xtbrestart')\n   call remove('xtbtopo.mol')\n   call remove('gfnff_topo')\nend subroutine xtbsp3\n\n!___________________________________________________________________________________\n!\n! An xTB single point calculation and lmo generation on all available threads\n!___________________________________________________________________________________\n\nsubroutine xtb_lmo(env, fname)!,chrg)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use zdata\n   implicit none\n   type(systemdata) :: env\n   character(len=*), intent(in)     :: fname\n   character(len=80)               :: pipe\n   character(len=512)              :: jobcall\n\n   pipe = ' > xtb.out 2>/dev/null'\n\n!---- setting threads\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, 1) !set the global OMP/MKL variables for the xtb jobs\n   end if\n\n!---- jobcall, special gbsa treatment not needed, as the entire flag is included in env%solv\n   write (jobcall, '(a,1x,a,1x,a,'' --sp --lmo '',a)') &\n   &     trim(env%ProgName), trim(fname), trim(env%lmover), trim(pipe)\n   call command(trim(jobcall))\n\n!--- cleanup\n   call remove('wbo')\n   call remove('charges')\n   call remove('xtbrestart')\n   call remove('xtbscreen.xyz')\n   call remove('lmocent.coord')\n   call remove('coordprot.0')\nend subroutine xtb_lmo\n\n!___________________________________________________________________________________\n!\n! An xTB-IFF calculation on all available threads\n!___________________________________________________________________________________\n\nsubroutine xtb_iff(env, file_lmo1, file_lmo2, solu, clus)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use zdata\n\n   implicit none\n\n   type(systemdata)                :: env\n   type(zmolecule), intent(in)     :: solu, clus\n   character(len=80)               :: pipe\n   character(len=512)              :: jobcall\n   character(len=*)                :: file_lmo1, file_lmo2\n\n!--- Option setting\n   pipe = ' > iff.out 2>/dev/null'\n\n!--- Setting threads\n!         if(env%autothreads)then\n   call ompautoset(env%threads, 7, env%omp, env%MAXRUN, 1) !set the global OMP/MKL variables for the xtb jobs\n!         endif\n\n!--- Jobcall\n   if (env%sameRandomNumber) then\n      write (jobcall, '(a,1x,a,1x,a,'' -nfrag1 '',i3,'' -ellips '',3f9.3,'' -qcg -test '',a)') &\n      &     trim(env%ProgIFF), trim(file_lmo1), trim(file_lmo2), solu%nat, clus%ell_abc, trim(pipe)\n   else\n      write (jobcall, '(a,1x,a,1x,a,'' -nfrag1 '',i3,'' -ellips '',3f9.3,'' -qcg '',a)') &\n      &     trim(env%ProgIFF), trim(file_lmo1), trim(file_lmo2), solu%nat, clus%ell_abc, trim(pipe)\n!            &     trim(env%ProgIFF),trim(solvent_file),trim(solute_file),solu%nat,clus%ell_abc,trim(pipe)\n   end if\n   call command(trim(jobcall))\n\n!--- Cleanup\n   call remove('xtbiff_bestsofar.xyz')\n   call remove('xtbiff_genstart.xyz')\n   call remove('xtbrestart')\n\nend subroutine xtb_iff\n\n!___________________________________________________________________________________\n!\n! An xTB docking on all available threads\n!___________________________________________________________________________________\n\nsubroutine xtb_dock(env, fnameA, fnameB, solu, clus)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use zdata\n\n   implicit none\n\n   type(systemdata)                :: env\n   type(zmolecule), intent(in)     :: solu, clus\n   character(len=*), intent(in)     :: fnameA, fnameB\n   character(len=80)               :: pipe\n   character(len=512)              :: jobcall\n\n   call remove('xtb_dock.out')\n   call remove('xcontrol')\n\n   pipe = ' 2>/dev/null'\n\n!---- writing wall pot in xcontrol\n   call write_wall(env, solu%nat, solu%ell_abc, clus%ell_abc, 'xcontrol')\n\n!--- Setting threads\n!   if(env%autothreads)then\n   call ompautoset(env%threads, 7, env%omp, env%MAXRUN, 1) !set the global OMP/MKL variables for the xtb jobs\n!   endif\n\n   !--- Jobcall docking\n   write (jobcall, '(a,1x,''dock'',1x,a,1x,a,1x,a,1x,f4.2,1x,''--nfrag1'',1x,i0,1x,a,1x&\n           & ''--input xcontrol > xtb_dock.out'',a)') &\n           &     trim(env%ProgName), trim(fnameA), trim(fnameB), trim(env%gfnver),&\n           &     env%optlev, solu%nat, trim(env%docking_qcg_flag), trim(pipe)\n   call command(trim(jobcall))\n\n! cleanup\n   call remove('wbo')\n   call remove('charges')\n   call remove('xtbrestart')\n\nend subroutine xtb_dock\n\n!___________________________________________________________________________________\n!\n! An xTB optimization on all available threads\n!___________________________________________________________________________________\n\nsubroutine opt_cluster(env, solu, clus, fname, without_pot)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use zdata\n\n   implicit none\n\n   type(systemdata)                :: env\n   type(zmolecule), intent(in)     :: solu, clus\n   character(len=*), intent(in)     :: fname\n   logical, optional, intent(in)   :: without_pot\n   character(len=80)               :: pipe\n   character(len=512)              :: jobcall\n\n   if (env%niceprint) then\n      call printemptybar()\n   end if\n\n   call remove('xtb.out')\n   pipe = ' 2>/dev/null'\n\n!---- writing wall pot in xcontrol\n   if (.not. without_pot) then\n      call write_wall(env, solu%nat, solu%ell_abc, clus%ell_abc, 'xcontrol')\n   end if\n\n!--- Setting threads\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, 1) !set the global OMP/MKL variables for the xtb jobs\n   end if\n\n!--- Jobcall optimization\n   if (.not. without_pot) then\n      write (jobcall, '(a,1x,a,1x,a,'' --opt '',f4.2,'' --input xcontrol > xtb_opt.out'',a)') &\n      &     trim(env%ProgName), trim(fname), trim(env%gfnver), env%optlev, trim(pipe)\n   else\n      write (jobcall, '(a,1x,a,1x,a,'' --opt '',f4.2,1x,a,'' > xtb_opt.out'',a)') &\n      &     trim(env%ProgName), trim(fname), trim(env%gfnver), env%optlev, trim(env%solv), trim(pipe)\n   end if\n   call command(trim(jobcall))\n\n! cleanup\n   call remove('wbo')\n   call remove('charges')\n   call remove('xtbrestart')\n\n!--- Jobcall SP for gbsa model\n   if (.not. without_pot) then\n      write (jobcall, '(a,1x,a,1x,a,'' --sp '',a,'' > xtb_sp.out'',a)') &\n      &    trim(env%ProgName), 'xtbopt.coord', trim(env%gfnver), trim(env%solv), trim(pipe)\n   end if\n   call command(trim(jobcall))\n\n! cleanup\n   call remove('wbo')\n   call remove('charges')\n   call remove('xtbrestart')\n\nend subroutine opt_cluster\n\n!___________________________________________________________________________________\n!\n! xTB LMO calculation performed in parallel\n!___________________________________________________________________________________\n\nsubroutine ensemble_lmo(env, fname, self, NTMP, TMPdir, conv)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use zdata\n\n   implicit none\n   type(systemdata)                :: env\n   type(zmolecule), intent(in)      :: self\n   character(len=*), intent(in)     :: fname      !file base name\n   character(len=*), intent(in)     :: TMPdir     !directory name\n   integer, intent(in)              :: NTMP       !number of structures to be optimized\n   integer, intent(in)              :: conv(env%nqcgclust + 1)\n   integer                         :: i, k\n   integer                         :: vz\n   character(len=20)               :: pipe\n   character(len=512)              :: thispath, tmppath\n   character(len=1024)             :: jobcall\n   character(len=52)               :: bar\n   real(wp)                        :: percent\n\n! setting the threads for correct parallelization\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, NTMP)\n   end if\n\n   pipe = '2>/dev/null'\n\n   !create the system call (it is the same for every optimization)\n\n   write (jobcall, '(a,1x,a,1x,a,'' --sp --lmo --chrg '',f4.1,1x,a,'' >xtb_lmo.out'')') &\n   &     trim(env%ProgName), trim(fname), trim(env%lmover), self%chrg, trim(pipe)\n   k = 0 !counting the finished jobs\n\n!___________________________________________________________________________________\n\n!$omp parallel &\n!$omp shared( vz,jobcall,NTMP,percent,k,bar,TMPdir,conv )\n!$omp single\n   do i = 1, NTMP\n      vz = i\n      !$omp task firstprivate( vz ) private( tmppath )\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(vz)\n      call command('cd '//trim(tmppath)//' && '//trim(jobcall))\n      !$omp critical\n      k = k + 1\n      percent = float(k)/float(NTMP)*100\n      !$omp end critical\n      !$omp end task\n   end do\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n!___________________________________________________________________________________\n\n   call getcwd(thispath)\n   do i = 1, NTMP\n      write (tmppath, '(a,i0)') trim(TMPdir), i\n      call chdir(trim(tmppath))\n      call remove('xtbrestart')\n      call chdir(trim(thispath))\n   end do\n\nend subroutine ensemble_lmo\n\n!___________________________________________________________________________________\n!\n! xTB-IFF calculation performed in parallel\n!___________________________________________________________________________________\n\nsubroutine ensemble_iff(env, outer_ell_abc, nfrag1, frag1_file, frag2_file, NTMP, TMPdir, conv)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use zdata\n\n   implicit none\n   type(systemdata)                :: env\n\n   character(len=*), intent(in)     :: TMPdir     !directory name\n   integer, intent(in)              :: NTMP       !number of structures to be optimized\n   integer, intent(in)              :: nfrag1     !#atoms of larger fragment\n   integer, intent(in)              :: conv(env%nqcgclust + 1)\n   real(wp), intent(in)             :: outer_ell_abc(env%nqcgclust, 3)\n\n   integer                         :: i, k\n   integer                         :: vz\n   character(len=20)               :: pipe\n   character(len=512)              :: tmppath\n   character(len=1024)             :: jobcall\n   character(len=52)               :: bar\n   character(len=64), intent(in)    :: frag1_file\n   character(len=64), intent(in)    :: frag2_file\n   character(len=64)               :: frag1\n   character(len=64)               :: frag2\n   real(wp)                        :: percent\n\n! some options\n   pipe = '2>/dev/null'\n   frag1 = 'solvent_cluster.lmo'\n   frag2 = 'solvent.lmo'\n\n! setting the threads for correct parallelization\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, NTMP)\n   end if\n\n   k = 0 !counting the finished jobs\n\n!___________________________________________________________________________________\n\n!$omp parallel &\n!$omp shared( vz,NTMP,percent,k,bar,TMPdir,conv )\n!$omp single\n   do i = 1, NTMP\n      vz = i\n      !$omp task firstprivate( vz ) private( tmppath,jobcall )\n! create the system call\n      write (jobcall, '(a,1x,a,1x,a,'' -nfrag1 '',i3,'' -ellips '',3f9.3,'' -qcg '',a,'' >iff.out'')') &\n&         trim(env%ProgIFF), trim(frag1_file), trim(frag2_file), nfrag1, outer_ell_abc(conv(vz), 1:3)*0.9, trim(pipe)\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(vz)\n      call command('cd '//trim(tmppath)//' && '//trim(jobcall))\n      !$omp critical\n      k = k + 1\n      percent = float(k)/float(NTMP)*100\n      !$omp end critical\n      !$omp end task\n   end do\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n!___________________________________________________________________________________\n\nend subroutine ensemble_iff\n\n!___________________________________________________________________________________\n!\n! xTB docking calculation performed in parallel\n!___________________________________________________________________________________\n\nsubroutine ensemble_dock(env, outer_ell_abc, nfrag1, frag1_file, frag2_file, n_shell&\n        &, n_solvent, NTMP, TMPdir, conv)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use zdata\n\n   implicit none\n   type(systemdata)                :: env\n\n   character(len=*), intent(in)     :: TMPdir     !directory name\n   integer, intent(in)              :: NTMP       !number of structures to be optimized\n   integer, intent(in)              :: nfrag1     !#atoms of larger fragment\n   integer, intent(in)              :: conv(env%nqcgclust + 1)\n   real(wp), intent(in)             :: outer_ell_abc(env%nqcgclust, 3)\n   integer, intent(in)              :: n_shell, n_solvent\n\n   integer                         :: i, k\n   integer                         :: vz\n   character(len=20)               :: pipe\n   character(len=1024)             :: jobcall\n   character(len=512)              :: thispath, tmppath\n   character(len=52)               :: bar\n   character(len=*), intent(in)     :: frag1_file\n   character(len=*), intent(in)     :: frag2_file\n   character(len=64)               :: frag1\n   character(len=64)               :: frag2\n   real(wp)                        :: percent\n   character(len=2)                :: flag\n   integer                         :: ich31\n\n! some options\n   pipe = '2>/dev/null'\n   frag1 = 'solvent_cluster.coord'\n   frag2 = 'solvent'\n   call getcwd(thispath)\n\n! setting the threads for correct parallelization\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, NTMP)\n   end if\n\n   write (jobcall, '(a,1x,''dock'',1x,a,1x,a,1x,a,1x,f4.2,1x,''--nfrag1'',1x,i0,1x,&\n           & ''--input xcontrol --fast > xtb_dock.out '',a)') &\n           & trim(env%ProgName), trim(frag1_file), trim(frag2_file),&\n           & trim(env%gfnver), env%optlev, nfrag1, trim(pipe)\n\n   flag = '$'\n   do i = 1, NTMP\n      vz = i\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(i)\n      call chdir(trim(tmppath))\n      open (newunit=ich31, file='xcontrol')\n      write (ich31, '(a,\"fix\")') trim(flag)\n      write (ich31, '(3x,\"atoms: 1-\",i0)') n_shell !Initial number of atoms (starting solvent shell)\n      write (ich31, '(a,\"wall\")') trim(flag)\n      write (31, '(3x,\"potential=polynomial\")')\n      write (ich31, '(3x,\"ellipsoid:\",1x,3(g0,\",\",1x),i0,\"-\",i0)') outer_ell_abc(conv(vz), :), &\n              & n_shell + 1, n_shell + n_solvent !Initial number of atoms (starting solvent shell)\n      close (ich31)\n      call chdir(trim(thispath))\n   end do\n\n   k = 0 !counting the finished jobs\n\n!___________________________________________________________________________________\n\n!$omp parallel &\n!$omp shared( vz,NTMP,percent,k,bar,TMPdir,conv,n_shell,n_solvent,jobcall )\n!$omp single\n   do i = 1, NTMP\n      vz = i\n      !$omp task firstprivate( vz ) private( tmppath )\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(vz)\n      call command('cd '//trim(tmppath)//' && '//trim(jobcall))\n      !$omp critical\n      k = k + 1\n      percent = float(k)/float(NTMP)*100\n      !$omp end critical\n      !$omp end task\n   end do\n\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n!___________________________________________________________________________________\n   call chdir(trim(thispath))\n\nend subroutine ensemble_dock\n\n!___________________________________________________________________________________\n!\n! xTB CFF optimization performed in parallel\n!___________________________________________________________________________________\n\nsubroutine cff_opt(postopt, env, fname, n12, NTMP, TMPdir, conv, nothing_added)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use strucrd\n   implicit none\n\n   type(systemdata)                :: env\n   character(len=*), intent(in)     :: fname      !file base name\n   character(len=*), intent(in)     :: TMPdir     !directory name\n   integer, intent(inout)           :: NTMP       !number of structures to be optimized\n   integer, intent(inout)           :: conv(env%nqcgclust + 1)\n   logical, intent(in)              :: postopt\n   logical, intent(in)              :: nothing_added(env%nqcgclust)\n   integer                         :: i, k, n12\n   integer                         :: vz\n   integer                         :: ich31\n   character(len=20)               :: pipe\n   character(len=512)              :: thispath, tmppath\n   character(len=1024)             :: jobcall\n   character(len=52)               :: bar\n   character(len=2)                :: flag\n   real(wp)                        :: percent\n\n! setting the threads for correct parallelization\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, NTMP)\n   end if\n\n   if (postopt) then\n      write (*, '(2x,''Starting optimizations + SP  of structures'')')\n      write (*, '(2x,i0,'' jobs to do.'')') NTMP\n   end if\n\n! postopt eq true => post opt run, which has to be performed in every directory !!!\n   if (postopt) then\n      k = 0\n      NTMP = env%nqcgclust\n      do i = 1, env%nqcgclust\n         k = k + 1\n         conv(k) = i\n         conv(env%nqcgclust + 1) = k\n      end do\n   end if\n   pipe = '2>/dev/null'\n\n   call getcwd(thispath)\n   do i = 1, NTMP\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(i)\n      call chdir(trim(tmppath))\n      open (newunit=ich31, file='xcontrol')\n      if (n12 .ne. 0) then\n         flag = '$'\n         write (ich31, '(a,\"fix\")') trim(flag)\n         write (ich31, '(3x,\"atoms: 1-\",i0)') n12 !Initial number of atoms (starting solvent shell)\n      end if\n      close (ich31)\n      if (postopt .and. nothing_added(i)) call remove('xcontrol')\n      call chdir(trim(thispath))\n   end do\n\n!--- Jobcall\n   write (jobcall, '(a,1x,a,1x,a,'' --input xcontrol --opt '',i0,1x,a,'' >xtb.out'')') &\n   &    trim(env%ProgName), trim(fname), trim(env%gfnver), nint(env%optlev), trim(pipe)\n\n   if (NTMP .lt. 1) then\n      write (*, '(2x,\"No structures to be optimized\")')\n      return\n   end if\n\n   k = 0 !counting the finished jobs\n   if (postopt) call printemptybar()\n!___________________________________________________________________________________\n\n!$omp parallel &\n!$omp shared( vz,jobcall,NTMP,percent,k,bar,TMPdir,conv )\n!$omp single\n   do i = 1, NTMP\n      vz = i\n      !$omp task firstprivate( vz ) private( tmppath )\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(vz)\n      call command('cd '//trim(tmppath)//' && '//trim(jobcall))\n      !$omp critical\n      k = k + 1\n      percent = float(k)/float(NTMP)*100\n      if (postopt) then\n         call progbar(percent, bar)\n         call printprogbar(percent, bar)\n      end if\n      !$omp end critical\n      !$omp end task\n   end do\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n!__________________________________________________________________________________\n\n   do i = 1, NTMP\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(i)\n      call chdir(trim(tmppath))\n      call remove('xtbrestart')\n      call chdir(trim(thispath))\n   end do\n\n   !create the system call for sp (needed for gbsa model)\n   write (jobcall, '(a,1x,a,1x,a,'' --sp '',a,1x,a,'' >xtb_sp.out'')') &\n   &    trim(env%ProgName), 'xtbopt.coord', trim(env%gfnver), trim(env%solv), trim(pipe)\n\n   if (NTMP .lt. 1) then\n      write (*, '(2x,\"Nothing to do\")')\n      return\n   end if\n\n   k = 0 !counting the finished jobs\n   if (postopt) call printemptybar()\n!___________________________________________________________________________________\n\n!$omp parallel &\n!$omp shared( vz,jobcall,NTMP,percent,k,bar,TMPdir,conv )\n!$omp single\n   do i = 1, NTMP\n      vz = i\n      !$omp task firstprivate( vz ) private( tmppath )\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(vz)\n      call command('cd '//trim(tmppath)//' && '//trim(jobcall))\n      !$omp critical\n      k = k + 1\n      percent = float(k)/float(NTMP)*100\n      if (postopt) then\n         call progbar(percent, bar)\n         call printprogbar(percent, bar)\n      end if\n      !$omp end critical\n      !$omp end task\n   end do\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n!___________________________________________________________________________________\n\n   do i = 1, NTMP\n      write (tmppath, '(a,i0)') trim(TMPdir), conv(i)\n      call chdir(trim(tmppath))\n      call remove('xtbrestart')\n      !call remove('xcontrol')\n      call chdir(trim(thispath))\n   end do\n\n   if (postopt) then\n      write (*, *) ''\n      write (*, '(2x,\"done.\")')\n   end if\n\nend subroutine cff_opt\n\n!___________________________________________________________________________________\n!\n! xTB SP performed in parallel\n!___________________________________________________________________________________\n\nsubroutine ens_sp(env, fname, NTMP, TMPdir)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use strucrd\n   implicit none\n\n   type(systemdata)                :: env\n   character(len=*), intent(in)     :: fname      !file base name\n   character(len=*), intent(in)     :: TMPdir     !directory name\n   integer, intent(inout)           :: NTMP       !number of structures to be optimized\n\n   integer                         :: i, k\n   integer                         :: vz\n   character(len=20)               :: pipe\n   character(len=512)              :: thispath, tmppath\n   character(len=1024)             :: jobcall\n   character(len=52)               :: bar\n   real(wp)                        :: percent\n\n! setting the threads for correct parallelization\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, NTMP)\n   end if\n\n   write (*, '(2x,''Single point computation with GBSA model'')')\n   write (*, '(2x,i0,'' jobs to do.'')') NTMP\n\n   pipe = '2>/dev/null'\n\n   call getcwd(thispath)\n\n   if (NTMP .lt. 1) then\n      write (*, '(2x,\"No structures to be optimized\")')\n      return\n   end if\n\n!--- Jobcall\n   write (jobcall, '(a,1x,a,1x,a,'' --sp '',a,1x,a,'' > xtb_sp.out'')') &\n   &    trim(env%ProgName), trim(fname), trim(env%gfnver), trim(env%solv), trim(pipe)\n\n   k = 0 !counting the finished jobs\n   call printemptybar()\n!___________________________________________________________________________________\n\n!$omp parallel &\n!$omp shared( vz,NTMP,percent,k,bar,TMPdir,jobcall )\n!$omp single\n   do i = 1, NTMP\n      vz = i\n      !$omp task firstprivate( vz ) private( tmppath )\n      write (tmppath, '(a,i0)') trim(TMPdir), i\n      call command('cd '//trim(tmppath)//' && '//trim(jobcall))\n      !$omp critical\n      k = k + 1\n      percent = float(k)/float(NTMP)*100\n      call progbar(percent, bar)\n      call printprogbar(percent, bar)\n      !$omp end critical\n      !$omp end task\n   end do\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n!__________________________________________________________________________________\n\n   do i = 1, NTMP\n      write (tmppath, '(a,i0)') trim(TMPdir), i\n      call chdir(trim(tmppath))\n      call remove('xtbrestart')\n      call chdir(trim(thispath))\n   end do\n   write (*, *) ''\n   write (*, '(2x,\"done.\")')\n\nend subroutine ens_sp\n\n!___________________________________________________________________________________\n!\n! xTB Freq compuatation performed in parallel\n!___________________________________________________________________________________\n\nsubroutine ens_freq(env, fname, NTMP, TMPdir, opt)\n   use iso_fortran_env, only: wp => real64\n   use iomod\n   use crest_data\n   use strucrd\n   implicit none\n\n   type(systemdata)                :: env\n   character(len=*), intent(in)     :: fname      !file base name\n   character(len=*), intent(in)     :: TMPdir     !directory name\n   integer, intent(inout)           :: NTMP       !number of structures to be optimized\n\n   integer                         :: i, k\n   integer                         :: vz\n   character(len=20)               :: pipe\n   character(len=512)              :: thispath, tmppath\n   character(len=1024)             :: jobcall\n   character(len=52)               :: bar\n   real(wp)                        :: percent\n   logical                         :: opt\n\n! setting the threads for correct parallelization\n   if (env%autothreads) then\n      call ompautoset(env%threads, 7, env%omp, env%MAXRUN, NTMP)\n   end if\n\n   write (*, '(2x,''Starting reoptimizations + Frequency computation of ensemble'')')\n   write (*, '(2x,i0,'' jobs to do.'')') NTMP\n\n   pipe = '2>/dev/null'\n\n   call getcwd(thispath)\n\n   if (NTMP .lt. 1) then\n      write (*, '(2x,\"No structures to be optimized\")')\n      return\n   end if\n\n   k = 0 !counting the finished jobs\n   call printemptybar()\n\n!--- Jobcall\n   if (.not. opt) then\n      write (jobcall, '(a,1x,a,1x,a,'' --hess '',a,'' >xtb_freq.out'')') &\n       &    trim(env%ProgName), trim(fname), trim(env%gfnver), trim(pipe)\n   else\n      write (jobcall, '(a,1x,a,1x,a,'' --ohess '',a,'' >xtb_freq.out'')') &\n      &    trim(env%ProgName), trim(fname), trim(env%gfnver), trim(pipe)\n   end if\n\n!___________________________________________________________________________________\n\n!$omp parallel &\n!$omp shared( vz,NTMP,percent,k,bar,TMPdir,jobcall )\n!$omp single\n   do i = 1, NTMP\n      vz = i\n      !$omp task firstprivate( vz ) private( tmppath )\n      write (tmppath, '(a,i0)') trim(TMPdir), i\n      call command('cd '//trim(tmppath)//' && '//trim(jobcall))\n      !$omp critical\n      k = k + 1\n      percent = float(k)/float(NTMP)*100\n      call progbar(percent, bar)\n      call printprogbar(percent, bar)\n      !$omp end critical\n      !$omp end task\n   end do\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n!__________________________________________________________________________________\n\n   do i = 1, NTMP\n      write (tmppath, '(a,i0)') trim(TMPdir), i\n      call chdir(trim(tmppath))\n      call remove('xtbrestart')\n      call chdir(trim(thispath))\n   end do\n   write (*, *) ''\n   write (*, '(2x,\"done.\")')\n\nend subroutine ens_freq\n\n!============================================================!\n! Read the Energies from a xtbiff output\n!============================================================!\n\nsubroutine rdxtbiffE(fname, m, n, e)\n\n   implicit none\n   integer :: m, n\n   character*(*) :: fname\n   real*8 :: e(*)\n\n   character*128 :: line\n   real*8 :: xx(10)\n   integer :: ich, i, j, nn\n\n   open (newunit=ich, file=fname)\n\n   j = 1\n10 continue\n   read (ich, '(a)', end=999) line\n   read (ich, '(a)') line\n   call readl(line, xx, nn)\n   e(j) = xx(1)\n   do i = 1, n\n      read (ich, '(a)') line\n   end do\n   j = j + 1\n   goto 10\n\n999 close (ich)\n   m = j - 1\nend\n\n!============================================================!\n! subroutine wr_cluster_cut\n! Cuts a cluster file and and writes the parts\n!\n! On Input: fname          - name of the coord file\n!           n1             - number of atoms fragment1\n!           n2             - number of atmos fragment2\n!           iter           - number of solvent molecules\n!           fname_solu_cut - name of outputfile fragment1\n!           fname_solv_cut - name of outputfile fragment2\n!\n!============================================================!\n\nsubroutine wr_cluster_cut(fname_cluster, n1, n2, iter, fname_solu_cut, fname_solv_cut)\n   use iso_fortran_env, only: wp => real64\n   use strucrd\n\n   implicit none\n   integer, intent(in)         :: n1, n2, iter\n   real(wp)                    :: xyz1(3, n1)\n   real(wp)                    :: xyz2(3, n2*iter)\n   integer                     :: at1(n1), at2(n2*iter)\n   character(len=*), intent(in) :: fname_cluster, fname_solu_cut, fname_solv_cut\n   character(len=256)         :: atmp\n   character(len=2)           :: a2\n   integer                     :: ich, i, k, stat, io, io2\n\n   ich = 142\n   open (unit=ich, file=fname_cluster, iostat=stat)\n   read (ich, '(a)') atmp\n   k = 1\n   do i = 1, n1\n      read (ich, '(a)', iostat=io) atmp\n      if (io < 0) exit\n      atmp = adjustl(atmp)\n      call coordline(atmp, a2, xyz1(1:3, k), io2)\n      at1(k) = e2i(a2)\n      k = k + 1\n   end do\n   k = 1\n   do i = 1, n2*iter\n      read (ich, '(a)', iostat=io) atmp\n      if (io < 0) exit\n      atmp = adjustl(atmp)\n      call coordline(atmp, a2, xyz2(1:3, k), io2)\n      at2(k) = e2i(a2)\n      k = k + 1\n   end do\n\n   call wrc0(fname_solu_cut, n1, at1, xyz1)\n   call wrc0(fname_solv_cut, n2*iter, at2, xyz2)\n   close (ich)\n\nend subroutine wr_cluster_cut\n\nsubroutine check_iff(neg_E)\n   use iso_fortran_env, only: wp => real64\n   use crest_data\n\n   implicit none\n   integer              :: io, ich\n   real(wp)             :: int_E\n   character(len=50)    :: tmp\n   logical, intent(out) :: neg_E\n\n   logical :: ex\n   character(len=*), parameter :: filename = 'xtbscreen.xyz'\n\n   neg_E = .false.\n   int_E = 0.0_wp\n\n   inquire (file=filename, exist=ex)\n   if (.not. ex) return\n\n   open (newunit=ich, file=filename, status=\"old\", iostat=io)\n   if (io == 0) read (ich, '(a)', iostat=io)\n   if (io == 0) read (ich, '(a)', iostat=io) tmp\n   close (ich)\n   if (io /= 0) return\n\n   tmp = adjustl(tmp(11:))\n   read (tmp, *, iostat=io) int_E\n   neg_E = io == 0 .and. int_E < 0.0_wp\n\nend subroutine check_iff\n\n!----------------------------------------------------------------------------\n! write a wall potential in a file used as xtb input\n\nsubroutine write_wall(env,n1,rabc1,rabc12,fname)\n  use iso_fortran_env, only : wp => real64\n  use crest_data\n\n  implicit none\n\n  type(systemdata)     :: env\n  integer, intent(in)  :: n1\n  real(wp),intent(in)  :: rabc1(3),rabc12(3)\n  character (len=8)    :: flag\n  character(len=*)    :: fname\n\n  open(unit=31,file=fname)\n  flag='$'\n  write(31,'(a,\"wall\")') trim(flag)\n  write(31,'(3x,\"potential=polynomial\")')\n  write(31,'(3x,\"ellipsoid:\",1x,3(g0,\",\",1x),\"all\")') rabc12\n  write(31,'(3x,\"ellipsoid:\",1x,3(g0,\",\",1x),\"1-\",i0)') rabc1,n1\n  if(env%constrain_solu) then\n    write(31,'(\"$fix\")')\n    write(31,'(3x,\"atoms: 1-\",i0)') n1\n  end if\n  call write_cts(31,env%cts)\n  call write_cts_biasext(31,env%cts)\n  if(env%cts%used) then !Only, if user set constrians is an $end written\n     write(31,'(a)') '$end'\n  end if\n\n  close(31)\n\nend subroutine write_wall\n\nsubroutine check_dock(neg_E)\n   use iso_fortran_env, only: wp => real64\n   use crest_data\n   use iomod, only: minigrep, grepval\n\n   implicit none\n   real(wp)             :: int_E\n   logical, intent(out) :: neg_E\n\n   logical :: ex\n   character(len=*), parameter :: filename = 'xtbscreen.xyz'\n\n   neg_E = .false.\n   int_E = 0.0_wp\n\n   call minigrep('xtb_dock.out', '  Lowest Interaction Energy: ********** kcal/mol', ex)\n   if (ex) return\n\n   call grepval('xtb_dock.out', 'Lowest Interaction Energy:', ex, int_E)\n\n   if (ex .and. int_E < 0.0_wp) neg_E = .true.\n\nend subroutine check_dock\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/qcg/solvtool_misc.f90 b/src/qcg/solvtool_misc.f90
--- a/src/qcg/solvtool_misc.f90	
+++ b/src/qcg/solvtool_misc.f90	
@@ -148,9 +148,10 @@
 
    type(systemdata)                :: env
    type(zmolecule), intent(in)     :: solu, clus
-   character(len=*), intent(in)     :: fnameA, fnameB
+   character(len=*), intent(in)    :: fnameA, fnameB
    character(len=80)               :: pipe
    character(len=512)              :: jobcall
+   integer                         :: i, ich
 
    call remove('xtb_dock.out')
    call remove('xcontrol')
@@ -160,6 +161,21 @@
 !---- writing wall pot in xcontrol
    call write_wall(env, solu%nat, solu%ell_abc, clus%ell_abc, 'xcontrol')
 
+!---- Write directed stuff, if requested
+   if (allocated(env%directed_file)) then
+      do i=1, size(env%directed_number)
+         if &
+         & ((i==1 .and. env%directed_number(i) >= clus%nmol) .OR. &
+         & (env%directed_number(i) >= clus%nmol .and. env%directed_number(i-1) < clus%nmol)) &
+         & then
+            open(newunit=ich, file='xcontrol', status='old', position='append', action='write')
+                 write(ich,'("$directed")')
+                 write(ich,'(a,1x,a)') 'atoms:', trim(env%directed_list(i,1))
+                 write(ich,'("$end")')
+         end if
+      end do
+   end if
+
 !--- Setting threads
 !   if(env%autothreads)then
    call ompautoset(env%threads, 7, env%omp, env%MAXRUN, 1) !set the global OMP/MKL variables for the xtb jobs
@@ -980,7 +996,6 @@
    implicit none
    real(wp)             :: int_E
    logical, intent(out) :: neg_E
-
    logical :: ex
    character(len=*), parameter :: filename = 'xtbscreen.xyz'
 
Index: src/calculator/calc_type.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nmodule calc_type\n  use iso_fortran_env,only:wp => real64,stdout => output_unit\n  use constraints\n!>--- api types\n  use tblite_api\n  use gfn0_api\n  use gfnff_api,only:gfnff_data\n  use xhcff_api,only:xhcff_calculator\n  implicit none\n\n  character(len=1),public,parameter :: sep = '/'\n  character(len=12),public,parameter :: dev0 = ' 2>/dev/null'\n\n!&<\n  !> job type enumerator\n  type ,private:: enum_jobtype\n    integer :: unknown   = 0\n    integer :: xtbsys    = 1\n    integer :: generic   = 2\n    integer :: turbomole = 3\n    integer :: orca      = 4\n    integer :: terachem  = 5\n    integer :: tblite    = 6\n    integer :: gfn0      = 7\n    integer :: gfn0occ   = 8\n    integer :: gfnff     = 9\n    integer :: xhcff     = 10\n  end type enum_jobtype\n  type(enum_jobtype), parameter,public :: jobtype = enum_jobtype()\n\n  character(len=45),parameter,private :: jobdescription(11) = [ &\n     & 'Unknown calculation type                    ', &\n     & 'xTB calculation via external binary         ', &\n     & 'Generic script execution                    ', &\n     & 'Systemcall to the Turbomole program package ', &\n     & 'Systemcall to the ORCA program package      ', &\n     & 'Systemcall to the TeraChem program package  ', &\n     & 'xTB calculation via tblite lib              ', &\n     & 'GFN0-xTB calculation via GFN0 lib           ', &\n     & 'GFN0*-xTB calculation via GFN0 lib          ', &\n     & 'GFN-FF calculation via GFNFF lib            ', &\n     & 'XHCFF calculation via XHCFF-lib             ' ]\n!&>\n\n!=========================================================================================!\n!>--- data object that contains the data for a *SINGLE* calculation\n  public :: calculation_settings\n  type :: calculation_settings\n\n    integer :: id  = 0  !> calculation type (see \"jobtype\" parameter above)\n    integer :: prch = stdout\n\n    integer :: chrg = 0\n    integer :: uhf = 0\n    real(wp) :: weight = 1.0_wp\n\n    character(len=:),allocatable :: calcspace  !> subdirectory to perform the calculation in\n    character(len=:),allocatable :: calcfile\n    character(len=:),allocatable :: gradfile\n    character(len=:),allocatable :: path\n    character(len=:),allocatable :: other\n    character(len=:),allocatable :: binary     !> binary or generic script\n    character(len=:),allocatable :: systemcall !> systemcall for running generic scripts\n    character(len=:),allocatable :: description\n\n!>--- gradient format specifications\n    integer :: gradtype = 0\n    integer :: gradfmt = 0\n    character(len=:),allocatable :: gradkey\n    character(len=:),allocatable :: efile\n\n!>--- results/property requests\n    real(wp) :: epot = 0.0_wp\n    real(wp) :: efix = 0.0_wp\n    real(wp) :: etot = 0.0_wp\n\n    !> bond orders\n    logical :: rdwbo = .false.\n    real(wp),allocatable :: wbo(:,:)\n\n    !> dipole and dipole gradient\n    logical :: rddip = .false.\n    real(wp) :: dip(3) = 0\n    logical :: rddipgrad = .false.\n    real(wp),allocatable :: dipgrad(:,:,:)\n\n!>--- API constructs\n    integer  :: tblitelvl = 2\n    real(wp) :: etemp = 300.0_wp\n    real(wp) :: accuracy = 1.0_wp\n    logical  :: apiclean = .true.\n    integer  :: maxscc = 500\n    logical  :: saveint = .false.\n    character(len=:),allocatable :: solvmodel\n    character(len=:),allocatable :: solvent\n\n    !> tblite data\n    type(wavefunction_type),allocatable  :: wfn\n    type(tblite_calculator),allocatable  :: tbcalc\n    type(tblite_ctx),allocatable         :: ctx\n    type(tblite_resultstype),allocatable :: tbres\n    type(wavefunction_type),allocatable  :: wfn_backup\n\n    !> GFN0-xTB data\n    type(gfn0_data),allocatable          :: g0calc\n    integer :: nconfig = 0\n    integer,allocatable :: config(:)\n    real(wp),allocatable :: occ(:)\n\n    !> GFN-FF data\n    type(gfnff_data),allocatable :: ff_dat\n    !> XHCFF data\n    integer :: ngrid = 230             !>  lebedev grid points per atom\n    real(wp) :: extpressure = 0.0_wp   !>  hydorstatic pressure in Gpa\n    real(wp) :: proberad = 1.5_wp       !>  proberadius in a.u.\n    integer :: vdwset = 0              !>  Set of VDW radii to use in sas calculation -> default D3, 1 -> Bondi\n    type(xhcff_calculator),allocatable :: xhcff\n\n!>--- Type procedures\n  contains\n    procedure :: deallocate => calculation_settings_deallocate\n    procedure :: addconfig => calculation_settings_addconfig\n    procedure :: autocomplete => calculation_settings_autocomplete\n    procedure :: info => calculation_settings_info\n  end type calculation_settings\n!=========================================================================================!\n\n!=========================================================================================!\n!> data object that collects settings for *ALL* calculations and constraints.\n  public :: calcdata\n  type :: calcdata\n    integer :: id = 0  !> this parameter will decide how to return or add up energies and gradients\n\n!>--- calculations\n    integer :: ncalculations = 0\n    type(calculation_settings),allocatable :: calcs(:)\n    real(wp),allocatable :: etmp(:)\n    real(wp),allocatable :: grdtmp(:,:,:)\n    real(wp),allocatable :: eweight(:)\n    real(wp),allocatable :: etmp2(:)\n    real(wp),allocatable :: grdtmp2(:,:,:)\n    real(wp),allocatable :: eweight2(:)\n\n!>--- constraints\n    integer :: nconstraints = 0\n    type(constraint),allocatable :: cons(:)\n\n!>--- scans\n    integer :: nscans = 0\n    logical :: relaxscan = .true.\n    real(wp) :: scansforce = 0.5_wp\n    type(scantype),allocatable :: scans(:)\n\n!>--- results/property requests\n    real(wp) :: epot\n    real(wp) :: efix\n    real(wp) :: etot\n\n!>--- optimization settings\n    integer  :: optlev = 0\n    integer  :: micro_opt = 20\n    integer  :: maxcycle = 0\n    real(wp) :: maxdispl_opt = 1.0_wp\n    real(wp) :: hlow_opt = 0.010_wp\n    real(wp) :: hmax_opt = 5.0_wp\n    real(wp) :: acc_opt = 1.0_wp\n    logical  :: exact_rf = .false.\n    logical  :: average_conv = .false.\n    logical  :: tsopt = .false.\n    integer  :: iupdat = 0  !> 0=BFGS, 1=Powell, 2=SR1, 3=Bofill, 4=Schlegel\n\n!>--- GFN0* data, needed for special MECP application\n    type(gfn0_data),allocatable  :: g0calc\n\n!>--- printouts and io\n    logical :: pr_energies = .false.\n    integer :: eout_unit = stdout\n    character(len=:),allocatable :: elog\n\n!>--- Type procedures\n  contains\n    procedure :: reset => calculation_reset\n    procedure :: init => calculation_init\n    generic,public :: add => calculation_add_constraint,calculation_add_settings,calculation_add_scan\n    procedure,private :: calculation_add_constraint,calculation_add_settings,calculation_add_scan\n    procedure :: copy => calculation_copy\n    procedure :: printconstraints => calculation_print_constraints\n    procedure :: removeconstraint => calculation_remove_constraint\n    procedure :: info => calculation_info\n  end type calcdata\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n  subroutine calculation_reset(self)\n    implicit none\n    class(calcdata) :: self\n\n    self%id = 0\n\n    if (allocated(self%calcs)) deallocate (self%calcs)\n    self%ncalculations = 0\n\n    if (allocated(self%cons)) deallocate (self%cons)\n    self%nconstraints = 0\n\n    self%optlev = 0\n    self%micro_opt = 20\n    self%maxcycle = 0\n    self%maxdispl_opt = 1.0_wp\n    self%hlow_opt = 0.010_wp\n    self%hmax_opt = 5.0_wp\n    self%acc_opt = 1.0_wp\n    self%exact_rf = .false.\n    self%average_conv = .false.\n    self%tsopt = .false.\n    self%iupdat = 0\n\n    self%pr_energies = .false.\n    self%eout_unit = stdout\n    if (allocated(self%elog)) deallocate (self%elog)\n\n    if (allocated(self%etmp)) deallocate (self%etmp)\n    if (allocated(self%grdtmp)) deallocate (self%grdtmp)\n    if (allocated(self%etmp2)) deallocate (self%etmp2)\n    if (allocated(self%grdtmp2)) deallocate (self%grdtmp2)\n\n    if (allocated(self%g0calc)) deallocate (self%g0calc)\n\n    return\n  end subroutine calculation_reset\n\n  subroutine calculation_settings_deallocate(self)\n    implicit none\n    class(calculation_settings) :: self\n\n    if (allocated(self%calcspace)) deallocate (self%calcspace)\n    if (allocated(self%calcfile)) deallocate (self%calcfile)\n    if (allocated(self%gradfile)) deallocate (self%gradfile)\n    if (allocated(self%path)) deallocate (self%path)\n    if (allocated(self%other)) deallocate (self%other)\n    if (allocated(self%binary)) deallocate (self%binary)\n    if (allocated(self%systemcall)) deallocate (self%systemcall)\n    if (allocated(self%description)) deallocate (self%description)\n    if (allocated(self%wbo)) deallocate (self%wbo)\n    if (allocated(self%dipgrad)) deallocate (self%dipgrad)\n    if (allocated(self%gradkey)) deallocate (self%gradkey)\n    if (allocated(self%efile)) deallocate (self%efile)\n    if (allocated(self%solvmodel)) deallocate (self%solvmodel)\n    if (allocated(self%solvent)) deallocate (self%solvent)\n    if (allocated(self%wfn)) deallocate (self%wfn)\n    if (allocated(self%tbcalc)) deallocate (self%tbcalc)\n    if (allocated(self%ctx)) deallocate (self%ctx)\n    if (allocated(self%tbres)) deallocate (self%tbres)\n    if (allocated(self%wfn_backup)) deallocate (self%wfn_backup)\n    if (allocated(self%g0calc)) deallocate (self%g0calc)\n    if (allocated(self%ff_dat)) deallocate (self%ff_dat)\n    if (allocated(self%xhcff)) deallocate(self%xhcff)\n\n    self%id = 0\n    self%prch = stdout\n    self%chrg = 0\n    self%uhf = 0\n    self%epot = 0.0_wp\n    self%efix = 0.0_wp\n    self%etot = 0.0_wp\n\n    self%rdwbo = .false.\n    self%rddip = .false.\n    self%dip = 0.0_wp\n    self%rddipgrad = .false.\n    self%gradtype = 0\n    self%gradfmt = 0\n\n    self%tblitelvl = 2\n    self%etemp = 300.0_wp\n    self%accuracy = 1.0_wp\n    self%apiclean = .false.\n    self%maxscc = 500\n    self%saveint = .false.\n\n    self%ngrid = 230 \n    self%extpressure = 0.0_wp\n    self%proberad = 1.5_wp\n\n\n    return\n  end subroutine calculation_settings_deallocate\n\n!=========================================================================================!\n\n  subroutine calculation_add_settings(self,cal)\n    implicit none\n    class(calcdata) :: self\n    type(calculation_settings) :: cal\n    type(calculation_settings),allocatable :: callist(:)\n    integer :: i,j\n\n    if (self%ncalculations < 1) then\n      allocate (self%calcs(1))\n      self%ncalculations = 1\n      self%calcs(1) = cal\n    else\n      i = self%ncalculations+1\n      j = self%ncalculations\n      allocate (callist(i))\n      callist(1:j) = self%calcs(1:j)\n      callist(i) = cal\n      call move_alloc(callist,self%calcs)\n      self%ncalculations = i\n    end if\n\n    return\n  end subroutine calculation_add_settings\n\n!=========================================================================================!\n\n  subroutine calculation_add_constraint(self,constr)\n    implicit none\n    class(calcdata) :: self\n    type(constraint) :: constr\n    type(constraint),allocatable :: conslist(:)\n    integer :: i,j\n\n    if (self%nconstraints < 1) then\n      allocate (self%cons(1))\n      self%nconstraints = 1\n      self%cons(1) = constr\n    else\n      i = self%nconstraints+1\n      j = self%nconstraints\n      allocate (conslist(i))\n      conslist(1:j) = self%cons(1:j)\n      conslist(i) = constr\n      call move_alloc(conslist,self%cons)\n      self%nconstraints = i\n    end if\n\n    return\n  end subroutine calculation_add_constraint\n\n!=========================================================================================!\n\n  subroutine calculation_add_scan(self,scn)\n    implicit none\n    class(calcdata) :: self\n    type(scantype) :: scn\n    type(scantype),allocatable :: scnlist(:)\n    integer :: i,j\n\n    if (self%nscans < 1) then\n      allocate (self%scans(1))\n      self%nscans = 1\n      self%scans(1) = scn\n    else\n      i = self%nscans+1\n      j = self%nscans\n      allocate (scnlist(i))\n      scnlist(1:j) = self%scans(1:j)\n      scnlist(i) = scn\n      call move_alloc(scnlist,self%scans)\n      self%nscans = i\n    end if\n\n    return\n  end subroutine calculation_add_scan\n\n!=========================================================================================!\n\n  subroutine calculation_remove_constraint(self,d)\n    implicit none\n    class(calcdata) :: self\n    type(constraint) :: constr\n    type(constraint),allocatable :: conslist(:)\n    integer :: i,j,d,d1,d2\n\n    if (self%nconstraints < d) return\n\n    i = self%nconstraints-1\n    j = self%nconstraints\n    allocate (conslist(i))\n    if (d == 1) then\n      conslist(1:i) = self%cons(2:j)\n    else if (d == j) then\n      conslist(1:i) = self%cons(1:i)\n    else\n      d1 = d-1\n      d2 = d+1\n      conslist(1:d1) = self%cons(1:d1)\n      conslist(d:i) = self%cons(d2:j)\n    end if\n    call move_alloc(conslist,self%cons)\n    self%nconstraints = i\n\n    return\n  end subroutine calculation_remove_constraint\n\n!=========================================================================================!\n  subroutine calculation_print_constraints(self,chnl)\n    implicit none\n    class(calcdata) :: self\n    integer :: i,j\n    integer,optional :: chnl\n\n    if (self%nconstraints < 1) then\n      return\n    else\n      if (present(chnl)) then\n        i = chnl\n      else\n        i = stdout\n      end if\n      !write(i,*)\n      do j = 1,self%nconstraints\n        call self%cons(j)%print(i)\n      end do\n    end if\n\n    return\n  end subroutine calculation_print_constraints\n\n!=========================================================================================!\n\n  subroutine calculation_init(self)\n    class(calcdata) :: self\n\n    if (allocated(self%elog)) then\n      self%pr_energies = .true.\n      open (newunit=self%eout_unit,file=self%elog)\n    end if\n\n  end subroutine calculation_init\n\n!=========================================================================================!\n!> copy a calcdata object from src to self\n  subroutine calculation_copy(self,src)\n    class(calcdata) :: self\n    type(calcdata) :: src\n    integer :: i\n    !call self%reset()\n\n    self%id = src%id\n\n    self%ncalculations = src%ncalculations\n    if (allocated(self%calcs)) deallocate (self%calcs)\n    !self%calcs = src%calcs\n    do i = 1,self%ncalculations\n      call self%add(src%calcs(i))\n    end do\n\n    self%nconstraints = src%nconstraints\n    if (allocated(self%cons)) deallocate (self%cons)\n    !self%cons = src%cons\n    do i = 1,self%nconstraints\n      call self%add(src%cons(i))\n    end do\n\n    self%optlev = src%optlev\n    self%micro_opt = src%micro_opt\n    self%maxcycle = src%maxcycle\n    self%maxdispl_opt = src%maxdispl_opt\n    self%hlow_opt = src%hlow_opt\n    self%hmax_opt = src%hmax_opt\n    self%acc_opt = src%acc_opt\n    self%exact_rf = src%exact_rf\n    self%average_conv = src%average_conv\n    self%tsopt = src%tsopt\n    self%iupdat = src%iupdat\n\n    self%pr_energies = src%pr_energies\n    self%eout_unit = src%eout_unit\n    self%elog = src%elog\n\n    return\n  end subroutine calculation_copy\n\n!=========================================================================================!\n\n  subroutine calculation_settings_addconfig(self,config)\n    implicit none\n    class(calculation_settings) :: self\n    integer,intent(in)  :: config(:)\n    integer :: i,j\n    integer :: l,lold,lnew,n,nnew\n    integer,allocatable :: configtmp(:,:)\n\n    l = size(config,1)\n    if (allocated(self%config)) deallocate (self%config)\n    allocate (self%config(l))\n    self%config = config\n  end subroutine calculation_settings_addconfig\n\n!=========================================================================================!\n\n!>-- check for missing settings in a calculation_settings object\n  subroutine calculation_settings_autocomplete(self,id)\n    implicit none\n    class(calculation_settings) :: self\n    integer,intent(in)  :: id\n    integer :: i,j\n    character(len=50) :: nmbr\n\n    !> add a short description\n    self%description = trim(jobdescription(self%id+1))\n\n    if (.not.allocated(self%calcspace)) then\n      !> I've decided to perform all calculations in a separate directory to\n      !> avoid accumulation of files in the main workspace\n      write (nmbr,'(i0)') id\n      self%calcspace = 'calculation.level.'//trim(nmbr)\n    end if\n  end subroutine calculation_settings_autocomplete\n\n!=========================================================================================!\n  subroutine calculation_settings_info(self,iunit)\n    implicit none\n    class(calculation_settings) :: self\n    integer,intent(in) :: iunit\n    integer :: i,j\n    character(len=*),parameter :: fmt1 = '(1x,a20,\" : \",i5)'\n    character(len=*),parameter :: fmt2 = '(1x,a20,\" : \",f12.5)'\n    character(len=*),parameter :: fmt3 = '(1x,a20,\" : \",a)'\n\n    if (allocated(self%description)) then\n      write (iunit,'(2x,a)') trim(self%description)\n    else\n      write (iunit,fmt1) 'Job type',self%id\n    end if\n\n    write (iunit,fmt1) 'Molecular charge',self%chrg\n    if (self%uhf /= 0) then\n      write (iunit,fmt1) 'UHF parameter',self%uhf\n    end if\n\n    if (allocated(self%solvmodel)) then\n      write (iunit,fmt3) 'Solvation model',trim(self%solvmodel)\n    end if\n    if (allocated(self%solvent)) then\n      write (iunit,fmt3) 'Solvent',trim(self%solvent)\n    end if\n\n    !> xTB specific parameters\n    if (any((/jobtype%tblite,jobtype%xtbsys,jobtype%gfn0,jobtype%gfn0occ/) == self%id)) then\n      write (iunit,fmt2) 'Fermi temperature',self%etemp\n      write (iunit,fmt2) 'Accuracy',self%accuracy\n      write (iunit,fmt1) 'max SCC cycles',self%maxscc\n    end if\n\n    if (self%apiclean) write (iunit,fmt3) 'Reset data?','  yes'\n    if (self%rdwbo) write (iunit,fmt3) 'Read WBOs?','  yes'\n    if (self%rddip) write (iunit,fmt3) 'Read dipoles?','  yes'\n\n  end subroutine calculation_settings_info\n!========================================================================================!\n  subroutine calculation_info(self,iunit)\n    implicit none\n    class(calcdata) :: self\n    integer,intent(in) :: iunit\n    integer :: i\n    character(len=*),parameter :: fmt1 = '(1x,a20,\" : \",i5)'\n    character(len=*),parameter :: fmt2 = '(1x,a20,\" : \",f12.5)'\n\n    write (iunit,'(1x,a)') '----------------'\n    write (iunit,'(1x,a)') 'Calculation info'\n    write (iunit,'(1x,a)') '----------------'\n    if (self%ncalculations <= 0) then\n      write (iunit,'(\"> \",a)') 'No calculation levels set up!'\n    else if (self%ncalculations > 1) then\n      do i = 1,self%ncalculations\n        write (iunit,'(\"> \",a,i0)') 'Calculation level ',i\n        call self%calcs(i)%info(iunit)\n        write (iunit,fmt2) 'weight',self%calcs(i)%weight\n      end do\n    else\n      write (iunit,'(\"> \",a)') 'Calculation level'\n      call self%calcs(1)%info(iunit)\n    end if\n    write (iunit,*)\n\n    if (self%nconstraints > 0) then\n      write (iunit,'(\"> \",a)') 'User-defined constraints:'\n      do i = 1,self%nconstraints\n        call self%cons(i)%print(iunit)\n      end do\n      write (iunit,*)\n    end if\n\n    if (self%ncalculations > 1) then\n      write (iunit,'(\"> \",a)') 'Energy and gradient processing:'\n      select case (self%id)\n      case (1:)\n        write (iunit,'(1x,a,i0)') 'Energies and gradients of calculation level ',self%id, &\n        &  ' will be used'\n      case (-1)\n        write (iunit,'(1x,a)') 'Special MECP energy and gradients will be constructed'\n        write (iunit,'(1x,a)') 'See https://doi.org/10.1021/acs.jpclett.3c00494'\n      case default\n        write (iunit,'(1x,a)') 'Energies and gradients of all calculation levels will be'// &\n        & ' added according to their weights'\n      end select\n      write (iunit,*)\n    end if\n\n    return\n  end subroutine calculation_info\n\n!=========================================================================================!\nend module calc_type\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/calc_type.f90 b/src/calculator/calc_type.f90
--- a/src/calculator/calc_type.f90	
+++ b/src/calculator/calc_type.f90	
@@ -20,15 +20,19 @@
 module calc_type
   use iso_fortran_env,only:wp => real64,stdout => output_unit
   use constraints
+  use strucrd,only:coord
 !>--- api types
   use tblite_api
   use gfn0_api
   use gfnff_api,only:gfnff_data
   use xhcff_api,only:xhcff_calculator
+!>--- other types
+  use orca_type
+  use lwoniom_module
   implicit none
 
-  character(len=1),public,parameter :: sep = '/'
-  character(len=12),public,parameter :: dev0 = ' 2>/dev/null'
+  character(len=*),public,parameter :: sep = '/'
+  character(len=*),public,parameter :: dev0 = ' 2>/dev/null'
 
 !&<
   !> job type enumerator
@@ -44,21 +48,23 @@
     integer :: gfn0occ   = 8
     integer :: gfnff     = 9
     integer :: xhcff     = 10
+    integer :: lj        = 11
   end type enum_jobtype
   type(enum_jobtype), parameter,public :: jobtype = enum_jobtype()
 
-  character(len=45),parameter,private :: jobdescription(11) = [ &
+  character(len=45),parameter,private :: jobdescription(12) = [ &
      & 'Unknown calculation type                    ', &
      & 'xTB calculation via external binary         ', &
      & 'Generic script execution                    ', &
-     & 'Systemcall to the Turbomole program package ', &
+     & 'Systemcall with Turbomole-style in/output   ', &
      & 'Systemcall to the ORCA program package      ', &
      & 'Systemcall to the TeraChem program package  ', &
      & 'xTB calculation via tblite lib              ', &
      & 'GFN0-xTB calculation via GFN0 lib           ', &
      & 'GFN0*-xTB calculation via GFN0 lib          ', &
      & 'GFN-FF calculation via GFNFF lib            ', &
-     & 'XHCFF calculation via XHCFF-lib             ' ]
+     & 'XHCFF calculation via XHCFF-lib             ', &
+     & 'Lennard-Jones potential calculation         ' ]
 !&>
 
 !=========================================================================================!
@@ -66,23 +72,27 @@
   public :: calculation_settings
   type :: calculation_settings
 
-    integer :: id  = 0  !> calculation type (see "jobtype" parameter above)
-    integer :: prch = stdout
+    integer :: id = 0         !> calculation type (see "jobtype" parameter above)
+    integer :: prch = stdout  !> printout channel
+    logical :: pr = .false.   !> allow the calculation to produce printout? Results in a lot I/O
+    integer :: refine_lvl = 0 !> to allow defining different refinement levels
 
-    integer :: chrg = 0
-    integer :: uhf = 0
-    real(wp) :: weight = 1.0_wp
+    integer :: chrg = 0          !> molecular charge
+    integer :: uhf = 0           !> uhf parameter (xtb) or multiplicity (other)
+    logical :: active = .true.   !> active setting to disable the calculation (this is different from weight=0)
+    real(wp) :: weight = 1.0_wp  !> calculation weight (when adding them up)
 
     character(len=:),allocatable :: calcspace  !> subdirectory to perform the calculation in
     character(len=:),allocatable :: calcfile
     character(len=:),allocatable :: gradfile
     character(len=:),allocatable :: path
     character(len=:),allocatable :: other
-    character(len=:),allocatable :: binary     !> binary or generic script
-    character(len=:),allocatable :: systemcall !> systemcall for running generic scripts
-    character(len=:),allocatable :: description
+    character(len=:),allocatable :: binary      !> binary or generic script
+    character(len=:),allocatable :: systemcall  !> systemcall for running generic scripts
+    character(len=:),allocatable :: description !> see above jobdescription parameter
 
 !>--- gradient format specifications
+    logical :: rdgrad = .true.
     integer :: gradtype = 0
     integer :: gradfmt = 0
     character(len=:),allocatable :: gradkey
@@ -114,11 +124,7 @@
     character(len=:),allocatable :: solvent
 
     !> tblite data
-    type(wavefunction_type),allocatable  :: wfn
-    type(tblite_calculator),allocatable  :: tbcalc
-    type(tblite_ctx),allocatable         :: ctx
-    type(tblite_resultstype),allocatable :: tbres
-    type(wavefunction_type),allocatable  :: wfn_backup
+    type(tblite_data),allocatable :: tblite
 
     !> GFN0-xTB data
     type(gfn0_data),allocatable          :: g0calc
@@ -128,19 +134,29 @@
 
     !> GFN-FF data
     type(gfnff_data),allocatable :: ff_dat
+
     !> XHCFF data
     integer :: ngrid = 230             !>  lebedev grid points per atom
     real(wp) :: extpressure = 0.0_wp   !>  hydorstatic pressure in Gpa
-    real(wp) :: proberad = 1.5_wp       !>  proberadius in a.u.
+    real(wp) :: proberad = 1.5_wp      !>  proberadius in Angstroem
     integer :: vdwset = 0              !>  Set of VDW radii to use in sas calculation -> default D3, 1 -> Bondi
     type(xhcff_calculator),allocatable :: xhcff
 
+    !> ONIOM fragment IDs
+    integer :: ONIOM_highlowroot = 0 
+    integer :: ONIOM_id = 0
+
+    !> ORCA job template
+    type(orca_input) :: ORCA
+
 !>--- Type procedures
   contains
     procedure :: deallocate => calculation_settings_deallocate
     procedure :: addconfig => calculation_settings_addconfig
     procedure :: autocomplete => calculation_settings_autocomplete
+    procedure :: printid => calculation_settings_printid
     procedure :: info => calculation_settings_info
+    procedure :: create => create_calclevel_shortcut
   end type calculation_settings
 !=========================================================================================!
 
@@ -148,7 +164,9 @@
 !> data object that collects settings for *ALL* calculations and constraints.
   public :: calcdata
   type :: calcdata
+
     integer :: id = 0  !> this parameter will decide how to return or add up energies and gradients
+    integer :: refine_stage = 0 !> to allow iterating different refinement stages
 
 !>--- calculations
     integer :: ncalculations = 0
@@ -156,9 +174,11 @@
     real(wp),allocatable :: etmp(:)
     real(wp),allocatable :: grdtmp(:,:,:)
     real(wp),allocatable :: eweight(:)
+    real(wp),allocatable :: weightbackup(:)
     real(wp),allocatable :: etmp2(:)
     real(wp),allocatable :: grdtmp2(:,:,:)
     real(wp),allocatable :: eweight2(:)
+    real(wp),allocatable :: grdfix(:,:)
 
 !>--- constraints
     integer :: nconstraints = 0
@@ -170,6 +190,10 @@
     real(wp) :: scansforce = 0.5_wp
     type(scantype),allocatable :: scans(:)
 
+!>--- frozen atoms
+    integer :: nfreeze = 0
+    logical,allocatable :: freezelist(:)
+
 !>--- results/property requests
     real(wp) :: epot
     real(wp) :: efix
@@ -187,6 +211,7 @@
     logical  :: average_conv = .false.
     logical  :: tsopt = .false.
     integer  :: iupdat = 0  !> 0=BFGS, 1=Powell, 2=SR1, 3=Bofill, 4=Schlegel
+    integer  :: opt_engine = 0 !> default: ANCOPT
 
 !>--- GFN0* data, needed for special MECP application
     type(gfn0_data),allocatable  :: g0calc
@@ -196,16 +221,28 @@
     integer :: eout_unit = stdout
     character(len=:),allocatable :: elog
 
+!>--- ONIOM calculator data
+    type(lwoniom_data),allocatable :: ONIOM
+    type(coord),allocatable :: ONIOMmols(:)
+    integer,allocatable :: ONIOMmap(:) !> map ONIOM fragments to calculation_settings
+    integer,allocatable :: ONIOMrevmap(:) !> map calculation settings to ONIOM frags (or zero)
+
 !>--- Type procedures
   contains
     procedure :: reset => calculation_reset
     procedure :: init => calculation_init
-    generic,public :: add => calculation_add_constraint,calculation_add_settings,calculation_add_scan
-    procedure,private :: calculation_add_constraint,calculation_add_settings,calculation_add_scan
+    generic,public :: add => calculation_add_constraint,calculation_add_settings, &
+    & calculation_add_scan,calculation_add_constraintlist
+    procedure,private :: calculation_add_constraint,calculation_add_settings, &
+    & calculation_add_scan,calculation_add_constraintlist
     procedure :: copy => calculation_copy
     procedure :: printconstraints => calculation_print_constraints
     procedure :: removeconstraint => calculation_remove_constraint
     procedure :: info => calculation_info
+    procedure :: ONIOMexpand => calculation_ONIOMexpand
+    procedure :: active => calc_set_active
+    procedure :: active_restore => calc_set_active_restore
+    procedure :: freezegrad => calculation_freezegrad
   end type calcdata
 
 !========================================================================================!
@@ -249,6 +286,10 @@
 
     if (allocated(self%g0calc)) deallocate (self%g0calc)
 
+    if (allocated(self%ONIOM)) deallocate (self%ONIOM)
+    if (allocated(self%ONIOMmols)) deallocate (self%ONIOMmols)
+    if (allocated(self%ONIOMmap)) deallocate (self%ONIOMmap)
+
     return
   end subroutine calculation_reset
 
@@ -270,14 +311,14 @@
     if (allocated(self%efile)) deallocate (self%efile)
     if (allocated(self%solvmodel)) deallocate (self%solvmodel)
     if (allocated(self%solvent)) deallocate (self%solvent)
-    if (allocated(self%wfn)) deallocate (self%wfn)
-    if (allocated(self%tbcalc)) deallocate (self%tbcalc)
-    if (allocated(self%ctx)) deallocate (self%ctx)
-    if (allocated(self%tbres)) deallocate (self%tbres)
-    if (allocated(self%wfn_backup)) deallocate (self%wfn_backup)
+    !if (allocated(self%wfn)) deallocate (self%wfn)
+    !if (allocated(self%tbcalc)) deallocate (self%tbcalc)
+    !if (allocated(self%ctx)) deallocate (self%ctx)
+    !if (allocated(self%tbres)) deallocate (self%tbres)
+    if (allocated(self%tblite)) deallocate(self%tblite)
     if (allocated(self%g0calc)) deallocate (self%g0calc)
     if (allocated(self%ff_dat)) deallocate (self%ff_dat)
-    if (allocated(self%xhcff)) deallocate(self%xhcff)
+    if (allocated(self%xhcff)) deallocate (self%xhcff)
 
     self%id = 0
     self%prch = stdout
@@ -301,11 +342,12 @@
     self%maxscc = 500
     self%saveint = .false.
 
-    self%ngrid = 230 
+    self%ngrid = 230
     self%extpressure = 0.0_wp
     self%proberad = 1.5_wp
 
-
+    self%ONIOM_highlowroot = 0
+    self%ONIOM_id = 0
     return
   end subroutine calculation_settings_deallocate
 
@@ -361,6 +403,32 @@
     return
   end subroutine calculation_add_constraint
 
+  subroutine calculation_add_constraintlist(self,k,constr)
+    implicit none
+    class(calcdata) :: self
+    integer :: k
+    type(constraint) :: constr(k)
+    type(constraint),allocatable :: conslist(:)
+    integer :: i,j
+
+    if (self%nconstraints < 1) then
+      allocate (self%cons(k))
+      self%nconstraints = k
+      self%cons(1:k) = constr(1:k)
+    else
+      i = self%nconstraints+k
+      j = self%nconstraints
+      allocate (conslist(i))
+      conslist(1:j) = self%cons(1:j)
+      conslist(j+1:i) = constr(1:k)
+      call move_alloc(conslist,self%cons)
+      self%nconstraints = i
+    end if
+
+    return
+  end subroutine calculation_add_constraintlist
+
+
 !=========================================================================================!
 
   subroutine calculation_add_scan(self,scn)
@@ -459,7 +527,6 @@
     class(calcdata) :: self
     type(calcdata) :: src
     integer :: i
-    !call self%reset()
 
     self%id = src%id
 
@@ -498,6 +565,24 @@
 
 !=========================================================================================!
 
+  subroutine calculation_freezegrad(self,grad)
+    class(calcdata) :: self
+    real(wp),intent(inout) :: grad(:,:)
+    integer :: nat,i
+    if (self%nfreeze > 0) then
+       nat = size(grad,2)
+       if(nat == self%nfreeze)then
+         error stop '**ERROR** Must not freeze all atoms!'
+       endif 
+       do i =1,nat
+         if(self%freezelist(i)) grad(:,i) = 0.0_wp
+       enddo
+    end if
+  end subroutine calculation_freezegrad
+
+
+!=========================================================================================!
+
   subroutine calculation_settings_addconfig(self,config)
     implicit none
     class(calculation_settings) :: self
@@ -531,56 +616,215 @@
       write (nmbr,'(i0)') id
       self%calcspace = 'calculation.level.'//trim(nmbr)
     end if
+
+    if (self%pr) then
+      self%prch = self%prch+id
+    end if
   end subroutine calculation_settings_autocomplete
 
+!>-- generate a unique print id for the calculation
+  subroutine calculation_settings_printid(self,thread,id)
+    implicit none
+    class(calculation_settings) :: self
+    integer,intent(in)  :: thread,id
+    integer :: i,j,dum
+    character(len=50) :: nmbr
+    dum = 100*(thread+1)
+    dum = dum+id
+    self%prch = dum
+  end subroutine calculation_settings_printid
+
+!=========================================================================================!
+
+  subroutine calculation_ONIOMexpand(self)
+!*******************************************************
+!* for an ONIOM calculations some of the calculators
+!* have to be duplikated, which is done by this routine
+!*******************************************************
+    class(calcdata) :: self
+    integer :: ncalcs
+    integer :: maxid
+    integer :: i,j,k,l,newid,j2
+    type(calculation_settings) :: calculator
+    integer,allocatable :: newids(:,:)
+    character(len=40) :: atmp
+    if (.not.allocated(self%ONIOM)) return
+    ncalcs = self%ONIOM%ncalcs
+    maxid = maxval(self%ONIOM%calcids(1,:),1)
+    if (maxid > self%ncalculations) then
+      write (stdout,'(a)') '**ERROR** in ONIOM setup: not enough calculators defined!'
+      error stop
+    end if
+
+    write(stdout,'(a)',advance='no') 'Assigning and duplicating calculators for ONIOM setup ...'
+    flush(stdout)
+
+    allocate (self%ONIOMmap(ncalcs),source=0)
+    allocate (newids(2,self%ONIOM%nfrag), source = 0)
+    k = 0
+    do i = 1,self%ONIOM%nfrag
+
+      do l = 1,2
+        !> j is now the ID of the reference calculation_settings object
+        j = self%ONIOM%calcids(l,i)
+        if (l == 2) then
+          !> to exlcude the highest ONIOM layer, we need to cycle
+          j2 = self%ONIOM%calcids(1,i)
+          if (j == j2)then
+             newid = newids(1,i)
+             newids(2,i) = newid
+             self%calcs(newid)%ONIOM_highlowroot = 3
+             self%calcs(newid)%ONIOM_id = i
+             cycle
+          endif
+        end if
+
+        if (any(self%ONIOMmap(:) .eq. j)) then
+          !> If one of this type is already in the mapping, duplicate the calculator and add it
+          call calculator%deallocate()
+          calculator = self%calcs(j)
+          call self%add(calculator)
+          newid = self%ncalculations
+          k = k+1
+          self%ONIOMmap(k) = newid
+        else
+          !> otherwise (i.e. it's not yet present), we can simply add it
+          k = k+1
+          newid = j
+          self%ONIOMmap(k) = newid
+        end if
+        newids(l,i) = newid
+
+        self%calcs(newid)%ONIOM_highlowroot = l
+        self%calcs(newid)%ONIOM_id = i
+        select case(l)
+        case( 1 ) 
+        write(atmp,'(a,i0,a)') 'ONIOM.',i,'.high'
+        case( 2 )
+        write(atmp,'(a,i0,a)') 'ONIOM.',i,'.low'
+        case( 3 )
+        write(atmp,'(a,i0,a)') 'ONIOM.',i,'.root'
+        end select
+        self%calcs(newid)%calcspace = trim(atmp)
+
+        !> ALWAYS set the weight of ONIOM calcs to 0!
+        self%calcs(newid)%weight = 0.0_wp
+      end do
+    end do
+    self%ONIOM%calcids = newids
+    deallocate(newids)
+
+    if(allocated(self%ONIOMrevmap)) deallocate(self%ONIOMrevmap)
+    allocate(self%ONIOMrevmap( self%ncalculations ), source=0)
+    do i =1,self%ncalculations
+       do j =1,self%ONIOM%ncalcs
+         if( self%ONIOMmap(j) == i)then
+            self%ONIOMrevmap(i) = j
+         endif
+       enddo
+    enddo
+
+    write(stdout,*) 'done.'
+  end subroutine calculation_ONIOMexpand
+
 !=========================================================================================!
   subroutine calculation_settings_info(self,iunit)
     implicit none
     class(calculation_settings) :: self
     integer,intent(in) :: iunit
     integer :: i,j
-    character(len=*),parameter :: fmt1 = '(1x,a20," : ",i5)'
-    character(len=*),parameter :: fmt2 = '(1x,a20," : ",f12.5)'
-    character(len=*),parameter :: fmt3 = '(1x,a20," : ",a)'
+    character(len=*),parameter :: fmt1 = '(" :",2x,a20," : ",i0)'
+    character(len=*),parameter :: fmt2 = '(" :",2x,a20," : ",f0.5)'
+    character(len=*),parameter :: fmt3 = '(" :",2x,a20," : ",a)'
+    character(len=*),parameter :: fmt4 = '(" :",1x,a)'
+    character(len=20) :: atmp
 
     if (allocated(self%description)) then
-      write (iunit,'(2x,a)') trim(self%description)
+      write (iunit,'(" :",1x,a)') trim(self%description)
     else
-      write (iunit,fmt1) 'Job type',self%id
+      write (atmp,*) 'Job type'
+      write (iunit,fmt1) atmp,self%id
+    end if
+    !> more info
+    if (self%id == jobtype%tblite) then
+      select case (self%tblitelvl)
+      case (2)
+        write (iunit,fmt4) 'GFN2-xTB level'
+      case (1)
+        write (iunit,fmt4) 'GFN1-xTB level'
+      end select
+    end if
+    if (any((/jobtype%orca,jobtype%xtbsys,jobtype%turbomole, &
+    &  jobtype%generic,jobtype%terachem/) == self%id)) then
+      write (iunit,'(" :",3x,a,a)') 'selected binary : ',trim(self%binary)
+    end if
+    if (self%refine_lvl > 0) then
+      write (atmp,*) 'refinement stage'
+      write (iunit,fmt1) atmp,self%refine_lvl
     end if
 
-    write (iunit,fmt1) 'Molecular charge',self%chrg
+    !> system data
+    write (atmp,*) 'Molecular charge'
+    write (iunit,fmt1) atmp,self%chrg
     if (self%uhf /= 0) then
-      write (iunit,fmt1) 'UHF parameter',self%uhf
+      write (atmp,*) 'UHF parameter'
+      write (iunit,fmt1) atmp,self%uhf
     end if
 
     if (allocated(self%solvmodel)) then
-      write (iunit,fmt3) 'Solvation model',trim(self%solvmodel)
+      write (atmp,*) 'Solvation model'
+      write (iunit,fmt3) atmp,trim(self%solvmodel)
     end if
     if (allocated(self%solvent)) then
-      write (iunit,fmt3) 'Solvent',trim(self%solvent)
+      write (atmp,*) 'Solvent'
+      write (iunit,fmt3) atmp,trim(self%solvent)
     end if
 
     !> xTB specific parameters
     if (any((/jobtype%tblite,jobtype%xtbsys,jobtype%gfn0,jobtype%gfn0occ/) == self%id)) then
-      write (iunit,fmt2) 'Fermi temperature',self%etemp
-      write (iunit,fmt2) 'Accuracy',self%accuracy
-      write (iunit,fmt1) 'max SCC cycles',self%maxscc
+      write (atmp,*) 'Fermi temperature'
+      write (iunit,fmt2) atmp,self%etemp
+      write (atmp,*) 'Accuracy'
+      write (iunit,fmt2) atmp,self%accuracy
+      write (atmp,*) 'max SCC cycles'
+      write (iunit,fmt1) atmp,self%maxscc
     end if
 
-    if (self%apiclean) write (iunit,fmt3) 'Reset data?','  yes'
-    if (self%rdwbo) write (iunit,fmt3) 'Read WBOs?','  yes'
-    if (self%rddip) write (iunit,fmt3) 'Read dipoles?','  yes'
+    write (atmp,*) 'Reset data?'
+    if (self%apiclean) write (iunit,fmt3) atmp,'yes'
+    write (atmp,*) 'Read WBOs?'
+    if (self%rdwbo) write (iunit,fmt3) atmp,'yes'
+    write (atmp,*) 'Read dipoles?'
+    if (self%rddip) write (iunit,fmt3) atmp,'yes'
+
+    write (atmp,*) 'Weight'
+    write (iunit,fmt2) atmp,self%weight
+
+    if(self%ONIOM_highlowroot /= 0)then
+      select case(self%ONIOM_highlowroot)
+      case( 1 )
+      write (atmp,*) 'ONIOM frag ("high")'
+      case(2)
+      write (atmp,*) 'ONIOM frag ("low")'
+      case(3)
+      write (atmp,*) 'ONIOM frag ("root")'
+      end select
+      write (iunit,fmt1) trim(atmp),self%ONIOM_id
+    endif
 
   end subroutine calculation_settings_info
+
 !========================================================================================!
+
   subroutine calculation_info(self,iunit)
     implicit none
     class(calcdata) :: self
     integer,intent(in) :: iunit
-    integer :: i
+    integer :: i,j
     character(len=*),parameter :: fmt1 = '(1x,a20," : ",i5)'
     character(len=*),parameter :: fmt2 = '(1x,a20," : ",f12.5)'
+    character(len=20) :: atmp
+    integer :: constraintype(8)
 
     write (iunit,'(1x,a)') '----------------'
     write (iunit,'(1x,a)') 'Calculation info'
@@ -589,21 +833,40 @@
       write (iunit,'("> ",a)') 'No calculation levels set up!'
     else if (self%ncalculations > 1) then
       do i = 1,self%ncalculations
-        write (iunit,'("> ",a,i0)') 'Calculation level ',i
+        if(self%calcs(i)%ONIOM_id > 0 )then
+        write (iunit,'("> ",a,i0,a)') 'Automatic ONIOM setup calculation level ',i,':'
+        else
+        write (iunit,'("> ",a,i0,a)') 'User-defined calculation level ',i,':'
+        endif
         call self%calcs(i)%info(iunit)
-        write (iunit,fmt2) 'weight',self%calcs(i)%weight
       end do
     else
-      write (iunit,'("> ",a)') 'Calculation level'
+      write (iunit,'("> ",a)') 'User-defined calculation level:'
       call self%calcs(1)%info(iunit)
     end if
     write (iunit,*)
 
     if (self%nconstraints > 0) then
       write (iunit,'("> ",a)') 'User-defined constraints:'
-      do i = 1,self%nconstraints
-        call self%cons(i)%print(iunit)
-      end do
+      if(self%nconstraints <= 20)then
+        do i = 1,self%nconstraints
+          call self%cons(i)%print(iunit)
+        end do
+      else
+         constraintype(:) = 0
+         do i = 1,self%nconstraints
+          j = self%cons(i)%type
+          if(j > 0 .and. j < 9)then
+            constraintype(j) = constraintype(j) + 1
+          endif 
+         end do
+         if(constraintype(1) > 0) write (iunit,'(2x,a,i0)') '# bond constraints    : ',constraintype(1)
+         if(constraintype(2) > 0) write (iunit,'(2x,a,i0)') '# angle constraints   : ',constraintype(2)
+         if(constraintype(3) > 0) write (iunit,'(2x,a,i0)') '# dihedral constraints: ',constraintype(3)
+         if(constraintype(4) > 0) write (iunit,'(2x,a,i0)') '# wall potential      : ',constraintype(4)
+         if(constraintype(5) > 0) write (iunit,'(2x,a,i0)') '# wall(logfermi) potential  : ',constraintype(5)
+         if(constraintype(8) > 0) write (iunit,'(2x,a,i0)') '# bondrange constraints    : ',constraintype(8)
+      endif 
       write (iunit,*)
     end if
 
@@ -620,11 +883,97 @@
         write (iunit,'(1x,a)') 'Energies and gradients of all calculation levels will be'// &
         & ' added according to their weights'
       end select
+      if(allocated(self%ONIOM))then
+        write (iunit,'(1x,a)') 'ONIOM energy and gradient will be constructed from calculations:'
+        do i=1,self%ncalculations
+          if(any(self%ONIOMmap(:).eq.i))then
+             write(stdout,'(1x,i0)',advance='no') i
+          endif
+        enddo
+        write (iunit,*)
+      endif
       write (iunit,*)
     end if
 
     return
   end subroutine calculation_info
 
+!=========================================================================================!
+
+  subroutine create_calclevel_shortcut(self,levelstring)
+!*********************************************************************
+!* subroutine create_calclevel_shortcut called with %create(...)
+!* Set up a calculation_settings object for a given level of theory
+!* More shortcuts can be added as required.
+!* Be careful about the intent(out) setting!
+!*********************************************************************
+    implicit none
+    class(calculation_settings),intent(out) :: self
+    character(len=*) :: levelstring
+    call self%deallocate()
+    select case (trim(levelstring))
+    case ('gfnff','--gff','--gfnff')
+      self%id = jobtype%gfnff
+    case ('gfn0','--gfn0')
+      self%id = jobtype%gfn0
+    case ('gfn2','--gfn2')
+      self%id = jobtype%tblite
+      self%tblitelvl = 2
+    case ('gfn1','--gfn1')
+      self%id = jobtype%tblite
+      self%tblitelvl = 1
+    case ('gp3')
+      self%id = jobtype%turbomole
+      self%rdgrad = .false.
+      self%binary = 'gp3'
+    case ('orca')
+      self%id = jobtype%orca
+
+    case ('generic')
+      self%id = jobtype%generic
+
+    end select
+  end subroutine create_calclevel_shortcut
+
+!=========================================================================================!
+
+  subroutine calc_set_active(self,ids)
+     implicit none
+     class(calcdata) :: self
+     integer,intent(in) :: ids(:) 
+     integer :: i,j,k,l
+     if(allocated(self%weightbackup)) deallocate(self%weightbackup)
+!>--- on-the-fly multiscale definition
+      allocate(self%weightbackup(self%ncalculations), source = 1.0_wp)
+      do i=1,self%ncalculations
+!>--- save backup weights
+        self%weightbackup(i) =  self%calcs(i)%weight
+!>--- set the weight of all unwanted calculations to 0
+        if(.not.any(ids(:).eq.i))then
+           self%calcs(i)%weight = 0.0_wp
+           self%calcs(i)%active = .false.
+        else
+!>--- and all other to 1
+           self%calcs(i)%weight = 1.0_wp
+           self%calcs(i)%active = .true.
+        endif
+      enddo
+  end subroutine calc_set_active
+  
+  subroutine calc_set_active_restore(self)
+     implicit none
+     class(calcdata) :: self
+     integer :: i,j,k,l
+     if(.not.allocated(self%weightbackup)) return
+     do i=1,self%ncalculations
+!>--- set all to active and restore saved weights        
+        self%calcs(i)%weight = self%weightbackup(i)
+        self%calcs(i)%active = .true.
+        self%eweight(i) = self%weightbackup(i)
+     enddo
+     deallocate(self%weightbackup)
+  end subroutine calc_set_active_restore
+ 
+
 !=========================================================================================!
 end module calc_type
Index: src/trackorigin.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=====================================================================================!\n! Add the string \"origin\" as a comment in every energy-line of an ensemble file\n!=====================================================================================!\nsubroutine addorigin(filename,origin)\n        use iso_fortran_env, only: wp=>real64\n        use iomod\n        use strucrd\n        implicit none\n        character(len=*),intent(in) :: filename\n        character(len=*),intent(in) :: origin        \n        integer :: i\n        integer :: nat,nall\n        integer,allocatable :: at(:)\n        real(wp),allocatable :: xyz(:,:,:)\n        real(wp),allocatable :: er(:)\n        character(len=128),allocatable :: comments(:)\n\n\n        call rdensembleparam(filename,nat,nall)\n        if(nall < 1)then\n            write(*,*) 'Warning: file ',trim(filename),' is empty!'\n            return\n        endif\n        allocate(at(nat),comments(nall),xyz(3,nat,nall),er(nall))\n        call rdensemble(filename,nat,nall,at,xyz,comments)\n\n        do i=1,nall\n           er(i) = grepenergy(comments(i))\n           comments(i) = '   !'//trim(origin)\n        enddo\n        call wrensemble('dummy',nat,nall,at,xyz,er,comments)\n\n        call remove(filename)\n        call rename('dummy',filename)\n\n        return\nend subroutine addorigin\n\n!--------------------------------------------------------------------------------------\n! Add the string \"origin\" as a comment in every energy-line of an ensemble file\n!--------------------------------------------------------------------------------------\nsubroutine addorigin2(filename,origin,nall)\n        use iomod\n        implicit none\n        integer,intent(in) :: nall\n        character(len=*),intent(in) :: filename\n        character(len=*),intent(in) :: origin(nall)\n\n        integer :: i,j,k\n        integer :: io,from,to\n        character(len=512) :: atmp\n\n        open(newunit=from,file=filename)\n        open(newunit=to,file='dummy')\n\n        do k=1,nall\n           read(from,'(a)',iostat=io)atmp\n           if(io<0)exit\n           read(atmp,*)j\n           write(to,'(a)')trim(atmp)\n           read(from,'(a)')atmp\n           write(to,'(a,3x,a,a)')trim(atmp),'!',trim(origin(k))\n           do i=1,j\n              read(from,'(a)',iostat=io)atmp\n              if(io<0)exit\n              write(to,'(a)')trim(atmp)\n           enddo\n        enddo\n\n        close(from)\n        close(to)\n        call remove(filename)\n        call rename('dummy',filename)\n\nend subroutine addorigin2\n\n!====================================================================================!\n! Add a timestamp indicator  as a comment in every energy-line of an ensemble file\n! The whole length(=nall) of the trajectory is split in \"nsplit\" parts.\n!====================================================================================! \nsubroutine addtimestamp(filename,nsplit)\n        use iso_fortran_env, wp => real64\n        use iomod\n        use strucrd, only: rdensembleparam,rdensemble\n        implicit none\n        character(len=*),intent(in) :: filename\n        integer,intent(in) :: nsplit\n\n        integer :: i\n        integer :: nat,nall\n        integer :: tag3\n        real(wp) :: tag1,tag2\n        character(len=40),allocatable :: stamp(:)\n\n        call rdensembleparam(filename,nat,nall)\n        allocate(stamp(nall))\n        do i=1,nall\n          tag1 = float(i)/float(nall)\n          tag2 = tag1 * float(nsplit)\n          tag3 = nint(tag2)\n          tag3 = max(1,tag3) !no 0 timestamp\n          write(stamp(i),'(a,i0)')'t',tag3\n        enddo\n        call addorigin2(filename,stamp,nall)\n        deallocate(stamp)\n        return\nend subroutine addtimestamp\n\n!--------------------------------------------------------------------------------------\n! same as above, but only for a single xyz file\n!--------------------------------------------------------------------------------------\nsubroutine addoriginXYZ(filename,origin)\n        use iomod\n        implicit none\n        character(len=*),intent(in) :: filename\n        character(len=*) :: origin\n        integer :: i,j\n        integer :: io,from,to\n        character(len=512) :: atmp\n\n        open(newunit=from,file=filename)\n        open(newunit=to,file='dummy')\n\n           read(from,'(a)',iostat=io)atmp\n           read(atmp,*)j\n           write(to,'(a)')trim(atmp)\n           read(from,'(a)')atmp\n           write(to,'(a,3x,a,a)')trim(atmp),'!',trim(origin)\n           do i=1,j\n              read(from,'(a)',iostat=io)atmp\n              if(io<0)exit\n              write(to,'(a)')trim(atmp)\n           enddo\n\n        close(from)\n        close(to)\n        call remove(filename)\n        call rename('dummy',filename)\n\nend subroutine addoriginXYZ\n\n!==================================================================================!\n! Set origin as comment for several trajectories in subdirectories\n!==================================================================================!\nsubroutine set_trj_origins(base,origin)\n      use iomod\n      implicit none\n\n      character(len=*) :: base\n      character(len=*) :: origin\n      character(len=256) :: str,dir\n      integer :: i\n      logical :: ex\n      i=1\n      do\n        write(dir,'(a,i0)')trim(base),i\n        ex = directory_exist(trim(dir))\n        if(.not.ex)then\n          exit\n        else\n          write(str,'(a,a,''xtb.trj'')')trim(dir),'/'\n          write(dir,'(a,i0)')trim(origin),i\n          call addorigin(trim(str),trim(dir))\n          i=i+1\n        endif\n      enddo\n      return\nend subroutine set_trj_origins\n\n!==================================================================================!\n! Set origin as comment for several trajectories in subdirectories\n! each trajectory length is cut in \"nsplit\" parts\n!==================================================================================!\nsubroutine set_trj_timestamps(base,nsplit)\n      use iomod\n      implicit none\n\n      character(len=*) :: base\n      integer,intent(in) :: nsplit\n      character(len=256) :: str,dir\n      integer :: i\n      logical :: ex\n      i=1\n      do\n        write(dir,'(a,i0)')trim(base),i\n        ex = directory_exist(trim(dir))\n        if(.not.ex)then\n          exit\n        else\n          write(str,'(a,a,''xtb.trj'')')trim(dir),'/'\n          call addtimestamp(trim(str),nsplit)\n          i=i+1\n        endif\n      enddo\n      return\nend subroutine set_trj_timestamps\n\n\n!==================================================================================!\n! get the string \"origin\" as a substring from line, if seperated by \"!\"\n!==================================================================================!\nsubroutine getorigin(line,origin)\n        implicit none\n        character(len=*),intent(in) :: line\n        character(len=*),intent(inout) :: origin\n        integer :: i,j\n        character(len=1) :: digit        \n\n        origin=''\n\n       do i=1,len(trim(line))\n         digit=line(i:i)\n         if(digit=='!') then\n           j=i+1\n           origin=trim(line(j:))\n           exit\n         endif\n       enddo\n       return\nend subroutine getorigin\n\n!==========================================================================!\n! subrotuine rdensemble_origin\n! is a wrappen for the rdensemble routine from module strucrd\n! that extracts the energy and the origin tag from the comment lines\n!==========================================================================!\nsubroutine rdensemble_origin(fname,nat,nall,at,xyz,energy,origin)\n    use iso_fortran_env, wp => real64\n    use strucrd, only: rdensemble,grepenergy\n    implicit none\n    character(len=*) :: fname\n    integer,intent(in)  :: nat\n    integer,intent(in)  :: nall\n    integer,intent(inout)  :: at(nat)\n    real(wp),intent(inout) :: xyz(3,nat,nall)\n    real(wp),intent(inout) :: energy(nall)\n    character(len=*),intent(inout) :: origin(nall)\n\n    character(len=256),allocatable :: comments(:)\n    character(len=256) :: a\n    integer :: i\n\n    allocate(comments(nall))\n    call rdensemble(fname,nat,nall,at,xyz,comments)\n\n    do i=1,nall\n      a=comments(i)\n      energy(i) = grepenergy(a)\n      call getorigin(trim(a),origin(i))\n    enddo\n\n    deallocate(comments)\n    return\nend subroutine rdensemble_origin\n\n!=========================================================================!\n!  get timestamp tag (as an integer) from a string tag\n!=========================================================================!\nsubroutine origin2time(nall,orig,tims)\n    implicit none\n    integer :: nall\n    character(len=*) :: orig(nall)\n    integer :: tims(nall)\n    character(len=40) :: atmp\n    integer :: i\n    do i=1,nall\n       atmp=trim(orig(i))\n       if(atmp(1:1)=='t')then !should work only with timetag flag\n         atmp=atmp(2:) !cut the \"t\"\n         read(atmp,*)tims(i)\n       else\n         tims(i)=1\n       endif\n    enddo\n    return\nend subroutine origin2time\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/trackorigin.f90 b/src/trackorigin.f90
--- a/src/trackorigin.f90	
+++ b/src/trackorigin.f90	
@@ -248,8 +248,8 @@
     use strucrd, only: rdensemble,grepenergy
     implicit none
     character(len=*) :: fname
-    integer,intent(in)  :: nat
-    integer,intent(in)  :: nall
+    integer,intent(inout)  :: nat
+    integer,intent(inout)  :: nall
     integer,intent(inout)  :: at(nat)
     real(wp),intent(inout) :: xyz(3,nat,nall)
     real(wp),intent(inout) :: energy(nall)
Index: src/calculator/generic_sc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!====================================================!\n! module generic_sc\n! A module containing routines for\n! system calls to a generic script\n!====================================================!\n\nmodule generic_sc\n\n  use iso_fortran_env,only:wp => real64\n  use strucrd\n  use calc_type\n  use iomod,only:makedir,directory_exist,remove,command\n  implicit none\n\n!=========================================================================================!\n  !--- private module variables and parameters\n  private\n  integer :: i,j,k,l,ich,och,io\n  logical :: ex\n\n  integer,parameter :: nf = 2\n  character(len=*),parameter :: rmfiles(nf) = [&\n          & 'genericinp.grad  ','genericinp.engrad']\n  character(len=6),parameter :: runscript = 'run.sh'\n  character(len=14),parameter :: xyzn = 'genericinp.xyz'\n  character(len=17),parameter :: gf = 'genericinp.engrad'\n\n  public :: generic_engrad\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n\n!========================================================================================!\n  subroutine generic_engrad(mol,calc,energy,grad,iostatus)\n    use iso_fortran_env,only:wp => real64\n    use strucrd\n    use calc_type\n    use iomod,only:makedir,directory_exist,remove\n\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    iostatus = 0\n    \n    !>--- setup system call information\n    !$omp critical\n    call generic_setup(mol,calc)\n    !$omp end critical\n\n    !>--- do the systemcall\n    call initsignal()\n    call command(calc%systemcall, iostatus)\n    if (iostatus /= 0) return\n\n    !>--- read energy and gradient\n    !$omp critical\n    call rd_generic_engrad(mol,calc,energy,grad,iostatus)\n    !$omp end critical\n    if (iostatus /= 0) return\n\n    !>--- read WBOs?\n    !!$omp critical\n    !call rd_generic_wbo(mol,calc,iostatus)\n    !!$omp end critical\n    !if (iostatus /= 0) return\n\n    return\n  end subroutine generic_engrad\n\n!========================================================================================!\n  subroutine generic_setup(mol,calc)\n    use iso_fortran_env,only:wp => real64\n    use strucrd\n    use calc_type\n    use iomod,only:makedir,directory_exist,remove\n\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    integer :: l\n    character(len=:),allocatable :: fname\n    character(len=:),allocatable :: cpath\n    character(len=:),allocatable :: tmprelpath\n    character(len=512) :: thispath\n    character(len=10) :: num\n    integer :: i,j,k,ich,och,io\n    logical :: ex\n\n    call initsignal()\n\n    !>--- set default binary if not present\n    if (.not. allocated(calc%binary)) then\n      calc%binary = runscript\n    end if\n\n    !>--- important for generec calls:\n    !     check if the requested binary/script is in the current working directory\n    !     if so, convert to absolute path\n    tmprelpath = '.'//sep//trim(calc%binary)\n    inquire(file=tmprelpath,exist=ex)\n    if(ex)then\n      call getcwd(thispath)\n      calc%binary = trim(thispath)//sep//trim(calc%binary)\n    endif \n    deallocate(tmprelpath)\n\n    !>--- check for the calculation space\n    if (allocated(calc%calcspace)) then\n      ex = directory_exist(calc%calcspace)\n      if (.not. ex) then\n        io = makedir(trim(calc%calcspace))\n      end if\n      cpath = calc%calcspace\n    else\n      cpath = ''\n    end if\n    !>--- cleanup old files\n    do i = 1,nf\n      !write(*,*) trim(cpath)//sep//trim(rmfiles(i)) \n      call remove(trim(cpath)//sep//trim(rmfiles(i)))\n    end do\n    deallocate (cpath)\n\n    !>--- construct path information and write coord file\n    if (.not. allocated(calc%calcfile)) then\n      if (allocated(calc%calcspace)) then\n        l = len_trim(calc%calcspace)\n        fname = trim(calc%calcspace)\n        if (calc%calcspace(l:l) == sep) then\n          fname = trim(fname)//xyzn\n        else\n          fname = trim(fname)//sep//xyzn\n        end if\n      else\n        fname = xyzn\n      end if\n      calc%calcfile = fname\n    else\n      fname = calc%calcfile\n    end if\n    call mol%write(fname)\n    deallocate (fname)\n\n    !>--- if the systemcall was already set up, return\n    if (allocated(calc%systemcall)) return\n\n    !>--- construct path information for sys-call\n    if (allocated(calc%calcspace)) then\n      calc%systemcall = 'cd '//calc%calcspace//' &&'\n      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%binary)\n    else\n      calc%systemcall = trim(calc%binary)\n    end if\n\n    !>--- add other call information\n    calc%systemcall = trim(calc%systemcall)//' '//xyzn\n    !>--- user-set flags\n    if (allocated(calc%other)) then\n      calc%systemcall = trim(calc%systemcall)//' '//trim(calc%other)\n    end if\n\n    !>--- add printout information\n    calc%systemcall = trim(calc%systemcall)//' '//'> generic.out'\n    calc%systemcall = trim(calc%systemcall)//dev0\n\n    !write (*,*) calc%systemcall\n    return\n  end subroutine generic_setup\n\n!========================================================================================!\n! subroutine rd_generic_engrad\n! read xtb's energy and Cartesian gradient from file\n! xtb's *.engrad format is used for this\n  subroutine rd_generic_engrad(mol,calc,energy,grad,iostatus)\n    use iso_fortran_env,only:wp => real64\n    use strucrd\n    use calc_type\n    use iomod,only:makedir,directory_exist,remove\n    use gradreader_module\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n    integer :: n,c\n    real(wp) :: dum\n    character(len=128) :: atmp\n    character(len=512) :: tmpgradfile,tmpefile\n\n    integer :: i,j,k,ich,och,io\n    logical :: ex\n\n    call initsignal()\n\n    iostatus = 0\n    tmpgradfile = ''\n    tmpefile = ''\n    if (.not. allocated(calc%gradfile)) then\n      calc%gradfile = gf\n    endif  \n    if (allocated(calc%calcspace)) then\n      tmpgradfile = trim(calc%calcspace)//sep//trim(calc%gradfile)\n      if(allocated(calc%efile)) &\n      & tmpefile  = trim(calc%calcspace)//sep//trim(calc%efile)\n    else\n      tmpgradfile = trim(calc%gradfile)\n      if(allocated(calc%efile)) &\n      & tmpefile  = trim(calc%efile)\n    end if\n\n    inquire (file=trim(tmpgradfile),exist=ex)\n    if (.not. ex) then\n      iostatus = 1\n      return\n    end if\n\n    open (newunit=ich,file=trim(tmpgradfile))\n    select case( calc%gradtype )\n    case( gradtype%engrad )\n      call rd_grad_engrad(ich,mol%nat,energy,grad,iostatus)\n    case( gradtype%turbomole )\n       \n    case default\n      if(.not.allocated(calc%efile))then\n         iostatus = 1\n         return\n      endif\n      call rd_efile(trim(tmpefile),energy,iostatus)\n      if(allocated(calc%gradkey))then\n        call rd_grad_generic(ich,mol%nat,grad, &\n        & calc%gradkey,calc%gradfmt,iostatus)\n      else\n        call rd_grad_generic(ich,mol%nat,grad, &\n        & '',calc%gradfmt,iostatus)\n      endif \n    end select\n    close (ich)\n\n    return\n  end subroutine rd_generic_engrad\n!========================================================================================!\n! subroutine rd_generic_wbo\n! helper routine ro read generic WBOs\n  subroutine rd_generic_wbo(mol,calc,iostatus)\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    integer,intent(out) :: iostatus\n    integer :: i,j\n    real(wp) :: dum\n    character(len=:),allocatable :: wbofile\n    character(len=128) :: atmp\n\n    call initsignal()\n\n    iostatus = 0\n\n    if (calc%rdwbo) then\n      if (allocated(calc%calcspace)) then\n        wbofile = trim(calc%calcspace)//sep//'wbo'\n      else\n        wbofile = 'wbo'\n      end if\n    else\n      return\n    end if\n\n    inquire (file=wbofile,exist=ex)\n    if (.not. ex) then\n      iostatus = 1\n      return\n    end if\n\n    if (allocated(calc%wbo)) deallocate (calc%wbo)\n    allocate (calc%wbo(mol%nat,mol%nat),source=0.0_wp)\n\n    open (newunit=ich,file=wbofile)\n    do\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      read (atmp,*) i,j,dum\n      calc%wbo(i,j) = dum\n      calc%wbo(j,i) = dum\n    end do\n    close (ich)\n\n  end subroutine rd_generic_wbo\n\n!========================================================================================!\nend module generic_sc\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/generic_sc.f90 b/src/calculator/generic_sc.f90
--- a/src/calculator/generic_sc.f90	
+++ b/src/calculator/generic_sc.f90	
@@ -17,12 +17,11 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-!====================================================!
-! module generic_sc
-! A module containing routines for
-! system calls to a generic script
-!====================================================!
+!> module generic_sc
+!> A module containing routines for
+!> system calls to a generic script
 
+!=========================================================================================!
 module generic_sc
 
   use iso_fortran_env,only:wp => real64
@@ -30,9 +29,7 @@
   use calc_type
   use iomod,only:makedir,directory_exist,remove,command
   implicit none
-
-!=========================================================================================!
-  !--- private module variables and parameters
+  !>--- private module variables and parameters
   private
   integer :: i,j,k,l,ich,och,io
   logical :: ex
@@ -52,8 +49,6 @@
 !========================================================================================!
 !========================================================================================!
 
-
-!========================================================================================!
   subroutine generic_engrad(mol,calc,energy,grad,iostatus)
     use iso_fortran_env,only:wp => real64
     use strucrd
@@ -68,8 +63,10 @@
     real(wp),intent(inout) :: grad(3,mol%nat)
     integer,intent(out) :: iostatus
 
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
     iostatus = 0
-    
+
     !>--- setup system call information
     !$omp critical
     call generic_setup(mol,calc)
@@ -77,7 +74,7 @@
 
     !>--- do the systemcall
     call initsignal()
-    call command(calc%systemcall, iostatus)
+    call command(calc%systemcall,iostatus)
     if (iostatus /= 0) return
 
     !>--- read energy and gradient
@@ -118,7 +115,7 @@
     call initsignal()
 
     !>--- set default binary if not present
-    if (.not. allocated(calc%binary)) then
+    if (.not.allocated(calc%binary)) then
       calc%binary = runscript
     end if
 
@@ -126,17 +123,17 @@
     !     check if the requested binary/script is in the current working directory
     !     if so, convert to absolute path
     tmprelpath = '.'//sep//trim(calc%binary)
-    inquire(file=tmprelpath,exist=ex)
-    if(ex)then
+    inquire (file=tmprelpath,exist=ex)
+    if (ex) then
       call getcwd(thispath)
       calc%binary = trim(thispath)//sep//trim(calc%binary)
-    endif 
-    deallocate(tmprelpath)
+    end if
+    deallocate (tmprelpath)
 
     !>--- check for the calculation space
     if (allocated(calc%calcspace)) then
       ex = directory_exist(calc%calcspace)
-      if (.not. ex) then
+      if (.not.ex) then
         io = makedir(trim(calc%calcspace))
       end if
       cpath = calc%calcspace
@@ -145,13 +142,13 @@
     end if
     !>--- cleanup old files
     do i = 1,nf
-      !write(*,*) trim(cpath)//sep//trim(rmfiles(i)) 
+      !write(*,*) trim(cpath)//sep//trim(rmfiles(i))
       call remove(trim(cpath)//sep//trim(rmfiles(i)))
     end do
     deallocate (cpath)
 
     !>--- construct path information and write coord file
-    if (.not. allocated(calc%calcfile)) then
+    if (.not.allocated(calc%calcfile)) then
       if (allocated(calc%calcspace)) then
         l = len_trim(calc%calcspace)
         fname = trim(calc%calcspace)
@@ -225,44 +222,44 @@
     iostatus = 0
     tmpgradfile = ''
     tmpefile = ''
-    if (.not. allocated(calc%gradfile)) then
+    if (.not.allocated(calc%gradfile)) then
       calc%gradfile = gf
-    endif  
+    end if
     if (allocated(calc%calcspace)) then
       tmpgradfile = trim(calc%calcspace)//sep//trim(calc%gradfile)
-      if(allocated(calc%efile)) &
-      & tmpefile  = trim(calc%calcspace)//sep//trim(calc%efile)
+      if (allocated(calc%efile)) &
+      & tmpefile = trim(calc%calcspace)//sep//trim(calc%efile)
     else
       tmpgradfile = trim(calc%gradfile)
-      if(allocated(calc%efile)) &
-      & tmpefile  = trim(calc%efile)
+      if (allocated(calc%efile)) &
+      & tmpefile = trim(calc%efile)
     end if
 
     inquire (file=trim(tmpgradfile),exist=ex)
-    if (.not. ex) then
+    if (.not.ex) then
       iostatus = 1
       return
     end if
 
     open (newunit=ich,file=trim(tmpgradfile))
-    select case( calc%gradtype )
-    case( gradtype%engrad )
+    select case (calc%gradtype)
+    case (gradtype%engrad)
       call rd_grad_engrad(ich,mol%nat,energy,grad,iostatus)
-    case( gradtype%turbomole )
-       
+    case (gradtype%turbomole)
+
     case default
-      if(.not.allocated(calc%efile))then
-         iostatus = 1
-         return
-      endif
+      if (.not.allocated(calc%efile)) then
+        iostatus = 1
+        return
+      end if
       call rd_efile(trim(tmpefile),energy,iostatus)
-      if(allocated(calc%gradkey))then
+      if (allocated(calc%gradkey)) then
         call rd_grad_generic(ich,mol%nat,grad, &
         & calc%gradkey,calc%gradfmt,iostatus)
       else
         call rd_grad_generic(ich,mol%nat,grad, &
         & '',calc%gradfmt,iostatus)
-      endif 
+      end if
     end select
     close (ich)
 
@@ -276,11 +273,12 @@
     type(coord) :: mol
     type(calculation_settings) :: calc
     integer,intent(out) :: iostatus
-    integer :: i,j
     real(wp) :: dum
     character(len=:),allocatable :: wbofile
     character(len=128) :: atmp
 
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
     call initsignal()
 
     iostatus = 0
@@ -296,7 +294,7 @@
     end if
 
     inquire (file=wbofile,exist=ex)
-    if (.not. ex) then
+    if (.not.ex) then
       iostatus = 1
       return
     end if
@@ -316,5 +314,6 @@
 
   end subroutine rd_generic_wbo
 
+!========================================================================================!
 !========================================================================================!
 end module generic_sc
Index: src/eval_timer.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021-2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\nsubroutine eval_timer(tim)\n  use crest_parameters\n  use crest_data\n  implicit none\n  type(timer) :: tim\n  write (stdout,*)\n  call smallhead('Wall Time Summary')\n  call tim%write(stdout,'CREST runtime',verbose=.true.)\n  call tim%clear\nend subroutine eval_timer\n\nsubroutine propquit(tim)\n  use crest_parameters, only: stdout\n  use crest_data\n  implicit none\n  type(timer) :: tim\n  call eval_timer(tim)\n  write (stdout,*) 'CREST terminated normally.'\n  stop\nend subroutine propquit\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/eval_timer.f90 b/src/eval_timer.f90
--- a/src/eval_timer.f90	
+++ b/src/eval_timer.f90	
@@ -17,14 +17,30 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 subroutine eval_timer(tim)
+!********************************
+!* The final timer evaluation to
+!* be called at the end of CREST
+!********************************
   use crest_parameters
   use crest_data
+  use crest_calculator,only: engrad_total
+  use crest_restartlog
   implicit none
   type(timer) :: tim
+  real(wp) :: time_total,time_avg
+  character(len=40) :: atmp
   write (stdout,*)
   call smallhead('Wall Time Summary')
   call tim%write(stdout,'CREST runtime',verbose=.true.)
+  time_total = tim%get()
   call tim%clear
+  if(engrad_total > 0)then
+  write(atmp,'(f30.3)') time_total/real(engrad_total,wp)
+  write(stdout,'(" * Total number of energy+grad calls: ",i0)') & !,a,1x,a,a)') & 
+  &  engrad_total!,' (avg. wall-time',trim(adjustl(atmp)),' sec)'
+  write(stdout,*)
+  call dump_restart() 
+  endif
 end subroutine eval_timer
 
 subroutine propquit(tim)
Index: src/calculator/api_engrad.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!====================================================!\n! module api_engrad\n! a collection of engrad calls for different APIs\n! this builds the communication between CRESTs\n! calculation_settings and the respective API setups\n!====================================================!\n\nmodule api_engrad\n\n  use iso_fortran_env,only:wp => real64,stdout => output_unit\n  use strucrd\n  use calc_type\n  use iomod,only:makedir,directory_exist,remove\n  !> API modules\n  use api_helpers\n  use tblite_api\n  use gfn0_api\n  use gfnff_api\n  use xhcff_api\n!=========================================================================================!\n  implicit none\n  !--- private module variables and parameters\n  private\n  integer :: i,j,k,l,ich,och,io\n  logical :: ex\n\n  public :: tblite_engrad\n  public :: gfn0_engrad,gfn0occ_engrad\n  public :: gfnff_engrad\n  public :: xhcff_engrad\n\n!=========================================================================================!\n!=========================================================================================!\ncontains    !> MODULE PROCEDURES START HERE\n!=========================================================================================!\n!=========================================================================================!\n\n  subroutine tblite_engrad(mol,calc,energy,grad,iostatus)\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    character(len=:),allocatable :: cpath\n    logical :: loadnew,pr\n    iostatus = 0\n    pr =.true. !> tblite always printes some data\n\n    !>--- setup system call information\n    !$omp critical\n    call tblite_init(calc,loadnew)\n    !> tblite printout handling\n    inquire (unit=calc%ctx%unit,opened=ex)\n    if ((calc%ctx%unit .ne. stdout).and.ex) then\n      close (calc%ctx%unit)\n    end if\n    if (allocated(calc%calcspace)) then\n      ex = directory_exist(calc%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(calc%calcspace))\n      end if\n      cpath = calc%calcspace//sep//'tblite.out'\n    else\n      cpath = 'tblite.out'\n    end if\n    open (newunit=calc%ctx%unit,file=cpath,status='replace')\n    deallocate (cpath)\n    call api_print_input_structure(pr, calc%ctx%unit, mol)\n    !> populate parameters and wavefunction\n    if (loadnew) then\n      call tblite_setup(mol,calc%chrg,calc%uhf,calc%tblitelvl,calc%etemp, &\n      &    calc%ctx,calc%wfn,calc%tbcalc)\n      call tblite_addsettings(calc%tbcalc,calc%maxscc,calc%rdwbo,calc%saveint)\n      call tblite_add_solv(mol,calc%chrg,calc%uhf,calc%ctx,calc%wfn,calc%tbcalc, &\n      &    calc%solvmodel,calc%solvent)\n    end if\n    !$omp end critical\n    !>--- do the engrad call\n    call initsignal()\n    call tblite_singlepoint(mol,calc%chrg,calc%uhf,calc%accuracy, &\n    & calc%ctx,calc%wfn,calc%tbcalc,energy,grad,calc%tbres,iostatus)\n    if (iostatus /= 0) return\n    call api_print_e_grd(pr,calc%ctx%unit,mol,energy,grad)\n\n    !>--- postprocessing, getting other data\n    !$omp critical\n    call tblite_wbos(calc,mol,iostatus)\n    !$omp end critical\n\n    return\n  end subroutine tblite_engrad\n\n!========================================================================================!\n\n  subroutine gfn0_engrad(mol,calc,g0calc,energy,grad,iostatus)\n!> This is the GFN0 engrad call that uses the standard implementation\n    implicit none\n    !> INPUT\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    !> OUTPUT\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n    !> LOCAL\n    type(gfn0_results) :: res\n    character(len=:),allocatable :: cpath\n    logical :: loadnew\n    logical :: pr\n    iostatus = 0\n    pr = .false.\n!>--- setup system call information\n    !$omp critical\n    call gfn0_init(calc,g0calc,loadnew)\n!>--- printout handling\n    inquire (unit=calc%prch,opened=ex)\n    if ((calc%prch .ne. stdout).and.ex) then\n      close (calc%prch)\n    end if\n    if (allocated(calc%calcspace)) then\n      ex = directory_exist(calc%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(calc%calcspace))\n      end if\n      cpath = calc%calcspace//sep//'gfn0.out'\n    else\n      cpath = 'gfn0.out'\n    end if\n    if ((calc%prch .ne. stdout)) then\n      open (newunit=calc%prch,file=cpath)\n      pr = .true.\n    end if\n    deallocate (cpath)\n    call api_print_input_structure(pr, calc%prch, mol)\n\n    !> populate parameters and wavefunction\n    if (loadnew) then\n      call gfn0_setup(mol,calc%chrg,calc%uhf,g0calc)\n      call gfn0_init2(mol,calc,g0calc)\n    end if\n    call gfn0_init3(mol,calc,g0calc)\n    !$omp end critical\n!>--- do the engrad call\n    call initsignal()\n    call gfn0_sp(mol,calc%chrg,calc%uhf,g0calc,energy,grad,iostatus,res)\n    if (iostatus /= 0) return\n    if (pr) then\n      call gfn0_print(calc%prch,g0calc,res)\n      call api_print_e_grd(pr,calc%prch,mol,energy,grad)\n    end if\n\n!>--- postprocessing, getting other data\n    !$omp critical\n    call gfn0_wbos(calc,calc%g0calc,mol,iostatus)\n    !$omp end critical\n\n    return\n  end subroutine gfn0_engrad\n\n!========================================================================================!\n\n  subroutine gfn0occ_engrad(mol,calc,g0calc,energy,grad,iostatus)\n!> This is the GFN0 engrad call in which a config can be specified\n    implicit none\n    !> INPUT\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n    type(gfn0_data),intent(inout),allocatable  :: g0calc\n    !> OUTPUT\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(:,:)\n    integer,intent(out) :: iostatus\n    !> LOCAL\n    type(gfn0_results) :: res\n    character(len=:),allocatable :: cpath\n    logical :: loadnew,pr\n    iostatus = 0\n    pr = .false.\n    !>--- setup system call information\n    !$omp critical\n    call gfn0occ_init(calc,g0calc,loadnew)\n    !> printout handling\n    inquire (unit=calc%prch,opened=ex)\n    if ((calc%prch .ne. stdout).and.ex) then\n      close (calc%prch)\n    end if\n    if (allocated(calc%calcspace)) then\n      ex = directory_exist(calc%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(calc%calcspace))\n      end if\n      cpath = calc%calcspace//sep//'gfn0.out'\n    else\n      cpath = 'gfn0.out'\n    end if\n    if (calc%prch .ne. stdout) then\n      open (newunit=calc%prch,file=cpath)\n      pr = .true.\n    end if\n    deallocate (cpath)\n    call api_print_input_structure(pr, calc%prch, mol)\n\n    !> populate parameters and wavefunction\n    if (loadnew) then\n      call gfn0_setup(mol,calc%chrg,calc%uhf,g0calc)\n      call gfn0occ_init2(mol,calc,g0calc)\n    end if\n    call gfn0occ_init3(mol,calc,g0calc)\n    !$omp end critical\n    !>--- do the engrad call\n    call initsignal()\n    call gfn0_sp_occ(mol,calc%chrg,calc%uhf,calc%occ,g0calc, &\n    &    energy,grad,iostatus,res)\n    if (iostatus /= 0) return\n    if (pr) then\n      call gfn0_print(calc%prch,g0calc,res)\n      call api_print_e_grd(pr,calc%prch,mol,energy,grad)\n    end if\n\n    !>--- postprocessing, getting other data\n    !$omp critical\n    call gfn0_wbos(calc,g0calc,mol,iostatus)\n    !$omp end critical\n\n    return\n  end subroutine gfn0occ_engrad\n\n!========================================================================================!\n  subroutine gfnff_engrad(mol,calc,energy,grad,iostatus)\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    character(len=:),allocatable :: cpath\n    logical :: loadnew,pr\n    iostatus = 0\n    pr = .false.\n!>--- setup system call information\n    !$omp critical\n    call gfnff_init(calc,loadnew)\n!>--- printout handling\n    inquire (unit=calc%prch,opened=ex)\n    if ((calc%prch .ne. stdout).and.ex) then\n      close (calc%prch)\n    end if\n    if (allocated(calc%calcspace)) then\n      ex = directory_exist(calc%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(calc%calcspace))\n      end if\n      cpath = calc%calcspace//sep//'gfnff.out'\n    else\n      cpath = 'gfnff.out'\n    end if\n    if ((calc%prch .ne. stdout)) then\n      open (newunit=calc%prch,file=cpath)\n      pr = .true.\n    end if\n    deallocate (cpath)\n    call api_print_input_structure(pr, calc%prch, mol)\n\n!>--- populate parameters and neighbourlists\n    if (loadnew) then\n      call gfnff_api_setup(mol,calc%chrg,calc%ff_dat,iostatus,pr,calc%prch)\n    end if\n    !$omp end critical\n    if (iostatus /= 0) return\n\n!>--- do the engrad call\n    call initsignal()\n    call gfnff_sp(mol,calc%ff_dat,energy,grad,iostatus)\n    if (iostatus /= 0) return\n\n!>--- printout\n    if (pr) then\n      call gfnff_printout(calc%prch,calc%ff_dat)\n      call api_print_e_grd(pr,calc%prch,mol,energy,grad)\n    end if\n\n!>--- postprocessing, getting other data\n    !$omp critical\n    call gfnff_wbos(calc,mol,iostatus)\n    !$omp end critical\n\n\n    return\n  end subroutine gfnff_engrad\n\n!========================================================================================!\n  subroutine xhcff_engrad(mol,calc,energy,grad,iostatus)\n    implicit none\n    type(coord) :: mol\n    type(calculation_settings) :: calc\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,mol%nat)\n    integer,intent(out) :: iostatus\n\n    character(len=:),allocatable :: cpath\n    logical :: loadnew,pr\n    iostatus = 0\n    pr = .false.\n!>--- setup system call information\n    !$omp critical\n    call xhcff_initcheck(calc,loadnew)\n!>--- printout handling\n    inquire (unit=calc%prch,opened=ex)\n    if ((calc%prch .ne. stdout).and.ex) then\n      close (calc%prch)\n    end if\n    if (allocated(calc%calcspace)) then\n      ex = directory_exist(calc%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(calc%calcspace))\n      end if\n      cpath = calc%calcspace//sep//'xhcff.out'\n    else\n      cpath = 'xhcff.out'\n    end if\n    if ((calc%prch .ne. stdout)) then\n      open (newunit=calc%prch,file=cpath)\n      pr = .true.\n    end if\n    deallocate (cpath)\n    call api_print_input_structure(pr, calc%prch, mol)\n\n!>--- populate parameters\n    if (loadnew) then\n      !> call xhcff with verbosity turned off\n      call xhcff_setup(mol,calc%xhcff, calc%extpressure, calc%ngrid, calc%proberad, calc%vdwset, iostatus)\n    end if\n    !$omp end critical\n    if (iostatus /= 0) return\n\n!>--- do the engrad call\n    call initsignal()\n    call xhcff_sp(mol,calc%xhcff,energy,grad,iostatus)\n    if (iostatus /= 0) return\n\n!>--- printout\n    if (pr) then\n      call xhcff_print(calc%prch,calc%xhcff)\n      call api_print_e_grd(pr,calc%prch,mol,energy,grad)\n    end if\n\n!>--- postprocessing, getting other data\n\n    return\n  end subroutine xhcff_engrad\n\n!========================================================================================!\nend module api_engrad\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/api_engrad.f90 b/src/calculator/api_engrad.f90
--- a/src/calculator/api_engrad.f90	
+++ b/src/calculator/api_engrad.f90	
@@ -17,12 +17,10 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-!====================================================!
-! module api_engrad
-! a collection of engrad calls for different APIs
-! this builds the communication between CRESTs
-! calculation_settings and the respective API setups
-!====================================================!
+!> module api_engrad
+!> a collection of engrad calls for different APIs
+!> this builds the communication between CRESTs
+!> "calculation_settings" and the respective API setups
 
 module api_engrad
 
@@ -37,11 +35,10 @@
   use gfnff_api
   use xhcff_api
 !=========================================================================================!
+  use xhcff_api
   implicit none
   !--- private module variables and parameters
   private
-  integer :: i,j,k,l,ich,och,io
-  logical :: ex
 
   public :: tblite_engrad
   public :: gfn0_engrad,gfn0occ_engrad
@@ -55,6 +52,9 @@
 !=========================================================================================!
 
   subroutine tblite_engrad(mol,calc,energy,grad,iostatus)
+!******************************************************
+!* Interface singlepoint call between CREST and tblite
+!******************************************************
     implicit none
     type(coord) :: mol
     type(calculation_settings) :: calc
@@ -65,46 +65,45 @@
 
     character(len=:),allocatable :: cpath
     logical :: loadnew,pr
+
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
     iostatus = 0
-    pr =.true. !> tblite always printes some data
+    pr = .false.
 
-    !>--- setup system call information
+!>--- setup system call information
     !$omp critical
     call tblite_init(calc,loadnew)
-    !> tblite printout handling
-    inquire (unit=calc%ctx%unit,opened=ex)
-    if ((calc%ctx%unit .ne. stdout).and.ex) then
-      close (calc%ctx%unit)
-    end if
-    if (allocated(calc%calcspace)) then
-      ex = directory_exist(calc%calcspace)
-      if (.not.ex) then
-        io = makedir(trim(calc%calcspace))
-      end if
-      cpath = calc%calcspace//sep//'tblite.out'
+!>--- tblite printout handling
+    call api_handle_output(calc,'tblite.out',mol,pr)
+    if(pr)then
+       !> tblite uses its context (ctx)( type, rather than calc%prch
+       calc%tblite%ctx%unit = calc%prch
+       calc%tblite%ctx%verbosity = 1
     else
-      cpath = 'tblite.out'
-    end if
-    open (newunit=calc%ctx%unit,file=cpath,status='replace')
-    deallocate (cpath)
-    call api_print_input_structure(pr, calc%ctx%unit, mol)
-    !> populate parameters and wavefunction
+       calc%tblite%ctx%verbosity = 0
+    endif
+
+!>-- populate parameters and wavefunction
     if (loadnew) then
       call tblite_setup(mol,calc%chrg,calc%uhf,calc%tblitelvl,calc%etemp, &
-      &    calc%ctx,calc%wfn,calc%tbcalc)
-      call tblite_addsettings(calc%tbcalc,calc%maxscc,calc%rdwbo,calc%saveint)
-      call tblite_add_solv(mol,calc%chrg,calc%uhf,calc%ctx,calc%wfn,calc%tbcalc, &
+      &    calc%tblite%ctx,calc%tblite%wfn,calc%tblite%calc)
+      call tblite_addsettings(calc%tblite%calc,calc%maxscc,calc%rdwbo,calc%saveint)
+      call tblite_add_solv(mol,calc%chrg,calc%uhf, &
+      &    calc%tblite%ctx,calc%tblite%wfn,calc%tblite%calc, &
       &    calc%solvmodel,calc%solvent)
     end if
     !$omp end critical
-    !>--- do the engrad call
+
+!>--- do the engrad call
     call initsignal()
     call tblite_singlepoint(mol,calc%chrg,calc%uhf,calc%accuracy, &
-    & calc%ctx,calc%wfn,calc%tbcalc,energy,grad,calc%tbres,iostatus)
+    & calc%tblite%ctx,calc%tblite%wfn,calc%tblite%calc, &
+    & energy,grad,calc%tblite%res,iostatus)
     if (iostatus /= 0) return
-    call api_print_e_grd(pr,calc%ctx%unit,mol,energy,grad)
+    call api_print_e_grd(pr,calc%tblite%ctx%unit,mol,energy,grad)
 
-    !>--- postprocessing, getting other data
+!>--- postprocessing, getting other data
     !$omp critical
     call tblite_wbos(calc,mol,iostatus)
     !$omp end critical
@@ -115,7 +114,10 @@
 !========================================================================================!
 
   subroutine gfn0_engrad(mol,calc,g0calc,energy,grad,iostatus)
-!> This is the GFN0 engrad call that uses the standard implementation
+!************************************************
+!* Interface singlepoint call between CREST and
+!* the GFN0 engrad standard implementation
+!************************************************
     implicit none
     !> INPUT
     type(coord) :: mol
@@ -130,39 +132,24 @@
     character(len=:),allocatable :: cpath
     logical :: loadnew
     logical :: pr
+
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
     iostatus = 0
     pr = .false.
 !>--- setup system call information
     !$omp critical
     call gfn0_init(calc,g0calc,loadnew)
 !>--- printout handling
-    inquire (unit=calc%prch,opened=ex)
-    if ((calc%prch .ne. stdout).and.ex) then
-      close (calc%prch)
-    end if
-    if (allocated(calc%calcspace)) then
-      ex = directory_exist(calc%calcspace)
-      if (.not.ex) then
-        io = makedir(trim(calc%calcspace))
-      end if
-      cpath = calc%calcspace//sep//'gfn0.out'
-    else
-      cpath = 'gfn0.out'
-    end if
-    if ((calc%prch .ne. stdout)) then
-      open (newunit=calc%prch,file=cpath)
-      pr = .true.
-    end if
-    deallocate (cpath)
-    call api_print_input_structure(pr, calc%prch, mol)
-
-    !> populate parameters and wavefunction
+    call api_handle_output(calc,'gfn0.out',mol,pr)
+!>-- populate parameters and wavefunction
     if (loadnew) then
       call gfn0_setup(mol,calc%chrg,calc%uhf,g0calc)
       call gfn0_init2(mol,calc,g0calc)
     end if
     call gfn0_init3(mol,calc,g0calc)
     !$omp end critical
+
 !>--- do the engrad call
     call initsignal()
     call gfn0_sp(mol,calc%chrg,calc%uhf,g0calc,energy,grad,iostatus,res)
@@ -183,7 +170,10 @@
 !========================================================================================!
 
   subroutine gfn0occ_engrad(mol,calc,g0calc,energy,grad,iostatus)
-!> This is the GFN0 engrad call in which a config can be specified
+!************************************************
+!* Interface singlepoint call between CREST and
+!* the GFN0 multi-occupation implementation
+!************************************************
     implicit none
     !> INPUT
     type(coord) :: mol
@@ -197,40 +187,24 @@
     type(gfn0_results) :: res
     character(len=:),allocatable :: cpath
     logical :: loadnew,pr
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
     iostatus = 0
     pr = .false.
-    !>--- setup system call information
+!>--- setup system call information
     !$omp critical
     call gfn0occ_init(calc,g0calc,loadnew)
-    !> printout handling
-    inquire (unit=calc%prch,opened=ex)
-    if ((calc%prch .ne. stdout).and.ex) then
-      close (calc%prch)
-    end if
-    if (allocated(calc%calcspace)) then
-      ex = directory_exist(calc%calcspace)
-      if (.not.ex) then
-        io = makedir(trim(calc%calcspace))
-      end if
-      cpath = calc%calcspace//sep//'gfn0.out'
-    else
-      cpath = 'gfn0.out'
-    end if
-    if (calc%prch .ne. stdout) then
-      open (newunit=calc%prch,file=cpath)
-      pr = .true.
-    end if
-    deallocate (cpath)
-    call api_print_input_structure(pr, calc%prch, mol)
-
-    !> populate parameters and wavefunction
+!>--- printout handling
+    call api_handle_output(calc,'gfn0.out',mol,pr)
+!>--- populate parameters and wavefunction
     if (loadnew) then
       call gfn0_setup(mol,calc%chrg,calc%uhf,g0calc)
       call gfn0occ_init2(mol,calc,g0calc)
     end if
     call gfn0occ_init3(mol,calc,g0calc)
     !$omp end critical
-    !>--- do the engrad call
+
+!>--- do the engrad call
     call initsignal()
     call gfn0_sp_occ(mol,calc%chrg,calc%uhf,calc%occ,g0calc, &
     &    energy,grad,iostatus,res)
@@ -240,7 +214,7 @@
       call api_print_e_grd(pr,calc%prch,mol,energy,grad)
     end if
 
-    !>--- postprocessing, getting other data
+!>--- postprocessing, getting other data
     !$omp critical
     call gfn0_wbos(calc,g0calc,mol,iostatus)
     !$omp end critical
@@ -249,7 +223,11 @@
   end subroutine gfn0occ_engrad
 
 !========================================================================================!
+
   subroutine gfnff_engrad(mol,calc,energy,grad,iostatus)
+!******************************************************************
+!* Interface singlepoint call between CREST and GFN-FF force field
+!******************************************************************
     implicit none
     type(coord) :: mol
     type(calculation_settings) :: calc
@@ -260,31 +238,15 @@
 
     character(len=:),allocatable :: cpath
     logical :: loadnew,pr
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
     iostatus = 0
     pr = .false.
 !>--- setup system call information
     !$omp critical
     call gfnff_init(calc,loadnew)
 !>--- printout handling
-    inquire (unit=calc%prch,opened=ex)
-    if ((calc%prch .ne. stdout).and.ex) then
-      close (calc%prch)
-    end if
-    if (allocated(calc%calcspace)) then
-      ex = directory_exist(calc%calcspace)
-      if (.not.ex) then
-        io = makedir(trim(calc%calcspace))
-      end if
-      cpath = calc%calcspace//sep//'gfnff.out'
-    else
-      cpath = 'gfnff.out'
-    end if
-    if ((calc%prch .ne. stdout)) then
-      open (newunit=calc%prch,file=cpath)
-      pr = .true.
-    end if
-    deallocate (cpath)
-    call api_print_input_structure(pr, calc%prch, mol)
+    call api_handle_output(calc,'gfnff.out',mol,pr)
 
 !>--- populate parameters and neighbourlists
     if (loadnew) then
@@ -309,12 +271,15 @@
     call gfnff_wbos(calc,mol,iostatus)
     !$omp end critical
 
-
     return
   end subroutine gfnff_engrad
 
 !========================================================================================!
+
   subroutine xhcff_engrad(mol,calc,energy,grad,iostatus)
+!***************************************************************
+!* Interface singlepoint call between CREST and XHC force field
+!***************************************************************
     implicit none
     type(coord) :: mol
     type(calculation_settings) :: calc
@@ -325,36 +290,20 @@
 
     character(len=:),allocatable :: cpath
     logical :: loadnew,pr
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
     iostatus = 0
     pr = .false.
 !>--- setup system call information
     !$omp critical
     call xhcff_initcheck(calc,loadnew)
 !>--- printout handling
-    inquire (unit=calc%prch,opened=ex)
-    if ((calc%prch .ne. stdout).and.ex) then
-      close (calc%prch)
-    end if
-    if (allocated(calc%calcspace)) then
-      ex = directory_exist(calc%calcspace)
-      if (.not.ex) then
-        io = makedir(trim(calc%calcspace))
-      end if
-      cpath = calc%calcspace//sep//'xhcff.out'
-    else
-      cpath = 'xhcff.out'
-    end if
-    if ((calc%prch .ne. stdout)) then
-      open (newunit=calc%prch,file=cpath)
-      pr = .true.
-    end if
-    deallocate (cpath)
-    call api_print_input_structure(pr, calc%prch, mol)
-
+    call api_handle_output(calc,'xhcff.out',mol,pr)
 !>--- populate parameters
     if (loadnew) then
       !> call xhcff with verbosity turned off
-      call xhcff_setup(mol,calc%xhcff, calc%extpressure, calc%ngrid, calc%proberad, calc%vdwset, iostatus)
+      call xhcff_setup(mol,calc%xhcff,calc%extpressure,calc%ngrid,calc%proberad, &
+      &                calc%vdwset,pr,calc%prch,iostatus)
     end if
     !$omp end critical
     if (iostatus /= 0) return
@@ -366,7 +315,7 @@
 
 !>--- printout
     if (pr) then
-      call xhcff_print(calc%prch,calc%xhcff)
+      !> the xhcff_sp call includes the printout within xhcff-lib
       call api_print_e_grd(pr,calc%prch,mol,energy,grad)
     end if
 
@@ -375,5 +324,6 @@
     return
   end subroutine xhcff_engrad
 
+!========================================================================================!
 !========================================================================================!
 end module api_engrad
Index: src/calculator/lj.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!====================================================!\n! a small module containing Lennard-Jones potentials\n! (mainly for testing other implementations)\n!====================================================!\n\nmodule lj\n\n  use iso_fortran_env,only:wp => real64\n\n  implicit none\n\n  !=========================================================================================!\n  !--- private module variables and parameters\n  private\n  integer :: i,j,k,l,ich,och,io\n  logical :: ex\n\n  !--- some constants and name mappings\n  real(wp),parameter :: bohr = 0.52917726_wp\n  real(wp),parameter :: autokcal = 627.509541_wp\n\n  public :: lj_engrad\n\ncontains\n\n  subroutine lj_engrad(n,xyz,epsi,sigma,energy,grad)\n    implicit none\n    integer,intent(in) :: n\n    real(wp),intent(in) :: xyz(3,n)\n    real(wp),intent(in) :: sigma\n    real(wp),intent(in) :: epsi\n\n    real(wp),intent(inout) :: energy\n    real(wp),intent(inout) :: grad(3,n)\n\n    real(wp) :: rij\n    real(wp) :: U,dU,dx,dy,dz\n\n    energy = 0.0_wp\n    grad = 0.0_wp\n\n    do i = 1,n\n      do j = 1,i - 1\n        rij = (xyz(1,i) - xyz(1,j))**2   &\n        &   + (xyz(2,i) - xyz(2,j))**2   &\n        &   + (xyz(3,i) - xyz(3,j))**2\n        rij = sqrt(rij)\n        !--- energy\n        U = 4.0_wp * epsi * ((sigma / rij)**12 - (sigma / rij)**6)\n        energy = energy + U\n        !--- Cartesian derivative\n        dU = 4.0_wp * epsi * (6.0_wp * (sigma**6) * &\n        & (rij**-7) - 12.0_wp * (sigma**12) * (rij**(-13)))\n        dU = dU / rij\n        dx = dU * (xyz(1,i) - xyz(1,j))\n        dy = dU * (xyz(2,i) - xyz(2,j))\n        dz = dU * (xyz(3,i) - xyz(3,j))\n        grad(1,i) = grad(1,i) + dx\n        grad(1,j) = grad(1,j) - dx\n        grad(2,i) = grad(2,i) + dy\n        grad(2,j) = grad(2,j) - dy\n        grad(3,i) = grad(3,i) + dz\n        grad(3,j) = grad(3,j) - dz\n      end do\n    end do\n\n    return\n  end subroutine lj_engrad\n\nend module lj\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/lj.f90 b/src/calculator/lj.f90
--- a/src/calculator/lj.f90	
+++ b/src/calculator/lj.f90	
@@ -17,30 +17,23 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-!====================================================!
-! a small module containing Lennard-Jones potentials
-! (mainly for testing other implementations)
-!====================================================!
+!> a small module containing the Lennard-Jones potential
+!> (mainly for testing other implementations)
 
 module lj
 
   use iso_fortran_env,only:wp => real64
 
   implicit none
-
-  !=========================================================================================!
-  !--- private module variables and parameters
   private
-  integer :: i,j,k,l,ich,och,io
-  logical :: ex
-
-  !--- some constants and name mappings
-  real(wp),parameter :: bohr = 0.52917726_wp
-  real(wp),parameter :: autokcal = 627.509541_wp
 
   public :: lj_engrad
 
-contains
+!========================================================================================!
+!========================================================================================!
+contains  !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
 
   subroutine lj_engrad(n,xyz,epsi,sigma,energy,grad)
     implicit none
@@ -52,6 +45,9 @@
     real(wp),intent(inout) :: energy
     real(wp),intent(inout) :: grad(3,n)
 
+    integer :: i,j,k,l,ich,och,io
+    logical :: ex
+
     real(wp) :: rij
     real(wp) :: U,dU,dx,dy,dz
 
@@ -59,31 +55,33 @@
     grad = 0.0_wp
 
     do i = 1,n
-      do j = 1,i - 1
-        rij = (xyz(1,i) - xyz(1,j))**2   &
-        &   + (xyz(2,i) - xyz(2,j))**2   &
-        &   + (xyz(3,i) - xyz(3,j))**2
+      do j = 1,i-1
+        rij = (xyz(1,i)-xyz(1,j))**2   &
+        &   +(xyz(2,i)-xyz(2,j))**2   &
+        &   +(xyz(3,i)-xyz(3,j))**2
         rij = sqrt(rij)
-        !--- energy
-        U = 4.0_wp * epsi * ((sigma / rij)**12 - (sigma / rij)**6)
-        energy = energy + U
-        !--- Cartesian derivative
-        dU = 4.0_wp * epsi * (6.0_wp * (sigma**6) * &
-        & (rij**-7) - 12.0_wp * (sigma**12) * (rij**(-13)))
-        dU = dU / rij
-        dx = dU * (xyz(1,i) - xyz(1,j))
-        dy = dU * (xyz(2,i) - xyz(2,j))
-        dz = dU * (xyz(3,i) - xyz(3,j))
-        grad(1,i) = grad(1,i) + dx
-        grad(1,j) = grad(1,j) - dx
-        grad(2,i) = grad(2,i) + dy
-        grad(2,j) = grad(2,j) - dy
-        grad(3,i) = grad(3,i) + dz
-        grad(3,j) = grad(3,j) - dz
+        !>--- energy
+        U = 4.0_wp*epsi*((sigma/rij)**12-(sigma/rij)**6)
+        energy = energy+U
+        !>--- Cartesian derivative
+        dU = 4.0_wp*epsi*(6.0_wp*(sigma**6)* &
+        & (rij**-7)-12.0_wp*(sigma**12)*(rij**(-13)))
+        dU = dU/rij
+        dx = dU*(xyz(1,i)-xyz(1,j))
+        dy = dU*(xyz(2,i)-xyz(2,j))
+        dz = dU*(xyz(3,i)-xyz(3,j))
+        grad(1,i) = grad(1,i)+dx
+        grad(1,j) = grad(1,j)-dx
+        grad(2,i) = grad(2,i)+dy
+        grad(2,j) = grad(2,j)-dy
+        grad(3,i) = grad(3,i)+dz
+        grad(3,j) = grad(3,j)-dz
       end do
     end do
 
     return
   end subroutine lj_engrad
 
+!========================================================================================!
+!========================================================================================!
 end module lj
Index: src/msreact.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2020 Stefan Grimme, Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!==============================================================!\n! the handler function is the sub-program that is called\n! by crest, i.e., within this routine the seperate input file is\n! read and the calculation is started.\n!==============================================================!\nsubroutine msreact_handler(env,tim)\n    use crest_parameters\n    use crest_data\n    use msmod\n    use strucrd\n    implicit none\n\n    type(systemdata) :: env\n    type(timer) :: tim\n\n    type(msobj) :: mso  !a new msreact object\n    type(coord) :: struc\n\n    interface\n        subroutine msreact_topowrap(mol,pair,paths,wboname)\n            import :: msmol\n            implicit none\n            type(msmol) :: mol\n            integer :: pair(mol%nat*(mol%nat+1)/2)\n            integer :: paths(mol%nat*(mol%nat+1)/2,mol%nat)\n            character(len=*),optional :: wboname\n        end subroutine msreact_topowrap\n    end interface\n    integer :: nat\n    integer,allocatable :: pair(:)\n    integer,allocatable :: paths(:,:)\n    integer :: k\n\n    call tim%start(1,'MSREACT')\n\n    !-- read the input coord and put it into the\n    !   iso-list as Gen 0 structure\n    call struc%open('coord')\n    struc%xyz=struc%xyz*bohr !to Angström, from this point on by convention!\n    call mso%il%append(struc%nat,struc%at,struc%xyz,0.0_wp,env%chrg,0)\n    call struc%deallocate()\n\n    !-- additional input file could be read here\n    !call msinputreader(mso)\n\n\n    nat = mso%il%mol(1)%nat\n    k=nat*(nat+1)/2\n    allocate(pair(k),paths(k,nat))\n    call msreact_topowrap(mso%il%mol(1),pair,paths,'wbo')\n\n    !-- setting the threads for correct parallelization\n    if(env%autothreads)then\n        call ompautoset(env%threads,6,env%omp,env%MAXRUN,0) !set global OMP/MKL variable for xtb jobs\n    endif\n\n    !-- do the directory setup and optimizations\n    call msreact(mso,mso%il%mol(1),nat,pair,3)\n\n\n    deallocate(paths,pair)\n\n    call tim%stop(1)\n    return\nend subroutine msreact_handler\n\n!==============================================================!\n! the main implementation of the msreact algo should go here\n!==============================================================!\nsubroutine msreact(mso,mol,nat,pair,nbonds)\n      use crest_parameters\n      use msmod\n      use iomod\n      implicit none\n\n      type(msobj) :: mso    !main storage object\n      type(msmol) :: mol    ! xyz etc\n\n      integer :: nat\n      integer :: pair(nat*(nat+1)/2)\n      !integer :: paths(nat*(nat+1)/2,nat)\n      integer :: nbonds\n      integer :: lin !this is a function\n      integer :: i,j,k\n      integer :: p\n      integer :: np\n      integer :: io\n\n      character(len=:),allocatable :: subdir\n      character(len=40) :: pdir\n      character(len=512) :: thisdir\n      real(wp)             :: constr_dist\n      real(wp),allocatable :: rcov(:)\n\n      allocate(rcov(94))\n      call setrcov(rcov)\n\n      !-- main subdirectory handling\n      call getcwd(thisdir)\n      subdir='MSDIR'\n      io = makedir(subdir)\n      call chdir(subdir)\n\n\n      !-- get specific pairs\n      np=0\n      do p=1,nbonds    ! bonds in between\n!        write(*,'(1x,a,i0,a)') '1,',p+1,' pairs'\n         do i=1,nat\n           do j=i,nat\n              k=lin(i,j)\n              if(p.eq.1.and.pair(k).eq.1.and.(mol%at(i).eq.1.or.mol%at(j).eq.1)) cycle\n              if(pair(k)==p)then\n                 np = np+1 \n                 write(pdir,'(a,i0)')'Pair_',np\n                 constr_dist = mso%cdist*(rcov(mol%at(i))+rcov(mol%at(j)))*bohr + float(p)\n!                write(*,*) mol%at(i),mol%at(j),constr_dist\n                 call isodir(mso,trim(pdir),mol,i,j,constr_dist)\n              endif    \n           enddo\n         enddo\n      enddo\n             \n      write(*,*) '# of distortions',np\n      call msreact_jobber(np,'Pair_',.false.)\n\n      call msreact_collect(mol%nat,np,'products.xyz')\n      call rename(subdir//'/'//'products.xyz','products.xyz')\n      call chdir(thisdir)\n      return\nend subroutine msreact\n\n\n!============================================================!\n! make a dir for a structure without fragments,\n! a controlfile with constraints on atoms A and B (at dist D)\n! will be written into the directory\n!============================================================!\nsubroutine isodir(mso,dirname,mol,A,B,D)\n    use crest_parameters\n    use msmod\n    use iomod\n    use strucrd, only : wrxyz\n    implicit none\n    type(msobj) :: mso\n    character(len=*) :: dirname\n    type(msmol) :: mol\n    integer :: A,B\n    real(wp) :: D\n\n    character(len=:),allocatable :: fname\n    character(len=20) :: dumm\n    integer :: io,ich\n\n    io = makedir(dirname) !create the directory\n    \n    fname = trim(dirname)//'/'//'struc.xyz'\n    open(newunit=ich,file=fname)\n    call wrxyz(ich,mol%nat,mol%at,mol%xyz)\n    close(ich)\n\n    fname = trim(dirname)//'/'//'.CHRG'\n    open(newunit=ich,file=fname)\n    write(ich,'(i0)') mol%chrg + 1   ! EI +1, DEA -1, CID 0\n    close(ich)\n\n    fname = trim(dirname)//'/'//'.xc1'\n    open(newunit=ich, file=fname)\n    write(ich,'(a)') '$scc'\n    write(dumm,'(f16.2)') mso%T\n    write(ich,'(1x,a,a)')'temp=',adjustl(trim(dumm))\n    write(ich,'(a)')'$constrain'\n    write(dumm,'(f16.4)') mso%fc\n    write(ich,'(3x,a,a)')'force constant=',adjustl(trim(dumm))\n    write(ich,'(3x,a,1x,i0,a,1x,i0,a,1x,f8.5)') 'distance:',A,',',B,',',D\n    close(ich)\n\n    fname = trim(dirname)//'/'//'.xc2'\n    open(newunit=ich, file=fname)\n    write(ich,'(a)') '$scc'\n    write(dumm,'(f16.2)') mso%T\n    write(ich,'(1x,a,a)')'temp=',adjustl(trim(dumm))\n    write(ich,'(a)') '$opt'\n    write(ich,'(1x,a)') 'maxcycle=5'\n    write(ich,'(a)') '$write'\n    write(ich,'(1x,a)') 'wiberg=true'\n    close(ich)\n\n    return\nend subroutine isodir\n\n!=====================================================================!\n! The job construction routine for MSREACT\n! (will have to be modified later, for now it is for testing)\n!=====================================================================!\nsubroutine msreact_jobber(ndirs,base,niceprint)\n    use crest_parameters\n    use msmod\n    use iomod\n    implicit none\n    integer :: ndirs\n    character(len=*) :: base\n    logical :: niceprint\n\n    character(len=1024) :: jobcall\n    character(len=1024) :: jobcall2\n\n    jobcall = ''\n    jobcall2 = ''\n\n    write(jobcall,'(a)')  'xtb struc.xyz  --opt loose --input .xc1 > split.out 2>/dev/null'\n    write(jobcall2,'(a)') 'xtb xtbopt.xyz --opt crude --input .xc2 > xtb.out 2>/dev/null'\n    jobcall = trim(jobcall)//' ; '//trim(jobcall2)\n\n    !-- directories must be numbered consecutively\n    call opt_OMP_loop(ndirs,base,jobcall,niceprint)\n    write(*,*)\n    write(*,*) 'done.'\n    return\nend subroutine msreact_jobber\n\n\n\n!=====================================================================!\n! A wrapper to generate the topology for a molecule within the\n! MSREACT subprogram\n!=====================================================================!\nsubroutine msreact_topowrap(mol,pair,paths,wboname)\n    use crest_parameters\n    use msmod\n    use zdata\n    use adjacency\n    implicit none\n    type(msmol) :: mol\n    integer :: pair(mol%nat*(mol%nat+1)/2)\n    !integer :: pair(mol%nat,mol%nat)\n    integer :: paths(mol%nat*(mol%nat+1)/2,mol%nat)\n    character(len=*),optional :: wboname\n    type(zmolecule) :: zmol\n\n    integer,allocatable :: A(:,:)\n    integer,allocatable :: prev(:,:)\n    real(wp),allocatable :: E(:,:)\n    real(wp),allocatable :: dist(:,:)\n\n    integer :: lpath,i,j,k\n    integer :: lin !this is a function\n    integer,allocatable :: path(:)\n    logical :: ex\n\n\n    ex=.false.\n    if(present(wboname))then\n      inquire(file=wboname,exist=ex)\n    endif  \n    if(ex)then\n      call simpletopo(mol%nat,mol%at,mol%xyz,zmol,.false.,.false.,wboname)\n    else   \n       mol%xyz = mol%xyz / bohr !CN based topo requires Bohrs \n       call simpletopo(mol%nat,mol%at,mol%xyz,zmol,.false.,.false.,'')\n       mol%xyz = mol%xyz * bohr\n    endif \n\n    allocate(A(mol%nat,mol%nat),E(mol%nat,mol%nat))\n    call zmol%adjacency(A,E)\n\n    allocate(prev(mol%nat,mol%nat),dist(mol%nat,mol%nat))\n\n    call FloydWarshall(mol%nat,A,E,dist,prev)\n    allocate(path(mol%nat), source = 0)\n    do i=1,mol%nat\n      do j=i,mol%nat\n       path = 0\n       call getPathFW(mol%nat,prev,i,j,path,lpath)\n       !write(*,*) path(1:lpath)\n       k=lin(i,j)\n       pair(k) = lpath - 1 ! number of bonds\n       paths(k,:) = path(:)\n      enddo\n     enddo\n\n    deallocate(dist,prev)\n    deallocate(E,A)\n\n    call zmol%deallocate() !clear the zmol memory\n    return\nend subroutine msreact_topowrap    \n\n!========================================================================!\n! collect structures of optimized molecules\n! xyz files should still have the same number and order of atoms\n!========================================================================!\nsubroutine msreact_collect(nat,np,outfile)\n    use crest_parameters\n    use strucrd\n    implicit none\n    integer :: nat\n    integer :: np\n    character(len=*) :: outfile\n    integer :: ich\n    character(len=40) :: pdir\n    character(len=:),allocatable :: optfile\n    character(len=128) :: newcomment\n    integer :: p,p2\n    logical :: ex\n    integer,allocatable :: at(:)\n    real(wp),allocatable :: xyz(:,:)\n    real(wp) :: etot\n\n\n    allocate(at(nat),xyz(3,nat))\n    open(newunit=ich,file=outfile)\n    p=0\n    do p2=1,np\n       write(pdir,'(i0,i0,a,i0)')1,p+1,'Pair_',p2\n       write(pdir,'(a,i0)')'Pair_',p2\n       optfile=trim(pdir)//'/'//'xtbopt.xyz'\n       inquire(file=optfile,exist=ex)\n       if(ex)then\n          call rdcoord(optfile,nat,at,xyz,etot)\n          xyz = xyz*bohr\n          write(newcomment,'(1x,f18.8,5x,a)')etot,trim(pdir)\n          call wrxyz(ich,nat,at,xyz,newcomment)       \n       endif    \n    enddo\n    close(ich)\n\n    deallocate(xyz,at)\n    return\nend subroutine msreact_collect\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/msreact.f90 b/src/msreact.f90
--- a/src/msreact.f90	
+++ b/src/msreact.f90	
@@ -90,6 +90,8 @@
       use crest_parameters
       use msmod
       use iomod
+      use miscdata, only: rcov
+      use utilities, only: lin
       implicit none
 
       type(msobj) :: mso    !main storage object
@@ -99,7 +101,6 @@
       integer :: pair(nat*(nat+1)/2)
       !integer :: paths(nat*(nat+1)/2,nat)
       integer :: nbonds
-      integer :: lin !this is a function
       integer :: i,j,k
       integer :: p
       integer :: np
@@ -109,10 +110,6 @@
       character(len=40) :: pdir
       character(len=512) :: thisdir
       real(wp)             :: constr_dist
-      real(wp),allocatable :: rcov(:)
-
-      allocate(rcov(94))
-      call setrcov(rcov)
 
       !-- main subdirectory handling
       call getcwd(thisdir)
@@ -249,6 +246,7 @@
     use msmod
     use zdata
     use adjacency
+    use utilities, only: lin
     implicit none
     type(msmol) :: mol
     integer :: pair(mol%nat*(mol%nat+1)/2)
@@ -263,7 +261,6 @@
     real(wp),allocatable :: dist(:,:)
 
     integer :: lpath,i,j,k
-    integer :: lin !this is a function
     integer,allocatable :: path(:)
     logical :: ex
 
Index: src/calculator/constraints.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!====================================================!\n! a small module for constraining potentials\n!====================================================!\n\nmodule constraints\n\n  use iso_fortran_env,only:wp => real64\n  implicit none\n\n  !=========================================================================================!\n  !--- private module variables and parameters\n  private\n  integer :: i,j,k,l,ich,och,io\n  logical :: ex\n\n  !--- some constants and name mappings\n  real(wp),parameter :: bohr = 0.52917726_wp\n  real(wp),parameter :: autokcal = 627.509541_wp\n  real(wp),parameter :: kB = 3.166808578545117e-06_wp !in Eh/K\n  real(wp),parameter :: pi = 3.14159265359_wp\n  real(wp),parameter :: deg = 180.0_wp / pi ! 1 rad in degrees\n  real(wp),parameter :: fcdefault = 0.01_wp\n  real(wp),parameter :: Tdefault = 298.15_wp\n\n  !>--- constrain types\n  integer,parameter :: bond = 1\n  integer,parameter :: allbonds = 11\n  integer,parameter :: angle = 2\n  integer,parameter :: dihedral = 3\n  integer,parameter :: wall = 4\n  integer,parameter :: wall_fermi = 5\n  integer,parameter :: box = 6\n  integer,parameter :: box_fermi = 7\n\n  integer,public,parameter :: na_gapdiff = -1\n  integer,public,parameter :: na_gapdiff2 = -2\n\n  integer,parameter :: pharmonic = 1\n  integer,parameter :: plogfermi = 2\n\n  public :: constraint\n  !=====================================================!\n  type :: constraint\n\n    integer :: type = 0\n    integer :: subtype = pharmonic\n    integer :: n = 0\n    integer,allocatable :: atms(:)\n    real(wp),allocatable :: ref(:)\n    real(wp),allocatable :: fc(:)\n\n  contains\n    procedure :: print => print_constraint\n    procedure :: deallocate => constraint_deallocate\n    procedure :: bondconstraint => create_bond_constraint\n    generic,public :: sphereconstraint => create_sphere_constraint,create_sphere_constraint_all\n    procedure,private :: create_sphere_constraint,create_sphere_constraint_all\n    procedure :: sphereupdate => sphere_update_nat\n    procedure :: angleconstraint => create_angle_constraint\n    procedure :: dihedralconstraint => create_dihedral_constraint\n    procedure :: gapdiffconstraint => create_gapdiff_constraint\n    procedure :: gapdiffconstraint2 => create_gapdiff_constraint2\n    procedure :: dummyconstraint => create_dummy_constraint\n    procedure :: analyzedummy => analyze_dummy_bond_constraint\n    procedure :: rdbondconstraint => analyze_dummy_bond_constraint2\n  end type constraint\n  !=====================================================!\n\n\n  public :: scantype\n  !=====================================================!\n  type :: scantype\n\n    integer :: type = 0  !> 0=nothing, 1=distance, 3=dihedral\n    integer :: n = 0\n    integer :: steps = 5 !> number of sampling steps for the scan\n    real(wp) :: minval = 0.0_wp\n    real(wp) :: maxval = 0.0_wp\n    integer,allocatable :: atms(:)\n    real(wp),allocatable :: points(:)\n    integer :: constrnmbr = 0\n    integer :: restore = 1\n    integer :: currentstep = 0\n  contains\n    procedure :: deallocate => scantype_deallocate\n  end type scantype\n  !=====================================================!\n\n\n\n  public :: calc_constraint\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n  subroutine calc_constraint(n,xyz,constr,energy,grd)\n    implicit none\n    integer,intent(in) :: n\n    real(wp),intent(in) :: xyz(3,n)\n    type(constraint) :: constr\n\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: grd(3,n)\n\n    energy = 0.0_wp\n    grd = 0.0_wp\n\n    select case (constr%type)\n    case (bond)\n      call bond_constraint(n,xyz,constr,energy,grd)\n    case (angle)\n      call angle_constraint(n,xyz,constr,energy,grd)\n    case (dihedral)\n      call dihedral_constraint(n,xyz,constr,energy,grd)\n    case (wall,wall_fermi)\n      call wall_constraint(n,xyz,constr,energy,grd,constr%type)\n    case (box)\n\n    case (box_fermi)\n\n    case default\n      return\n    end select\n\n    return\n  end subroutine calc_constraint\n\n  subroutine print_constraint(self,chnl)\n    implicit none\n    class(constraint) :: self\n    character(len=64) :: art\n    character(len=64) :: atoms\n    character(len=258) :: values\n    character(len=10) :: atm\n    integer :: chnl\n    logical :: pr\n\n    if (self%type == 0) return\n    pr = .true.\n    select case (self%type)\n    case (bond)\n      art = 'distance'\n      write (atoms,'(1x,\"atoms:\",1x,i0,\",\",i0)') self%atms(1:2)\n      write (values,'(\" d=\",f8.2,1x,\"k=\",f8.5)') self%ref(1),self%fc(1)\n    case (angle)\n      art = 'angle'\n      write (atoms,'(1x,\"atoms:\",1x,i0,\",\",i0,\",\",i0)') self%atms(1:3)\n      write (values,'(\" deg=\",f6.2,1x,\"k=\",f8.5)') self%ref(1) * deg,self%fc(1)\n    case (dihedral)\n      art = 'dihedral'\n      write (atoms,'(1x,\"atoms:\",1x,i0,\",\",i0,\",\",i0,\",\",i0)') self%atms(1:4)\n      write (values,'(\" deg=\",f6.2,1x,\"k=\",f8.5)') self%ref(1) * deg,self%fc(1)\n    case (wall)\n      art = 'wall'\n      write (atoms,'(1x,\"atoms:\",1x,i0,a)') self%n,'/all'\n      write (values,'(\" radii=\",3f12.5,\" k=\",f8.5,1x,\"exp=\",f5.2)') self%ref(1:3),self%fc(1:2)\n    case (wall_fermi)\n      art = 'wall_fermi'\n      write (atoms,'(1x,\"atoms:\",1x,i0,a)') self%n,'/all'\n      write (values,'(\" radii=\",3f12.5,\" k=\",f8.5,1x,\"exp=\",f5.2)') self%ref(1:3),self%fc(1:2)\n    case (na_gapdiff)\n      art = 'nonadiabatic gap'\n      write (atoms,'(1x,\"[\",a,\"]\")') 'σ*ΔE²/(ΔE+α)'\n      write (values,'(\" σ=\",f8.5,\" α=\",f8.5)') self%fc(1:2)\n    case (na_gapdiff2)\n      art = 'nonadiabatic gap'\n      write (atoms,'(1x,\"[\",a,\"]\")') 'σ*(exp(-β|ΔE|)+C) * ΔE²/(|ΔE|+α)'\n      write (values,'(\" σ=\",f8.5,\" α=\",f8.5,\" C=\",f8.5,\" β=\",f8.5)') self%fc(1:3),27.2114_wp\n    case default\n      art = 'none'\n      atoms = 'none'\n      values = ' '\n      pr=.false.\n    end select\n    if(pr) &\n    & write (chnl,'(a,a,\",\",a,\",\",a,1x,a)') ' constraint: ',trim(art),trim(atoms),trim(values)\n\n    return\n  end subroutine print_constraint\n\n!========================================================================================!\n!> subroutine analyze_dummy_bond_constraint\n  subroutine analyze_dummy_bond_constraint(self,t,i,rawa)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: i,t\n    character(len=*) :: rawa(i)\n    real(wp) :: k,dist\n    integer :: a1,a2\n\n    call self%deallocate()\n    \n    select case( i )\n    case ( 1 )\n      if( any(rawa(1) == (/character(7)::'all','allauto' /)))then\n      call self%dummyconstraint(t)\n      endif\n    case (2) \n      if( any(rawa(1) == (/character(9)::'all','allauto' /)))then\n      read(rawa(2),*) k\n      call self%dummyconstraint(t,k)\n      endif\n    case (3)\n      read(rawa(1),*) a1\n      read(rawa(2),*) a2\n      read(rawa(3),*) dist\n      dist = abs(dist)\n      call self%bondconstraint(a1,a2,dist)\n    case (4)   \n      read(rawa(1),*) a1\n      read(rawa(2),*) a2\n      read(rawa(3),*) dist\n      read(rawa(4),*) k\n      dist = abs(dist)\n      call self%bondconstraint(a1,a2,dist,k)\n    end select\n\n    return\n  end subroutine analyze_dummy_bond_constraint\n\n  subroutine analyze_dummy_bond_constraint2(self,i,fa)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: i\n    real(wp),intent(in) :: fa(i)\n    real(wp) :: k,dist\n    integer :: a1,a2\n\n    call self%deallocate()\n\n    select case( i )\n    case (3)\n      a1 = nint(fa(1))\n      a2 = nint(fa(2))\n      dist = abs(fa(3))\n      call self%bondconstraint(a1,a2,dist)\n    case (4)\n      a1 = nint(fa(1))\n      a2 = nint(fa(2))\n      dist = abs(fa(3))\n      k = abs(fa(4))\n      call self%bondconstraint(a1,a2,dist,k)\n    end select\n\n    return\n  end subroutine analyze_dummy_bond_constraint2\n\n\n\n!========================================================================================!\n!> subroutine constraint_deallocate\n!> reset and deallocate all data of a given constraint object\n  subroutine constraint_deallocate(self)\n    implicit none\n    class(constraint) :: self\n    if (allocated(self%atms)) deallocate (self%atms)\n    if (allocated(self%fc)) deallocate (self%fc)\n    if (allocated(self%ref)) deallocate (self%ref)\n    self%type = 0\n    self%subtype = pharmonic\n    self%n = 0\n    return\n  end subroutine constraint_deallocate\n\n!========================================================================================!\n!> subroutine scantype_deallocate\n!> reset and deallocate all data of a given scantype object\n  subroutine scantype_deallocate(self)\n    implicit none\n    class(scantype) :: self\n    if (allocated(self%atms)) deallocate (self%atms)\n    self%type = 0\n    self%steps = 5\n    self%n = 0\n    self%minval = 0.0_wp\n    self%maxval = 0.0_wp\n    if (allocated(self%points)) deallocate (self%points)\n    self%restore = 1\n    return\n  end subroutine scantype_deallocate\n\n!========================================================================================!\n!> subroutien create_bond_constraint\n  subroutine create_dummy_constraint(self,t,k)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: t\n    real(wp),optional :: k\n\n    call self%deallocate()\n    self%type = t\n    self%n = 0\n    allocate (self%fc(1),source=fcdefault)\n    if (present(k)) then\n      self%fc(1) = k\n    end if\n    return\n  end subroutine create_dummy_constraint\n\n!========================================================================================!\n!> subroutien create_bond_constraint\n  subroutine create_bond_constraint(self,i,j,d,k)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: i,j\n    real(wp),intent(in) :: d\n    real(wp),optional :: k\n\n    call self%deallocate()\n    self%type = bond\n    self%n = 2\n    allocate (self%atms(2))\n    allocate (self%fc(1),source=fcdefault)\n    allocate (self%ref(1))\n    self%atms(1) = i\n    self%atms(2) = j\n    self%ref(1) = d\n    if (present(k)) then\n      self%fc(1) = k\n    end if\n    return\n  end subroutine create_bond_constraint\n\n!========================================================================================!\n!> constrain the distance between two atoms A...B\n!> by an harmonic potential V(r) = 1/2kr²\n  subroutine bond_constraint(n,xyz,constr,energy,grd)\n    implicit none\n    integer,intent(in) :: n\n    real(wp),intent(in) :: xyz(3,n)\n    type(constraint) :: constr\n\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: grd(3,n)\n    integer :: iat,jat\n    real(wp) :: a,b,c,x\n    real(wp) :: dist,ref,k,dum\n    real(wp) :: T,beta\n\n    energy = 0.0_wp\n    grd = 0.0_wp\n\n    if (constr%n /= 2) return\n    if (.not. allocated(constr%atms)) return\n    if (.not. allocated(constr%ref)) return\n    if (.not. allocated(constr%fc)) return\n\n    iat = constr%atms(1)\n    jat = constr%atms(2)\n    a = xyz(1,iat) - xyz(1,jat)\n    b = xyz(2,iat) - xyz(2,jat)\n    c = xyz(3,iat) - xyz(3,jat)\n    dist = sqrt(a**2 + b**2 + c**2)\n    ref = constr%ref(1)\n    k = constr%fc(1)\n\n    x = dist - ref\n    select case (constr%subtype)\n    case (pharmonic)\n      energy = 0.5_wp * k * (x)**2\n      dum = k * x\n    case (plogfermi)\n      energy = kb * T * log(1.0_wp + exp(beta * x))\n      dum = (kb * T * beta * exp(beta * x)) / (exp(beta * x) + 1.0_wp)\n    end select\n\n    grd(1,iat) = dum * (a / dist)\n    grd(2,iat) = dum * (b / dist)\n    grd(3,iat) = dum * (c / dist)\n    grd(1,jat) = -grd(1,iat)\n    grd(2,jat) = -grd(2,iat)\n    grd(3,jat) = -grd(3,iat)\n\n    return\n  end subroutine bond_constraint\n\n!========================================================================================!\n!> subroutien create_angle_constraint\n  subroutine create_angle_constraint(self,a,b,c,d,k)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: a,b,c\n    real(wp),intent(in) :: d ! constrain angle in degrees\n    real(wp),optional :: k\n    real(wp) :: dum,d2\n    call self%deallocate()\n    self%type = angle\n    self%n = 3\n    allocate (self%atms(3))\n    allocate (self%fc(1),source=fcdefault)\n    allocate (self%ref(1))\n    self%atms(1) = a\n    self%atms(2) = b\n    self%atms(3) = c\n    d2 = abs(d)\n    if (d2 > 360.0_wp) then\n      dum = d2\n      do\n        dum = dum - 360.0_wp\n        if (dum < 360.0_wp) then\n          d2 = dum\n          exit\n        end if\n      end do\n    end if\n    if (d2 > 180.0_wp) then\n      d2 = 360.0_wp - d2\n    end if\n    self%ref(1) = d2 / deg !reference in rad\n    if (present(k)) then\n      self%fc(1) = k\n    end if\n    return\n  end subroutine create_angle_constraint\n\n!========================================================================================!\n!> subroutine angle_constraint\n!> constrain angle between atoms A and C, connected via a central atom B:  A-B-C\n!> using a harmonic potential\n  subroutine angle_constraint(n,xyz,constr,energy,grd)\n    implicit none\n    integer,intent(in) :: n\n    real(wp),intent(in) :: xyz(3,n)\n    type(constraint) :: constr\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: grd(3,n)\n    integer :: i,iat,jat,kat\n    real(wp) :: A(3),B(3),C(3)\n    real(wp) :: r1(3),r2(3)\n    real(wp) :: angle,k,ref,p,d,l1,l2\n    real(wp) :: dinv,dum,x,T,beta\n    real(wp) :: dadA(3),dadB(3),dadC(3)\n\n    energy = 0.0_wp\n    grd = 0.0_wp\n\n    if (constr%n /= 3) return\n    if (.not. allocated(constr%atms)) return\n    if (.not. allocated(constr%ref)) return\n    if (.not. allocated(constr%fc)) return\n\n    ref = constr%ref(1)\n    k = constr%fc(1)\n    iat = constr%atms(1)\n    jat = constr%atms(2)\n    kat = constr%atms(3)\n    A = xyz(:,iat)\n    B = xyz(:,jat)\n    C = xyz(:,kat)\n    call angle_and_derivatives(A,B,C,angle,dadA,dadB,dadC)\n\n    x = angle - ref\n    select case (constr%subtype)\n    case (pharmonic) !> harmonic potential\n      energy = 0.5_wp * k * (x)**2\n      dum = k * (x)\n    case (plogfermi) !> logfermi potential\n      energy = kb * T * log(1.0_wp + exp(beta * x))\n      dum = (kb * T * beta * exp(beta * x)) / (exp(beta * x) + 1.0_wp)\n    end select\n\n    grd(1,iat) = dum * dadA(1)\n    grd(2,iat) = dum * dadA(2)\n    grd(3,iat) = dum * dadA(3)\n    grd(1,jat) = dum * dadB(1)\n    grd(2,jat) = dum * dadB(2)\n    grd(3,jat) = dum * dadB(3)\n    grd(1,kat) = dum * dadC(1)\n    grd(2,kat) = dum * dadC(2)\n    grd(3,kat) = dum * dadC(3)\n\n    return\n  end subroutine angle_constraint\n\n  subroutine angle_and_derivatives(A,B,C,angle,dadA,dadB,dadC)\n    implicit none\n    real(wp),intent(in) :: A(3),B(3),C(3) !> points spanning the angle\n    real(wp),intent(out) :: angle !> the angle in rad\n    real(wp),intent(out) :: dadA(3),dadB(3),dadC(3) !> Cartesian derivatives\n    real(wp) :: r1(3),r2(3)\n    real(wp) :: p,d,l1,l2\n    real(wp) :: dinv,dum\n\n    angle = 0.0_wp\n    dadA = 0.0_wp\n    dadB = 0.0_wp\n    dadC = 0.0_wp\n\n    r1 = A - B\n    r2 = C - B\n    l1 = rlen(r1)\n    l2 = rlen(r2)\n    p = dot(r1,r2)\n    d = p / (l1 * l2)\n    angle = acos(d)\n    if (angle < 1d-6 .or. (pi - angle) < 1d-6) then\n      dadA(:) = (1.0_wp / l2) * sin(acos(r2(:) / l2))\n      dadC(:) = (1.0_wp / l1) * sin(acos(r1(:) / l1))\n      if ((pi - angle) < 1d-6) then\n        dadA = -dadA\n        dadC = -dadC\n      end if\n    else\n      dinv = 1.0_wp / sqrt(1.0_wp - d**2)\n      dadA(:) = -dinv * (r2(:) * l1 * l2 - p * (l2 / l1) * r1(:)) / (l1**2 * l2**2)\n      dadC(:) = -dinv * (r1(:) * l1 * l2 - p * (l1 / l2) * r2(:)) / (l1**2 * l2**2)\n    end if\n    dadB = -dadA - dadC\n\n    return\n  end subroutine angle_and_derivatives\n\n  real(wp) function rlen(r)\n    implicit none\n    real(wp) :: r(3)\n    rlen = 0.0_wp\n    rlen = r(1)**2 + r(2)**2 + r(3)**2\n    rlen = sqrt(rlen)\n    return\n  end function rlen\n  real(wp) function dot(r1,r2)\n    implicit none\n    real(wp) :: r1(3),r2(3)\n    dot = 0.0_wp\n    dot = r1(1) * r2(1) + r1(2) * r2(2) + r1(3) * r2(3)\n    return\n  end function dot\n  subroutine cross(r1,r2,r3)\n    implicit none\n    real(wp) :: r1(3),r2(3)\n    real(wp) :: r3(3)\n    r3 = 0.0_wp\n    r3(1) = r1(2) * r2(3) - r1(3) * r2(2)\n    r3(2) = r1(3) * r2(1) - r1(1) * r2(3)\n    r3(3) = r1(1) * r2(2) - r1(2) * r2(1)\n    return\n  end subroutine cross\n\n!========================================================================================!\n!> subroutien create_dihedral_constraint\n!> constrain angle in degrees (°), input should be between -180° and 180°\n  subroutine create_dihedral_constraint(self,a,b,c,d,ref,k)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: a,b,c,d\n    real(wp),intent(in) :: ref !> constrain angle in degrees\n    real(wp),optional :: k\n    real(wp) :: dum,d2,sig\n    call self%deallocate()\n    self%type = dihedral\n    self%n = 4\n    allocate (self%atms(4))\n    allocate (self%fc(1),source=fcdefault)\n    allocate (self%ref(1))\n    self%atms(1) = a\n    self%atms(2) = b\n    self%atms(3) = c\n    self%atms(4) = d\n\n    d2 = ref\n    sig = sign(1.0_wp,ref)\n    if (abs(d2) > 360.0_wp) then\n      dum = abs(d2)\n      do\n        dum = dum - 360.0_wp\n        if (dum < 360.0_wp) then\n          d2 = dum\n          exit\n        end if\n      end do\n      d2 = d2 * sig\n    end if\n    if (d2 > 180.0_wp) then\n      d2 = d2 - 360.0_wp\n    end if\n    if (d2 < -180.0_wp) then\n      d2 = d2 + 360.0_wp\n    end if\n    self%ref(1) = d2 / deg !reference in rad\n    if (present(k)) then\n      self%fc(1) = k\n    end if\n    return\n  end subroutine create_dihedral_constraint\n!========================================================================================!\n!> subroutine dihedral_constraint\n!> constrain dihedral angle spanned by atoms A-B-C-D\n!> using a harmonic potential\n  subroutine dihedral_constraint(n,xyz,constr,energy,grd)\n    implicit none\n    integer,intent(in) :: n\n    real(wp),intent(in) :: xyz(3,n)\n    type(constraint) :: constr\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: grd(3,n)\n    integer :: i,iat,jat,kat,lat\n    real(wp) :: A(3),B(3),C(3),D(3)\n    real(wp) :: N1(3),N2(3),Nzero(3)\n    real(wp) :: rab(3),rcb(3),rdc(3),na,nb,nc\n    real(wp) :: dangle,k,ref,p,l1,l2\n    real(wp) :: dinv,dum,x,T,beta\n    real(wp) :: dadN1(3),dadN2(3),dad0(3)\n    real(wp) :: sig,dDdr(3)\n    real(wp) :: dDdA(3),dDdB(3),dDdC(3),dDdD(3)\n\n    energy = 0.0_wp\n    grd = 0.0_wp\n\n    if (constr%n /= 4) return\n    if (.not. allocated(constr%atms)) return\n    if (.not. allocated(constr%ref)) return\n    if (.not. allocated(constr%fc)) return\n\n    ref = constr%ref(1)\n    k = constr%fc(1)\n    iat = constr%atms(1)\n    jat = constr%atms(2)\n    kat = constr%atms(3)\n    lat = constr%atms(4)\n    A = xyz(:,iat)\n    B = xyz(:,jat)\n    C = xyz(:,kat)\n    D = xyz(:,lat)\n    Nzero = 0.0_wp\n    !> vectors spanning the planes (A,B,C) and (D,C,B)\n    rab = A - B\n    rcb = C - B\n    rdc = D - C\n    !> get the two normal vectors N1 and N2 for the two planes\n    call cross(rab,rcb,N1)\n    call cross(rdc,rcb,N2)\n    p = dot(N1,rdc)\n    sig = -sign(1.0_wp,p)\n    call angle_and_derivatives(N1,Nzero,N2,dangle,dadN1,dad0,dadN2)\n    dangle = sig * dangle\n    \n    x = dangle - ref\n    if(x < -180.0_wp/deg) x = x + 360.0_wp/deg\n    if(x > 180.0_wp/deg) x = x - 360.0_wp/deg\n    select case (constr%subtype)\n    case (pharmonic) !> harmonic potential\n      energy = 0.5_wp * k * (x)**2\n      dum = k * (x)\n    case (plogfermi) !> logfermi potential\n      energy = kb * T * log(1.0_wp + exp(beta * x))\n      dum = (kb * T * beta * exp(beta * x)) / (exp(beta * x) + 1.0_wp)\n    end select\n\n    call dtorsdr(A,B,C,D,dadN1,dadN2,sig,dDdA,dDdB,dDdC,dDdD)\n    grd(1:3,iat) = dum * dDdA(1:3)\n    grd(1:3,jat) = dum * dDdB(1:3)\n    grd(1:3,kat) = dum * dDdC(1:3)\n    grd(1:3,lat) = dum * dDdD(1:3)\n\n    return\n  contains\n    subroutine dtorsdr(A,B,C,D,dadN1,dadN2,sig,dphidA,dphidB,dphidC,dphidD)\n      implicit none\n      real(wp),intent(in) :: A(3),B(3),C(3),D(3) !>points spanning the torsion A-B-C-D\n      real(wp),intent(in) :: dadN1(3),dadN2(3) !> derivatives of the angle between N1 and N2\n      real(wp),intent(in) :: sig !> sign\n      real(wp),intent(out) :: dphidA(3),dphidB(3),dphidC(3),dphidD(3) !> Cartesian derivatives\n\n      dphidA(1) = sig * (dadN1(2) * (B(3) - C(3)) + dadN1(3) * (C(2) - B(2)))\n      dphidA(2) = sig * (dadN1(1) * (C(3) - B(3)) + dadN1(3) * (B(1) - C(1)))\n      dphidA(3) = sig * (dadN1(1) * (B(2) - C(2)) + dadN1(2) * (C(1) - B(1)))\n\n      dphidB(1) = sig * (dadN1(2) * (C(3) - A(3)) + dadN1(3) * (A(2) - C(2)) &\n      &       + dadN2(2) * (C(3) - D(3)) + dadN2(3) * (D(2) - C(2)))\n      dphidB(2) = sig * (dadN1(1) * (A(3) - C(3)) + dadN1(3) * (C(1) - A(1)) &\n      &       + dadN2(1) * (D(3) - C(3)) + dadN2(3) * (C(1) - D(1)))\n      dphidB(3) = sig * (dadN1(1) * (C(2) - A(2)) + dadN1(2) * (A(1) - C(1)) &\n      &       + dadN2(1) * (C(2) - D(2)) + dadN2(2) * (D(1) - C(1)))\n\n      dphidC(1) = sig * (dadN1(2) * (A(3) - B(3)) + dadN1(3) * (B(2) - A(2)) &\n      &       + dadN2(2) * (D(3) - B(3)) + dadN2(3) * (B(2) - D(2)))\n      dphidC(2) = sig * (dadN1(1) * (B(3) - A(3)) + dadN1(3) * (A(1) - B(1)) &\n      &       + dadN2(1) * (B(3) - D(3)) + dadN2(3) * (D(1) - B(1)))\n      dphidC(3) = sig * (dadN1(1) * (A(2) - B(2)) + dadN1(2) * (B(1) - A(1)) &\n      &       + dadN2(1) * (D(2) - B(2)) + dadN2(2) * (B(1) - D(1)))\n\n      dphidD(1) = sig * (dadN2(2) * (B(3) - C(3)) + dadN2(3) * (C(2) - B(2)))\n      dphidD(2) = sig * (dadN2(1) * (C(3) - B(3)) + dadN2(3) * (B(1) - C(1)))\n      dphidD(3) = sig * (dadN2(1) * (B(2) - C(2)) + dadN2(2) * (C(1) - B(1)))\n\n      return\n    end subroutine dtorsdr\n\n  end subroutine dihedral_constraint\n\n!========================================================================================!\n!> subroutien create_sphere_constraint\n\n  subroutine create_sphere_constraint_all(self,n,r,k,alpha,logfermi)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: n\n    logical,allocatable :: atms(:)\n    real(wp),intent(in) :: r\n    real(wp) :: k,alpha\n    logical,intent(in) :: logfermi\n    integer :: i,c\n\n    allocate (atms(n),source=.true.)\n    call create_sphere_constraint(self,n,atms,r,k,alpha,logfermi)\n    deallocate (atms)\n    return\n  end subroutine create_sphere_constraint_all\n\n  subroutine create_sphere_constraint(self,n,atms,r,k,alpha,logfermi)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: n\n    logical,intent(in) :: atms(n)\n    real(wp),intent(in) :: r\n    real(wp) :: k,alpha\n    logical,intent(in) :: logfermi\n    integer :: i,c\n\n    call self%deallocate()\n    if (logfermi) then\n      self%type = wall_fermi\n    else\n      self%type = wall\n    end if\n    c = count(atms,1)\n    self%n = c\n    allocate (self%atms(c))\n    allocate (self%fc(2),source=fcdefault)\n    allocate (self%ref(3),source=r)\n    do i = 1,n\n      if (atms(i)) self%atms(i) = i\n    end do\n    self%ref = r\n    self%fc(1) = k\n    self%fc(2) = alpha\n    return\n  end subroutine create_sphere_constraint\n\n  subroutine sphere_update_nat(self,n,atms)\n    implicit none\n    class(constraint) :: self\n    integer,intent(in) :: n\n    logical,intent(in) :: atms(n)\n    integer :: c,i\n    c = count(atms,1)\n    self%n = c\n    if(allocated(self%atms))deallocate(self%atms)\n    allocate(self%atms(c))\n    do i=1,n\n      if (atms(i)) self%atms(i) = i\n    enddo\n    return\n  end subroutine sphere_update_nat\n!========================================================================================!\n!> constrain atoms within defined wall potentials\n!> the potentials themselves can be polinomial or logfermi type\n  subroutine wall_constraint(n,xyz,constr,energy,grd,subtype)\n    implicit none\n    integer,intent(in) :: n\n    real(wp),intent(in) :: xyz(3,n)\n    type(constraint) :: constr\n    integer,intent(in) :: subtype\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: grd(3,n)\n    integer :: i,iat,jat\n    real(wp) :: a,b,c,x,y,z,dx,dy,dz\n    real(wp) :: dist,ddist,ref\n    real(wp) :: k,alpha,dalpha,T,beta\n    real(wp) :: fermi,expo,r(3),w(3)\n\n    energy = 0.0_wp\n    grd = 0.0_wp\n\n    if (.not. allocated(constr%atms)) return\n    if (.not. allocated(constr%ref)) return\n    if (.not. allocated(constr%fc)) return\n\n    do i = 1,n\n      iat = constr%atms(i)\n      select case (subtype)\n      case default\n        return\n      case (wall)\n        !>\n        !> V = k*Σ(|R-O|/Rref)^α \n        !>\n        k = constr%fc(1)\n        alpha = constr%fc(2)\n        dalpha = alpha - 1.0_wp\n        x = xyz(1,iat)\n        y = xyz(2,iat)\n        z = xyz(3,iat)\n        a = constr%ref(1)\n        b = constr%ref(2)\n        c = constr%ref(3)\n        dist = (x / a)**2 + (y / b)**2 + (z / c)**2\n        energy = energy + k * (dist**alpha)\n        dx = 2.0_wp * (x / (a**2))\n        dy = 2.0_wp * (y / (b**2))\n        dz = 2.0_wp * (z / (c**2))\n        ddist = k * alpha * (dist**dalpha)\n        grd(1,iat) = ddist * dx\n        grd(2,iat) = ddist * dy\n        grd(3,iat) = ddist * dz\n      case (wall_fermi)\n        !>\n        !> V = Σ kT*log{1+exp[β(|R-O|-Rref)]} \n        !>\n        T = constr%fc(1)\n        beta = constr%fc(2)\n        ref = maxval(constr%ref(1:3))\n        w(1:3) = ref / constr%ref(1:3)\n        r = w * (xyz(1:3,iat))\n        dist = sqrt(sum(r**2))\n        expo = exp(beta * (dist - ref))\n        fermi = 1.0_wp / (1.0_wp + expo)\n        energy = energy + kB * T * log(1.0_wp + expo)\n        grd(:,iat) = grd(:,iat) + kB * T * beta * expo * fermi * (r * w) / (dist + 1.0e-14_wp)\n      case (box)\n\n      case (box_fermi)\n\n      end select\n    end do\n\n    return\n  end subroutine wall_constraint\n\n!========================================================================================!\n!> subroutien create_gapdiff_constraint\n!> (calculation of the constraint in nonadiabatic.f90)\n  subroutine create_gapdiff_constraint(self,sigm,alph)\n    implicit none\n    class(constraint) :: self\n    real(wp),intent(in) :: sigm,alph\n\n    call self%deallocate()\n    self%type = na_gapdiff\n    allocate (self%fc(2),source=fcdefault)\n    self%fc(1) = sigm\n    self%fc(2) = alph\n    return\n  end subroutine create_gapdiff_constraint\n\n!========================================================================================!\n!> subroutien create_gapdiff_constraint2\n!> (calculation of the constraint in nonadiabatic.f90)\n  subroutine create_gapdiff_constraint2(self,sigm,alph,c)\n    implicit none\n    class(constraint) :: self\n    real(wp),intent(in) :: sigm,alph,c\n\n    call self%deallocate()\n    self%type = na_gapdiff2\n    allocate (self%fc(3),source=fcdefault)\n    self%fc(1) = sigm\n    self%fc(2) = alph\n    self%fc(3) = c\n    return\n  end subroutine create_gapdiff_constraint2\n\n\n\n\n!========================================================================================!\nend module constraints\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/constraints.f90 b/src/calculator/constraints.f90
--- a/src/calculator/constraints.f90	
+++ b/src/calculator/constraints.f90	
@@ -37,7 +37,7 @@
   real(wp),parameter :: autokcal = 627.509541_wp
   real(wp),parameter :: kB = 3.166808578545117e-06_wp !in Eh/K
   real(wp),parameter :: pi = 3.14159265359_wp
-  real(wp),parameter :: deg = 180.0_wp / pi ! 1 rad in degrees
+  real(wp),parameter :: deg = 180.0_wp/pi ! 1 rad in degrees
   real(wp),parameter :: fcdefault = 0.01_wp
   real(wp),parameter :: Tdefault = 298.15_wp
 
@@ -50,6 +50,7 @@
   integer,parameter :: wall_fermi = 5
   integer,parameter :: box = 6
   integer,parameter :: box_fermi = 7
+  integer,parameter :: bondrange = 8
 
   integer,public,parameter :: na_gapdiff = -1
   integer,public,parameter :: na_gapdiff2 = -2
@@ -57,8 +58,9 @@
   integer,parameter :: pharmonic = 1
   integer,parameter :: plogfermi = 2
 
-  public :: constraint
   !=====================================================!
+
+  public :: constraint
   type :: constraint
 
     integer :: type = 0
@@ -75,6 +77,7 @@
     generic,public :: sphereconstraint => create_sphere_constraint,create_sphere_constraint_all
     procedure,private :: create_sphere_constraint,create_sphere_constraint_all
     procedure :: sphereupdate => sphere_update_nat
+    procedure :: ellipsoid => create_ellips_constraint
     procedure :: angleconstraint => create_angle_constraint
     procedure :: dihedralconstraint => create_dihedral_constraint
     procedure :: gapdiffconstraint => create_gapdiff_constraint
@@ -82,12 +85,12 @@
     procedure :: dummyconstraint => create_dummy_constraint
     procedure :: analyzedummy => analyze_dummy_bond_constraint
     procedure :: rdbondconstraint => analyze_dummy_bond_constraint2
+    procedure :: bondrangeconstraint => create_bondrange_constraint
   end type constraint
-  !=====================================================!
+
+  !=====================================================! 
 
-
   public :: scantype
-  !=====================================================!
   type :: scantype
 
     integer :: type = 0  !> 0=nothing, 1=distance, 3=dihedral
@@ -105,8 +108,6 @@
   end type scantype
   !=====================================================!
 
-
-
   public :: calc_constraint
 
 !========================================================================================!
@@ -116,6 +117,11 @@
 !========================================================================================!
 
   subroutine calc_constraint(n,xyz,constr,energy,grd)
+!*****************************************************
+!* Calculate energy and gradient contribution for
+!* the given constraint.
+!* In and outputs are in atomic units (Bohr, Hartree)
+!*****************************************************
     implicit none
     integer,intent(in) :: n
     real(wp),intent(in) :: xyz(3,n)
@@ -140,6 +146,8 @@
 
     case (box_fermi)
 
+    case (bondrange)
+      call bondrange_constraint(n,xyz,constr,energy,grd)
     case default
       return
     end select
@@ -163,23 +171,23 @@
     case (bond)
       art = 'distance'
       write (atoms,'(1x,"atoms:",1x,i0,",",i0)') self%atms(1:2)
-      write (values,'(" d=",f8.2,1x,"k=",f8.5)') self%ref(1),self%fc(1)
+      write (values,'(" d=",f8.2,1x,"k=",f8.5)') self%ref(1)*bohr,self%fc(1)
     case (angle)
       art = 'angle'
       write (atoms,'(1x,"atoms:",1x,i0,",",i0,",",i0)') self%atms(1:3)
-      write (values,'(" deg=",f6.2,1x,"k=",f8.5)') self%ref(1) * deg,self%fc(1)
+      write (values,'(" deg=",f6.2,1x,"k=",f8.5)') self%ref(1)*deg,self%fc(1)
     case (dihedral)
       art = 'dihedral'
       write (atoms,'(1x,"atoms:",1x,i0,",",i0,",",i0,",",i0)') self%atms(1:4)
-      write (values,'(" deg=",f6.2,1x,"k=",f8.5)') self%ref(1) * deg,self%fc(1)
+      write (values,'(" deg=",f6.2,1x,"k=",f8.5)') self%ref(1)*deg,self%fc(1)
     case (wall)
       art = 'wall'
       write (atoms,'(1x,"atoms:",1x,i0,a)') self%n,'/all'
-      write (values,'(" radii=",3f12.5," k=",f8.5,1x,"exp=",f5.2)') self%ref(1:3),self%fc(1:2)
+      write (values,'(" radii(Bohr)=",3f12.5," k=",f8.5,1x,"exp=",f5.2)') self%ref(1:3),self%fc(1:2)
     case (wall_fermi)
       art = 'wall_fermi'
       write (atoms,'(1x,"atoms:",1x,i0,a)') self%n,'/all'
-      write (values,'(" radii=",3f12.5," k=",f8.5,1x,"exp=",f5.2)') self%ref(1:3),self%fc(1:2)
+      write (values,'(" radii(Bohr)=",3f12.5," T=",f8.1,1x,"exp=",f5.2)') self%ref(1:3),self%fc(1:2)
     case (na_gapdiff)
       art = 'nonadiabatic gap'
       write (atoms,'(1x,"[",a,"]")') 'σ*ΔE²/(ΔE+α)'
@@ -188,14 +196,20 @@
       art = 'nonadiabatic gap'
       write (atoms,'(1x,"[",a,"]")') 'σ*(exp(-β|ΔE|)+C) * ΔE²/(|ΔE|+α)'
       write (values,'(" σ=",f8.5," α=",f8.5," C=",f8.5," β=",f8.5)') self%fc(1:3),27.2114_wp
+    case (bondrange)
+      art = 'bondrange'
+      write (atoms,'(1x,"atoms:",1x,i0,",",i0)') self%atms(1:2)
+      write (values,'(" upper=",f8.2,1x,"lower=",f8.2)') self%ref(1)*bohr,self%ref(2)*bohr
     case default
       art = 'none'
       atoms = 'none'
       values = ' '
-      pr=.false.
+      pr = .false.
     end select
-    if(pr) &
-    & write (chnl,'(a,a,",",a,",",a,1x,a)') ' constraint: ',trim(art),trim(atoms),trim(values)
+    if (pr) then
+      write (chnl,'("> ",a,a,a)') 'constraint: ',trim(art),trim(atoms)
+      write (chnl,'(1x,a)') trim(values)
+    end if
 
     return
   end subroutine print_constraint
@@ -211,28 +225,28 @@
     integer :: a1,a2
 
     call self%deallocate()
-    
-    select case( i )
-    case ( 1 )
-      if( any(rawa(1) == (/character(7)::'all','allauto' /)))then
-      call self%dummyconstraint(t)
-      endif
-    case (2) 
-      if( any(rawa(1) == (/character(9)::'all','allauto' /)))then
-      read(rawa(2),*) k
-      call self%dummyconstraint(t,k)
-      endif
+
+    select case (i)
+    case (1)
+      if (any(rawa(1) == (/character(7)::'all','allauto'/))) then
+        call self%dummyconstraint(t)
+      end if
+    case (2)
+      if (any(rawa(1) == (/character(9)::'all','allauto'/))) then
+        read (rawa(2),*) k
+        call self%dummyconstraint(t,k)
+      end if
     case (3)
-      read(rawa(1),*) a1
-      read(rawa(2),*) a2
-      read(rawa(3),*) dist
+      read (rawa(1),*) a1
+      read (rawa(2),*) a2
+      read (rawa(3),*) dist
       dist = abs(dist)
       call self%bondconstraint(a1,a2,dist)
-    case (4)   
-      read(rawa(1),*) a1
-      read(rawa(2),*) a2
-      read(rawa(3),*) dist
-      read(rawa(4),*) k
+    case (4)
+      read (rawa(1),*) a1
+      read (rawa(2),*) a2
+      read (rawa(3),*) dist
+      read (rawa(4),*) k
       dist = abs(dist)
       call self%bondconstraint(a1,a2,dist,k)
     end select
@@ -250,7 +264,7 @@
 
     call self%deallocate()
 
-    select case( i )
+    select case (i)
     case (3)
       a1 = nint(fa(1))
       a2 = nint(fa(2))
@@ -267,8 +281,6 @@
     return
   end subroutine analyze_dummy_bond_constraint2
 
-
-
 !========================================================================================!
 !> subroutine constraint_deallocate
 !> reset and deallocate all data of a given constraint object
@@ -344,9 +356,13 @@
   end subroutine create_bond_constraint
 
 !========================================================================================!
-!> constrain the distance between two atoms A...B
-!> by an harmonic potential V(r) = 1/2kr²
+
   subroutine bond_constraint(n,xyz,constr,energy,grd)
+!**************************************************
+!* constrain the distance between two atoms A...B
+!* by an harmonic potential V(r) = 1/2kr²
+!* r and k are in atomic units (Bohr, Hartree)
+!**************************************************
     implicit none
     integer,intent(in) :: n
     real(wp),intent(in) :: xyz(3,n)
@@ -363,32 +379,32 @@
     grd = 0.0_wp
 
     if (constr%n /= 2) return
-    if (.not. allocated(constr%atms)) return
-    if (.not. allocated(constr%ref)) return
-    if (.not. allocated(constr%fc)) return
+    !if (.not.allocated(constr%atms)) return
+    !if (.not.allocated(constr%ref)) return
+    !if (.not.allocated(constr%fc)) return
 
     iat = constr%atms(1)
     jat = constr%atms(2)
-    a = xyz(1,iat) - xyz(1,jat)
-    b = xyz(2,iat) - xyz(2,jat)
-    c = xyz(3,iat) - xyz(3,jat)
-    dist = sqrt(a**2 + b**2 + c**2)
+    a = xyz(1,iat)-xyz(1,jat)
+    b = xyz(2,iat)-xyz(2,jat)
+    c = xyz(3,iat)-xyz(3,jat)
+    dist = sqrt(a**2+b**2+c**2)
     ref = constr%ref(1)
     k = constr%fc(1)
 
-    x = dist - ref
+    x = dist-ref
     select case (constr%subtype)
     case (pharmonic)
-      energy = 0.5_wp * k * (x)**2
-      dum = k * x
+      energy = 0.5_wp*k*(x)**2
+      dum = k*x
     case (plogfermi)
-      energy = kb * T * log(1.0_wp + exp(beta * x))
-      dum = (kb * T * beta * exp(beta * x)) / (exp(beta * x) + 1.0_wp)
+      energy = kb*T*log(1.0_wp+exp(beta*x))
+      dum = (kb*T*beta*exp(beta*x))/(exp(beta*x)+1.0_wp)
     end select
 
-    grd(1,iat) = dum * (a / dist)
-    grd(2,iat) = dum * (b / dist)
-    grd(3,iat) = dum * (c / dist)
+    grd(1,iat) = dum*(a/dist)
+    grd(2,iat) = dum*(b/dist)
+    grd(3,iat) = dum*(c/dist)
     grd(1,jat) = -grd(1,iat)
     grd(2,jat) = -grd(2,iat)
     grd(3,jat) = -grd(3,iat)
@@ -396,6 +412,146 @@
     return
   end subroutine bond_constraint
 
+!========================================================================================!
+
+  subroutine create_bondrange_constraint(self,i,j,dup,dlow,beta,T)
+    implicit none
+    class(constraint) :: self
+    integer,intent(in) :: i,j
+    real(wp),intent(in) :: dup,dlow
+    real(wp),optional :: beta
+    real(wp),optional :: T
+
+    call self%deallocate()
+    self%type = bondrange
+    self%n = 2
+    allocate (self%atms(2))
+    allocate (self%fc(2),source=fcdefault)
+    allocate (self%ref(2))
+    self%atms(1) = i
+    self%atms(2) = j
+    self%ref(1) = max(dup,dlow)
+    self%ref(2) = min(dup,dlow)
+    if (present(T)) then
+      self%fc(1) = T/kb
+    else
+      self%fc(1) = 0.1_wp/kb
+    end if
+    self%fc(1) = abs(self%fc(1))
+    if (present(beta))then
+      self%fc(2) = beta 
+    else
+      self%fc(2) = 50.0_wp
+    endif
+    return
+  end subroutine create_bondrange_constraint
+
+
+
+  subroutine bondrange_constraint(n,xyz,constr,energy,grd)
+!************************************************************
+!* constrain the distance between two atoms A...B
+!* via two logfermi potentials V(r) = kb*T*log(1+e^(beta*r))
+!* This potential allows to define an upper and lower bound
+!* for the AB distance
+!************************************************************
+    implicit none
+    integer,intent(in) :: n
+    real(wp),intent(in) :: xyz(3,n)
+    type(constraint) :: constr
+
+    real(wp),intent(out) :: energy
+    real(wp),intent(out) :: grd(3,n)
+    integer :: iat,jat
+    real(wp) :: a,b,c,x
+    real(wp) :: dist,ref,k,dum
+    real(wp) :: ref_upper, ref_lower
+    real(wp) :: T,beta
+    real(wp) :: dr(3)
+
+    energy = 0.0_wp
+    grd = 0.0_wp
+
+    if (constr%n /= 2) return
+    !if (.not.allocated(constr%atms)) return
+    !if (.not.allocated(constr%ref)) return
+    !if (size(constr%ref,1) < 2) return
+    !if (.not.allocated(constr%fc)) return
+    !if (size(constr%fc,1) < 2) return
+
+    iat = constr%atms(1)
+    jat = constr%atms(2)
+    a = xyz(1,iat)-xyz(1,jat)
+    b = xyz(2,iat)-xyz(2,jat)
+    c = xyz(3,iat)-xyz(3,jat)
+    dist = sqrt(a**2+b**2+c**2)
+    ref_upper = constr%ref(1)
+    ref_lower = constr%ref(2)
+    T = constr%fc(1)
+    beta = constr%fc(2)
+
+    !> upper bound contribution
+    x = dist-ref_upper
+    !energy = kb*T*log(1.0_wp+exp(beta*x))
+    energy = logfermi(T,beta,x)
+    !dum = (kb*T*beta*exp(beta*x))/(exp(beta*x)+1.0_wp)
+    dum = dlogfermi(T,beta,x)
+    grd(1,iat) = dum*(a/dist)
+    grd(2,iat) = dum*(b/dist)
+    grd(3,iat) = dum*(c/dist)
+    grd(1,jat) = -grd(1,iat)
+    grd(2,jat) = -grd(2,iat)
+    grd(3,jat) = -grd(3,iat)
+
+    !> lower bound contribution
+    x = ref_lower - dist
+    !energy = energy +  kb*T*log(1.0_wp+exp(beta*x))
+    energy = energy + logfermi(T,beta,x)
+    !dum = (kb*T*beta*exp(beta*x))/(exp(beta*x)+1.0_wp)
+    dum = dlogfermi(T,beta,x) 
+    dr(1) = -dum*(a/dist)
+    dr(2) = -dum*(b/dist)
+    dr(3) = -dum*(c/dist)
+    grd(1,iat) = grd(1,iat) + dr(1)
+    grd(2,iat) = grd(2,iat) + dr(2) 
+    grd(3,iat) = grd(3,iat) + dr(3)
+    grd(1,jat) = grd(1,jat) - dr(1)
+    grd(2,jat) = grd(2,jat) - dr(2)
+    grd(3,jat) = grd(3,jat) - dr(3)
+
+    !> energy shift (no gard contribution)
+    !> if ref_upper == ref_lower, this will transform the
+    !> bondrange constraint into something close to a harmonic potential
+    !> and the shift shifts the potential to zero at the minimum
+    ref = (ref_upper + ref_lower)/2.0_wp
+    x = ref - ref_upper
+    dum = logfermi(T,beta,x)
+    x = ref_lower - ref
+    dum = dum + logfermi(T,beta,x)
+    energy = energy - dum
+
+    return 
+  end subroutine bondrange_constraint
+
+  function logfermi(T,beta,x) result(energy)
+    implicit none
+    real(wp) :: energy
+    real(wp),intent(in) :: T
+    real(wp),intent(in) :: beta
+    real(wp),intent(in) :: x
+    energy = kb*T*log(1.0_wp+exp(beta*x))
+  end function logfermi
+
+  function dlogfermi(T,beta,x) result(dldx)
+    implicit none
+    real(wp) :: dldx
+    real(wp),intent(in) :: T
+    real(wp),intent(in) :: beta
+    real(wp),intent(in) :: x
+    dldx = (kb*T*beta*exp(beta*x))/(exp(beta*x)+1.0_wp)
+  end function dlogfermi
+
+
 !========================================================================================!
 !> subroutien create_angle_constraint
   subroutine create_angle_constraint(self,a,b,c,d,k)
@@ -418,7 +574,7 @@
     if (d2 > 360.0_wp) then
       dum = d2
       do
-        dum = dum - 360.0_wp
+        dum = dum-360.0_wp
         if (dum < 360.0_wp) then
           d2 = dum
           exit
@@ -426,9 +582,9 @@
       end do
     end if
     if (d2 > 180.0_wp) then
-      d2 = 360.0_wp - d2
+      d2 = 360.0_wp-d2
     end if
-    self%ref(1) = d2 / deg !reference in rad
+    self%ref(1) = d2/deg !reference in rad
     if (present(k)) then
       self%fc(1) = k
     end if
@@ -457,9 +613,9 @@
     grd = 0.0_wp
 
     if (constr%n /= 3) return
-    if (.not. allocated(constr%atms)) return
-    if (.not. allocated(constr%ref)) return
-    if (.not. allocated(constr%fc)) return
+    if (.not.allocated(constr%atms)) return
+    if (.not.allocated(constr%ref)) return
+    if (.not.allocated(constr%fc)) return
 
     ref = constr%ref(1)
     k = constr%fc(1)
@@ -471,25 +627,25 @@
     C = xyz(:,kat)
     call angle_and_derivatives(A,B,C,angle,dadA,dadB,dadC)
 
-    x = angle - ref
+    x = angle-ref
     select case (constr%subtype)
     case (pharmonic) !> harmonic potential
-      energy = 0.5_wp * k * (x)**2
-      dum = k * (x)
+      energy = 0.5_wp*k*(x)**2
+      dum = k*(x)
     case (plogfermi) !> logfermi potential
-      energy = kb * T * log(1.0_wp + exp(beta * x))
-      dum = (kb * T * beta * exp(beta * x)) / (exp(beta * x) + 1.0_wp)
+      energy = kb*T*log(1.0_wp+exp(beta*x))
+      dum = (kb*T*beta*exp(beta*x))/(exp(beta*x)+1.0_wp)
     end select
 
-    grd(1,iat) = dum * dadA(1)
-    grd(2,iat) = dum * dadA(2)
-    grd(3,iat) = dum * dadA(3)
-    grd(1,jat) = dum * dadB(1)
-    grd(2,jat) = dum * dadB(2)
-    grd(3,jat) = dum * dadB(3)
-    grd(1,kat) = dum * dadC(1)
-    grd(2,kat) = dum * dadC(2)
-    grd(3,kat) = dum * dadC(3)
+    grd(1,iat) = dum*dadA(1)
+    grd(2,iat) = dum*dadA(2)
+    grd(3,iat) = dum*dadA(3)
+    grd(1,jat) = dum*dadB(1)
+    grd(2,jat) = dum*dadB(2)
+    grd(3,jat) = dum*dadB(3)
+    grd(1,kat) = dum*dadC(1)
+    grd(2,kat) = dum*dadC(2)
+    grd(3,kat) = dum*dadC(3)
 
     return
   end subroutine angle_constraint
@@ -508,26 +664,26 @@
     dadB = 0.0_wp
     dadC = 0.0_wp
 
-    r1 = A - B
-    r2 = C - B
+    r1 = A-B
+    r2 = C-B
     l1 = rlen(r1)
     l2 = rlen(r2)
     p = dot(r1,r2)
-    d = p / (l1 * l2)
+    d = p/(l1*l2)
     angle = acos(d)
-    if (angle < 1d-6 .or. (pi - angle) < 1d-6) then
-      dadA(:) = (1.0_wp / l2) * sin(acos(r2(:) / l2))
-      dadC(:) = (1.0_wp / l1) * sin(acos(r1(:) / l1))
-      if ((pi - angle) < 1d-6) then
+    if (angle < 1d-6.or.(pi-angle) < 1d-6) then
+      dadA(:) = (1.0_wp/l2)*sin(acos(r2(:)/l2))
+      dadC(:) = (1.0_wp/l1)*sin(acos(r1(:)/l1))
+      if ((pi-angle) < 1d-6) then
         dadA = -dadA
         dadC = -dadC
       end if
     else
-      dinv = 1.0_wp / sqrt(1.0_wp - d**2)
-      dadA(:) = -dinv * (r2(:) * l1 * l2 - p * (l2 / l1) * r1(:)) / (l1**2 * l2**2)
-      dadC(:) = -dinv * (r1(:) * l1 * l2 - p * (l1 / l2) * r2(:)) / (l1**2 * l2**2)
+      dinv = 1.0_wp/sqrt(1.0_wp-d**2)
+      dadA(:) = -dinv*(r2(:)*l1*l2-p*(l2/l1)*r1(:))/(l1**2*l2**2)
+      dadC(:) = -dinv*(r1(:)*l1*l2-p*(l1/l2)*r2(:))/(l1**2*l2**2)
     end if
-    dadB = -dadA - dadC
+    dadB = -dadA-dadC
 
     return
   end subroutine angle_and_derivatives
@@ -536,7 +692,7 @@
     implicit none
     real(wp) :: r(3)
     rlen = 0.0_wp
-    rlen = r(1)**2 + r(2)**2 + r(3)**2
+    rlen = r(1)**2+r(2)**2+r(3)**2
     rlen = sqrt(rlen)
     return
   end function rlen
@@ -544,7 +700,7 @@
     implicit none
     real(wp) :: r1(3),r2(3)
     dot = 0.0_wp
-    dot = r1(1) * r2(1) + r1(2) * r2(2) + r1(3) * r2(3)
+    dot = r1(1)*r2(1)+r1(2)*r2(2)+r1(3)*r2(3)
     return
   end function dot
   subroutine cross(r1,r2,r3)
@@ -552,9 +708,9 @@
     real(wp) :: r1(3),r2(3)
     real(wp) :: r3(3)
     r3 = 0.0_wp
-    r3(1) = r1(2) * r2(3) - r1(3) * r2(2)
-    r3(2) = r1(3) * r2(1) - r1(1) * r2(3)
-    r3(3) = r1(1) * r2(2) - r1(2) * r2(1)
+    r3(1) = r1(2)*r2(3)-r1(3)*r2(2)
+    r3(2) = r1(3)*r2(1)-r1(1)*r2(3)
+    r3(3) = r1(1)*r2(2)-r1(2)*r2(1)
     return
   end subroutine cross
 
@@ -584,21 +740,21 @@
     if (abs(d2) > 360.0_wp) then
       dum = abs(d2)
       do
-        dum = dum - 360.0_wp
+        dum = dum-360.0_wp
         if (dum < 360.0_wp) then
           d2 = dum
           exit
         end if
       end do
-      d2 = d2 * sig
+      d2 = d2*sig
     end if
     if (d2 > 180.0_wp) then
-      d2 = d2 - 360.0_wp
+      d2 = d2-360.0_wp
     end if
     if (d2 < -180.0_wp) then
-      d2 = d2 + 360.0_wp
+      d2 = d2+360.0_wp
     end if
-    self%ref(1) = d2 / deg !reference in rad
+    self%ref(1) = d2/deg !reference in rad
     if (present(k)) then
       self%fc(1) = k
     end if
@@ -629,9 +785,9 @@
     grd = 0.0_wp
 
     if (constr%n /= 4) return
-    if (.not. allocated(constr%atms)) return
-    if (.not. allocated(constr%ref)) return
-    if (.not. allocated(constr%fc)) return
+    if (.not.allocated(constr%atms)) return
+    if (.not.allocated(constr%ref)) return
+    if (.not.allocated(constr%fc)) return
 
     ref = constr%ref(1)
     k = constr%fc(1)
@@ -645,34 +801,34 @@
     D = xyz(:,lat)
     Nzero = 0.0_wp
     !> vectors spanning the planes (A,B,C) and (D,C,B)
-    rab = A - B
-    rcb = C - B
-    rdc = D - C
+    rab = A-B
+    rcb = C-B
+    rdc = D-C
     !> get the two normal vectors N1 and N2 for the two planes
     call cross(rab,rcb,N1)
     call cross(rdc,rcb,N2)
     p = dot(N1,rdc)
     sig = -sign(1.0_wp,p)
     call angle_and_derivatives(N1,Nzero,N2,dangle,dadN1,dad0,dadN2)
-    dangle = sig * dangle
-    
-    x = dangle - ref
-    if(x < -180.0_wp/deg) x = x + 360.0_wp/deg
-    if(x > 180.0_wp/deg) x = x - 360.0_wp/deg
+    dangle = sig*dangle
+
+    x = dangle-ref
+    if (x < -180.0_wp/deg) x = x+360.0_wp/deg
+    if (x > 180.0_wp/deg) x = x-360.0_wp/deg
     select case (constr%subtype)
     case (pharmonic) !> harmonic potential
-      energy = 0.5_wp * k * (x)**2
-      dum = k * (x)
+      energy = 0.5_wp*k*(x)**2
+      dum = k*(x)
     case (plogfermi) !> logfermi potential
-      energy = kb * T * log(1.0_wp + exp(beta * x))
-      dum = (kb * T * beta * exp(beta * x)) / (exp(beta * x) + 1.0_wp)
+      energy = kb*T*log(1.0_wp+exp(beta*x))
+      dum = (kb*T*beta*exp(beta*x))/(exp(beta*x)+1.0_wp)
     end select
 
     call dtorsdr(A,B,C,D,dadN1,dadN2,sig,dDdA,dDdB,dDdC,dDdD)
-    grd(1:3,iat) = dum * dDdA(1:3)
-    grd(1:3,jat) = dum * dDdB(1:3)
-    grd(1:3,kat) = dum * dDdC(1:3)
-    grd(1:3,lat) = dum * dDdD(1:3)
+    grd(1:3,iat) = dum*dDdA(1:3)
+    grd(1:3,jat) = dum*dDdB(1:3)
+    grd(1:3,kat) = dum*dDdC(1:3)
+    grd(1:3,lat) = dum*dDdD(1:3)
 
     return
   contains
@@ -683,27 +839,27 @@
       real(wp),intent(in) :: sig !> sign
       real(wp),intent(out) :: dphidA(3),dphidB(3),dphidC(3),dphidD(3) !> Cartesian derivatives
 
-      dphidA(1) = sig * (dadN1(2) * (B(3) - C(3)) + dadN1(3) * (C(2) - B(2)))
-      dphidA(2) = sig * (dadN1(1) * (C(3) - B(3)) + dadN1(3) * (B(1) - C(1)))
-      dphidA(3) = sig * (dadN1(1) * (B(2) - C(2)) + dadN1(2) * (C(1) - B(1)))
+      dphidA(1) = sig*(dadN1(2)*(B(3)-C(3))+dadN1(3)*(C(2)-B(2)))
+      dphidA(2) = sig*(dadN1(1)*(C(3)-B(3))+dadN1(3)*(B(1)-C(1)))
+      dphidA(3) = sig*(dadN1(1)*(B(2)-C(2))+dadN1(2)*(C(1)-B(1)))
 
-      dphidB(1) = sig * (dadN1(2) * (C(3) - A(3)) + dadN1(3) * (A(2) - C(2)) &
-      &       + dadN2(2) * (C(3) - D(3)) + dadN2(3) * (D(2) - C(2)))
-      dphidB(2) = sig * (dadN1(1) * (A(3) - C(3)) + dadN1(3) * (C(1) - A(1)) &
-      &       + dadN2(1) * (D(3) - C(3)) + dadN2(3) * (C(1) - D(1)))
-      dphidB(3) = sig * (dadN1(1) * (C(2) - A(2)) + dadN1(2) * (A(1) - C(1)) &
-      &       + dadN2(1) * (C(2) - D(2)) + dadN2(2) * (D(1) - C(1)))
+      dphidB(1) = sig*(dadN1(2)*(C(3)-A(3))+dadN1(3)*(A(2)-C(2)) &
+      &       +dadN2(2)*(C(3)-D(3))+dadN2(3)*(D(2)-C(2)))
+      dphidB(2) = sig*(dadN1(1)*(A(3)-C(3))+dadN1(3)*(C(1)-A(1)) &
+      &       +dadN2(1)*(D(3)-C(3))+dadN2(3)*(C(1)-D(1)))
+      dphidB(3) = sig*(dadN1(1)*(C(2)-A(2))+dadN1(2)*(A(1)-C(1)) &
+      &       +dadN2(1)*(C(2)-D(2))+dadN2(2)*(D(1)-C(1)))
 
-      dphidC(1) = sig * (dadN1(2) * (A(3) - B(3)) + dadN1(3) * (B(2) - A(2)) &
-      &       + dadN2(2) * (D(3) - B(3)) + dadN2(3) * (B(2) - D(2)))
-      dphidC(2) = sig * (dadN1(1) * (B(3) - A(3)) + dadN1(3) * (A(1) - B(1)) &
-      &       + dadN2(1) * (B(3) - D(3)) + dadN2(3) * (D(1) - B(1)))
-      dphidC(3) = sig * (dadN1(1) * (A(2) - B(2)) + dadN1(2) * (B(1) - A(1)) &
-      &       + dadN2(1) * (D(2) - B(2)) + dadN2(2) * (B(1) - D(1)))
+      dphidC(1) = sig*(dadN1(2)*(A(3)-B(3))+dadN1(3)*(B(2)-A(2)) &
+      &       +dadN2(2)*(D(3)-B(3))+dadN2(3)*(B(2)-D(2)))
+      dphidC(2) = sig*(dadN1(1)*(B(3)-A(3))+dadN1(3)*(A(1)-B(1)) &
+      &       +dadN2(1)*(B(3)-D(3))+dadN2(3)*(D(1)-B(1)))
+      dphidC(3) = sig*(dadN1(1)*(A(2)-B(2))+dadN1(2)*(B(1)-A(1)) &
+      &       +dadN2(1)*(D(2)-B(2))+dadN2(2)*(B(1)-D(1)))
 
-      dphidD(1) = sig * (dadN2(2) * (B(3) - C(3)) + dadN2(3) * (C(2) - B(2)))
-      dphidD(2) = sig * (dadN2(1) * (C(3) - B(3)) + dadN2(3) * (B(1) - C(1)))
-      dphidD(3) = sig * (dadN2(1) * (B(2) - C(2)) + dadN2(2) * (C(1) - B(1)))
+      dphidD(1) = sig*(dadN2(2)*(B(3)-C(3))+dadN2(3)*(C(2)-B(2)))
+      dphidD(2) = sig*(dadN2(1)*(C(3)-B(3))+dadN2(3)*(B(1)-C(1)))
+      dphidD(3) = sig*(dadN2(1)*(B(2)-C(2))+dadN2(2)*(C(1)-B(1)))
 
       return
     end subroutine dtorsdr
@@ -711,7 +867,7 @@
   end subroutine dihedral_constraint
 
 !========================================================================================!
-!> subroutien create_sphere_constraint
+!> subroutine create_sphere_constraint
 
   subroutine create_sphere_constraint_all(self,n,r,k,alpha,logfermi)
     implicit none
@@ -753,12 +909,42 @@
     do i = 1,n
       if (atms(i)) self%atms(i) = i
     end do
-    self%ref = r
+    self%ref(:) = r
     self%fc(1) = k
     self%fc(2) = alpha
     return
   end subroutine create_sphere_constraint
 
+  subroutine create_ellips_constraint(self,n,atms,r,k,alpha,logfermi)
+    implicit none
+    class(constraint) :: self
+    integer,intent(in) :: n
+    logical,intent(in) :: atms(n)
+    real(wp),intent(in) :: r(3)
+    real(wp) :: k,alpha
+    logical,intent(in) :: logfermi
+    integer :: i,c
+
+    call self%deallocate()
+    if (logfermi) then
+      self%type = wall_fermi
+    else
+      self%type = wall
+    end if
+    c = count(atms,1)
+    self%n = c
+    allocate (self%atms(c))
+    allocate (self%fc(2),source=fcdefault)
+    allocate (self%ref(3),source=r)
+    do i = 1,n
+      if (atms(i)) self%atms(i) = i
+    end do
+    self%ref(:) = r(:)
+    self%fc(1) = k
+    self%fc(2) = alpha
+    return
+  end subroutine create_ellips_constraint
+
   subroutine sphere_update_nat(self,n,atms)
     implicit none
     class(constraint) :: self
@@ -767,11 +953,11 @@
     integer :: c,i
     c = count(atms,1)
     self%n = c
-    if(allocated(self%atms))deallocate(self%atms)
-    allocate(self%atms(c))
-    do i=1,n
+    if (allocated(self%atms)) deallocate (self%atms)
+    allocate (self%atms(c))
+    do i = 1,n
       if (atms(i)) self%atms(i) = i
-    enddo
+    end do
     return
   end subroutine sphere_update_nat
 !========================================================================================!
@@ -794,10 +980,15 @@
     energy = 0.0_wp
     grd = 0.0_wp
 
-    if (.not. allocated(constr%atms)) return
-    if (.not. allocated(constr%ref)) return
-    if (.not. allocated(constr%fc)) return
+    if (.not.allocated(constr%atms)) return
+    if (.not.allocated(constr%ref)) return
+    if (.not.allocated(constr%fc)) return
 
+    !>--- xtb defaults are:
+    !> sphere_alpha = 30
+    !> sphere_beta  = 6.0_wp
+    !> sphere_temp  = 300.0_wp
+
     do i = 1,n
       iat = constr%atms(i)
       select case (subtype)
@@ -805,40 +996,41 @@
         return
       case (wall)
         !>
-        !> V = k*Σ(|R-O|/Rref)^α 
+        !> V = k*Σ(|R-O|/Rref)^α
         !>
         k = constr%fc(1)
         alpha = constr%fc(2)
-        dalpha = alpha - 1.0_wp
+        dalpha = alpha-1.0_wp
         x = xyz(1,iat)
         y = xyz(2,iat)
         z = xyz(3,iat)
         a = constr%ref(1)
         b = constr%ref(2)
         c = constr%ref(3)
-        dist = (x / a)**2 + (y / b)**2 + (z / c)**2
-        energy = energy + k * (dist**alpha)
-        dx = 2.0_wp * (x / (a**2))
-        dy = 2.0_wp * (y / (b**2))
-        dz = 2.0_wp * (z / (c**2))
-        ddist = k * alpha * (dist**dalpha)
-        grd(1,iat) = ddist * dx
-        grd(2,iat) = ddist * dy
-        grd(3,iat) = ddist * dz
+        dist = (x/a)**2+(y/b)**2+(z/c)**2
+        energy = energy+k*(dist**alpha)
+        dx = 2.0_wp*(x/(a**2))
+        dy = 2.0_wp*(y/(b**2))
+        dz = 2.0_wp*(z/(c**2))
+        ddist = k*alpha*(dist**dalpha)
+        grd(1,iat) = ddist*dx
+        grd(2,iat) = ddist*dy
+        grd(3,iat) = ddist*dz
+
       case (wall_fermi)
         !>
-        !> V = Σ kT*log{1+exp[β(|R-O|-Rref)]} 
+        !> V = Σ kT*log{1+exp[β(|R-O|-Rref)]}
         !>
         T = constr%fc(1)
         beta = constr%fc(2)
         ref = maxval(constr%ref(1:3))
-        w(1:3) = ref / constr%ref(1:3)
-        r = w * (xyz(1:3,iat))
+        w(1:3) = ref/constr%ref(1:3)
+        r = w*(xyz(1:3,iat))
         dist = sqrt(sum(r**2))
-        expo = exp(beta * (dist - ref))
-        fermi = 1.0_wp / (1.0_wp + expo)
-        energy = energy + kB * T * log(1.0_wp + expo)
-        grd(:,iat) = grd(:,iat) + kB * T * beta * expo * fermi * (r * w) / (dist + 1.0e-14_wp)
+        expo = exp(beta*(dist-ref))
+        fermi = 1.0_wp/(1.0_wp+expo)
+        energy = energy+kB*T*log(1.0_wp+expo)
+        grd(:,iat) = grd(:,iat)+kB*T*beta*expo*fermi*(r*w)/(dist+1.0e-14_wp)
       case (box)
 
       case (box_fermi)
@@ -882,8 +1074,6 @@
     return
   end subroutine create_gapdiff_constraint2
 
-
-
-
+!========================================================================================!
 !========================================================================================!
 end module constraints
Index: src/calculator/meson.build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nsrcs += files(\n  'calculator.F90',\n  'calc_type.f90',\n  'constraints.f90',\n  'gfn0_api.F90',\n  'gfnff_api.F90',\n  'lj.f90',\n  'nonadiabatic.f90',\n  'tblite_api.F90',\n  'api_helpers.F90',\n  'api_engrad.f90', \n  'gradreader.f90',\n  'xhcff.F90',\n  'xtb_sc.f90',\n  'generic_sc.f90',\n)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/meson.build b/src/calculator/meson.build
--- a/src/calculator/meson.build	
+++ b/src/calculator/meson.build	
@@ -21,6 +21,7 @@
   'gfn0_api.F90',
   'gfnff_api.F90',
   'lj.f90',
+  'lwoniom.F90', 
   'nonadiabatic.f90',
   'tblite_api.F90',
   'api_helpers.F90',
@@ -28,5 +29,9 @@
   'gradreader.f90',
   'xhcff.F90',
   'xtb_sc.f90',
+  'subprocess_types.f90',
+  'orca_sc.f90',
   'generic_sc.f90',
+  'turbom_sc.f90',
+  'subprocess_engrad.f90',
 )
Index: src/confparse.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> ARGUMENT PARSER FOR CREST\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n!> The parseflags routine does at one expects from\n!> its name, but also some other things as setting\n!> several defaults for the program.\n!> This is the program initialization.\n!>\n!> Input/Output:\n!>  env  -  crest's systemdata object, which\n!>          contains basically all information\n!>          for the calculation\n!>  arg  -  an array of the command line args\n!>          that were read in the beginning\n!>  nra  -  number of command line args in \"arg\"\n!>-----------------------------------------------\nsubroutine parseflags(env,arg,nra)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use crest_calculator\n  use iomod\n  use strucrd\n  use dynamics_module\n  use optimize_module\n  use parse_inputfile\n  implicit none\n  type(systemdata),intent(inout) :: env\n  integer,intent(in) :: nra\n  real(wp),allocatable :: xx(:),floats(:)\n  character(len=256),allocatable :: strings(:)\n  character(len=*) :: arg(nra)\n  character(len=1024) :: cmd\n  character(len=512) :: atmp,btmp\n  character(len=:),allocatable :: ctmp,dtmp\n  integer :: i,j,k,l,io,ich,idum\n  real(wp) :: rdum\n  integer :: ctype\n  logical :: ex,bondconst\n  character(len=:),allocatable :: argument\n\n  allocate (xx(10),floats(3),strings(3))\n  ctmp = ''\n  dtmp = ''\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> Set the defaults\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n  do i = 1,nra\n    if (any((/'--GUI','--gui'/) == trim(arg(i)))) gui = .true.\n    if ('-niceprint' == trim(arg(i))) env%niceprint = .true.\n    if (any((/character(9)::'-version','--version'/) == trim(arg(i)))) then\n      call confscript_head(.true.)\n      stop\n    end if\n  end do\n\n!=========================================================================================!\n!>--- print the program header and command line input\n  if (.not. gui) then\n    call confscript_head(.false.)\n\n    write (*,'(/,1x,a)') 'Command line input:'\n    call get_command(cmd)\n    write (*,'(1x,a,a,/)') '> ',trim(cmd)\n  end if\n\n!=========================================================================================!\n!>--- check if help is requested or citations shall be diplayed\n  do i = 1,nra\n    if (any((/character(6)::'-h','-H','--h','--H','--help'/) == trim(arg(i)))) then\n      call confscript_help()\n    end if\n    if (any((/character(10)::'-cite','--cite','--citation'/) == trim(arg(i)))) then\n      call crestcite()\n    end if\n    if (index(arg(i),'-newversion') .ne. 0)then !> as in CREST version >= 3.0\n      env%legacy = .false. \n    endif\n    if (index(arg(i),'-legacy') .ne. 0)then  !> as in CREST version <3.0\n      env%legacy = .true.\n    endif\n    if (index(arg(i),'-dry').ne.0)then   !> \"dry\" run to print settings \n        env%dryrun = .true.\n    endif\n  end do\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!>    D E F A U L T   S E T T I N G S\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n!&<\n!>--- parallelization stuff\n  env%Threads = 1                !> total number of threads\n  env%MAXRUN = 1                 !> number of parallel xtb jobs\n  env%omp = 1                    !> # of OMP_NUM_THREADS and MKL_NUMTHREADS to be used\n  env%autothreads = .true.       !> automatically determine optimal parameters omp and MAXRUN\n  env%threadssetmanual = .false. !> did the user set the #threads manually?\n\n  env%scratch = .false.          !> use scratch directory?\n  env%scratchdir = ''            !> directory that shall be used for scratch\n\n!>--- xtb settings\n  env%ProgName = 'xtb'           !> the name of the xtb executable used per default\n  env%ProgIFF = 'xtbiff'         !> name of the IFF that is per default xtbiff, only for  QCG\n  env%optlev = 2.0d0             !> optimization level for the GFN-xTB optimizations in ALL steps\n  env%gbsa = .false.             !> use GBSA (or ALPB)\n  env%solv = ''                  !> if gbsa is used, the entrie flag will be written into here\n  env%chrg = 0                   !> molecular chrg\n  env%uhf = 0                    !> nα-nβ electrons\n  env%gfnver = '--gfn2'          !> selct the GFN verison as complete flag(!)\n  env%gfnver2 = ''               !> a second level, used for multilevel post-optimization\n  env%ensemble_opt = '--gff'     !> qcg specific method for ensemble search and optimization\n\n!--- cregen settings\n  env%confgo = .false.           !> perform confg (cregen) subroutine only\n  env%methautocorr = .false.     !> for the \"-metac\" flag\n  env%printscoords = .false.     !> write scoord.* files?\n  env%doNMR = .false.            !> option for the very last confg call\n  env%elowest = 0.0d0            !> energy of the lowest conformer\n  env%ENSO = .false.             !> some options for CREST usage within ENSO\n  env%subRMSD = .false.          !> use only the RMSD of the selected atoms (e.g. if given bei atomlist+/-) in CREGEN\n\n  env%newcregen = .true.         !> use the re-written version of CREGEN?\n  env%checktopo = .true.       !> check topology (neighborlists) in CREGEN\n  env%checkiso = .false.       !> check for E/Z C=C isomerizations\n\n!>--- important: DEFAULT THRESHOLDS\n  env%ewin = 6.0d0    !> EWIN - energy window in kcal/mol (for confg and confcross)\n  env%rthr = 0.125d0  !> RTHR - RMSD thr in Angstroem\n  env%ethr = 0.05d0   !> ETHR - E threshold in kcal\n  env%ethrpurge = 0.20d0   !> ETHRPURGE - E threshold in kcal (purgemode)\n  env%couthr = 0.1d0    !> COUTHR - CREGEN coulomb energy threshold\n  env%thresholds(4) = 15.0d0   !> BTHR - rot.const. thr., A B and C in MHz\n  env%bthr2 = 0.01d0   !> BTHR2 - rot.const relative deviation\n  env%bthrmax = 0.025d0  !> max value of BTHR2 for anisotropic rot. const.\n  env%bthrshift = 0.5d0    !> BHTR2 anisotropy error-function shift\n  env%athr = 0.04d0   !> ATHR -to det. int. rotation. equal atoms for NMR, CRITICAL!\n  env%pthr = 0.05d0   !> PTHR - population thr (I don't really know why we have this)\n  env%pthrsum = 0.85d0   !> PTHRSUM - sum of populations threshold\n  env%tboltz = 298.15d0 !> T - Temperature for Boltzmann weights\n  env%esort = .false.  !> legacy option for energy sorting only in cregen\n\n  !---set default logical options for confg\n  env%cgf(1) = .false.         !> DEBUG\n  env%cgf(2) = .true.          !> NEWFILE\n  env%cgf(3) = .false.         !> ANAL\n  env%cgf(4) = .false.         !> HEAVY - compare only heavy atoms + OH in RMSD\n  env%cgf(5) = .true.          !> RMSDCHK\n  env%cgf(6) = .false.         !> write confg output to file <tmp> instead of <confg.out>\n\n!>--- general runtype settings (shared for V1 & V2 and other functionallities)\n  env%autozsort = .false.      !> zsort at the beginning\n  env%onlyZsort = .false.      !> perform only the zsort routine\n  env%performCross = .true.    !> do the GC in V1 and V2\n  env%slow = .false.\n  env%setgcmax = .false.       !> adjust max. number of structures for GC?\n  env%quick = .false.          !> use loose options for a quick conformation search\n  env%superquick = .false.     !> very crude variant of quick-mode\n  env%niceprint = .false.      !> progressbar printout for some of the steps\n  env%multilevelopt = .true.   !> perform multilevel optimization\n  env%trackorigin = .true.     !> for v2 track generation step by default\n  env%compareens = .false.     !> compare two given ensembles\n  env%maxcompare = 10          !> maximum number of (lowest) conformers to compare when using \"-compare\"\n  env%QCG = .false.          !> special QCG usage\n\n!>--- The following settings are mainly for v.1 (MF-MD-GC)\n  env%level = 1             !> full number of modes\n  env%performMD = .true.    !do the MD in V1\n  env%keepModef = .true.    !keep the MODEF* directories ate the end?\n  !>---some md defaults\n  env%mdmode = 0            !1=qmdff, 0=normal md\n  env%mdtime = -1.0d0       !dummy argument, the actual MD length is set depending\n  !on the number of atoms and number of meta-MDs\n  env%snapshots = 100       !number of snapshots to be taken from the MD\n  env%temps = -1            !dummy argument for normMDs\n  env%shake = 2             !SHAKE on\n  env%mdtemps = 0\n  env%nrotammds = -1    !number of normMDs (-1 means that a default will be set automatically)\n  env%mdtemps(1:3) = (/500,400,300/) !default temperatures for the 3 QMDFF MDs\n\n!>--- Mixed MD settings required by iMTD-GC (V2)\n  env%hmass = 2.0d0       ! if hmass=0, hmass is taken from the .xtbrc\n  env%mdtemp = 300.d0     ! Due to Guiding Force the Temperature is not so important\n  env%nmdtemp = 400.0d0   ! base temperature for additional normal MDs \n  env%mdstep = 5.0d0      ! 4 fs\n  env%shake = 2           ! shake 1 makes it more stable but requires mdstep 2.0\n  env%mddumpxyz = 100     ! if not set by the user mddumpxyz is adjusted in subroutine\n  env%mdskip = 1          ! 1 --> no structure is skipped\n  env%mddump = 1000       ! Vbias dump in fs, e.g. every 2 ps new Vbias\n  env%scallen = .false.   ! scale md length?\n  env%mdlenfac = 1.0d0     ! md length scaling factor\n  env%hlowopt = 0.005d0   ! ancopt\n  env%microopt = 20d0     !  \"\n  env%s6opt = 20.0d0      !  \"\n  env%Maxrestart = 5       !maximum number of restarts\n\n!--- Settings for MTD-GC (V2)\n  env%restartopt = .false.  !> jump to second iteration of the Multilevel optimization (V2 only)\n  env%rotamermds = .true.   !> do some additional mds for the lowermost conformers in V2 (after first step of multilevel optimization)\n  env%gcmultiopt = .true.   !> optimize in two steps after GC (loose/vtight) in V2 ? !SG\n  env%performMTD = .true.   !> do the MTD in V2\n  env%metadynset = .false.  !> is the metadyn prepared? (V2)\n  env%useqmdff = .false.    !> use qmdff for the MDs?\n  env%iru = .false.         !> re-use previously found conformers as bias in iterative approach\n  !>--- array to determine if RMSD are included\n  env%keepModef = .false.   !> delete intermediate Directories\n  env%nmetadyn = 0          !> number of METADYNs (dummy argument at this point; set later)\n\n  env%forceconst = 0.02_wp !> force constant (mainly for GFN-FF iMTD-GC)\n  bondconst = .false.      !> constrain all bonds\n  ctype = 0                !> bond constraint type\n\n  env%NCI = .false.      !> use specialized NCI mode?\n  env%potscal = 1.0d0    !> scale automatically set wall potential by this factor\n\n!>--- get CHRG and UHF if the respective files are present\n  inquire (file='.CHRG',exist=ex)\n  if (any(index(arg,'-chrg') .ne. 0)) ex = .false.\n  if (ex) then\n    call rdshort('.CHRG',env%chrg)\n    if (env%chrg .ne. 0) then\n      write (*,'(2x,a,i0)') 'molecular charge read from .CHRG:  ',env%chrg\n    end if\n  end if\n  inquire (file='.UHF',exist=ex)\n  if (any(index(arg,'-uhf') .ne. 0)) ex = .false.\n  if (ex) then\n    call rdshort('.UHF',env%uhf)\n    if (env%uhf .ne. 0) then\n      write (*,'(2x,a,i0)') 'nα-nβ electrons read from .UHF:  ',env%uhf\n    end if\n  end if\n\n!>--- options for constrained conformer sampling\n  env%fixfile = 'none selected'\n\n!>--- options for possible property calculations, mainly protonation/deprotonation/taut. tool\n  env%ptb%popthr = 0.01_wp  !> = 1% population\n  env%ptb%ewin = 30.0_wp  !> 30 kcal for protonation\n  env%ptb%swat = 0\n  env%ptb%swchrg = 0\n  env%ptb%iter = 1           !> number of iteration cycles for tautomerization\n  env%ptb%swelem = .false. !> replace H⁺ in protonation routine by something else?\n  env%ptb%allowFrag = .false. !> allow dissociated Structures?\n  env%ptb%threshsort = .false. !> use ewin threshold window\n  env%ptb%protdeprot = .false. !> (tautomerize) do first protonation and then deprotonation\n  env%ptb%deprotprot = .false. !> (tautomerize) do first deprotonation and then protonation\n  env%ptb%strictPDT = .false.  !> strict mode (i.e. bond constraints) for (de)protonation,tautomerization\n  !call protreffrag(env)    !> ref. number of fragments in file\n  env%pclean = .false.       !> cleanup option for property mode\n\n!>--- options for principal component analysis (PCA) and clustering\n  !env%pcmeasure='zmat'\n  env%pcmeasure = 'dihedral'\n\n!>--- thermo options\n  env%thermo%trange(1) = 278.15d0  !> T start\n  env%thermo%trange(2) = 380.0d0   !> T stop (approx.)\n  env%thermo%trange(3) = 10.0d0    !> T step\n  env%thermo%ptot = 0.9d0   !> for hessians take x% conformers\n  env%thermo%pcap = 50000   !> limit number of structures\n  env%thermo%sthr = 25.0d0  !> rotor cutoff\n  env%thermo%fscal = 1.0d0   !> frequency scaling factor\n\n!>--- options for QCG\n  env%cff = .true.\n  env%nqcgclust = 0\n  env%freq_scal = 0.75\n  env%freqver = '--gfn2'\n  env%max_solv = 150\n  env%solv_file = ''\n  env%solu_file = ''\n \n!&>\n \n!=========================================================================================!\n!=========================================================================================!\n!> MAIN RUNTYPE SELECTION VIA CMD\n!=========================================================================================!\n!=========================================================================================!\n!>--- get the CREST version/runtype\n  env%crestver = crest_imtd !> confscript version (v.1 = MF-MD-GC, v.2 = MTD)\n  env%runver = 1            !> default\n  env%properties  = p_none  !> additional calculations/options before or after confsearch\n  env%properties2 = p_none  !> backup for env%properties\n  env%iterativeV2 = .true.  !> iterative crest V2 version\n  env%preopt = .true.\n!>--- check for input file\n  do i = 1,nra\n    argument = trim(arg(i))\n    if (argument == '--input' .or. argument == '-i') then\n      call parseinputfile(env,trim(arg(i + 1)))\n      exit\n    end if\n    if (i==1 .and. index(argument,'.toml').ne.0)then\n      call parseinputfile(env,trim(arg(1)))\n      exit\n    endif\n  end do\n!>--- first arg loop\n  do i = 1,nra\n    argument = trim(arg(i))\n    if (argument(1:2) == '--') then\n      argument = argument(2:)\n    end if\n    if (argument .ne. '') then\n      select case (argument) !> RUNTYPES\n\n      case ('-v1') !> confscript version 1 (MF-MD-GC)\n        env%crestver = crest_mfmdgc\n        write (*,'(2x,a,'' : MF-MD-GC'')') trim(arg(i))\n        env%mdtime = 40.0d0       !simulation length of the MD, 40ps total (2*20ps)(default for QMDFF would be 500)\n        env%temps = 1             !number of default MD cycles\n        env%Maxrestart = 15\n        env%performModef = .true. !do the MF in V1\n        env%trackorigin = .false.      !for v1 there is not much insight from this\n        exit\n\n      case ('-v2') !> confscript version 2 (MTD-GC)\n        env%crestver = crest_imtd\n        write (*,'(2x,a,'' : MTD-GC'')') trim(arg(i))\n        env%iterativeV2 = .false.  !iterative crest V2 version\n        env%Maxrestart = 1       !for non-iterative MTD-GC only\n        exit\n\n      case ('-v3','-v2i') !> confscript version 2 but iterativ (iMTD-GC)\n        env%crestver = crest_imtd\n        env%iterativeV2 = .true.\n        write (*,'(2x,a,'' : iMTD-GC'')') trim(arg(i))\n        exit\n\n      case ('-v4') !> sMTD-iMTD (same as entropy mode)\n        env%crestver = crest_imtd2\n        env%iterativeV2 = .true.\n        env%entropymd = .true.\n        env%rotamermds = .false.\n        env%performCross = .false.\n        env%emtd%maxfallback = 1\n        write (*,'(2x,a,'' : iMTD-sMTD'')') trim(arg(i))\n        exit\n\n      case ('-mdopt','-purge') !> MDOPT\n        env%crestver = crest_mdopt\n        atmp = ''\n        env%preopt = .false.\n        env%ensemblename = 'none selected'\n        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))\n        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then\n          env%ensemblename = trim(atmp)\n        end if\n        call xyz2coord(env%ensemblename,'coord') !write coord from lowest structure\n        env%inputcoords = env%ensemblename !just for a printout\n        exit\n\n      case ('-screen')  !> SCREEN\n        env%crestver = crest_screen\n        atmp = ''\n        env%ensemblename = 'none selected'\n        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))\n        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then\n          env%ensemblename = trim(atmp)\n        end if\n        call xyz2coord(env%ensemblename,'coord') !write coord from lowest structure\n        env%inputcoords = env%ensemblename !just for a printout\n        exit\n     \n      case ('-pka','-pKa')  !> pKa calculation script\n        env%crestver = crest_pka\n        env%runver = 33\n        !env%relax=.true.\n        env%performCross = .false.    !skip the genetic crossing\n        env%trackorigin = .false.\n        env%Maxrestart = 1\n        env%ptb%ewin = 15.0d0\n        env%gbsa = .true.\n        env%solv = '--alpb h2o'\n        env%ptb%h_acidic = 0\n        call pka_argparse(arg(i + 1),env%ptb%h_acidic)\n        if (env%ptb%h_acidic == -2) env%ptb%pka_baseinp = trim(arg(i + 1))\n\n      case ('-compare')   !> flag for comparing two ensembles, analysis tool\n        env%compareens = .true.\n        env%crestver = 5\n        env%properties = p_compare\n        env%ensemblename = 'none selected'\n        env%ensemblename2 = 'none selected'\n        if (nra .ge. (i + 2)) then\n          atmp = adjustl(arg(i + 1))\n          btmp = adjustl(arg(i + 2))\n        else\n          write (*,'(a,a)') trim(arg(i)),' requires two arguments:'\n          write (*,'(2x,a,a)') trim(arg(i)),' [ensemble1] [ensemble2]'\n          error stop\n        end if\n        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1) .and. &\n        &  (btmp(1:1) /= '-') .and. (len_trim(btmp) .ge. 1)) then\n          env%ensemblename = trim(atmp)\n          env%ensemblename2 = trim(btmp)\n        end if\n        write (*,'(1x,a,1x,a,1x,a)') trim(arg(i)),trim(env%ensemblename),trim(env%ensemblename2)\n        exit\n\n      case ('-protonate') !>protonation tool\n        env%properties = p_protonate\n        write (*,'(2x,a,'' : automated protonation script'')') trim(arg(i))\n        exit\n\n      case ('-deprotonate') !> deprotonation tool\n        env%properties = p_deprotonate\n        write (*,'(2x,a,'' : automated deprotonation script'')') trim(arg(i))\n        exit\n\n      case ('-tautomerize') !> tautomerization tool\n        env%properties = p_tautomerize\n        write (*,'(2x,a,'' : automated tautomerization script'')') trim(arg(i))\n        exit\n\n      case ('-isomerize','-stereomers') !> isomerization tool\n        env%properties = p_isomerize\n        write (*,'(2x,a,'' : automated stereoisomerization script'')') trim(arg(i))\n        write (*,'(2x,''Note: Use of GFN-FF required for stereoisomer generation.'')')\n        exit\n\n      case ('-forall','-for') !> property mode with ensemble as input\n        env%properties = p_propcalc\n        atmp = ''\n        env%ensemblename = 'none selected'\n        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))\n        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then\n          env%ensemblename = trim(atmp)\n        end if\n        inquire (file=env%ensemblename,exist=ex)\n        if (.not. ex) then\n          write (*,'(1x,a,a,a)') 'invalid ensemble file <',trim(env%ensemblename),'>. exit.'\n          error stop\n        end if\n        call xyz2coord(env%ensemblename,'coord') !write coord from lowest structure\n        env%inputcoords = env%ensemblename !just for a printout\n        if (argument == '-forall') then\n          env%ptb%alldivers = .true.\n        end if\n        exit\n\n      case ('-rrhoav')  !> Hessians along given ensemble and average\n        env%properties = p_rrhoaverage\n        atmp = ''\n        env%ensemblename = 'none selected'\n        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))\n        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then\n          env%ensemblename = trim(atmp)\n        end if\n        inquire (file=env%ensemblename,exist=ex)\n        if (.not. ex) then\n          write (*,'(1x,a,a,a)') 'invalid ensemble file <',trim(env%ensemblename),'>. exit.'\n          error stop\n        end if\n        exit\n\n      case ('-reactor')  !> xtb nanoreactor workarounds\n        env%preopt = .false.\n        env%crestver = crest_nano\n        exit\n\n      case ('-solvtool','-qcg')\n!               env%mddumpxyz = 1000\n        env%preopt = .false.\n        env%crestver = crest_solv\n        env%QCG = .true.\n        env%runver = 3\n        env%performCross = .false.\n        env%optlev = 0 !If QCG is invoked, optlevel default is normal\n        env%properties = p_qcg\n        env%ewin = 3.0d0\n        env%doOHflip = .false. !Switch off OH-flip\n        if (env%iterativeV2) env%iterativeV2 = .false.\n        if (nra >= i + 1) then\n           env%solv_file = trim(arg(i + 1))\n        endif  \n        exit\n\n      case ('-compress')\n        env%crestver = crest_compr\n        env%runver = 77\n        env%mdstep = 2.5d0\n        env%mddump = 2000\n        env%autozsort = .false.\n        exit\n\n      case ('-msreact')\n        env%crestver = crest_msreac\n        env%preopt = .false.\n        env%presp = .true.\n\n      case ('-splitfile')\n        ctmp = trim(arg(i + 1))\n        k = huge(j)\n        l = 1\n        if (nra >= i + 2) then\n          read (arg(i + 2),*,iostat=io) j\n          if (io == 0) then\n            k = j\n          end if\n        end if\n        if (nra >= i + 3) then\n          read (arg(i + 3),*,iostat=io) j\n          if (io == 0) then\n            l = j\n          end if\n        end if\n        call splitfile(ctmp,k,l)\n        stop\n\n      case ('-printaniso')\n        ctmp = trim(arg(i + 1))\n        inquire (file=ctmp,exist=ex)\n        if (ex) then\n          call printaniso(ctmp,0.01_wp,0.025_wp,0.5_wp)\n        end if\n        stop\n\n      case ('-printboltz')\n        if (nra >= i + 2) then\n          ctmp = trim(arg(i + 1))\n          dtmp = trim(arg(i + 2))\n          call prbweight(ctmp,dtmp)\n        else\n          ctmp = trim(arg(i + 1))\n          call prbweight(ctmp,'')\n        end if\n\n      case ('-wbotopo','-usewbo')  !> try to use a WBO file in topology analysis\n        ctmp = trim(arg(i + 1))\n        if (ctmp(1:1) .ne. '-' .and. (nra >= i + 1)) then\n          env%wbofile = trim(ctmp)\n        else\n          env%wbofile = 'wbo'\n        end if\n        env%wbotopo = .true.\n\n      case ('-testtopo')\n        ctmp = trim(arg(i + 1))\n        inquire (file=ctmp,exist=ex)\n        if (i + 2 .le. nra) then\n          dtmp = trim(arg(i + 2))\n          if (dtmp(1:1) == '-') then\n            dtmp = 'default'\n          end if\n        end if\n        if (ex) then\n          call testtopo(ctmp,env,dtmp)\n        end if\n\n      case ('-resortensemble')\n        ctmp = trim(arg(i + 1))\n        inquire (file=ctmp,exist=ex)\n        if (ex) then\n          call resort_ensemble(ctmp)\n        end if\n        stop\n\n      case ('-thermo','-thermotool')\n        env%properties = p_thermo\n        ctmp = trim(arg(1))  !either first argument\n        if (ctmp(1:1) .ne. '-') then\n          env%inputcoords = trim(ctmp)\n        end if\n        ctmp = trim(arg(i + 1)) !or this\n        if (ctmp(1:1) .ne. '-') then\n          env%inputcoords = trim(ctmp)\n        end if\n\n      case ('-rmsd','-rmsdheavy')\n        ctmp = trim(arg(i + 1))\n        dtmp = trim(arg(i + 2))\n        if (argument == '-rmsdheavy') then\n          call quick_rmsd_tool(ctmp,dtmp,.true.)\n        else\n          call quick_rmsd_tool(ctmp,dtmp,.false.)\n        end if\n        stop\n\n      case ('-symmetries')\n        ctmp = trim(arg(i + 1))\n        inquire (file=ctmp,exist=ex)\n        if (ex) then\n          call ensemble_analsym(trim(ctmp),.true.)\n        end if\n        stop\n\n      case ('-exlig','-exligand','-exchligand')\n        env%properties = p_ligand\n        env%ptb%infile = trim(arg(1))\n        ctmp = trim(arg(i + 1))\n        env%ptb%newligand = trim(ctmp)\n        read (arg(i + 2),*,iostat=io) j\n        if (io == 0) then\n          env%ptb%centeratom = j\n        end if\n        read (arg(i + 3),*,iostat=io) j\n        if (io == 0) then\n          env%ptb%ligand = j\n        end if\n        exit\n\n      case (\"-acidbase\",\"-ab\",'-abprep','-pkaprep','-gdissprep')  !-- acid base correction\n        !> crest --ab <acid.xyz> <base.xyz> --chrg <acidchrg>\n        env%properties = p_acidbase\n        if (index(arg(i),'prep') .ne. 0) then\n          call pka_argparse2(env,arg(i + 1),arg(i + 2),env%ptb%pka_mode)\n        else\n          ctmp = trim(arg(i + 1))\n          inquire (file=ctmp,exist=ex)\n          if (ex) then\n            env%ptb%pka_acidensemble = trim(ctmp)\n            write (*,'(1x,a,a)') 'File used for the acid: ',trim(ctmp)\n          end if\n          ctmp = trim(arg(i + 2))\n          inquire (file=ctmp,exist=ex)\n          if (ex) then\n            env%ptb%pka_baseensemble = trim(ctmp)\n            write (*,'(1x,a,a)') 'File used for the base: ',trim(ctmp)\n          end if\n        end if\n        env%solv = '--alpb h2o'\n        env%gfnver = '--gfn2'\n\n      case ('-redoextrapol')\n        ctmp = trim(arg(i + 1))\n        read (arg(i + 2),*,iostat=io) j\n        if (io == 0) then\n          call redo_extrapol(ctmp,j)\n        else\n          call redo_extrapol(ctmp,0)\n        end if\n        stop\n\n\n\n      case( '-sp' ) !> singlepoint calculation (uses new calculator routines)\n        env%crestver = crest_sp\n        env%preopt = .false.\n        env%legacy = .false.\n        exit\n\n      case ('-optimize','-ancopt') !> ANCOPT structure optimization (uses new calculator routines)\n        env%preopt = .false.\n        env%crestver = crest_optimize\n        env%legacy = .false.\n        exit\n\n      case ('-dynamics','-dyn') !> molecular dynamics (uses new calculator routines)\n        env%preopt = .false.\n        env%crestver = crest_moldyn\n        env%legacy = .false.\n        exit\n\n\n\n      case ('-SANDBOX')\n        !>--- IMPLEMENT HERE WHATEVER YOU LIKE, FOR TESTING\n        !>-----\n        stop\n      case ('-PLAYGROUND','-TEST')\n        env%preopt = .false.\n        env%crestver = crest_test\n        exit\n      case default\n        continue\n      end select !> RUNTYPES\n    end if\n  end do\n\n!=========================================================================================!\n!=========================================================================================!\n!=========================================================================================!\n!>--- options for the xtb Nano-reactor\n  if (any((/crest_nano,crest_compr/) == env%crestver)) then\n    env%rdens = -1.0_wp       !> reference density (i.e., =-1 means it is not set here)\n    env%preactormtd = .false.  !> prepare reactor mtd?\n    env%preactorpot = .false.  !> prepare reactor logfermi?\n  end if\n\n!>--- turn off autozsort for additional applications preceeding conf.searches\n  if (env%properties .lt. 0) then\n    env%autozsort = .false.\n  end if\n\n!>--- options for topology related applications.\n  if (.not. allocated(env%wbofile)) then\n    env%wbotopo = .false.\n    env%wbofile = ''\n  end if\n!>    E.g. stereoisomer sampling or rotamer enhancement for entropy calc.\n  if (env%properties == p_isomerize) then\n    env%gfnver = '-gff'    !stereoisomer generation works only with GFN-FF!\n  end if\n  env%tsplit = 5   !timeframe splitting in conformational search for Entropy extrapolation\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!>    I N P U T   C O O R D I N A T E S\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n!> If env%inputcoords is initialized anywhere prior to \n!> this point, it will be taken as the input.\n!> Otherwise, the first cmd argument after \"crest\" will\n!> taken for the input coordinates\n    if (allocated(env%inputcoords)) then\n      call inputcoords(env,env%inputcoords)\n    else\n      call inputcoords(env,trim(arg(1)))\n    end if\n!========================================================================================!\n!> after this point there should always be a \"coord\" file present\n!========================================================================================!\n  allocate (env%includeRMSD(env%nat))\n  env%includeRMSD = 1\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> parse the input flags\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n  do i = 1,nra\n    argument = trim(arg(i))\n    if (argument(1:2) == '--') then\n      argument = argument(2:)\n    end if\n    if (argument .ne. '') then\n!========================================================================================!\n!-------- switch between legacy (systemcall) and new code (API) implementations\n!========================================================================================!\n      select case(argument)\n       case('-legacy')\n         env%legacy = .true.\n       case('-newversion' )\n         env%legacy = .false.\n      end select \n!========================================================================================!\n!-------- flags exclusively for V1 (MF-MD-GC)\n!========================================================================================!\n      if (env%crestver .eq. crest_mfmdgc) then\n        select case (argument) !> V1\n        case ('-m')\n          if (index(arg(i + 1),'ff') .ne. 0) then            !turn on qmdff MD mode\n            !env%mdmode=1\n            write (*,'(2x,a,1x,a,'' :'')') trim(arg(i)),trim(arg(i + 1))\n            !write(*,'(5x,''QMDFF for MD part requested'')')\n            write (*,'(5x,''QMDFF for MD part requested, but this option is discontinued!'')')\n            write (*,'(5x,''Regular xTB MD is performed instead'')')\n          end if\n          if (index(arg(i + 1),'md') .ne. 0) then            !turn on xtb MD mode\n            env%mdmode = 0\n            !env%mdtime=40.0d0\n            write (*,'(2x,a,1x,a,'' :'')') trim(arg(i)),trim(arg(i + 1))\n            write (*,'(5x,''xTB MD for MD part requested'')')\n          end if\n        case ('-loose')\n          env%level = 2     !decreases # modes by factor 2\n        case ('-veryloose','-vloose')\n          env%level = 3    !decreases # modes by factor 3\n        case ('-tight')\n          env%level = 0.7   !increases # modes by factor 0.7\n        case ('-mdtemp')           !set md temperature (V1 version)\n          call readl(arg(i + 1),xx,j)\n          env%mdtemps(1) = xx(1)\n        case ('-addmd')    !add another QMDFF MD at a temperature\n          call readl(arg(i + 1),xx,j)\n          env%temps = env%temps + 1\n          env%mdtemps(env%temps) = xx(1)\n        case ('-nomf')\n          env%performModef = .false.                          !skip the modefollowing\n          write (*,'(2x,a,1x,a)') trim(arg(i)),' : skipping MF part.'\n        case ('-nomd')\n          env%performMD = .false.                             !skip the MD part\n          write (*,'(2x,a,1x,a)') trim(arg(i)),' : skipping MD part.'\n        case ('-shake')    !set shake\n          call readl(arg(i + 1),xx,j)\n          env%shake = nint(xx(1))\n        case ('-quick')    !performing quick conformational search\n          env%quick = .true.\n          env%runver = 2\n          env%performModef = .true.\n          env%performMD = .true.\n          env%performCross = .false.\n          env%optlev = -1.0d0\n          env%temps = 1\n          env%mdtemps(env%temps) = 400\n        case ('-mrest')     !set max number of restarts\n          call readl(arg(i + 1),xx,j)\n          env%Maxrestart = nint(xx(1))\n        case default\n          continue\n        end select !> V1\n      end if\n!========================================================================================!\n!------- flags exclusively for V2 (MTD-GC) V2i/V3 (iMTD-GC) V4 (iMTD-sMTD)\n!========================================================================================!\n      if (any((/crest_imtd,crest_imtd2,11/) == env%crestver)) then\n        select case (argument) !> V2\n        case ('-mdtemp')                          !set MTD temperature (V2 version)\n          call readl(arg(i + 1),xx,j)\n          env%mdtemp = xx(1)\n          env%user_temp = .true.\n        case ('-quick')                           !performing quick conformational search\n          env%quick = .true.\n          env%runver = 2\n          !env%thresholds(1)=5.0d0 !smaller energy window\n          env%ewin = 5.0d0\n          if (env%optlev > 1.0d0) env%optlev = 1.0d0        !optlev tight for quick run\n        case ('-shake')                           !set shake\n          call readl(arg(i + 1),xx,j)\n          env%shake = nint(xx(1))\n        case ('-tstep')                           !set MD timestep in fs\n          call readl(arg(i + 1),xx,j)\n          env%mdstep = xx(1)\n          env%user_mdstep = .true.\n        case ('-vbdump')                          !Vbias dump in ps\n          call readl(arg(i + 1),xx,j)\n          xx(2) = xx(1) * 1000\n          env%mddump = nint(xx(2))\n        case ('-mdskip')                          !set skipping structures in -mdopt\n          call readl(arg(i + 1),xx,j)\n          env%mdskip = nint(xx(1))\n        case ('-mddump')                          !set dumpstep for writing structures out of the md\n          call readl(arg(i + 1),xx,j)\n          env%mddumpxyz = nint(xx(1))\n        case ('-nomtd')                           !Don't do the MTD in V2\n          env%performMTD = .false.\n        case ('-restartopt')                      !go to step 2 of multilevel optimization immideatly\n          env%restartopt = .true.\n          env%autozsort = .false.\n        case ('-norotmd')                         !don't do the regular mds after step 2 in multilevel optimization of V2\n          env%rotamermds = .false.\n        case ('-rotmd')\n          env%rotamermds = .true.\n        case ('-tnmd')                            !temperature for additional normal MDs\n          call readl(arg(i + 1),xx,j)\n          env%nmdtemp = xx(1)\n        case ('-gcmopt')                          !GC multilevel optimization activate in V2\n          env%gcmultiopt = .true.\n        case ('-gcsopt')                          !GC single level optimization in V2\n          env%gcmultiopt = .false.\n        case ('-nogcmopt')                        !GC single level optimization in V2\n          env%gcmultiopt = .false.\n        case ('-qmdff')                           !use QMDFF for the MDs in V2?\n          env%useqmdff = .true.\n        case ('-nci')                             !NCI special mode\n          write (*,'(2x,a,1x,a)') trim(arg(i)),' : Special NCI mode for non-covalently bound complexes or clusters.'\n          env%NCI = .true.\n          env%runver = 4\n          env%autozsort = .false.\n          env%performCross = .false.\n          env%rotamermds = .false.\n        case ('-wscal')                           !scale size of wall potential\n          call readl(arg(i + 1),xx,j)\n          env%potscal = xx(1)\n        case ('-wall')\n          env%wallsetup = .true.\n          write (*,'(2x,a,1x,a)')'--wall:','requesting setup of wall potential'\n        case ( '-wallxl','-wall-xl')\n          env%wallsetup = .true.\n          env%potscal = 1.5_wp\n          write (*,'(2x,a,1x,a)')'--wall-xl:','requesting setup of wall potential (x1.5 size)'\n        case ( '-wallxxl','-wall-xxl') \n          env%wallsetup = .true.\n          env%potscal = 2.0_wp\n          write (*,'(2x,a,1x,a)')'--wall-xxl:','requesting setup of wall potential (x2.0 size)'\n        case ('-squick','-superquick')            !extremely crude quick mode\n          write (*,'(2x,a,1x,a)') trim(arg(i)),' : very crude quick-mode (no NORMMD, no GC, crude opt.)'\n          env%rotamermds = .false.      !no NORMMD\n          env%performCross = .false.    !no GC\n          env%quick = .true.            !MTD settings from the quick-mode\n          env%superquick = .true.       !use user-set opt level in Multilevel opt.\n          env%runver = 5\n          if (env%optlev > 0.0d0) env%optlev = 0.0d0            !user-set opt level\n          !env%thresholds(1)=5.0d0     !smaller energy window\n          env%ewin = 5.0d0              !smaller energy window\n          !env%Maxrestart=1            !remove iterative cycles in V2i\n        case ('-mquick','-megaquick')             !extremely crude quick mode pt.2\n          write (*,'(2x,a,1x,a)') trim(arg(i)),' : very crude quick-mode (no NORMMD, no GC, crude opt.)'\n          env%rotamermds = .false.      !no NORMMD\n          env%performCross = .false.    !no GC\n          env%quick = .true.            !MTD settings from the quick-mode\n          env%superquick = .true.       !use user-set opt level in Multilevel opt.\n          env%Maxrestart = 1            !only one MTD iteration\n          env%runver = 6\n          if (env%optlev > 0.0d0) env%optlev = 0.0d0  !user-set opt level\n          !env%thresholds(1)=2.5d0     !smaller energy window\n          env%ewin = 2.5d0              !smaller energy window\n        case ('-extensive')   !counterpart to quick mode\n          env%slow = .true.\n          env%quick = .false.\n          env%superquick = .false.\n          env%optlev = 0.0d0\n          !env%thresholds(1) = 8.0d0\n          env%ewin = 8.0d0\n          env%runver = 8\n        case ('-static','-staticmtd')\n          env%staticmtd = .true.\n        case default\n          continue\n        end select !> V2\n        !--- iterative version of V2\n        if (env%iterativeV2) then\n          select case (argument) !> V2i\n          case ('-mrest')                  !set max number of restarts\n            call readl(arg(i + 1),xx,j)\n            env%Maxrestart = nint(xx(1))\n          case ('-iru')                    !re-use previously found conformers as bias in iterative approach\n            env%iru = .true.\n          case ('-keepdir','-keeptmp')     ! Do not delete METADYN and NORMMD directories\n            env%keepModef = .true.\n            !env%inplaceMode=.false.\n          case ('-singlerun')                             !QCG special mode\n            write (*,'(2x,a,1x,a)') trim(arg(i)),' : run mode with only a single MTD and no iterations (for tessting)'\n            env%runver = 45\n            env%Maxrestart = 1\n            env%rotamermds = .false.\n          case default\n            continue\n          end select !> V2i\n          !-----\n        end if\n      end if\n!========================================================================================!\n!------- Settings for MDOPT and SCREEN\n!========================================================================================!\n      if (env%crestver == crest_mdopt .or. env%crestver == crest_screen) then\n        select case (argument) !> SCREEN\n        case ('-qmdff')                     !use QMDFF for the MDs in SCREEN/MDOPT?\n          env%useqmdff = .true.\n        case ('-purge')        !Purge special application\n          env%optpurge = .true.\n        case ('-ethrpurge','-ethrp')\n          read (arg(i + 1),*,iostat=io) rdum\n          if (io == 0) env%ethrpurge = rdum\n        case default\n          continue\n        end select !> SCREEN\n      end if\n!========================================================================================!\n!------- Settings for NANO-REACTOR\n!========================================================================================!\n      if (env%crestver == crest_nano) then\n        select case (argument) !> RCTR\n        case ('-genpot')\n          if (i + 1 .le. nra) then\n            atmp = trim(arg(i + 1))\n            if (atmp(1:1) .ne. '-') then\n              call readl(arg(i + 1),xx,j)\n              env%rdens = xx(1)\n            end if\n          end if\n          env%properties = p_reactorset\n          env%preactorpot = .true.\n        case ('-genmtd')\n          env%properties = p_reactorset\n          env%mdtime = 20.0d0\n          if (i + 1 .le. nra) then\n            atmp = trim(arg(i + 1))\n            if (atmp(1:1) .ne. '-') then\n              call readl(arg(i + 1),xx,j)\n              env%mdtime = xx(1)\n            end if\n          end if\n          env%nmetadyn = 1\n          if (.not. allocated(env%metadfac)) then\n            allocate (env%metadfac(1))\n            allocate (env%metadexp(1))\n            allocate (env%metadlist(1))\n          end if\n          env%metadlist(1) = nint(env%mdtime)\n          env%metadexp(1) = 1.00_wp\n          env%metadfac(1) = 0.04_wp\n          env%preactormtd = .true.\n        case ('-fragopt')\n          env%restartopt = .true.\n        case ('-iso')\n          env%riso = .true.\n        case default\n          continue\n        end select !> RCTR\n      end if\n!========================================================================================!\n!------- Flags for QCG\n!========================================================================================!\n      if (env%QCG) then\n        select case (argument) !> QCG\n        case ('-keepdir','-keeptmp')\n          env%keepModef = .true.\n        case ('-tstep')                           !set MD timestep in fs\n          call readl(arg(i + 1),xx,j)\n          env%mdstep = xx(1)\n          env%user_mdstep = .true.\n        case ('-vbdump')                          !Vbias dump in ps\n          call readl(arg(i + 1),xx,j)\n          xx(2) = xx(1) * 1000\n          env%mddump = nint(xx(2))\n        case ('-mdskip')                          !set skipping structures in -mdopt\n          call readl(arg(i + 1),xx,j)\n          env%mdskip = nint(xx(1))\n        case ('-mddump')                          !set dumpstep for writing structures out of the md\n          env%user_dumxyz = .true.\n          call readl(arg(i + 1),xx,j)\n          env%mddumpxyz = nint(xx(1))\n        case ('-nomtd')                           !Don't do the MTD in V2\n          env%performMTD = .false.\n        case ('-wscal')                           !scale size of wall potential\n          call readl(arg(i + 1),xx,j)\n          env%potscal = xx(1)\n          env%user_wscal = .true.\n        case ('-fixsolute')                       !Fix the solute after CMA trafo\n          env%constrain_solu = .true.\n        case ('-nofix')                           !No fixing of the solute after CMA trafo\n          env%noconst = .true.\n!                case( '-fixens' )                          !Constraining the MTD run\n!                   env%ens_const = .true.\n        case ('-restartopt')                      !go to step 2 of multilevel optimization immideatly\n          env%restartopt = .true.\n          env%autozsort = .false.\n        case ('-norotmd')                         !don't do the regular mds after step 2 in multilevel optimization of V2\n          env%rotamermds = .false.\n        case( '-mdtemp' )                          !set MTD temperature (V2 version)\n          call readl(arg(i+1),xx,j)\n          env%mdtemp=xx(1)\n          env%user_temp = .true.\n        case ('-tnmd')                            !temperature for additional normal MDs\n          call readl(arg(i + 1),xx,j)\n          env%nmdtemp = xx(1)\n        case( '-shake' )                          !set shake\n          call readl(arg(i+1),xx,j)\n          env%shake=nint(xx(1))\n        end select !> QCG\n      end if\n!========================================================================================!\n!------- other general flags\n!========================================================================================!\n      select case (argument) !> ARGPARSER1\n      case ('-dry')             !\"dry\" run to print settings\n        env%dryrun = .true.\n      case ('-nozs')\n        env%autozsort = .false.   !turn off automatic zsort\n      case ('-zs')\n        env%autozsort = .true.    !turn on automatic zsort\n      case ('-nocross')\n        env%performCross = .false.    !skip the genetic crossing\n        write (*,'(2x,a,1x,a)') trim(arg(i)),' : skipping GC part.'\n      case ('-cross')\n        env%performCross = .true.     !do the genetic crossing\n        env%autozsort = .true.\n      case ('-opt','-optlev')              !settings for optimization level of GFN-xTB\n        env%optlev = optlevnum(arg(i + 1))\n        write (*,'(2x,a,1x,i0)') trim(arg(i)),nint(env%optlev)\n      case ('-gfn','-gfn1','-gfn2','-gfn0','-gff','-gfnff')\n        ctmp = argument\n        if (argument == '-gfn') then\n          dtmp = trim(arg(i + 1))\n          ctmp = ctmp//dtmp\n        end if\n        if (env%properties == p_isomerize) then\n          ctmp = 'stereoisomers'\n        end if\n        select case (ctmp) !> GFN\n        case ('-gfn1')\n          env%gfnver = '--gfn1'\n          write (*,'(2x,a,'' : Use of GFN1-xTB requested.'')') ctmp\n        case ('-gfn2')\n          env%gfnver = '--gfn2'\n          write (*,'(2x,a,'' : Use of GFN2-xTB requested.'')') ctmp\n        case ('-gfn0')\n          env%gfnver = '--gfn0'\n          write (*,'(2x,a,'' : Use of GFN0-xTB requested.'')') ctmp\n        case ('-gff','-gfnff')\n          env%gfnver = '--gff'\n          write (*,'(2x,a,'' : Use of GFN-FF requested.'')') ctmp\n          env%mdstep = 1.5d0\n          env%hmass = 5.0d0\n          !call autoBondConstraint('coord',env%forceconst,env%wbofile)\n          ctype = 5 !bond constraint\n          bondconst = .true.\n          env%cts%cbonds_md = .true.\n          env%checkiso = .true.\n        case ('stereoisomers')\n          env%gfnver = '--gff'\n        case default\n          env%gfnver = '--gfn2'\n        end select !> GFN\n      case ('-gfn2@gfn0','-gfn2@gfn1','-gfn2@gff','-gfn2@ff','-gfn2@gfnff')\n        if(.not.env%legacy)then !TODO\n         write(*,'(\"> \",a,1x,a)')argument,'option not yet available with new calculator'\n         error stop\n        endif\n        select case (argument) !> GFN2ON\n        case ('-gfn2@gfn0')\n          env%gfnver = '--gfn0'\n        case ('-gfn2@gfn1')\n          env%gfnver = '--gfn1'\n        case ('-gfn2@gff','-gfn2@ff','-gfn2@gfnff')\n          env%gfnver = '--gff'\n          env%mdstep = 2.0d0\n        case default\n          env%gfnver = '--gfn2'\n        end select !> GFN2ON\n        env%gfnver2 = '--gfn2'\n        call env%addjob(51)\n        call env%checkhy()\n        env%reweight = .false.\n      case ('-gfn2//gfnff')\n        if(.not.env%legacy)then !TODO\n         write(*,'(\"> \",a,1x,a)')argument,'option not yet available with new calculator'\n         error stop\n        endif\n        env%gfnver = '--gff'\n        env%mdstep = 2.0d0\n        env%gfnver2 = '--gfn2'\n        env%reweight = .true.\n        env%mdstep = 2.0d0\n        env%hmass = 4.0d0\n        ctype = 1 !bond constraint\n        bondconst = .true.\n        env%cts%cbonds_md = .true.\n        env%checkiso = .true.\n        if (index(arg(i + 1),'opt') .ne. 0) then\n          env%altopt = .true.\n          write (*,'(2x,a,a)') argument,' : GFN-FF MDs + GFN2 opt.'\n        else\n          write (*,'(2x,a,a)') argument,' : energy reweighting'\n        end if\n      case ('-charges') !read charges from file for GFN-FF calcs.\n        ctmp = trim(arg(i + 1))\n        if ((len_trim(ctmp) < 1) .or. (ctmp(1:1) == '-')) then\n          ctmp = 'charges'\n        end if\n        inquire (file=ctmp,exist=ex)\n        if (ex) then\n          env%chargesfilename = ctmp\n          env%chargesfile = .true.\n          write (*,'(2x,a,a,a)') '-charges: file <',trim(ctmp),'> used for atomic charges'\n          call env%ref%rdcharges(env%chargesfilename,idum)\n          if (idum .ne. env%chrg) then\n            write (*,'(12x,a,i0)') 'with total summed up molecular charge: ',idum\n            env%chrg = idum\n            env%ref%ichrg = idum\n          end if\n        end if\n      case ('-dscal','-dispscal','-dscal_global','-dispscal_global')\n        env%cts%dispscal_md = .true.\n        if (index(argument,'_global') .ne. 0) then\n          env%cts%dispscal_global = .true.\n        end if\n        if (nra .ge. i + 1) then\n          ctmp = trim(arg(i + 1))\n          read (ctmp,*,iostat=io) rdum\n          if (io .eq. 0) env%cts%dscal = rdum\n        end if\n      case ('-norestart')\n        env%allowrestart = .false.\n      case ('-readbias')\n        env%readbias = .true.\n      case ('-useonly')\n        env%properties = p_useonly\n        env%autozsort = .false.\n        env%dummypercent = 1.0_wp\n        if (nra .ge. i + 1) then\n          atmp = adjustl(arg(i + 1))\n          if (atmp(1:1) .ne. '-') then\n            read (atmp,*) env%dummypercent\n          end if\n        end if\n\n      case ('-gbsa','-g','-alpb')                                     !use GBSA implicit solvation\n        env%gbsa = .true.\n        atmp = adjustl(arg(i + 1))\n        if (atmp(1:1) .ne. '-' .and. atmp(1:1) .ne. ' ') then\n          env%solvent = arg(i + 1)\n          if (trim(argument) == '-alpb') then\n            env%solv = '--alpb '//trim(env%solvent)\n          else\n            env%solv = '--gbsa '//trim(env%solvent)\n          end if\n        end if\n        write (*,'(2x,a,a)') trim(env%solv),' : implicit solvation'\n\n      case ('-chrg')                                          !create a .CHRG file\n        call readl(arg(i + 1),xx,j)\n        open (newunit=ich,file='.CHRG')\n        env%chrg = nint(xx(1))\n        env%ref%ichrg = env%chrg\n        write (ich,'(i0)') nint(xx(1))\n        close (ich)\n        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))\n\n      case ('-uhf')                                           !create a .UHF file\n        call readl(arg(i + 1),xx,j)\n        open (newunit=ich,file='.UHF')\n        env%uhf = nint(xx(1))\n        env%ref%uhf = env%uhf\n        write (ich,'(i0)') nint(xx(1))\n        close (ich)\n        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))\n\n      case ('-len','-mdlen','-mdtime')                        !set md length in ps\n        atmp = arg(i + 1)\n        call to_lower(atmp)\n        j = index(atmp,'x')\n        env%user_mdtime = .true.\n        if (j .ne. 0) then                ! scaling of the md length\n          btmp = atmp(j + 1:)\n          env%scallen = .true.\n          call readl(btmp,xx,j)\n          env%mdlenfac = xx(1)\n        else                          ! direct setting of the md length\n          call readl(arg(i + 1),xx,j)\n          env%mdtime = xx(1)\n          write (*,'(2x,a,1x,a,1x,a)') trim(arg(i)),trim(arg(i + 1)), &\n          &    '(MD length in ps)'\n        end if\n      case ('-mdscal','-lenscal')                             !scale md length\n        env%scallen = .true.\n        call readl(arg(i + 1),xx,j)\n        env%mdlenfac = xx(1)\n      case( '-nmtd' ) !set number of MTDs\n        env%runver = 787878\n        call readl(arg(i+1),xx,j)\n        env%nmetadyn=nint(xx(1))\n      case ('-gcmax','-setgcmax')                             !set maximum number of structures for GC\n        env%setgcmax = .true.\n        call readl(arg(i + 1),xx,j)\n        env%gcmax = xx(1)\n      case ('-xnam')                                          !select a name for the xTB executeable\n        env%ProgName = trim(arg(i + 1))\n        write (*,'(2x,''-xnam :'')')\n        write (*,'(5x,''xtb executable was set to: \"'',a,''\"'')') trim(env%ProgName)\n      case ('-niceprint')                                     !progres bar printout\n        env%niceprint = .true.\n      case ('-origin')                                        !track the origin (i.e. the generation step) of each conformer\n        env%trackorigin = .true.\n        write (*,'(2x,a,1x,a)') trim(arg(i)),': tracking conformer origins.'\n      case ('-constrain')                       !provide a list of atoms to write a .xcontrol.sample\n        ctmp = trim(arg(i + 1))\n        call quick_constrain_file('coord',env%nat,env%ref%at,ctmp)\n      case ('-nocbonds')\n        bondconst = .false.\n        env%cts%cbonds_global = .false.\n        env%cts%cbonds_md = .false.\n        inquire (file='bondlengths',exist=ex)\n        if (ex) call remove('bondlengths')\n      case ('-cbonds','-cbonds_md','-cbonds_ez')            !constrain all bonds\n        ctmp = trim(arg(i + 1))\n        if (ctmp(1:1) .ne. '-') then\n          read (ctmp,*,iostat=io) rdum\n          if (io .eq. 0) env%forceconst = rdum\n        end if\n        ctype = 1\n        bondconst = .true.\n        env%cts%cbonds_global = .true.\n        if (index(argument,'_md') .ne. 0) then !if the bond constraint shall be present only in the MDs/MTDs\n          env%cts%cbonds_md = .true.\n          env%cts%cbonds_global = .false.\n        end if\n        if (index(argument,'_ez') .ne. 0) then !if the bond constraint shall be present only in the MDs/MTDs\n          ctype = 5\n        end if\n      case ('-cmetal','-cmetal_md')              !constrain transition metal coordination sites\n        ctmp = trim(arg(i + 1))\n        if (ctmp(1:1) .ne. '-') then\n          read (ctmp,*,iostat=io) rdum\n          if (io .eq. 0) env%forceconst = rdum\n        end if\n        ctype = 2\n        bondconst = .true.\n        env%cts%cbonds_global = .true.\n        if (index(argument,'_md') .ne. 0) then\n          env%cts%cbonds_md = .true.\n          env%cts%cbonds_global = .false.\n        end if\n      case ('-cheavy','-fixheavy','-cheavy_md')    !constrain all heavy atom bonds\n        ctmp = trim(arg(i + 1))\n        if (ctmp(1:1) .ne. '-') then\n          read (ctmp,*,iostat=io) rdum\n          if (io .eq. 0) env%forceconst = rdum\n        end if\n        ctype = 3\n        bondconst = .true.\n        env%cts%cbonds_global = .true.\n        if (index(argument,'_md') .ne. 0) then\n          env%cts%cbonds_md = .true.\n          env%cts%cbonds_global = .false.\n        end if\n      case ('-clight','-fixhyd','-clight_md')  !constraint all X-H bonds\n        ctmp = trim(arg(i + 1))\n        if (ctmp(1:1) .ne. '-') then\n          read (ctmp,*,iostat=io) rdum\n          if (io .eq. 0) env%forceconst = rdum\n        end if\n        ctype = 4\n        bondconst = .true.\n        env%cts%cbonds_global = .true.\n        if (index(argument,'_md') .ne. 0) then\n          env%cts%cbonds_md = .true.\n          env%cts%cbonds_global = .false.\n        end if\n      case ('-cfile','-cinp')                                 !specify the constrain file\n        ctmp = trim(arg(i + 1))\n        if (ctmp(1:1) .ne. '-') then\n          env%constraints = trim(ctmp)\n          write (*,'(2x,a,1x,a)') trim(argument)//' :',trim(ctmp)\n        end if\n      case ('-fc','-forceconstant')\n        ctmp = trim(arg(i + 1))\n        if (i + 1 >= nra) then\n          call readl(arg(i + 1),xx,j)\n          env%forceconst = xx(1)\n        end if\n        write (*,'(2x,a,f6.4,a)') '-fc ',env%forceconst,': selected force constant in Eh'\n      case ('-nomlo')   !turn off multilevel optimization\n        env%multilevelopt = .false.\n      case ('-normmd')             !set number of normMDs\n        env%rotamermds = .true.\n        if (i + 1 .le. nra) then\n          call readl(arg(i + 1),xx,j)\n          env%nrotammds = nint(xx(1))  !how many lowest conformers?\n        end if\n        if (i + 2 .le. nra) then\n          call readl(arg(i + 2),xx,j)\n          env%temps = nint(xx(1))     !how many different temperatures\n        end if\n      case ('-rmsdpot','-gesc')\n        ctmp = trim(arg(i + 1))\n        inquire (file=ctmp,exist=ex)\n        if (ex) then\n          env%cts%usermsdpot = .true.\n          call getcwd(atmp)\n          env%cts%rmsdpotfile = trim(atmp)//'/'//ctmp\n          write (*,'(2x,a,a,a,a)') argument,': using <',ctmp,'> as bias'\n        else\n          write (*,'(a,a)') argument,': Warning! File could not be found!'\n        end if\n      case ('-mergebias','-mergebias+','-gesc+')\n        env%properties = -9224\n        if (index(argument,'+') > 0) env%properties = p_gesc2\n        ctmp = trim(arg(i + 1))\n        inquire (file=ctmp,exist=ex)\n        if (ex) then\n          env%biasfile = ctmp\n        end if\n        env%autozsort = .false.\n      case ('-gescopt')\n        env%gescoptlev = optlevnum(arg(i + 1))\n      case ('-gescheavy','-heavygesc','-gesc_heavy')\n        env%cts%gesc_heavy = .true.\n      case ('-rthr2') !bias rmsd threshold\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0) env%rthr2 = rdum\n      case ('-kshift')\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0) env%kshift = rdum\n        env%kshiftnum = 1\n      case ('-hflip')\n        env%doOHflip = .true.\n      case ('-noflip')\n        env%doOHflip = .false.\n      case ('-maxflip')\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then\n          env%maxflip = nint(rdum)\n        end if\n      case ('-osdf')\n        env%outputsdf = .true.\n        write(*,'(2x,a,\" :\",1x,a)') trim(arg(i)), &\n        & \"output ensemble requested in sdf format\"\n!========================================================================================!\n!------ flags for parallelization / disk space\n!========================================================================================!\n      case ('-T','-P','-parallel')  !set total number of OMP threads, this replaces -P and -O entirely\n        call readl(arg(i + 1),xx,j)\n        if (index(arg(i + 1),'-') .ne. 0) xx = 0d0\n        env%Threads = nint(xx(1))\n        env%autothreads = .true.\n        env%threadssetmanual = .true.\n        write (*,'(2x,a,1x,i0,1x,a)') trim(arg(i)),nint(xx(1)), &\n        &     '(CPUs/Threads selected)'\n      case ('-inplace')     ! activate in-place mode for optimizations (ON by default)\n        env%inplaceMode = .true.\n!========================================================================================!\n!------- CREGEN related flags\n!========================================================================================!\n      case ('-cregen','-oldcregen')                                        !cregen standalone\n        env%confgo = .true.\n        env%properties = p_cregen\n        env%autozsort = .false.\n        atmp = ''\n        env%ensemblename = 'none selected'\n        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))\n        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then\n          env%ensemblename = trim(atmp)\n        end if\n        if (index(env%ensemblename,'none selected') .ne. 0) then\n          write (*,'(2x,a,1x,a)') trim(arg(i)),': CREGEN standalone usage.'\n        else\n          write (*,'(2x,a,1x,a,a,a)') trim(arg(i)),': CREGEN standalone usage. Sorting file <', &\n          & trim(env%ensemblename),'>'\n        end if\n        if (trim(arg(i)) .eq. '-oldcregen') then\n          write (*,'(3x,a)') 'Using the old version of the CREGEN subroutine.'\n          env%newcregen = .false.\n        end if\n      case ('-oldcr')\n        write (*,'(3x,a)') 'Using the old version of the CREGEN subroutine.'\n        env%newcregen = .false.\n        env%ethr = 0.1d0 !ETHR old value\n      case ('-enso')                                           !compare two given ensembles\n        env%ENSO = .true.\n      case ('-compare')                                        !compare two given ensembles\n        env%compareens = .true.\n      case ('-maxcomp')                                        !maximum number of lowest conformers to compare with \"-compare\"\n        call readl(arg(i + 1),xx,j)\n        env%maxcompare = nint(xx(1))\n      case ('-ewin')                                           !set energy threshold in kcal/mol\n        call readl(arg(i + 1),xx,j)\n        env%ewin = abs(xx(1))\n        if (any((/ p_protonate, p_deprotonate, p_tautomerize /) == env%properties))then\n          env%ptb%ewin = abs(xx(1))\n        end if\n        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))\n      case ('-rthr')                                           !set RMSD thr\n        call readl(arg(i + 1),xx,j)\n        env%rthr = xx(1)\n        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))\n      case ('-ethr')                                           !set E thr\n        call readl(arg(i + 1),xx,j)\n        env%ethr = xx(1)\n        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))\n      case ('-bthr')                                           !set rot const thr\n        call readl(arg(i + 1),xx,j)\n        env%thresholds(4) = xx(1)  !legacy\n        env%bthr2 = xx(1)\n        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))\n      case ('-allrot')                                         !use all rotational constants for comparison, instead of mean\n        env%allrot = .true.\n      case ('-athr')                                           !set int. rotation. equal atoms for NMR thr\n        call readl(arg(i + 1),xx,j)\n        env%athr = xx(1)\n        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))\n      case ('-pthr')                                           !set population thr\n        call readl(arg(i + 1),xx,j)\n        rdum = min(1.0_wp,xx(1)) !--> pthr <= 1\n        rdum = max(0.0_wp,rdum)  !--> pthr >= 0\n        env%pthr = rdum\n        write (*,'(2x,a,1x,f6.4)') trim(arg(i)),rdum !trim(arg(i+1))\n      case ('-eqv')\n        env%doNMR = .true. !option for the very last confg call\n      case ('-zsort')\n        env%onlyZsort = .true.                                 !perform only the zsort subroutine\n        env%autozsort = .true.                                 ! CB: needs to be set to run zsort\n        write (*,'(2x,a,1x,a)') trim(arg(i)),' : only using the ZSORT subroutine.'\n      case ('-metac')                                        !automatic complete of mag. and chem. methyl equivalencies\n        env%methautocorr = .true.\n      case ('-esort')                                        !cregen legacy option\n        env%esort = .true.\n      case ('-debug')\n        env%cgf(1) = .true.    !debug option for confg\n      case ('-nowr')\n        env%cgf(2) = .false.   !newfile option for confg\n      case ('-eqan')\n        env%cgf(3) = .true.    !equivalence analysis on (for NMR)\n      case ('-noeqan')\n        env%cgf(3) = .false.   !equivalence analysis off (for nmr)\n      case ('-rot')\n        env%cgf(5) = .false.   !just rotamer check\n      case ('-nmr')                                          !NMR mode for confscript\n        env%doNMR = .true.\n        env%optlev = 2.0d0\n      case ('-fullcre')\n        env%doNMR = .true.\n        env%fullcre = .true.\n      case ('-heavy')\n        env%cgf(4) = .true.   !perform just the heavy atom RMSD\n        env%heavyrmsd = .true.\n      case ('-temp')\n        ctmp = trim(arg(i + 1))\n        if (index(ctmp,'-') .eq. 0) then\n          call readl(arg(i + 1),xx,j)\n          env%tboltz = xx(1)\n        end if\n      case ('-prsc')                !> write scoord files\n        env%printscoords = .true.\n      case ('-noprsc')              !> don't write scoord files\n        env%printscoords = .false.\n      case ('-subrmsd')             !> use only the RMSD for atoms that are included in the MTD\n        env%subRMSD = .true.\n      case ('-noopt')               !> skip the pre-optimization with GFNn-xTB before the confsearch\n        env%preopt = .false.\n      case ('-topo','-topocheck')\n        env%checktopo = .true.\n      case ('-notopo','-notopocheck')\n        env%checktopo = .false.\n        ctmp=trim(arg(i+1))\n        if(ctmp(1:1).ne.'-')then\n          call parse_topo_excl(env,ctmp)\n          if(allocated(env%excludeTOPO))then\n            env%checktopo = .true.\n          endif\n        endif\n      case ('-noreftopo')\n        env%reftopo = .false.\n      case ('-ezcheck','-checkez')\n        env%checkiso = .true.\n      case ('-noezcheck','-nocheckez')\n        env%checkiso = .false.\n!========================================================================================!\n!-------- PROPERTY CALCULATION related flags\n!========================================================================================!\n      case ('-protonate')             !protonation tool\n        env%properties = p_protonate\n        env%autozsort = .false.\n        env%ptb%threshsort = .true.\n      case ('-swel')                  !switch out H+ to something else in protonation script\n        if (env%properties .eq. -3) then\n          call swparse(arg(i + 1),env%ptb)\n        end if\n      case ('-deprotonate')           !deprotonation tool\n        env%properties = p_deprotonate\n        env%autozsort = .false.\n        env%ptb%threshsort = .true.\n      case ('-tautomerize')           !tautomerization tool\n        env%properties = p_tautomerize\n        env%autozsort = .false.\n        env%ptb%threshsort = .true.\n      case ('-tautomerize2','-exttautomerize')\n        if (env%properties == p_propcalc) then\n          env%properties = p_tautomerize2\n        else\n          call env%addjob(abs(p_tautomerize2))\n        end if\n        env%autozsort = .false.\n        env%ptb%threshsort = .true.\n        env%runver = 33\n        env%relax = .true.\n        env%performCross = .false.                              !skip the genetic crossing\n        env%trackorigin = .false.\n        env%Maxrestart = 1\n      case ('-relax')\n        env%runver = 33\n        env%relax = .true.\n        env%performCross = .false.                              !skip the genetic crossing\n        env%trackorigin = .false.\n        env%Maxrestart = 1\n      case ('-trev','-tdp')\n        env%ptb%deprotprot = .true. !switch to deprotonation-first mode in tautomerization\n      case ('-iter')                  !number of Protonation/Deprotonation cycles in Tautomerization\n        call readl(arg(i + 1),xx,j)\n        env%ptb%iter = nint(xx(1))\n      case ('-texcl','-blacklist')\n        ctmp = trim(arg(i + 1))\n      case ('-strict')\n        env%ptb%strictPDT = .true.\n      case ('-verystrict','-vstrict')\n        env%ptb%strictPDT = .false.\n        env%ptb%fixPDT = .true.\n      case ('-fstrict')\n        env%ptb%strictPDT = .true.\n        env%ptb%fixPDT = .true.\n      case ('-corr','-abcorr')\n        env%ptb%strictPDT = .true.\n        env%ptb%fixPDT = .true.\n        env%ptb%ABcorrection = .true.\n      case ('-pkaensemble')\n        env%preopt = .false.\n        env%presp = .false.\n        call pka_argparse2(env,arg(i + 1),arg(i + 2),env%ptb%pka_mode)\n      case ('-pkaparam')\n        env%ptb%rdcfer = .true.\n        if (i + 1 .le. nra) then\n          ctmp = trim(arg(i + 1))\n          if (ctmp(1:1) .ne. '-') then\n            env%ptb%cferfile = ctmp\n          end if\n        end if\n!========================================================================================!\n!--------- ENTROPY related settings\n!========================================================================================!\n      case ('-entropy','-entropic')  !> new, specialized calculation of molecular entropies\n        write (*,'(2x,a,'' : enhanced ensemble entropy calculation'')') trim(arg(i))\n        if (env%properties == p_propcalc) then \n        !>--- for standalone use\n          env%properties = p_CREentropy\n\n        elseif (env%confgo .and. env%properties == -1) then \n        !>--- as extension for CREGEN\n          env%entropic = .true.\n          env%fullcre = .true.\n\n        else if (env%crestver == crest_imtd) then  \n        !>--- works as an extensiton to the conformational search\n          env%properties = abs(p_CREentropy)\n          env%autozsort = .false.     !> turn off zsort (since we are not going to GC anyways)\n          env%performCross = .false.  !> turn off GC\n          env%entropic = .true.       !> indicator for this runtype\n          env%Maxrestart = 1          !> turn off MTD iterations (just do one)\n          env%rotamermds = .false.    !> turn off normMDs\n          env%entropymd = .true.      !> special static MTDs\n          call read_bhess_ref(env,'coord')\n        end if\n        env%runver = 111             !> version  for selection of MTD bias settings\n        env%doNMR = .true.           !> we need equivalencies\n        if (i + 1 .le. nra) then\n          ctmp = trim(arg(i + 1))    !> second argument can be the temperature\n          if (index(ctmp,'-') .eq. 0) then\n            call readl(arg(i + 1),xx,j)\n            env%tboltz = xx(1)\n          end if\n        end if\n        call env%addjob(env%properties)\n\n      case ('-scthr','-entropy_cthr')\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0) env%emtd%confthr = rdum\n      case ('-ssthr','-entropy_sthr')\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0) env%emtd%sconvthr = rdum\n      case ('-rrhoav')             ! see above in the first specification of -rrhoav\n        env%properties = p_rrhoaverage\n        call read_bhess_ref(env,'coord')\n      case ('-avbhess')\n        env%thermo%avbhess = .true.  !use bhess in rrhoav for all structures (expensive)\n      case ('-avchess')\n        env%thermo%constrhess = .true.   !apply constraints during rrhoav routine\n      case ('-printpop')\n        env%thermo%printpop = .true. !print a file with free energy pop. at different T\n      case ('-noref')              ! dont use a bhess reference\n        env%emtd%bhess = .false.\n      case ('-ref')\n        env%emtd%bhess = .true.\n        inquire (file=trim(arg(i + 1)),exist=ex)\n        if (ex) then\n          call read_bhess_ref(env,trim(arg(i + 1)))\n        end if\n      case ('-pcap')\n        read (arg(i + 1),*,iostat=io) j\n        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then\n          env%thermo%pcap = j\n        end if\n      case ('-ptot')\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then\n          if (rdum > 1.0d0) rdum = 1.0d0\n          env%thermo%ptot = rdum\n        end if\n      case ('-ithr')\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0) then\n          if (rdum > 0.0d0) rdum = 0.0\n          env%thermo%ithr = rdum\n        end if\n      case ('-rotorcut','-sthr')\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then\n          if (rdum < 0.0d0) rdum = 0.0d0\n          env%thermo%sthr = rdum\n        end if\n      case ('-fscal')\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then\n          env%thermo%fscal = rdum\n        end if\n      case ('-trange')    !provide a range of temperatures (min max step) for entropy evaluation\n        read (arg(i + 1),*,iostat=io) rdum\n        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then\n          env%thermo%trange(1) = rdum  !> T start\n        end if\n        read (arg(i + 2),*,iostat=io) rdum\n        if (io == 0 .and. (index(arg(i + 2),'-') .eq. 0)) then\n          env%thermo%trange(2) = rdum  !> T stop (approx.)\n        end if\n        read (arg(i + 3),*,iostat=io) rdum\n        if (io == 0 .and. (index(arg(i + 3),'-') .eq. 0)) then\n          env%thermo%trange(3) = rdum  !> T step\n        end if\n      case ('-tread')   !> read a file with temperatures (one per line) for entropy evaluation\n        ctmp = trim(arg(i + 1))\n        inquire (file=ctmp,exist=ex)\n        if (ex) then\n          call env%thermo%read_temps(ctmp)\n        end if\n!=========================================================================================!\n!-------- QCG-Related flags\n!=========================================================================================!\n      case ('-nopreopt')\n        env%nopreopt = .true.\n        env%qcg_flag = .true.\n      case ('-xtbiff')\n         env%use_xtbiff = .true.\n      case ('-grow')\n        env%qcg_runtype = 0\n        env%qcg_flag = .true.\n      case ('-ensemble')\n        env%qcg_runtype = 1\n        env%qcg_flag = .true.\n      case ('-esolv')\n        env%qcg_runtype = 2\n        env%qcg_flag = .true.\n      case ('-gsolv')\n        env%qcg_runtype = 3\n        env%qcg_flag = .true.\n      case ('-nsolv')\n        env%qcg_flag = .true.\n        call readl(arg(i + 1),xx,j)\n        env%nsolv = NINT(xx(1))\n      case ('-maxsolv')\n        env%qcg_flag = .true.\n        call readl(arg(i + 1),xx,j)\n        env%max_solv = NINT(xx(1))\n      case ('-normdock')\n        env%docking_qcg_flag = ''\n      case ('-nclus')\n        env%qcg_flag = .true.\n        call readl(arg(i + 1),xx,j)\n        env%nqcgclust = NINT(xx(1))\n        env%user_nclust = .true.\n      case ('-freqscal')\n        env%qcg_flag = .true.\n        call readl(arg(i + 1),xx,j)\n        env%freq_scal = (xx(1))\n      case ('-qcgmtd')\n        env%ensemble_method = -1\n        env%qcg_flag = .true.\n      case ('-ncimtd')\n        env%ensemble_method = 0\n        env%qcg_flag = .true.\n      case ('-md')\n        env%ensemble_method = 1\n        env%qcg_flag = .true.\n        if (.not. env%user_enslvl) then\n          env%ensemble_opt = '--gfn2'\n        end if\n      case ('-mtd')\n        env%ensemble_method = 2\n        env%qcg_flag = .true.\n        if (.not. env%user_enslvl) then\n          env%ensemble_opt = '--gfn2'\n        end if\n      case ('-samerand')\n        env%sameRandomNumber = .true.\n        env%qcg_flag = .true.\n      case ('-nocff')\n        env%cff = .false.\n        env%qcg_flag = .true.\n      case ('-enslvl')\n        ctmp = arg(i + 1)\n        env%user_enslvl = .true.\n        env%qcg_flag = .true.\n        if (arg(i + 1) == 'gfn') then\n          dtmp = trim(arg(i + 2))\n          ctmp = trim(ctmp)//dtmp\n        end if\n        select case (ctmp)\n        case ('gfn1')\n          env%ensemble_opt = '--gfn1'\n          write (*,'(2x, a)') 'Use of GFN1-xTB for ensemble search requested.'\n        case ('gfn2')\n          env%ensemble_opt = '--gfn2'\n          write (*,'(2x, a)') 'Use of GFN2-xTB for ensemble search requested.'\n        case ('gfn0')\n          env%ensemble_opt = '--gfn0'\n          write (*,'(2x, a)') 'Use of GFN0-xTB for ensemble search requested.'\n        case ('gff','gfnff')\n          env%ensemble_opt = '--gff'\n          write (*,'(2x, a)') 'Use of GFN-FF for ensemble search requested.'\n        end select\n\n      case ('-freqlvl')\n        ctmp = arg(i + 1)\n        env%qcg_flag = .true.\n        if (arg(i + 1) == 'gfn') then\n          dtmp = trim(arg(i + 2))\n          ctmp = trim(ctmp)//dtmp\n        end if\n        select case (ctmp)\n        case ('gfn1')\n          env%freqver = '--gfn1'\n          write (*,'(2x, a)') 'Use of GFN1-xTB for frequency computation requested.'\n        case ('gfn2')\n          env%freqver = '--gfn2'\n          write (*,'(2x, a)') 'Use of GFN2-xTB for frequency computation requested.'\n        case ('gfn0')\n          env%freqver = '--gfn0'\n          write (*,'(2x, a)') 'Use of GFN0-xTB for frequency computation requested.'\n        case ('gff','gfnff')\n          env%freqver = '--gff'\n          write (*,'(2x, a)') 'Use of GFN-FF for frequency computation requested.'\n        end select\n!========================================================================================!\n!-------- PRINCIPAL COMPONENT analysis and CLUSTERING flags\n!========================================================================================!\n      case ('-cluster')\n        write (*,'(2x,a,'' : ensemble clustering'')') trim(arg(i))\n        if (env%properties == p_propcalc) then \n        !>--- for standalone use\n          env%properties = p_cluster\n        elseif (env%confgo .and. env%properties == p_cregen) then \n        !>--- as extension for CREGEN\n          env%cluster = .true.\n        else if (any((/crest_imtd,crest_imtd2/) == env%crestver)) then\n        !>--- works as an extensiton to the conformational search\n          env%properties = abs(p_cluster)\n        elseif (env%QCG) then \n          env%properties = abs(p_cluster)\n        end if\n        env%doNMR = .true.     !> we need equivalencies\n        call env%addjob(env%properties)\n        if (i + 1 .le. nra) then !second argument a distinct number of clusters\n          read (arg(i + 1),*,iostat=io) j\n          if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then\n            env%nclust = j\n          else\n            env%nclust = 0\n            if ((index(arg(i + 1),'-') .eq. 0)) then\n              ctmp = trim(arg(i + 1))\n              select case (ctmp)\n              case ('loose')\n                env%clustlev = -1\n                write (*,'(2x,a,'' loose : using loose clustering setting'')') trim(arg(i))\n              case ('normal')\n                env%clustlev = 0\n                write (*,'(2x,a,'' normal : using normal clustering setting'')') trim(arg(i))\n              case ('tight')\n                env%clustlev = 1\n                write (*,'(2x,a,'' tight : using tight clustering setting'')') trim(arg(i))\n              case ('vtight','verytight')\n                env%clustlev = 2\n                write (*,'(2x,a,'' vtight : using very tight clustering setting'')') trim(arg(i))\n              case ('incremental','incr')\n                env%clustlev = 10\n                write (*,'(2x,a,'' incremental : using incremental clustering settings'')') trim(arg(i))\n              case ('tightincremental','tightincr')\n                env%clustlev = 11\n                write (*,'(2x,a,'' tightincremental : using incremental clustering settings'')') &\n                &    trim(arg(i))\n              case ('vtightincremental','vtightincr')\n                env%clustlev = 12\n                write (*,'(2x,a,'' vtightincremental : using incremental clustering settings'')') &\n                 & trim(arg(i))\n              end select\n            end if\n          end if\n        end if\n      case ('-pccap')\n        if (i + 1 .le. nra) then !second argument is the max. number of PCs\n          read (arg(i + 1),*,iostat=io) j\n          if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then\n            env%pccap = j\n          end if\n        end if\n      case ('-nopcmin')\n        env%pcmin = 0.0d0\n      case ('-pctype','-pctyp')\n        if (i + 1 .le. nra) then\n          ctmp = trim(arg(i + 1))\n          if (ctmp(1:1) .ne. '-') then\n            env%pcmeasure = ctmp\n          end if\n        end if\n      case ('-pcaex','-pcaexclude')\n        if (i + 1 .le. nra) then\n          ctmp = trim(arg(i + 1))\n          if (ctmp(1:1) .ne. '-') then\n            env%atlist = ctmp\n            env%pcaexclude = .true.\n          end if\n        end if\n!========================================================================================!\n!---------- PROPERTY MODE\n!========================================================================================!\n      case ('-prop')\n        if ((env%properties == p_none .or.    &\n        &  env%properties == p_propcalc )) then         !property selection\n          ctmp = trim(arg(i + 1))\n          PROPARG:select case(ctmp)\n          case ('hess')                  !hessian calculation to free energies for all conformers\n          env%properties2 = 1\n          case ('ohess')                 !optimization+hessian calculation\n          env%properties2 = 10\n          case ('autoir','autoIR')       !automated IR averaging for populated (-pthr) conformers\n          env%properties2 = 2\n          case ('b973c')                 !B97-3c optimization (xtb driver for ancopt)\n          env%properties2 = 3\n          case ('b973cIR')               !B97-3c optimization + IR spectra average\n          env%properties2 = 4\n          case ('dft')                   !DFT (custom) job, read from dftrc\n          env%properties2 = 100\n          case ('dftOPT')                !DFT (custom) optimization (xtb driver for ancopt)\n          env%properties2 = 5\n          case ('dftIR')                 !DFT (custom) optimization + IR spectra average\n          env%properties2 = 6\n          case ('dftSP')                 !DFT (custom) singlepoint\n          env%properties2 = 7\n          env%harcutpthr = 0.75\n          case ('dftFREQ')               !DFT (custom) optimization + frequencies\n          env%properties2 = 8\n          case ('reopt')                 !reoptimize only conformers at vtight level\n          env%properties2 = 20\n          case ('TEST')                  !testSTUFF\n          env%properties2 = -9999\n          case ('singlepoint','sp')      !singlepoint calculation and ensemble sorting\n          env%properties2 = 999\n          env%pclean = .true.\n          case ('dipole')      !singlepoint calculation and dipole grepping\n          env%properties2 = 998\n          env%pclean = .true.\n          case default\n          env%properties2 = 0\n          end select PROPARG\n          if (env%properties2 .ne. 0) then\n            call env%addjob(env%properties2)\n          end if\n        end if\n      case ('-dftrc')                            !provide dft-rc file (including path)\n        atmp = ''\n        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))\n        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then\n          env%dftrcfile = trim(atmp)\n        end if\n      case ('-hardcut')                          !cut DFT populations hard\n        env%hardcutDFT = .true.\n      case ('-pclean')                           !cleanup option for property mode, i.e., remove PROP/\n        env%pclean = .true.\n!========================================================================================!\n      case ('-scratch') \n        !use a scratch directory to perform the calculation in\n        env%scratch = .true.\n        atmp = ''\n        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))\n        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then\n          env%scratchdir = trim(atmp)\n        end if\n      case ('-keepscratch')\n        env%keepScratch = .true.\n      case default\n        continue\n      end select !> ARGPARSER1\n!========================================================================================!\n    end if\n  end do\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> END OF ARGPARSER LOOP\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n  deallocate (strings,floats,xx)\n!>----- additional checks and settings\n  if (env%crestver .eq. crest_solv) bondconst = .false.\n\n  if (env%qcg_flag .and. env%crestver .ne. crest_solv) then\n    error stop 'At least one flag is only usable for QCG runtype. Exit.'\n  end if\n\n  if (env%autozsort .and. env%crestver .eq. crest_solv) then\n    error stop 'Z sorting of the input is unavailable for -qcg runtyp.'\n  end if\n\n  if (env%NCI .or. env%wallsetup) then\n    call wallpot(env)\n    if(env%wallsetup)then\n    write(*,'(2x,a)') 'Automatically generated ellipsoide potential:'\n    else\n    write (*,'(2x,a)') 'Automatically generated ellipsoide potential for NCI mode:'\n    endif\n    call write_cts_NCI_pr(6,env%cts)\n    write (*,*)\n  end if\n\n!>--- automatic bond constraint setup\n  if (env%crestver > 200 .and. env%crestver < 300) then\n    !>--- internal calculation engine versions\n    if (.not. bondconst) then\n      call autoconstraint_internal(env)\n    else\n      select case (ctype)\n      case (1)\n        call autobond_internal(env,0)\n      end select\n    end if\n  else if (bondconst) then\n    !>--- standard crest+xtb version\n    select case (ctype)\n    case (1)\n      call autoBondConstraint('coord',env%forceconst,env%wbofile)\n    case (2)\n      call autoMetalConstraint('coord',env%forceconst,env%wbofile)\n    case (3)\n      call autoHeavyConstraint('coord',env%forceconst)\n    case (4)\n      call autoHydrogenConstraint('coord',env%forceconst)\n    case (5)\n      call autoBondConstraint_withEZ('coord',env%forceconst,env%wbofile)\n    end select\n  end if\n\n!>--- additional parsing of $setblock, .constrains and .confscriptrc file\n  call parseRC2(env,bondconst)   \n\n!>--- internal constraint check-up\n  call  internal_constraint_repair(env)\n\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> settings after user input parsing\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n  if ((any((/crest_imtd,crest_imtd2,crest_pka,crest_compr,11/) == env%crestver)) .and.  &\n  &  .not. env%confgo) then\n    call defaultGF(env) !set Guiding Force default if none was read\n  end if\n\n  !-- increase gbsa grid for GFNn-xTB calculations (not for the FF)\n  if ((env%gfnver .ne. '--gff') .and. (env%gbsa)) then\n    env%cts%ggrid = .true.\n    env%cts%gbsagrid = 'tight'\n  end if\n\n  if (env%gfnver == '--gff') then\n    env%hmass = 5.0d0\n    if (bondconst) then\n      env%autozsort = .false.\n    end if\n  end if\n\n  !>--- defaults for QCG gfnff ensemble search\n  if( env%crestver ==  crest_solv)then\n  if (env%ensemble_opt .EQ. '--gff') then\n    env%mdstep = 1.5d0\n    env%hmass = 5.0d0\n    ctype = 5 !bond constraint\n    bondconst = .true.\n    env%cts%cbonds_md = .true.\n    env%checkiso = .true.\n    env%lmover = '--gfn2'\n  end if\n  if ((env%gfnver .EQ. '--gff') .OR. (env%gfnver .EQ. '--gfn0')) then\n    env%lmover = '--gfn2'\n  else\n    env%lmover = env%gfnver\n  end if\n  endif\n\n  if (env%useqmdff) then\n    env%autozsort = .false.\n  end if\n\n  if (.not. env%preopt) then\n    if (allocated(env%ref%topo)) deallocate (env%ref%topo)\n  end if\n\n\n!>-- driver for optimization along trajectory, additional settings\n  if (.not. any((/crest_mfmdgc,crest_imtd,crest_imtd2,crest_compr/) == env%crestver) &\n      & .OR. (env%qcg_runtype .GT. 0 .and. env%ensemble_method .EQ. 0)) then\n    env%autozsort = .false.\n    env%trackorigin = .false.\n    env%confgo = .false.\n  end if\n\n!>-- final settings for property mode (-prop)\n  if (env%properties .eq. p_none) then\n    env%properties = env%properties2\n  end if\n  if (env%properties .eq. p_propcalc) then\n    env%autozsort = .false.\n  end if\n\n!>-- some more zsort checks\n  if (.not. env%onlyZsort .and. env%autozsort) then\n    call zsortwarning2(env) !turn autozsort off when a .constrains file is present.\n  end if\n  if (env%autozsort) then\n    if (allocated(env%ref%topo)) deallocate (env%ref%topo)\n  end if\n  if (env%sdfformat) then\n    env%autozsort = .false.\n  end if\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> FALLBACK setup of new calculator\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n  if(.not.env%legacy .and. env%calc%ncalculations == 0 )then\n    call env2calc_setup(env)\n  endif\n\n  return\nend subroutine parseflags\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!\n!=========================================================================================!\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC!\n!=========================================================================================!\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!\n\n!=========================================================================================!\n!> Parse the \"confscriptrc\" and set-block in the input file\n!=========================================================================================!\nsubroutine parseRC2(env,bondconst)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  implicit none\n\n  type(systemdata),intent(inout) :: env\n\n  integer :: i,j,k\n  character(len=512),allocatable :: cfiles(:)\n  character(len=256) :: atmp,btmp\n  character(len=512) :: dg,argument\n  integer,allocatable :: atlist(:)\n  logical :: ex,ex1,ex2\n  logical :: create,atomlistused\n  logical :: bondconst\n\n!>--- check for any of the possible constrainement files\n    ex1 = .false.\n\n    allocate (cfiles(4))\n\n    cfiles(1) = '.xcontrol'\n    cfiles(2) = '.constrains'\n    cfiles(3) = '.constraints'\n    cfiles(4) = env%constraints  !for user-set option (todo)\n\n    do i = 1,4\n      inquire (file=cfiles(i),exist=ex)\n      if (ex) then\n        env%constraints = trim(cfiles(i))\n        ex1 = .true.\n      end if\n    end do\n    deallocate (cfiles)\n\n!>--- do we have a user-set constraint to all bonds?\n    if (bondconst) then\n      inquire (file='bondlengths',exist=ex2)\n      if (ex2) then\n        call rd_cbonds('bondlengths',env)\n        if (.not. env%cts%cbonds_md) then\n          env%cts%cbonds_global = .true.\n        end if\n      end if\n    end if\n\n    if (ex1) then\n      write (*,'(/,1x,a,a,a)') '<',trim(env%constraints),'> file present.'\n      env%cts%used = .true.\n    else\n      env%cts%used = .false.\n      return\n    end if\n\n!>--- read the data\n    call read_constrainbuffer(env%constraints,env%cts)\n    call sort_constraints(env%cts)\n    write (*,*) 'content of the constraining file (sorted):'\n    if (env%cts%ndim .gt. 20) then\n      write (*,'(1x,a)') '<skipped due to length of constraining file>'\n    else\n      do i = 1,env%cts%ndim\n        if (trim(env%cts%sett(i)) .ne. '') then\n          write (*,'(''>'',1x,a)') trim(env%cts%sett(i))\n        end if\n      end do\n    end if\n\n!>--- some settings\n    create = .false.\n    atomlistused = .false.\n    allocate (atlist(env%nat))\n\n!>--- parse for special arguments that are used by CREST also\n    do i = 1,env%cts%ndim\n      btmp = env%cts%sett(i)\n      if (trim(btmp) .eq. '') cycle\n      atmp = btmp\n      call to_lower(atmp)  !convert to lower-case for case-insensitivity\n      if (index(atmp,'atomlist+') .ne. 0) then\n        create = .true.\n        atomlistused = .true.\n        dg = atmp\n        call split_set_args(dg,argument)\n        call parse_atlist_new(trim(argument),env%rednat,env%nat,env%ref%at,atlist)\n        write (*,'(2x,a)') trim(adjustl(btmp))\n        write (*,'(5x,a,i0)') '# of atoms considered for RMSDs:',env%rednat\n        env%includeRMSD = atlist !includeRMSD contains only the atoms that are included in RMSD\n      end if\n      if (index(atmp,'atomlist-') .ne. 0) then\n        create = .true.\n        atomlistused = .true.\n        dg = atmp\n        call split_set_args(dg,argument)\n        call parse_atlist_new(trim(argument),j,env%nat,env%ref%at,atlist)\n        env%rednat = env%nat - j\n        write (*,'(2x,a)') trim(adjustl(btmp))\n        write (*,'(3x,a,i0)') '# of atoms considered for RMSDs:',env%rednat\n        env%includeRMSD = atlist !includeRMSD contains the atoms that are NOT included in RMSD\n        do k = 1,env%nat\n          if (env%includeRMSD(k) .lt. 1) then   !therefore the values have to be \"inverted\"\n            env%includeRMSD(k) = 1\n          else\n            env%includeRMSD(k) = 0\n          end if\n        end do\n      end if\n      if ((index(atmp,'$metadyn') .ne. 0)) then\n        do j = i + 1,env%cts%ndim\n          btmp = env%cts%sett(j)\n          if (index(btmp,'$') .ne. 0) exit    !--- exit $metadyn-block\n          if (index(btmp,'atoms:') .ne. 0) then\n            create = .true.\n            atomlistused = .true.\n            dg = btmp\n            call split_set_args(dg,argument)\n            call parse_atlist_new(trim(argument),env%rednat,env%nat,env%ref%at,atlist)\n            write (*,'(2x,a)') trim(adjustl(btmp))\n            write (*,'(5x,a,i0)') '# of atoms considered for RMSDs:',env%rednat\n            env%includeRMSD = atlist !includeRMSD contains only the atoms that are included in RMSD\n          end if\n        end do\n      end if\n      if (index(btmp,'reference=') .ne. 0) then\n        call rdarg(btmp,'reference=',env%fixfile)\n        write (*,'(1x,a,1x,a)') 'fix file:',trim(env%fixfile)\n      end if\n      if ((index(atmp,'$wall') .ne. 0)) then\n        if (env%NCI) then\n          env%cts%sett(i) = ''\n          env%cts%pots = ''\n          write (env%cts%pots(1),'(a)') '$wall'\n          k = 2\n          do j = i + 1,env%cts%ndim\n            btmp = env%cts%sett(j)\n            if (index(btmp,'$') .ne. 0) exit    !--- exit $wall-block\n            env%cts%sett(j) = ''\n            write (env%cts%pots(k),'(a)') trim(btmp)\n            k = k + 1\n          end do\n\n          write (*,'(/,2x,a)') 'Automatically generated ellipsoide potential overwritten by:'\n          call write_cts_NCI(6,env%cts)\n          write (*,*)\n\n        end if\n      end if\n    end do\n\n    if (.not. atomlistused) then\n      atlist = 1\n      env%includeRMSD = atlist\n    end if\n\n    deallocate (atlist)\n\n  return\nend subroutine parseRC2\n\n!========================================================================================!\n!> Convert given input coordinate file into a \"coord\" file (TM format)\n!> If the input is in SDF format, document the info to convert the\n!> final ensemble back into this format\n!========================================================================================!\nsubroutine inputcoords(env,arg)\n  use crest_parameters\n  use crest_data\n  use strucrd\n  use axis_module\n  use zdata\n  use iomod\n  implicit none\n  !> Input\n  type(systemdata) :: env\n  character(len=*) :: arg\n  !> Local variables\n  logical :: ex,ex2\n  character(len=:),allocatable :: inputfile\n  character(len=:),allocatable :: arg2\n  type(coord) :: mol\n  type(zmolecule) :: zmol\n  integer :: i\n\n!>--- Redirect for QCG input reading\n  if (env%QCG) then\n    arg2 = env%solv_file\n    call inputcoords_qcg(env,arg,arg2)\n    return\n  endif\n!>---\n\n  inquire (file=arg,exist=ex)\n  inquire (file='coord',exist=ex2)\n  if (.not. ex .and. .not. ex2) then\n    if(env%dryrun)then\n      write(stdout,*) 'No (valid) input file, but ignoring for dry run.'\n      return\n    else\n      error stop 'No (valid) input file! exit.'\n    endif\n  end if\n  if (ex2) then \n!>-- save coord as reference\n    call copy('coord','coord.original')\n  end if\n  if (ex .and. arg(1:1) .ne. '-') then\n    call mol%open(arg)\n    call mol%write('coord')\n    call mol%write('struc.xyz')\n    call mol%deallocate()\n    inputfile = trim(arg)\n  else\n    inputfile = 'coord'\n  end if\n\n!>-- if the input was a SDF file, special handling\n  env%sdfformat = .false.\n  call checkcoordtype(inputfile,i)\n  if (any((/31,32/) == i)) then\n     env%sdfformat = .true.\n     env%outputsdf = .true.\n  end if\n\n!>-- after this point there should always be an coord file present\n  if (.not. allocated(env%inputcoords)) env%inputcoords = 'coord'\n  call mol%open('coord')\n!>-- shift to CMA and align according to rot.const.\n  if(env%crestver /= crest_solv) call axis(mol%nat,mol%at,mol%xyz)\n!>-- overwrite coord\n  call mol%write('coord')\n\n!>-- get the number of atoms and the reduced number of atoms if some of\n!>-- them are excluded from the RMSD calc in V2. Initially they are the same\n  env%nat = mol%nat\n  env%rednat = env%nat\n!>-- reference geo save\n  env%ref%nat = mol%nat\n  env%ref%at = mol%at\n  env%ref%xyz = mol%xyz\n  env%ref%ichrg = env%chrg\n  env%ref%uhf = env%uhf \n!>-- topology save\n  if (any((/crest_mfmdgc,crest_imtd,crest_imtd2/) == env%crestver)) then\n    if (.not. env%autozsort) then\n      env%ref%ntopo = mol%nat * (mol%nat + 1) / 2\n      allocate (env%ref%topo(env%ref%ntopo))\n      call quicktopo(mol%nat,mol%at,mol%xyz,env%ref%ntopo,env%ref%topo)\n    end if\n  end if\n  call mol%deallocate()\n\n!>-- for protonation/deprotonation applications get ref. number of fragments\n!>-- also get some other structure based info\n  call simpletopo_file('coord',zmol,.false.,.false.,'')\n  env%ptb%nfrag = zmol%nfrag\n  call zmol%deallocate()\n\n  return\nend subroutine inputcoords\n\n!========================================================================================!\n!> Convert given QCG coordinate files into (TM format)\n!> If the input is in SDF format, document the info to convert the\n!> final ensemble back into this format\n!========================================================================================!\nsubroutine inputcoords_qcg(env,arg1,arg2)\n  use iso_fortran_env,only:wp => real64\n  use crest_data\n  use strucrd\n  use zdata\n  use iomod\n  implicit none\n\n  type(systemdata) :: env\n  character(len=*) :: arg1,arg2\n\n  logical :: ex11,ex12,ex21,ex22,solu,solv\n  character(len=:),allocatable :: inputfile\n  type(coord) :: mol\n  type(zmolecule) :: zmol,zmol1\n  integer :: i\n\n!--------------------Checking for input-------------!\n\n  inquire (file='solute',exist=solu)\n  inquire (file=arg1,exist=ex11)\n  inquire (file='coord',exist=ex12)\n\n  inquire (file='solvent',exist=solv)\n  inquire (file=arg2,exist=ex21)\n  if (len_trim(arg2) .eq. 0) then !Check if the second argument is just empty\n    ex21 = .false.\n  end if\n  inquire (file='coord',exist=ex22)\n\n  if (.not. ex11 .and. .not. ex12 .and. .not. solu) then\n    error stop 'No (valid) solute file! exit.'\n  else if (.not. ex21 .and. .not. ex22 .and. .not. solv) then\n    error stop 'No (valid) solvent file! exit.'\n  end if\n\n!---------------Handling solute---------------------!\n\n  if (ex11 .and. arg1(1:1) .ne. '-') then\n    call mol%open(arg1)\n    call mol%write('solute')\n    call mol%write('solute.xyz')\n    call mol%deallocate()\n    inputfile = trim(arg1)\n    write (*,*) 'Solute-file: ',arg1\n    env%solu_file = arg1\n  else if (solu .and. .not. ex11) then\n    call copy('solute','solute.old')\n    inputfile = 'solute'\n    write (*,'(/,1x,a)') 'Solute-file: solute'\n    env%solu_file = 'solute'\n  else if (ex12 .and. .not. ex11) then !-- save coord as reference\n    call copy('coord','coord.old')\n    call copy('coord','solute')\n    write (*,'(/,1x,a)') 'Solute-file: coord'\n    inputfile = 'coord'\n    env%solu_file = 'coord'\n  else\n    write (*,*) 'An error occured processing the solute-input file'\n  end if\n\n  !--- if the input was a SDF file, special handling\n  env%sdfformat = .false.\n  call checkcoordtype(inputfile,i)\n  if (i == 31 .or. i == 32) then\n!      call inpsdf(env,inputfile)\n    write (*,*) 'QCG currently does not support SDF-files.'\n  end if\n\n!---------------Handling solvent---------------------!\n\n  if (ex21 .and. arg2(1:1) .ne. '-' .and. arg2(1:1) .ne. ' ') then\n    call mol%open(arg2)\n    call mol%write('solvent')\n    call mol%write('solvent.xyz')\n    call mol%deallocate()\n    inputfile = trim(arg2)\n    write (*,*) 'Solvent-file: ',arg2\n    env%solv_file = arg2\n  else if (solv .and. .not. ex21) then\n    call copy('solvent','solvent.old')\n    inputfile = 'solvent'\n    write (*,'(/,1x,a)') 'Solvent-file: solvent'\n    env%solv_file = 'solvent'\n  else if (ex22 .and. .not. ex21) then !-- save coord as reference\n    call copy('coord','coord.old')\n    call copy('coord','solvent')\n    inputfile = 'coord'\n    write (*,'(/,1x,a)') 'Solvent-file: coord'\n    env%solv_file = 'coord'\n  else\n    write (*,*) 'An error occured during solvent-file processing'\n  end if\n\n  !--- if the input was a SDF file, special handling\n  env%sdfformat = .false.\n  call checkcoordtype(inputfile,i)\n  if (i == 31 .or. i == 32) then\n    !call inpsdf(env,inputfile)\n    write (*,*) 'QCG currently does not support SDF-files.'\n  end if\n\n!-------------Checking both files and saving them---------------------------!\n\n  !--- after this point there should always be a solvent and solute file present\n  if (.not. allocated(env%inputcoords_solu)) env%inputcoords_solu = 'solute'\n  if (.not. allocated(env%inputcoords_solv)) env%inputcoords_solv = 'solvent'\n\n  call mol%open('solute')\n\n  env%nat = mol%nat\n  !--- solute geo\n  env%qcg_solute%nat = mol%nat\n  env%qcg_solute%at = mol%at\n  env%qcg_solute%xyz = mol%xyz\n  if (any((/crest_mfmdgc,crest_imtd,crest_imtd2/) == env%crestver)) then\n    if (.not. env%autozsort) then\n      env%qcg_solute%ntopo = mol%nat * (mol%nat + 1) / 2\n      allocate (env%qcg_solute%topo(env%qcg_solute%ntopo))\n      call quicktopo(mol%nat,mol%at,mol%xyz,env%qcg_solute%ntopo,env%qcg_solute%topo)\n    end if\n  end if\n  call mol%deallocate()\n\n  call mol%open('solvent')\n\n  env%nat = mol%nat\n  env%rednat = env%nat        !get the number of atoms and the reduced number of atoms if some of them are     excluded from the RMSD calc in V2\n  !--- solvent geo\n  env%qcg_solvent%nat = mol%nat\n  env%qcg_solvent%at = mol%at\n  env%qcg_solvent%xyz = mol%xyz\n  if (any((/crest_mfmdgc,crest_imtd,crest_imtd2/) == env%crestver)) then\n    if (.not. env%autozsort) then\n      env%qcg_solvent%ntopo = mol%nat * (mol%nat + 1) / 2\n      allocate (env%qcg_solvent%topo(env%qcg_solvent%ntopo))\n      call quicktopo(mol%nat,mol%at,mol%xyz,env%qcg_solvent%ntopo,env%qcg_solvent%topo)\n    end if\n  end if\n  call mol%deallocate()\n\n  !--- for protonation/deprotonation applications get ref. number of fragments\n  !--- also get some other structure based info\n  call simpletopo_file('solute',zmol,.false.,.false.,'')\n  env%ptb_solute%nfrag = zmol%nfrag\n  call zmol%deallocate()\n\n  call simpletopo_file('solvent',zmol1,.false.,.false.,'')\n  env%ptb_solvent%nfrag = zmol1%nfrag\n  call zmol1%deallocate()\n\n  return\nend subroutine inputcoords_qcg\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/confparse.f90 b/src/confparse.f90
--- a/src/confparse.f90	
+++ b/src/confparse.f90	
@@ -40,10 +40,13 @@
   use crest_data
   use crest_calculator
   use iomod
+  use utilities
   use strucrd
   use dynamics_module
   use optimize_module
   use parse_inputfile
+  use crest_restartlog
+  use lwoniom_module
   implicit none
   type(systemdata),intent(inout) :: env
   integer,intent(in) :: nra
@@ -78,13 +81,14 @@
 
 !=========================================================================================!
 !>--- print the program header and command line input
-  if (.not. gui) then
+  call get_command(cmd)
+  if (.not.gui) then
     call confscript_head(.false.)
 
     write (*,'(/,1x,a)') 'Command line input:'
-    call get_command(cmd)
-    write (*,'(1x,a,a,/)') '> ',trim(cmd)
+    write (*,'(1x,a,a,/)') '$ ',trim(cmd)
   end if
+  env%cmd = trim(cmd)
 
 !=========================================================================================!
 !>--- check if help is requested or citations shall be diplayed
@@ -95,15 +99,15 @@
     if (any((/character(10)::'-cite','--cite','--citation'/) == trim(arg(i)))) then
       call crestcite()
     end if
-    if (index(arg(i),'-newversion') .ne. 0)then !> as in CREST version >= 3.0
-      env%legacy = .false. 
-    endif
-    if (index(arg(i),'-legacy') .ne. 0)then  !> as in CREST version <3.0
+    if (index(arg(i),'-newversion') .ne. 0) then !> as in CREST version >= 3.0
+      env%legacy = .false.
+    end if
+    if (index(arg(i),'-legacy') .ne. 0) then  !> as in CREST version <3.0
       env%legacy = .true.
-    endif
-    if (index(arg(i),'-dry').ne.0)then   !> "dry" run to print settings 
-        env%dryrun = .true.
-    endif
+    end if
+    if (index(arg(i),'-dry') .ne. 0) then   !> "dry" run to print settings
+      env%dryrun = .true.
+    end if
   end do
 
 !========================================================================================!
@@ -120,6 +124,7 @@
   env%threadssetmanual = .false. !> did the user set the #threads manually?
 
   env%scratch = .false.          !> use scratch directory?
+  call getcwd(env%homedir)       !> original directory
   env%scratchdir = ''            !> directory that shall be used for scratch
 
 !>--- xtb settings
@@ -204,7 +209,7 @@
 !>--- Mixed MD settings required by iMTD-GC (V2)
   env%hmass = 2.0d0       ! if hmass=0, hmass is taken from the .xtbrc
   env%mdtemp = 300.d0     ! Due to Guiding Force the Temperature is not so important
-  env%nmdtemp = 400.0d0   ! base temperature for additional normal MDs 
+  env%nmdtemp = 400.0d0   ! base temperature for additional normal MDs
   env%mdstep = 5.0d0      ! 4 fs
   env%shake = 2           ! shake 1 makes it more stable but requires mdstep 2.0
   env%mddumpxyz = 100     ! if not set by the user mddumpxyz is adjusted in subroutine
@@ -293,9 +298,9 @@
   env%max_solv = 150
   env%solv_file = ''
   env%solu_file = ''
- 
+
 !&>
- 
+
 !=========================================================================================!
 !=========================================================================================!
 !> MAIN RUNTYPE SELECTION VIA CMD
@@ -304,21 +309,21 @@
 !>--- get the CREST version/runtype
   env%crestver = crest_imtd !> confscript version (v.1 = MF-MD-GC, v.2 = MTD)
   env%runver = 1            !> default
-  env%properties  = p_none  !> additional calculations/options before or after confsearch
+  env%properties = p_none  !> additional calculations/options before or after confsearch
   env%properties2 = p_none  !> backup for env%properties
   env%iterativeV2 = .true.  !> iterative crest V2 version
   env%preopt = .true.
 !>--- check for input file
   do i = 1,nra
     argument = trim(arg(i))
-    if (argument == '--input' .or. argument == '-i') then
-      call parseinputfile(env,trim(arg(i + 1)))
+    if (argument == '--input'.or.argument == '-i') then
+      call parseinputfile(env,trim(arg(i+1)))
       exit
     end if
-    if (i==1 .and. index(argument,'.toml').ne.0)then
+    if (i == 1.and.index(argument,'.toml') .ne. 0) then
       call parseinputfile(env,trim(arg(1)))
       exit
-    endif
+    end if
   end do
 !>--- first arg loop
   do i = 1,nra
@@ -367,8 +372,8 @@
         atmp = ''
         env%preopt = .false.
         env%ensemblename = 'none selected'
-        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))
-        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then
+        if (nra .ge. (i+1)) atmp = adjustl(arg(i+1))
+        if ((atmp(1:1) /= '-').and.(len_trim(atmp) .ge. 1)) then
           env%ensemblename = trim(atmp)
         end if
         call xyz2coord(env%ensemblename,'coord') !write coord from lowest structure
@@ -379,14 +384,14 @@
         env%crestver = crest_screen
         atmp = ''
         env%ensemblename = 'none selected'
-        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))
-        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then
+        if (nra .ge. (i+1)) atmp = adjustl(arg(i+1))
+        if ((atmp(1:1) /= '-').and.(len_trim(atmp) .ge. 1)) then
           env%ensemblename = trim(atmp)
         end if
         call xyz2coord(env%ensemblename,'coord') !write coord from lowest structure
         env%inputcoords = env%ensemblename !just for a printout
         exit
-     
+
       case ('-pka','-pKa')  !> pKa calculation script
         env%crestver = crest_pka
         env%runver = 33
@@ -398,8 +403,8 @@
         env%gbsa = .true.
         env%solv = '--alpb h2o'
         env%ptb%h_acidic = 0
-        call pka_argparse(arg(i + 1),env%ptb%h_acidic)
-        if (env%ptb%h_acidic == -2) env%ptb%pka_baseinp = trim(arg(i + 1))
+        call pka_argparse(arg(i+1),env%ptb%h_acidic)
+        if (env%ptb%h_acidic == -2) env%ptb%pka_baseinp = trim(arg(i+1))
 
       case ('-compare')   !> flag for comparing two ensembles, analysis tool
         env%compareens = .true.
@@ -407,16 +412,16 @@
         env%properties = p_compare
         env%ensemblename = 'none selected'
         env%ensemblename2 = 'none selected'
-        if (nra .ge. (i + 2)) then
-          atmp = adjustl(arg(i + 1))
-          btmp = adjustl(arg(i + 2))
+        if (nra .ge. (i+2)) then
+          atmp = adjustl(arg(i+1))
+          btmp = adjustl(arg(i+2))
         else
           write (*,'(a,a)') trim(arg(i)),' requires two arguments:'
           write (*,'(2x,a,a)') trim(arg(i)),' [ensemble1] [ensemble2]'
           error stop
         end if
-        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1) .and. &
-        &  (btmp(1:1) /= '-') .and. (len_trim(btmp) .ge. 1)) then
+        if ((atmp(1:1) /= '-').and.(len_trim(atmp) .ge. 1).and. &
+        &  (btmp(1:1) /= '-').and.(len_trim(btmp) .ge. 1)) then
           env%ensemblename = trim(atmp)
           env%ensemblename2 = trim(btmp)
         end if
@@ -448,12 +453,12 @@
         env%properties = p_propcalc
         atmp = ''
         env%ensemblename = 'none selected'
-        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))
-        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then
+        if (nra .ge. (i+1)) atmp = adjustl(arg(i+1))
+        if ((atmp(1:1) /= '-').and.(len_trim(atmp) .ge. 1)) then
           env%ensemblename = trim(atmp)
         end if
         inquire (file=env%ensemblename,exist=ex)
-        if (.not. ex) then
+        if (.not.ex) then
           write (*,'(1x,a,a,a)') 'invalid ensemble file <',trim(env%ensemblename),'>. exit.'
           error stop
         end if
@@ -468,12 +473,12 @@
         env%properties = p_rrhoaverage
         atmp = ''
         env%ensemblename = 'none selected'
-        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))
-        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then
+        if (nra .ge. (i+1)) atmp = adjustl(arg(i+1))
+        if ((atmp(1:1) /= '-').and.(len_trim(atmp) .ge. 1)) then
           env%ensemblename = trim(atmp)
         end if
         inquire (file=env%ensemblename,exist=ex)
-        if (.not. ex) then
+        if (.not.ex) then
           write (*,'(1x,a,a,a)') 'invalid ensemble file <',trim(env%ensemblename),'>. exit.'
           error stop
         end if
@@ -496,9 +501,9 @@
         env%ewin = 3.0d0
         env%doOHflip = .false. !Switch off OH-flip
         if (env%iterativeV2) env%iterativeV2 = .false.
-        if (nra >= i + 1) then
-           env%solv_file = trim(arg(i + 1))
-        endif  
+        if (nra >= i+1) then
+          env%solv_file = trim(arg(i+1))
+        end if
         exit
 
       case ('-compress')
@@ -515,17 +520,17 @@
         env%presp = .true.
 
       case ('-splitfile')
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         k = huge(j)
         l = 1
-        if (nra >= i + 2) then
-          read (arg(i + 2),*,iostat=io) j
+        if (nra >= i+2) then
+          read (arg(i+2),*,iostat=io) j
           if (io == 0) then
             k = j
           end if
         end if
-        if (nra >= i + 3) then
-          read (arg(i + 3),*,iostat=io) j
+        if (nra >= i+3) then
+          read (arg(i+3),*,iostat=io) j
           if (io == 0) then
             l = j
           end if
@@ -534,7 +539,7 @@
         stop
 
       case ('-printaniso')
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         inquire (file=ctmp,exist=ex)
         if (ex) then
           call printaniso(ctmp,0.01_wp,0.025_wp,0.5_wp)
@@ -542,18 +547,18 @@
         stop
 
       case ('-printboltz')
-        if (nra >= i + 2) then
-          ctmp = trim(arg(i + 1))
-          dtmp = trim(arg(i + 2))
+        if (nra >= i+2) then
+          ctmp = trim(arg(i+1))
+          dtmp = trim(arg(i+2))
           call prbweight(ctmp,dtmp)
         else
-          ctmp = trim(arg(i + 1))
+          ctmp = trim(arg(i+1))
           call prbweight(ctmp,'')
         end if
 
       case ('-wbotopo','-usewbo')  !> try to use a WBO file in topology analysis
-        ctmp = trim(arg(i + 1))
-        if (ctmp(1:1) .ne. '-' .and. (nra >= i + 1)) then
+        ctmp = trim(arg(i+1))
+        if (ctmp(1:1) .ne. '-'.and.(nra >= i+1)) then
           env%wbofile = trim(ctmp)
         else
           env%wbofile = 'wbo'
@@ -561,10 +566,10 @@
         env%wbotopo = .true.
 
       case ('-testtopo')
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         inquire (file=ctmp,exist=ex)
-        if (i + 2 .le. nra) then
-          dtmp = trim(arg(i + 2))
+        if (i+2 .le. nra) then
+          dtmp = trim(arg(i+2))
           if (dtmp(1:1) == '-') then
             dtmp = 'default'
           end if
@@ -574,7 +579,7 @@
         end if
 
       case ('-resortensemble')
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         inquire (file=ctmp,exist=ex)
         if (ex) then
           call resort_ensemble(ctmp)
@@ -587,15 +592,15 @@
         if (ctmp(1:1) .ne. '-') then
           env%inputcoords = trim(ctmp)
         end if
-        ctmp = trim(arg(i + 1)) !or this
+        ctmp = trim(arg(i+1)) !or this
         if (ctmp(1:1) .ne. '-') then
           env%inputcoords = trim(ctmp)
         end if
 
-      case ('-rmsd','-rmsdheavy')
-        ctmp = trim(arg(i + 1))
-        dtmp = trim(arg(i + 2))
-        if (argument == '-rmsdheavy') then
+      case ('-rmsd','-rmsdheavy','-hrmsd')
+        ctmp = trim(arg(i+1))
+        dtmp = trim(arg(i+2))
+        if ((argument == '-rmsdheavy').or.(argument=='-hrmsd')) then
           call quick_rmsd_tool(ctmp,dtmp,.true.)
         else
           call quick_rmsd_tool(ctmp,dtmp,.false.)
@@ -603,7 +608,7 @@
         stop
 
       case ('-symmetries')
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         inquire (file=ctmp,exist=ex)
         if (ex) then
           call ensemble_analsym(trim(ctmp),.true.)
@@ -613,13 +618,13 @@
       case ('-exlig','-exligand','-exchligand')
         env%properties = p_ligand
         env%ptb%infile = trim(arg(1))
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         env%ptb%newligand = trim(ctmp)
-        read (arg(i + 2),*,iostat=io) j
+        read (arg(i+2),*,iostat=io) j
         if (io == 0) then
           env%ptb%centeratom = j
         end if
-        read (arg(i + 3),*,iostat=io) j
+        read (arg(i+3),*,iostat=io) j
         if (io == 0) then
           env%ptb%ligand = j
         end if
@@ -629,15 +634,15 @@
         !> crest --ab <acid.xyz> <base.xyz> --chrg <acidchrg>
         env%properties = p_acidbase
         if (index(arg(i),'prep') .ne. 0) then
-          call pka_argparse2(env,arg(i + 1),arg(i + 2),env%ptb%pka_mode)
+          call pka_argparse2(env,arg(i+1),arg(i+2),env%ptb%pka_mode)
         else
-          ctmp = trim(arg(i + 1))
+          ctmp = trim(arg(i+1))
           inquire (file=ctmp,exist=ex)
           if (ex) then
             env%ptb%pka_acidensemble = trim(ctmp)
             write (*,'(1x,a,a)') 'File used for the acid: ',trim(ctmp)
           end if
-          ctmp = trim(arg(i + 2))
+          ctmp = trim(arg(i+2))
           inquire (file=ctmp,exist=ex)
           if (ex) then
             env%ptb%pka_baseensemble = trim(ctmp)
@@ -648,8 +653,8 @@
         env%gfnver = '--gfn2'
 
       case ('-redoextrapol')
-        ctmp = trim(arg(i + 1))
-        read (arg(i + 2),*,iostat=io) j
+        ctmp = trim(arg(i+1))
+        read (arg(i+2),*,iostat=io) j
         if (io == 0) then
           call redo_extrapol(ctmp,j)
         else
@@ -657,15 +662,13 @@
         end if
         stop
 
-
-
-      case( '-sp' ) !> singlepoint calculation (uses new calculator routines)
+      case ('-sp') !> singlepoint calculation (uses new calculator routines)
         env%crestver = crest_sp
         env%preopt = .false.
         env%legacy = .false.
         exit
 
-      case ('-optimize','-ancopt') !> ANCOPT structure optimization (uses new calculator routines)
+      case ('-opt','-optimize','-ancopt') !> ANCOPT structure optimization (uses new calculator routines)
         env%preopt = .false.
         env%crestver = crest_optimize
         env%legacy = .false.
@@ -677,8 +680,6 @@
         env%legacy = .false.
         exit
 
-
-
       case ('-SANDBOX')
         !>--- IMPLEMENT HERE WHATEVER YOU LIKE, FOR TESTING
         !>-----
@@ -709,7 +710,7 @@
   end if
 
 !>--- options for topology related applications.
-  if (.not. allocated(env%wbofile)) then
+  if (.not.allocated(env%wbofile)) then
     env%wbotopo = .false.
     env%wbofile = ''
   end if
@@ -724,15 +725,15 @@
 !>    I N P U T   C O O R D I N A T E S
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!
 !========================================================================================!
-!> If env%inputcoords is initialized anywhere prior to 
+!> If env%inputcoords is initialized anywhere prior to
 !> this point, it will be taken as the input.
 !> Otherwise, the first cmd argument after "crest" will
 !> taken for the input coordinates
-    if (allocated(env%inputcoords)) then
-      call inputcoords(env,env%inputcoords)
-    else
-      call inputcoords(env,trim(arg(1)))
-    end if
+  if (allocated(env%inputcoords)) then
+    call inputcoords(env,env%inputcoords)
+  else
+    call inputcoords(env,trim(arg(1)))
+  end if
 !========================================================================================!
 !> after this point there should always be a "coord" file present
 !========================================================================================!
@@ -753,29 +754,29 @@
 !========================================================================================!
 !-------- switch between legacy (systemcall) and new code (API) implementations
 !========================================================================================!
-      select case(argument)
-       case('-legacy')
-         env%legacy = .true.
-       case('-newversion' )
-         env%legacy = .false.
-      end select 
+      select case (argument)
+      case ('-legacy')
+        env%legacy = .true.
+      case ('-newversion')
+        env%legacy = .false.
+      end select
 !========================================================================================!
 !-------- flags exclusively for V1 (MF-MD-GC)
 !========================================================================================!
       if (env%crestver .eq. crest_mfmdgc) then
         select case (argument) !> V1
         case ('-m')
-          if (index(arg(i + 1),'ff') .ne. 0) then            !turn on qmdff MD mode
+          if (index(arg(i+1),'ff') .ne. 0) then            !turn on qmdff MD mode
             !env%mdmode=1
-            write (*,'(2x,a,1x,a,'' :'')') trim(arg(i)),trim(arg(i + 1))
+            write (*,'(2x,a,1x,a,'' :'')') trim(arg(i)),trim(arg(i+1))
             !write(*,'(5x,''QMDFF for MD part requested'')')
             write (*,'(5x,''QMDFF for MD part requested, but this option is discontinued!'')')
             write (*,'(5x,''Regular xTB MD is performed instead'')')
           end if
-          if (index(arg(i + 1),'md') .ne. 0) then            !turn on xtb MD mode
+          if (index(arg(i+1),'md') .ne. 0) then            !turn on xtb MD mode
             env%mdmode = 0
             !env%mdtime=40.0d0
-            write (*,'(2x,a,1x,a,'' :'')') trim(arg(i)),trim(arg(i + 1))
+            write (*,'(2x,a,1x,a,'' :'')') trim(arg(i)),trim(arg(i+1))
             write (*,'(5x,''xTB MD for MD part requested'')')
           end if
         case ('-loose')
@@ -785,11 +786,11 @@
         case ('-tight')
           env%level = 0.7   !increases # modes by factor 0.7
         case ('-mdtemp')           !set md temperature (V1 version)
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mdtemps(1) = xx(1)
         case ('-addmd')    !add another QMDFF MD at a temperature
-          call readl(arg(i + 1),xx,j)
-          env%temps = env%temps + 1
+          call readl(arg(i+1),xx,j)
+          env%temps = env%temps+1
           env%mdtemps(env%temps) = xx(1)
         case ('-nomf')
           env%performModef = .false.                          !skip the modefollowing
@@ -798,7 +799,7 @@
           env%performMD = .false.                             !skip the MD part
           write (*,'(2x,a,1x,a)') trim(arg(i)),' : skipping MD part.'
         case ('-shake')    !set shake
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%shake = nint(xx(1))
         case ('-quick')    !performing quick conformational search
           env%quick = .true.
@@ -810,7 +811,7 @@
           env%temps = 1
           env%mdtemps(env%temps) = 400
         case ('-mrest')     !set max number of restarts
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%Maxrestart = nint(xx(1))
         case default
           continue
@@ -822,7 +823,7 @@
       if (any((/crest_imtd,crest_imtd2,11/) == env%crestver)) then
         select case (argument) !> V2
         case ('-mdtemp')                          !set MTD temperature (V2 version)
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mdtemp = xx(1)
           env%user_temp = .true.
         case ('-quick')                           !performing quick conformational search
@@ -832,21 +833,21 @@
           env%ewin = 5.0d0
           if (env%optlev > 1.0d0) env%optlev = 1.0d0        !optlev tight for quick run
         case ('-shake')                           !set shake
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%shake = nint(xx(1))
         case ('-tstep')                           !set MD timestep in fs
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mdstep = xx(1)
           env%user_mdstep = .true.
         case ('-vbdump')                          !Vbias dump in ps
-          call readl(arg(i + 1),xx,j)
-          xx(2) = xx(1) * 1000
+          call readl(arg(i+1),xx,j)
+          xx(2) = xx(1)*1000
           env%mddump = nint(xx(2))
         case ('-mdskip')                          !set skipping structures in -mdopt
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mdskip = nint(xx(1))
         case ('-mddump')                          !set dumpstep for writing structures out of the md
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mddumpxyz = nint(xx(1))
         case ('-nomtd')                           !Don't do the MTD in V2
           env%performMTD = .false.
@@ -858,7 +859,7 @@
         case ('-rotmd')
           env%rotamermds = .true.
         case ('-tnmd')                            !temperature for additional normal MDs
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%nmdtemp = xx(1)
         case ('-gcmopt')                          !GC multilevel optimization activate in V2
           env%gcmultiopt = .true.
@@ -928,7 +929,7 @@
         if (env%iterativeV2) then
           select case (argument) !> V2i
           case ('-mrest')                  !set max number of restarts
-            call readl(arg(i + 1),xx,j)
+            call readl(arg(i+1),xx,j)
             env%Maxrestart = nint(xx(1))
           case ('-iru')                    !re-use previously found conformers as bias in iterative approach
             env%iru = .true.
@@ -949,14 +950,14 @@
 !========================================================================================!
 !------- Settings for MDOPT and SCREEN
 !========================================================================================!
-      if (env%crestver == crest_mdopt .or. env%crestver == crest_screen) then
+      if (env%crestver == crest_mdopt.or.env%crestver == crest_screen) then
         select case (argument) !> SCREEN
         case ('-qmdff')                     !use QMDFF for the MDs in SCREEN/MDOPT?
           env%useqmdff = .true.
         case ('-purge')        !Purge special application
           env%optpurge = .true.
         case ('-ethrpurge','-ethrp')
-          read (arg(i + 1),*,iostat=io) rdum
+          read (arg(i+1),*,iostat=io) rdum
           if (io == 0) env%ethrpurge = rdum
         case default
           continue
@@ -968,10 +969,10 @@
       if (env%crestver == crest_nano) then
         select case (argument) !> RCTR
         case ('-genpot')
-          if (i + 1 .le. nra) then
-            atmp = trim(arg(i + 1))
+          if (i+1 .le. nra) then
+            atmp = trim(arg(i+1))
             if (atmp(1:1) .ne. '-') then
-              call readl(arg(i + 1),xx,j)
+              call readl(arg(i+1),xx,j)
               env%rdens = xx(1)
             end if
           end if
@@ -980,15 +981,15 @@
         case ('-genmtd')
           env%properties = p_reactorset
           env%mdtime = 20.0d0
-          if (i + 1 .le. nra) then
-            atmp = trim(arg(i + 1))
+          if (i+1 .le. nra) then
+            atmp = trim(arg(i+1))
             if (atmp(1:1) .ne. '-') then
-              call readl(arg(i + 1),xx,j)
+              call readl(arg(i+1),xx,j)
               env%mdtime = xx(1)
             end if
           end if
           env%nmetadyn = 1
-          if (.not. allocated(env%metadfac)) then
+          if (.not.allocated(env%metadfac)) then
             allocate (env%metadfac(1))
             allocate (env%metadexp(1))
             allocate (env%metadlist(1))
@@ -1013,24 +1014,24 @@
         case ('-keepdir','-keeptmp')
           env%keepModef = .true.
         case ('-tstep')                           !set MD timestep in fs
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mdstep = xx(1)
           env%user_mdstep = .true.
         case ('-vbdump')                          !Vbias dump in ps
-          call readl(arg(i + 1),xx,j)
-          xx(2) = xx(1) * 1000
+          call readl(arg(i+1),xx,j)
+          xx(2) = xx(1)*1000
           env%mddump = nint(xx(2))
         case ('-mdskip')                          !set skipping structures in -mdopt
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mdskip = nint(xx(1))
         case ('-mddump')                          !set dumpstep for writing structures out of the md
           env%user_dumxyz = .true.
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mddumpxyz = nint(xx(1))
         case ('-nomtd')                           !Don't do the MTD in V2
           env%performMTD = .false.
         case ('-wscal')                           !scale size of wall potential
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%potscal = xx(1)
           env%user_wscal = .true.
         case ('-fixsolute')                       !Fix the solute after CMA trafo
@@ -1044,16 +1045,16 @@
           env%autozsort = .false.
         case ('-norotmd')                         !don't do the regular mds after step 2 in multilevel optimization of V2
           env%rotamermds = .false.
-        case( '-mdtemp' )                          !set MTD temperature (V2 version)
+        case ('-mdtemp')                          !set MTD temperature (V2 version)
           call readl(arg(i+1),xx,j)
-          env%mdtemp=xx(1)
+          env%mdtemp = xx(1)
           env%user_temp = .true.
         case ('-tnmd')                            !temperature for additional normal MDs
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%nmdtemp = xx(1)
-        case( '-shake' )                          !set shake
+        case ('-shake')                          !set shake
           call readl(arg(i+1),xx,j)
-          env%shake=nint(xx(1))
+          env%shake = nint(xx(1))
         end select !> QCG
       end if
 !========================================================================================!
@@ -1073,12 +1074,12 @@
         env%performCross = .true.     !do the genetic crossing
         env%autozsort = .true.
       case ('-opt','-optlev')              !settings for optimization level of GFN-xTB
-        env%optlev = optlevnum(arg(i + 1))
-        write (*,'(2x,a,1x,i0)') trim(arg(i)),nint(env%optlev)
+        env%optlev = optlevnum(arg(i+1))
+        write (*,'(2x,a,1x,a)') trim(arg(i)),optlevflag(env%optlev)
       case ('-gfn','-gfn1','-gfn2','-gfn0','-gff','-gfnff')
         ctmp = argument
         if (argument == '-gfn') then
-          dtmp = trim(arg(i + 1))
+          dtmp = trim(arg(i+1))
           ctmp = ctmp//dtmp
         end if
         if (env%properties == p_isomerize) then
@@ -1087,16 +1088,16 @@
         select case (ctmp) !> GFN
         case ('-gfn1')
           env%gfnver = '--gfn1'
-          write (*,'(2x,a,'' : Use of GFN1-xTB requested.'')') ctmp
+          write (*,'(2x,a,'' : Use of GFN1-xTB requested.'')') env%gfnver
         case ('-gfn2')
           env%gfnver = '--gfn2'
-          write (*,'(2x,a,'' : Use of GFN2-xTB requested.'')') ctmp
+          write (*,'(2x,a,'' : Use of GFN2-xTB requested.'')')  env%gfnver
         case ('-gfn0')
           env%gfnver = '--gfn0'
-          write (*,'(2x,a,'' : Use of GFN0-xTB requested.'')') ctmp
+          write (*,'(2x,a,'' : Use of GFN0-xTB requested.'')') env%gfnver
         case ('-gff','-gfnff')
           env%gfnver = '--gff'
-          write (*,'(2x,a,'' : Use of GFN-FF requested.'')') ctmp
+          write (*,'(2x,a,'' : Use of GFN-FF requested.'')') '--gfnff'
           env%mdstep = 1.5d0
           env%hmass = 5.0d0
           !call autoBondConstraint('coord',env%forceconst,env%wbofile)
@@ -1110,10 +1111,10 @@
           env%gfnver = '--gfn2'
         end select !> GFN
       case ('-gfn2@gfn0','-gfn2@gfn1','-gfn2@gff','-gfn2@ff','-gfn2@gfnff')
-        if(.not.env%legacy)then !TODO
-         write(*,'("> ",a,1x,a)')argument,'option not yet available with new calculator'
-         error stop
-        endif
+        if (.not.env%legacy) then !TODO
+          write (*,'("> ",a,1x,a)') argument,'option not yet available with new calculator'
+          error stop
+        end if
         select case (argument) !> GFN2ON
         case ('-gfn2@gfn0')
           env%gfnver = '--gfn0'
@@ -1130,10 +1131,10 @@
         call env%checkhy()
         env%reweight = .false.
       case ('-gfn2//gfnff')
-        if(.not.env%legacy)then !TODO
-         write(*,'("> ",a,1x,a)')argument,'option not yet available with new calculator'
-         error stop
-        endif
+        if (.not.env%legacy) then !TODO
+          write (*,'("> ",a,1x,a)') argument,'option not yet available with new calculator'
+          error stop
+        end if
         env%gfnver = '--gff'
         env%mdstep = 2.0d0
         env%gfnver2 = '--gfn2'
@@ -1144,15 +1145,24 @@
         bondconst = .true.
         env%cts%cbonds_md = .true.
         env%checkiso = .true.
-        if (index(arg(i + 1),'opt') .ne. 0) then
+        if (index(arg(i+1),'opt') .ne. 0) then
           env%altopt = .true.
           write (*,'(2x,a,a)') argument,' : GFN-FF MDs + GFN2 opt.'
         else
           write (*,'(2x,a,a)') argument,' : energy reweighting'
         end if
+
+      case('-refine','-rsp','-ropt') !> add one refinement step (via cmd only one is possible)
+        env%legacy = .false. !> new calculators only!
+        if(nra >= i+1)then
+          env%gfnver2 = trim(arg(i+1))
+          write (*,'(2x,a,1x,a,a)') argument,trim(env%gfnver2), &
+          & ' : adding refinement step (singlepoint on optimized structures)'
+        endif
+        
       case ('-charges') !read charges from file for GFN-FF calcs.
-        ctmp = trim(arg(i + 1))
-        if ((len_trim(ctmp) < 1) .or. (ctmp(1:1) == '-')) then
+        ctmp = trim(arg(i+1))
+        if ((len_trim(ctmp) < 1).or.(ctmp(1:1) == '-')) then
           ctmp = 'charges'
         end if
         inquire (file=ctmp,exist=ex)
@@ -1172,11 +1182,14 @@
         if (index(argument,'_global') .ne. 0) then
           env%cts%dispscal_global = .true.
         end if
-        if (nra .ge. i + 1) then
-          ctmp = trim(arg(i + 1))
+        if (nra .ge. i+1) then
+          ctmp = trim(arg(i+1))
           read (ctmp,*,iostat=io) rdum
           if (io .eq. 0) env%cts%dscal = rdum
         end if
+      case ('-mtd_kscal','-mtdkscal')
+         call readl(arg(i+1),xx,j)
+         env%mtd_kscal = xx(1)
       case ('-norestart')
         env%allowrestart = .false.
       case ('-readbias')
@@ -1185,8 +1198,8 @@
         env%properties = p_useonly
         env%autozsort = .false.
         env%dummypercent = 1.0_wp
-        if (nra .ge. i + 1) then
-          atmp = adjustl(arg(i + 1))
+        if (nra .ge. i+1) then
+          atmp = adjustl(arg(i+1))
           if (atmp(1:1) .ne. '-') then
             read (atmp,*) env%dummypercent
           end if
@@ -1194,9 +1207,9 @@
 
       case ('-gbsa','-g','-alpb')                                     !use GBSA implicit solvation
         env%gbsa = .true.
-        atmp = adjustl(arg(i + 1))
-        if (atmp(1:1) .ne. '-' .and. atmp(1:1) .ne. ' ') then
-          env%solvent = arg(i + 1)
+        atmp = adjustl(arg(i+1))
+        if (atmp(1:1) .ne. '-'.and.atmp(1:1) .ne. ' ') then
+          env%solvent = arg(i+1)
           if (trim(argument) == '-alpb') then
             env%solv = '--alpb '//trim(env%solvent)
           else
@@ -1206,53 +1219,53 @@
         write (*,'(2x,a,a)') trim(env%solv),' : implicit solvation'
 
       case ('-chrg')                                          !create a .CHRG file
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         open (newunit=ich,file='.CHRG')
         env%chrg = nint(xx(1))
         env%ref%ichrg = env%chrg
         write (ich,'(i0)') nint(xx(1))
         close (ich)
-        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))
+        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i+1))
 
       case ('-uhf')                                           !create a .UHF file
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         open (newunit=ich,file='.UHF')
         env%uhf = nint(xx(1))
         env%ref%uhf = env%uhf
         write (ich,'(i0)') nint(xx(1))
         close (ich)
-        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))
+        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i+1))
 
       case ('-len','-mdlen','-mdtime')                        !set md length in ps
-        atmp = arg(i + 1)
+        atmp = arg(i+1)
         call to_lower(atmp)
         j = index(atmp,'x')
         env%user_mdtime = .true.
         if (j .ne. 0) then                ! scaling of the md length
-          btmp = atmp(j + 1:)
+          btmp = atmp(j+1:)
           env%scallen = .true.
           call readl(btmp,xx,j)
           env%mdlenfac = xx(1)
         else                          ! direct setting of the md length
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%mdtime = xx(1)
-          write (*,'(2x,a,1x,a,1x,a)') trim(arg(i)),trim(arg(i + 1)), &
+          write (*,'(2x,a,1x,a,1x,a)') trim(arg(i)),trim(arg(i+1)), &
           &    '(MD length in ps)'
         end if
       case ('-mdscal','-lenscal')                             !scale md length
         env%scallen = .true.
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%mdlenfac = xx(1)
-      case( '-nmtd' ) !set number of MTDs
+      case ('-nmtd') !set number of MTDs
         env%runver = 787878
         call readl(arg(i+1),xx,j)
-        env%nmetadyn=nint(xx(1))
+        env%nmetadyn = nint(xx(1))
       case ('-gcmax','-setgcmax')                             !set maximum number of structures for GC
         env%setgcmax = .true.
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%gcmax = xx(1)
       case ('-xnam')                                          !select a name for the xTB executeable
-        env%ProgName = trim(arg(i + 1))
+        env%ProgName = trim(arg(i+1))
         write (*,'(2x,''-xnam :'')')
         write (*,'(5x,''xtb executable was set to: "'',a,''"'')') trim(env%ProgName)
       case ('-niceprint')                                     !progres bar printout
@@ -1261,7 +1274,7 @@
         env%trackorigin = .true.
         write (*,'(2x,a,1x,a)') trim(arg(i)),': tracking conformer origins.'
       case ('-constrain')                       !provide a list of atoms to write a .xcontrol.sample
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         call quick_constrain_file('coord',env%nat,env%ref%at,ctmp)
       case ('-nocbonds')
         bondconst = .false.
@@ -1270,7 +1283,7 @@
         inquire (file='bondlengths',exist=ex)
         if (ex) call remove('bondlengths')
       case ('-cbonds','-cbonds_md','-cbonds_ez')            !constrain all bonds
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         if (ctmp(1:1) .ne. '-') then
           read (ctmp,*,iostat=io) rdum
           if (io .eq. 0) env%forceconst = rdum
@@ -1286,7 +1299,7 @@
           ctype = 5
         end if
       case ('-cmetal','-cmetal_md')              !constrain transition metal coordination sites
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         if (ctmp(1:1) .ne. '-') then
           read (ctmp,*,iostat=io) rdum
           if (io .eq. 0) env%forceconst = rdum
@@ -1299,7 +1312,7 @@
           env%cts%cbonds_global = .false.
         end if
       case ('-cheavy','-fixheavy','-cheavy_md')    !constrain all heavy atom bonds
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         if (ctmp(1:1) .ne. '-') then
           read (ctmp,*,iostat=io) rdum
           if (io .eq. 0) env%forceconst = rdum
@@ -1312,7 +1325,7 @@
           env%cts%cbonds_global = .false.
         end if
       case ('-clight','-fixhyd','-clight_md')  !constraint all X-H bonds
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         if (ctmp(1:1) .ne. '-') then
           read (ctmp,*,iostat=io) rdum
           if (io .eq. 0) env%forceconst = rdum
@@ -1325,15 +1338,15 @@
           env%cts%cbonds_global = .false.
         end if
       case ('-cfile','-cinp')                                 !specify the constrain file
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         if (ctmp(1:1) .ne. '-') then
           env%constraints = trim(ctmp)
-          write (*,'(2x,a,1x,a)') trim(argument)//' :',trim(ctmp)
+          write (*,'(2x,a,1x,a)') '--cinp :',trim(ctmp)
         end if
       case ('-fc','-forceconstant')
-        ctmp = trim(arg(i + 1))
-        if (i + 1 >= nra) then
-          call readl(arg(i + 1),xx,j)
+        ctmp = trim(arg(i+1))
+        if (i+1 >= nra) then
+          call readl(arg(i+1),xx,j)
           env%forceconst = xx(1)
         end if
         write (*,'(2x,a,f6.4,a)') '-fc ',env%forceconst,': selected force constant in Eh'
@@ -1341,16 +1354,16 @@
         env%multilevelopt = .false.
       case ('-normmd')             !set number of normMDs
         env%rotamermds = .true.
-        if (i + 1 .le. nra) then
-          call readl(arg(i + 1),xx,j)
+        if (i+1 .le. nra) then
+          call readl(arg(i+1),xx,j)
           env%nrotammds = nint(xx(1))  !how many lowest conformers?
         end if
-        if (i + 2 .le. nra) then
-          call readl(arg(i + 2),xx,j)
+        if (i+2 .le. nra) then
+          call readl(arg(i+2),xx,j)
           env%temps = nint(xx(1))     !how many different temperatures
         end if
       case ('-rmsdpot','-gesc')
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         inquire (file=ctmp,exist=ex)
         if (ex) then
           env%cts%usermsdpot = .true.
@@ -1363,21 +1376,21 @@
       case ('-mergebias','-mergebias+','-gesc+')
         env%properties = -9224
         if (index(argument,'+') > 0) env%properties = p_gesc2
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         inquire (file=ctmp,exist=ex)
         if (ex) then
           env%biasfile = ctmp
         end if
         env%autozsort = .false.
       case ('-gescopt')
-        env%gescoptlev = optlevnum(arg(i + 1))
+        env%gescoptlev = optlevnum(arg(i+1))
       case ('-gescheavy','-heavygesc','-gesc_heavy')
         env%cts%gesc_heavy = .true.
       case ('-rthr2') !bias rmsd threshold
-        read (arg(i + 1),*,iostat=io) rdum
+        read (arg(i+1),*,iostat=io) rdum
         if (io == 0) env%rthr2 = rdum
       case ('-kshift')
-        read (arg(i + 1),*,iostat=io) rdum
+        read (arg(i+1),*,iostat=io) rdum
         if (io == 0) env%kshift = rdum
         env%kshiftnum = 1
       case ('-hflip')
@@ -1385,20 +1398,35 @@
       case ('-noflip')
         env%doOHflip = .false.
       case ('-maxflip')
-        read (arg(i + 1),*,iostat=io) rdum
-        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then
+        read (arg(i+1),*,iostat=io) rdum
+        if (io == 0.and.(index(arg(i+1),'-') .eq. 0)) then
           env%maxflip = nint(rdum)
         end if
       case ('-osdf')
         env%outputsdf = .true.
-        write(*,'(2x,a," :",1x,a)') trim(arg(i)), &
+        write (*,'(2x,a," :",1x,a)') trim(arg(i)), &
         & "output ensemble requested in sdf format"
+
+      case ('-wscal')                           !scale size of wall potential
+        call readl(arg(i+1),xx,j)
+        env%potscal = xx(1)
+      case ('-wall')
+        env%wallsetup = .true.
+        write (*,'(2x,a,1x,a)') '--wall:','requesting setup of wall potential'
+      case ('-wallxl','-wall-xl')
+        env%wallsetup = .true.
+        env%potscal = 1.5_wp
+        write (*,'(2x,a,1x,a)') '--wall-xl:','requesting setup of wall potential (x1.5 size)'
+      case ('-wallxxl','-wall-xxl')
+        env%wallsetup = .true.
+        env%potscal = 2.0_wp
+        write (*,'(2x,a,1x,a)') '--wall-xxl:','requesting setup of wall potential (x2.0 size)'
 !========================================================================================!
 !------ flags for parallelization / disk space
 !========================================================================================!
       case ('-T','-P','-parallel')  !set total number of OMP threads, this replaces -P and -O entirely
-        call readl(arg(i + 1),xx,j)
-        if (index(arg(i + 1),'-') .ne. 0) xx = 0d0
+        call readl(arg(i+1),xx,j)
+        if (index(arg(i+1),'-') .ne. 0) xx = 0d0
         env%Threads = nint(xx(1))
         env%autothreads = .true.
         env%threadssetmanual = .true.
@@ -1415,8 +1443,8 @@
         env%autozsort = .false.
         atmp = ''
         env%ensemblename = 'none selected'
-        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))
-        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then
+        if (nra .ge. (i+1)) atmp = adjustl(arg(i+1))
+        if ((atmp(1:1) /= '-').and.(len_trim(atmp) .ge. 1)) then
           env%ensemblename = trim(atmp)
         end if
         if (index(env%ensemblename,'none selected') .ne. 0) then
@@ -1438,36 +1466,36 @@
       case ('-compare')                                        !compare two given ensembles
         env%compareens = .true.
       case ('-maxcomp')                                        !maximum number of lowest conformers to compare with "-compare"
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%maxcompare = nint(xx(1))
       case ('-ewin')                                           !set energy threshold in kcal/mol
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%ewin = abs(xx(1))
-        if (any((/ p_protonate, p_deprotonate, p_tautomerize /) == env%properties))then
+        if (any((/p_protonate,p_deprotonate,p_tautomerize/) == env%properties)) then
           env%ptb%ewin = abs(xx(1))
         end if
-        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))
+        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i+1))
       case ('-rthr')                                           !set RMSD thr
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%rthr = xx(1)
-        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))
+        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i+1))
       case ('-ethr')                                           !set E thr
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%ethr = xx(1)
-        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))
+        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i+1))
       case ('-bthr')                                           !set rot const thr
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%thresholds(4) = xx(1)  !legacy
         env%bthr2 = xx(1)
-        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))
+        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i+1))
       case ('-allrot')                                         !use all rotational constants for comparison, instead of mean
         env%allrot = .true.
       case ('-athr')                                           !set int. rotation. equal atoms for NMR thr
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%athr = xx(1)
-        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i + 1))
+        write (*,'(2x,a,1x,a)') trim(arg(i)),trim(arg(i+1))
       case ('-pthr')                                           !set population thr
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         rdum = min(1.0_wp,xx(1)) !--> pthr <= 1
         rdum = max(0.0_wp,rdum)  !--> pthr >= 0
         env%pthr = rdum
@@ -1502,9 +1530,9 @@
         env%cgf(4) = .true.   !perform just the heavy atom RMSD
         env%heavyrmsd = .true.
       case ('-temp')
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         if (index(ctmp,'-') .eq. 0) then
-          call readl(arg(i + 1),xx,j)
+          call readl(arg(i+1),xx,j)
           env%tboltz = xx(1)
         end if
       case ('-prsc')                !> write scoord files
@@ -1519,13 +1547,13 @@
         env%checktopo = .true.
       case ('-notopo','-notopocheck')
         env%checktopo = .false.
-        ctmp=trim(arg(i+1))
-        if(ctmp(1:1).ne.'-')then
+        ctmp = trim(arg(i+1))
+        if (ctmp(1:1) .ne. '-') then
           call parse_topo_excl(env,ctmp)
-          if(allocated(env%excludeTOPO))then
+          if (allocated(env%excludeTOPO)) then
             env%checktopo = .true.
-          endif
-        endif
+          end if
+        end if
       case ('-noreftopo')
         env%reftopo = .false.
       case ('-ezcheck','-checkez')
@@ -1541,7 +1569,7 @@
         env%ptb%threshsort = .true.
       case ('-swel')                  !switch out H+ to something else in protonation script
         if (env%properties .eq. -3) then
-          call swparse(arg(i + 1),env%ptb)
+          call swparse(arg(i+1),env%ptb)
         end if
       case ('-deprotonate')           !deprotonation tool
         env%properties = p_deprotonate
@@ -1573,10 +1601,10 @@
       case ('-trev','-tdp')
         env%ptb%deprotprot = .true. !switch to deprotonation-first mode in tautomerization
       case ('-iter')                  !number of Protonation/Deprotonation cycles in Tautomerization
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%ptb%iter = nint(xx(1))
       case ('-texcl','-blacklist')
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
       case ('-strict')
         env%ptb%strictPDT = .true.
       case ('-verystrict','-vstrict')
@@ -1592,11 +1620,11 @@
       case ('-pkaensemble')
         env%preopt = .false.
         env%presp = .false.
-        call pka_argparse2(env,arg(i + 1),arg(i + 2),env%ptb%pka_mode)
+        call pka_argparse2(env,arg(i+1),arg(i+2),env%ptb%pka_mode)
       case ('-pkaparam')
         env%ptb%rdcfer = .true.
-        if (i + 1 .le. nra) then
-          ctmp = trim(arg(i + 1))
+        if (i+1 .le. nra) then
+          ctmp = trim(arg(i+1))
           if (ctmp(1:1) .ne. '-') then
             env%ptb%cferfile = ctmp
           end if
@@ -1606,17 +1634,17 @@
 !========================================================================================!
       case ('-entropy','-entropic')  !> new, specialized calculation of molecular entropies
         write (*,'(2x,a,'' : enhanced ensemble entropy calculation'')') trim(arg(i))
-        if (env%properties == p_propcalc) then 
-        !>--- for standalone use
+        if (env%properties == p_propcalc) then
+          !>--- for standalone use
           env%properties = p_CREentropy
 
-        elseif (env%confgo .and. env%properties == -1) then 
-        !>--- as extension for CREGEN
+        elseif (env%confgo.and.env%properties == -1) then
+          !>--- as extension for CREGEN
           env%entropic = .true.
           env%fullcre = .true.
 
-        else if (env%crestver == crest_imtd) then  
-        !>--- works as an extensiton to the conformational search
+        else if (env%crestver == crest_imtd) then
+          !>--- works as an extensiton to the conformational search
           env%properties = abs(p_CREentropy)
           env%autozsort = .false.     !> turn off zsort (since we are not going to GC anyways)
           env%performCross = .false.  !> turn off GC
@@ -1628,20 +1656,20 @@
         end if
         env%runver = 111             !> version  for selection of MTD bias settings
         env%doNMR = .true.           !> we need equivalencies
-        if (i + 1 .le. nra) then
-          ctmp = trim(arg(i + 1))    !> second argument can be the temperature
+        if (i+1 .le. nra) then
+          ctmp = trim(arg(i+1))    !> second argument can be the temperature
           if (index(ctmp,'-') .eq. 0) then
-            call readl(arg(i + 1),xx,j)
+            call readl(arg(i+1),xx,j)
             env%tboltz = xx(1)
           end if
         end if
         call env%addjob(env%properties)
 
       case ('-scthr','-entropy_cthr')
-        read (arg(i + 1),*,iostat=io) rdum
+        read (arg(i+1),*,iostat=io) rdum
         if (io == 0) env%emtd%confthr = rdum
       case ('-ssthr','-entropy_sthr')
-        read (arg(i + 1),*,iostat=io) rdum
+        read (arg(i+1),*,iostat=io) rdum
         if (io == 0) env%emtd%sconvthr = rdum
       case ('-rrhoav')             ! see above in the first specification of -rrhoav
         env%properties = p_rrhoaverage
@@ -1656,53 +1684,53 @@
         env%emtd%bhess = .false.
       case ('-ref')
         env%emtd%bhess = .true.
-        inquire (file=trim(arg(i + 1)),exist=ex)
+        inquire (file=trim(arg(i+1)),exist=ex)
         if (ex) then
-          call read_bhess_ref(env,trim(arg(i + 1)))
+          call read_bhess_ref(env,trim(arg(i+1)))
         end if
       case ('-pcap')
-        read (arg(i + 1),*,iostat=io) j
-        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then
+        read (arg(i+1),*,iostat=io) j
+        if (io == 0.and.(index(arg(i+1),'-') .eq. 0)) then
           env%thermo%pcap = j
         end if
       case ('-ptot')
-        read (arg(i + 1),*,iostat=io) rdum
-        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then
+        read (arg(i+1),*,iostat=io) rdum
+        if (io == 0.and.(index(arg(i+1),'-') .eq. 0)) then
           if (rdum > 1.0d0) rdum = 1.0d0
           env%thermo%ptot = rdum
         end if
       case ('-ithr')
-        read (arg(i + 1),*,iostat=io) rdum
+        read (arg(i+1),*,iostat=io) rdum
         if (io == 0) then
           if (rdum > 0.0d0) rdum = 0.0
           env%thermo%ithr = rdum
         end if
       case ('-rotorcut','-sthr')
-        read (arg(i + 1),*,iostat=io) rdum
-        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then
+        read (arg(i+1),*,iostat=io) rdum
+        if (io == 0.and.(index(arg(i+1),'-') .eq. 0)) then
           if (rdum < 0.0d0) rdum = 0.0d0
           env%thermo%sthr = rdum
         end if
       case ('-fscal')
-        read (arg(i + 1),*,iostat=io) rdum
-        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then
+        read (arg(i+1),*,iostat=io) rdum
+        if (io == 0.and.(index(arg(i+1),'-') .eq. 0)) then
           env%thermo%fscal = rdum
         end if
       case ('-trange')    !provide a range of temperatures (min max step) for entropy evaluation
-        read (arg(i + 1),*,iostat=io) rdum
-        if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then
+        read (arg(i+1),*,iostat=io) rdum
+        if (io == 0.and.(index(arg(i+1),'-') .eq. 0)) then
           env%thermo%trange(1) = rdum  !> T start
         end if
-        read (arg(i + 2),*,iostat=io) rdum
-        if (io == 0 .and. (index(arg(i + 2),'-') .eq. 0)) then
+        read (arg(i+2),*,iostat=io) rdum
+        if (io == 0.and.(index(arg(i+2),'-') .eq. 0)) then
           env%thermo%trange(2) = rdum  !> T stop (approx.)
         end if
-        read (arg(i + 3),*,iostat=io) rdum
-        if (io == 0 .and. (index(arg(i + 3),'-') .eq. 0)) then
+        read (arg(i+3),*,iostat=io) rdum
+        if (io == 0.and.(index(arg(i+3),'-') .eq. 0)) then
           env%thermo%trange(3) = rdum  !> T step
         end if
       case ('-tread')   !> read a file with temperatures (one per line) for entropy evaluation
-        ctmp = trim(arg(i + 1))
+        ctmp = trim(arg(i+1))
         inquire (file=ctmp,exist=ex)
         if (ex) then
           call env%thermo%read_temps(ctmp)
@@ -1714,7 +1742,7 @@
         env%nopreopt = .true.
         env%qcg_flag = .true.
       case ('-xtbiff')
-         env%use_xtbiff = .true.
+        env%use_xtbiff = .true.
       case ('-grow')
         env%qcg_runtype = 0
         env%qcg_flag = .true.
@@ -1729,22 +1757,31 @@
         env%qcg_flag = .true.
       case ('-nsolv')
         env%qcg_flag = .true.
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%nsolv = NINT(xx(1))
       case ('-maxsolv')
         env%qcg_flag = .true.
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%max_solv = NINT(xx(1))
       case ('-normdock')
         env%docking_qcg_flag = ''
+      case ('-fin_opt_gfn2')
+        env%final_gfn2_opt = .true.
+      case ('-directed') !specify the directed list
+        env%qcg_flag = .true.
+        ctmp = trim(arg(i + 1))
+        if (ctmp(1:1) .ne. '-') then
+          env%directed_file = trim(ctmp)
+          write (*,'(2x,a,1x,a)') trim(argument)//' :',trim(ctmp)
+        end if
       case ('-nclus')
         env%qcg_flag = .true.
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%nqcgclust = NINT(xx(1))
         env%user_nclust = .true.
       case ('-freqscal')
         env%qcg_flag = .true.
-        call readl(arg(i + 1),xx,j)
+        call readl(arg(i+1),xx,j)
         env%freq_scal = (xx(1))
       case ('-qcgmtd')
         env%ensemble_method = -1
@@ -1755,13 +1792,13 @@
       case ('-md')
         env%ensemble_method = 1
         env%qcg_flag = .true.
-        if (.not. env%user_enslvl) then
+        if (.not.env%user_enslvl) then
           env%ensemble_opt = '--gfn2'
         end if
       case ('-mtd')
         env%ensemble_method = 2
         env%qcg_flag = .true.
-        if (.not. env%user_enslvl) then
+        if (.not.env%user_enslvl) then
           env%ensemble_opt = '--gfn2'
         end if
       case ('-samerand')
@@ -1771,11 +1808,11 @@
         env%cff = .false.
         env%qcg_flag = .true.
       case ('-enslvl')
-        ctmp = arg(i + 1)
+        ctmp = arg(i+1)
         env%user_enslvl = .true.
         env%qcg_flag = .true.
-        if (arg(i + 1) == 'gfn') then
-          dtmp = trim(arg(i + 2))
+        if (arg(i+1) == 'gfn') then
+          dtmp = trim(arg(i+2))
           ctmp = trim(ctmp)//dtmp
         end if
         select case (ctmp)
@@ -1794,10 +1831,10 @@
         end select
 
       case ('-freqlvl')
-        ctmp = arg(i + 1)
+        ctmp = arg(i+1)
         env%qcg_flag = .true.
-        if (arg(i + 1) == 'gfn') then
-          dtmp = trim(arg(i + 2))
+        if (arg(i+1) == 'gfn') then
+          dtmp = trim(arg(i+2))
           ctmp = trim(ctmp)//dtmp
         end if
         select case (ctmp)
@@ -1819,28 +1856,28 @@
 !========================================================================================!
       case ('-cluster')
         write (*,'(2x,a,'' : ensemble clustering'')') trim(arg(i))
-        if (env%properties == p_propcalc) then 
-        !>--- for standalone use
+        if (env%properties == p_propcalc) then
+          !>--- for standalone use
           env%properties = p_cluster
-        elseif (env%confgo .and. env%properties == p_cregen) then 
-        !>--- as extension for CREGEN
+        elseif (env%confgo.and.env%properties == p_cregen) then
+          !>--- as extension for CREGEN
           env%cluster = .true.
         else if (any((/crest_imtd,crest_imtd2/) == env%crestver)) then
-        !>--- works as an extensiton to the conformational search
+          !>--- works as an extensiton to the conformational search
           env%properties = abs(p_cluster)
-        elseif (env%QCG) then 
+        elseif (env%QCG) then
           env%properties = abs(p_cluster)
         end if
         env%doNMR = .true.     !> we need equivalencies
         call env%addjob(env%properties)
-        if (i + 1 .le. nra) then !second argument a distinct number of clusters
-          read (arg(i + 1),*,iostat=io) j
-          if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then
+        if (i+1 .le. nra) then !second argument a distinct number of clusters
+          read (arg(i+1),*,iostat=io) j
+          if (io == 0.and.(index(arg(i+1),'-') .eq. 0)) then
             env%nclust = j
           else
             env%nclust = 0
-            if ((index(arg(i + 1),'-') .eq. 0)) then
-              ctmp = trim(arg(i + 1))
+            if ((index(arg(i+1),'-') .eq. 0)) then
+              ctmp = trim(arg(i+1))
               select case (ctmp)
               case ('loose')
                 env%clustlev = -1
@@ -1870,24 +1907,24 @@
           end if
         end if
       case ('-pccap')
-        if (i + 1 .le. nra) then !second argument is the max. number of PCs
-          read (arg(i + 1),*,iostat=io) j
-          if (io == 0 .and. (index(arg(i + 1),'-') .eq. 0)) then
+        if (i+1 .le. nra) then !second argument is the max. number of PCs
+          read (arg(i+1),*,iostat=io) j
+          if (io == 0.and.(index(arg(i+1),'-') .eq. 0)) then
             env%pccap = j
           end if
         end if
       case ('-nopcmin')
         env%pcmin = 0.0d0
       case ('-pctype','-pctyp')
-        if (i + 1 .le. nra) then
-          ctmp = trim(arg(i + 1))
+        if (i+1 .le. nra) then
+          ctmp = trim(arg(i+1))
           if (ctmp(1:1) .ne. '-') then
             env%pcmeasure = ctmp
           end if
         end if
       case ('-pcaex','-pcaexclude')
-        if (i + 1 .le. nra) then
-          ctmp = trim(arg(i + 1))
+        if (i+1 .le. nra) then
+          ctmp = trim(arg(i+1))
           if (ctmp(1:1) .ne. '-') then
             env%atlist = ctmp
             env%pcaexclude = .true.
@@ -1897,9 +1934,9 @@
 !---------- PROPERTY MODE
 !========================================================================================!
       case ('-prop')
-        if ((env%properties == p_none .or.    &
-        &  env%properties == p_propcalc )) then         !property selection
-          ctmp = trim(arg(i + 1))
+        if ((env%properties == p_none.or.    &
+        &  env%properties == p_propcalc)) then         !property selection
+          ctmp = trim(arg(i+1))
           PROPARG:select case(ctmp)
           case ('hess')                  !hessian calculation to free energies for all conformers
           env%properties2 = 1
@@ -1941,8 +1978,8 @@
         end if
       case ('-dftrc')                            !provide dft-rc file (including path)
         atmp = ''
-        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))
-        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then
+        if (nra .ge. (i+1)) atmp = adjustl(arg(i+1))
+        if ((atmp(1:1) /= '-').and.(len_trim(atmp) .ge. 1)) then
           env%dftrcfile = trim(atmp)
         end if
       case ('-hardcut')                          !cut DFT populations hard
@@ -1950,12 +1987,12 @@
       case ('-pclean')                           !cleanup option for property mode, i.e., remove PROP/
         env%pclean = .true.
 !========================================================================================!
-      case ('-scratch') 
+      case ('-scratch')
         !use a scratch directory to perform the calculation in
         env%scratch = .true.
         atmp = ''
-        if (nra .ge. (i + 1)) atmp = adjustl(arg(i + 1))
-        if ((atmp(1:1) /= '-') .and. (len_trim(atmp) .ge. 1)) then
+        if (nra .ge. (i+1)) atmp = adjustl(arg(i+1))
+        if ((atmp(1:1) /= '-').and.(len_trim(atmp) .ge. 1)) then
           env%scratchdir = trim(atmp)
         end if
       case ('-keepscratch')
@@ -1975,29 +2012,29 @@
 !>----- additional checks and settings
   if (env%crestver .eq. crest_solv) bondconst = .false.
 
-  if (env%qcg_flag .and. env%crestver .ne. crest_solv) then
+  if (env%qcg_flag.and.env%crestver .ne. crest_solv) then
     error stop 'At least one flag is only usable for QCG runtype. Exit.'
   end if
 
-  if (env%autozsort .and. env%crestver .eq. crest_solv) then
+  if (env%autozsort.and.env%crestver .eq. crest_solv) then
     error stop 'Z sorting of the input is unavailable for -qcg runtyp.'
   end if
 
-  if (env%NCI .or. env%wallsetup) then
+  if (env%NCI.or.env%wallsetup) then
     call wallpot(env)
-    if(env%wallsetup)then
-    write(*,'(2x,a)') 'Automatically generated ellipsoide potential:'
+    if (env%wallsetup) then
+      write (*,'(2x,a)') 'Automatically generated ellipsoide potential:'
     else
-    write (*,'(2x,a)') 'Automatically generated ellipsoide potential for NCI mode:'
-    endif
+      write (*,'(2x,a)') 'Automatically generated ellipsoide potential for NCI mode:'
+    end if
     call write_cts_NCI_pr(6,env%cts)
     write (*,*)
   end if
 
 !>--- automatic bond constraint setup
-  if (env%crestver > 200 .and. env%crestver < 300) then
+  if (env%crestver > 200.and.env%crestver < 300) then
     !>--- internal calculation engine versions
-    if (.not. bondconst) then
+    if (.not.bondconst) then
       call autoconstraint_internal(env)
     else
       select case (ctype)
@@ -2022,24 +2059,23 @@
   end if
 
 !>--- additional parsing of $setblock, .constrains and .confscriptrc file
-  call parseRC2(env,bondconst)   
+  call parseRC2(env,bondconst)
 
 !>--- internal constraint check-up
-  call  internal_constraint_repair(env)
+  call internal_constraint_repair(env)
 
-
 !========================================================================================!
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!
 !> settings after user input parsing
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!
 !========================================================================================!
-  if ((any((/crest_imtd,crest_imtd2,crest_pka,crest_compr,11/) == env%crestver)) .and.  &
-  &  .not. env%confgo) then
+  if ((any((/crest_imtd,crest_imtd2,crest_pka,crest_compr,11/) == env%crestver)).and.  &
+  &  .not.env%confgo) then
     call defaultGF(env) !set Guiding Force default if none was read
   end if
 
   !-- increase gbsa grid for GFNn-xTB calculations (not for the FF)
-  if ((env%gfnver .ne. '--gff') .and. (env%gbsa)) then
+  if ((env%gfnver .ne. '--gff').and.(env%gbsa)) then
     env%cts%ggrid = .true.
     env%cts%gbsagrid = 'tight'
   end if
@@ -2052,35 +2088,36 @@
   end if
 
   !>--- defaults for QCG gfnff ensemble search
-  if( env%crestver ==  crest_solv)then
-  if (env%ensemble_opt .EQ. '--gff') then
-    env%mdstep = 1.5d0
-    env%hmass = 5.0d0
-    ctype = 5 !bond constraint
-    bondconst = .true.
-    env%cts%cbonds_md = .true.
-    env%checkiso = .true.
-    env%lmover = '--gfn2'
-  end if
-  if ((env%gfnver .EQ. '--gff') .OR. (env%gfnver .EQ. '--gfn0')) then
-    env%lmover = '--gfn2'
-  else
-    env%lmover = env%gfnver
-  end if
-  endif
+  if (env%crestver == crest_solv) then
+    if (env%ensemble_opt .EQ. '--gff') then
+      env%mdstep = 1.5d0
+      env%hmass = 5.0d0
+      ctype = 5 !bond constraint
+      bondconst = .true.
+      env%cts%cbonds_md = .true.
+      env%checkiso = .true.
+      env%lmover = '--gfn2'
+    end if
+    if ((env%gfnver .EQ. '--gff').OR.(env%gfnver .EQ. '--gfn0')) then
+      env%lmover = '--gfn2'
+    else
+      env%lmover = env%gfnver
+    end if
+  end if
+  if (env%ensemble_opt == '--gfn2' .or. env%gfnver == '--gfn2') &
+          & env%final_gfn2_opt = .false. !Prevent additional opt.
 
   if (env%useqmdff) then
     env%autozsort = .false.
   end if
 
-  if (.not. env%preopt) then
+  if (.not.env%preopt) then
     if (allocated(env%ref%topo)) deallocate (env%ref%topo)
   end if
 
-
 !>-- driver for optimization along trajectory, additional settings
-  if (.not. any((/crest_mfmdgc,crest_imtd,crest_imtd2,crest_compr/) == env%crestver) &
-      & .OR. (env%qcg_runtype .GT. 0 .and. env%ensemble_method .EQ. 0)) then
+  if (.not.any((/crest_mfmdgc,crest_imtd,crest_imtd2,crest_compr/) == env%crestver) &
+      & .OR.(env%qcg_runtype .GT. 0.and.env%ensemble_method .EQ. 0)) then
     env%autozsort = .false.
     env%trackorigin = .false.
     env%confgo = .false.
@@ -2095,7 +2132,7 @@
   end if
 
 !>-- some more zsort checks
-  if (.not. env%onlyZsort .and. env%autozsort) then
+  if (.not.env%onlyZsort.and.env%autozsort) then
     call zsortwarning2(env) !turn autozsort off when a .constrains file is present.
   end if
   if (env%autozsort) then
@@ -2104,16 +2141,46 @@
   if (env%sdfformat) then
     env%autozsort = .false.
   end if
+  
+!>--- 2023/08/19 moved zsort to a standalone property tool
+  if(env%autozsort)then
+    env%properties = p_zsort
+  endif 
 
+!>--- for legacy runtypes, check if xtb is present
+  if(env%legacy)then
+    call checkprog_silent(env%ProgName,.true.,iostat=io)
+    if(io /= 0 ) error stop
+  endif
+
 !========================================================================================!
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!
 !> FALLBACK setup of new calculator
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!
 !========================================================================================!
-  if(.not.env%legacy .and. env%calc%ncalculations == 0 )then
+  if (.not.env%legacy.and.env%calc%ncalculations == 0) then
+    write (stdout,'(/,a)',advance='no') '> Setting up backup calculator ...'
+    flush (stdout)
     call env2calc_setup(env)
+    write(stdout,*) 'done.'
+    call env%calc%info(stdout)
+  end if
+!>--- pass on opt-level to new calculator
+  if(.not.env%legacy)then
+     env%calc%optlev = nint(env%optlev)
+  endif
+
+!>--- ONIOM setup from toml file
+  if (allocated(env%ONIOM_toml))then
+    allocate(env%calc%ONIOM)
+    call ONIOM_read_toml(env%ONIOM_toml,env%nat,env%ref%at,env%ref%xyz,env%calc%ONIOM)     
+    call env%calc%ONIOMexpand()
+    !call env%calc%info(stdout)
+    !call env%calc%ONIOM%dump_fragments() 
+    !stop 'ONIOM read'
   endif
 
+
   return
 end subroutine parseflags
 
@@ -2130,6 +2197,8 @@
   use iso_fortran_env,wp => real64
   use crest_data
   use iomod
+  use utilities
+  use parse_xtbinput
   implicit none
 
   type(systemdata),intent(inout) :: env
@@ -2143,145 +2212,133 @@
   logical :: create,atomlistused
   logical :: bondconst
 
-!>--- check for any of the possible constrainement files
-    ex1 = .false.
-
-    allocate (cfiles(4))
-
-    cfiles(1) = '.xcontrol'
-    cfiles(2) = '.constrains'
-    cfiles(3) = '.constraints'
-    cfiles(4) = env%constraints  !for user-set option (todo)
-
-    do i = 1,4
-      inquire (file=cfiles(i),exist=ex)
-      if (ex) then
-        env%constraints = trim(cfiles(i))
-        ex1 = .true.
-      end if
-    end do
-    deallocate (cfiles)
+!>--- check for constraint file
+  ex1 = .false.
+  inquire (file=env%constraints,exist=ex1)
 
 !>--- do we have a user-set constraint to all bonds?
-    if (bondconst) then
-      inquire (file='bondlengths',exist=ex2)
-      if (ex2) then
-        call rd_cbonds('bondlengths',env)
-        if (.not. env%cts%cbonds_md) then
-          env%cts%cbonds_global = .true.
-        end if
-      end if
-    end if
+  if (bondconst) then
+    inquire (file='bondlengths',exist=ex2)
+    if (ex2) then
+      call rd_cbonds('bondlengths',env)
+      if (.not.env%cts%cbonds_md) then
+        env%cts%cbonds_global = .true.
+      end if
+    end if
+  end if
 
-    if (ex1) then
-      write (*,'(/,1x,a,a,a)') '<',trim(env%constraints),'> file present.'
-      env%cts%used = .true.
-    else
-      env%cts%used = .false.
-      return
-    end if
+  if (ex1) then
+    write (*,'(/,1x,a,a,a)') '<',trim(env%constraints),'> file present.'
+    env%cts%used = .true.
+  else
+    env%cts%used = .false.
+    return
+  end if 
 
 !>--- read the data
-    call read_constrainbuffer(env%constraints,env%cts)
-    call sort_constraints(env%cts)
-    write (*,*) 'content of the constraining file (sorted):'
-    if (env%cts%ndim .gt. 20) then
-      write (*,'(1x,a)') '<skipped due to length of constraining file>'
-    else
-      do i = 1,env%cts%ndim
-        if (trim(env%cts%sett(i)) .ne. '') then
-          write (*,'(''>'',1x,a)') trim(env%cts%sett(i))
-        end if
-      end do
-    end if
+  call read_constrainbuffer(env%constraints,env%cts)
+  call sort_constraints(env%cts)
+  write (*,*) 'content of the constraining file (sorted):'
+  if (env%cts%ndim .gt. 20) then
+    write (*,'(1x,a)') '<skipped due to length of constraining file>'
+  else
+    do i = 1,env%cts%ndim
+      if (trim(env%cts%sett(i)) .ne. '') then
+        write (*,'(''>'',1x,a)') trim(env%cts%sett(i))
+      end if
+    end do
+  end if
+  if(.not.env%legacy)then
+    call parse_xtbinputfile(env,env%constraints)
+  endif
 
 !>--- some settings
-    create = .false.
-    atomlistused = .false.
-    allocate (atlist(env%nat))
+  create = .false.
+  atomlistused = .false.
+  allocate (atlist(env%nat))
 
 !>--- parse for special arguments that are used by CREST also
-    do i = 1,env%cts%ndim
-      btmp = env%cts%sett(i)
-      if (trim(btmp) .eq. '') cycle
-      atmp = btmp
-      call to_lower(atmp)  !convert to lower-case for case-insensitivity
-      if (index(atmp,'atomlist+') .ne. 0) then
-        create = .true.
-        atomlistused = .true.
-        dg = atmp
-        call split_set_args(dg,argument)
-        call parse_atlist_new(trim(argument),env%rednat,env%nat,env%ref%at,atlist)
-        write (*,'(2x,a)') trim(adjustl(btmp))
-        write (*,'(5x,a,i0)') '# of atoms considered for RMSDs:',env%rednat
-        env%includeRMSD = atlist !includeRMSD contains only the atoms that are included in RMSD
-      end if
-      if (index(atmp,'atomlist-') .ne. 0) then
-        create = .true.
-        atomlistused = .true.
-        dg = atmp
-        call split_set_args(dg,argument)
-        call parse_atlist_new(trim(argument),j,env%nat,env%ref%at,atlist)
-        env%rednat = env%nat - j
-        write (*,'(2x,a)') trim(adjustl(btmp))
-        write (*,'(3x,a,i0)') '# of atoms considered for RMSDs:',env%rednat
-        env%includeRMSD = atlist !includeRMSD contains the atoms that are NOT included in RMSD
-        do k = 1,env%nat
-          if (env%includeRMSD(k) .lt. 1) then   !therefore the values have to be "inverted"
-            env%includeRMSD(k) = 1
-          else
-            env%includeRMSD(k) = 0
-          end if
-        end do
-      end if
-      if ((index(atmp,'$metadyn') .ne. 0)) then
-        do j = i + 1,env%cts%ndim
-          btmp = env%cts%sett(j)
-          if (index(btmp,'$') .ne. 0) exit    !--- exit $metadyn-block
-          if (index(btmp,'atoms:') .ne. 0) then
-            create = .true.
-            atomlistused = .true.
-            dg = btmp
-            call split_set_args(dg,argument)
-            call parse_atlist_new(trim(argument),env%rednat,env%nat,env%ref%at,atlist)
-            write (*,'(2x,a)') trim(adjustl(btmp))
-            write (*,'(5x,a,i0)') '# of atoms considered for RMSDs:',env%rednat
-            env%includeRMSD = atlist !includeRMSD contains only the atoms that are included in RMSD
-          end if
-        end do
-      end if
-      if (index(btmp,'reference=') .ne. 0) then
-        call rdarg(btmp,'reference=',env%fixfile)
-        write (*,'(1x,a,1x,a)') 'fix file:',trim(env%fixfile)
-      end if
-      if ((index(atmp,'$wall') .ne. 0)) then
-        if (env%NCI) then
-          env%cts%sett(i) = ''
-          env%cts%pots = ''
-          write (env%cts%pots(1),'(a)') '$wall'
-          k = 2
-          do j = i + 1,env%cts%ndim
-            btmp = env%cts%sett(j)
-            if (index(btmp,'$') .ne. 0) exit    !--- exit $wall-block
-            env%cts%sett(j) = ''
-            write (env%cts%pots(k),'(a)') trim(btmp)
-            k = k + 1
-          end do
+  do i = 1,env%cts%ndim
+    btmp = env%cts%sett(i)
+    if (trim(btmp) .eq. '') cycle
+    atmp = btmp
+    call to_lower(atmp)  !convert to lower-case for case-insensitivity
+    if (index(atmp,'atomlist+') .ne. 0) then
+      create = .true.
+      atomlistused = .true.
+      dg = atmp
+      call split_set_args(dg,argument)
+      call parse_atlist_new(trim(argument),env%rednat,env%nat,env%ref%at,atlist)
+      write (*,'(2x,a)') trim(adjustl(btmp))
+      write (*,'(5x,a,i0)') '# of atoms considered for RMSDs:',env%rednat
+      env%includeRMSD = atlist !includeRMSD contains only the atoms that are included in RMSD
+    end if
+    if (index(atmp,'atomlist-') .ne. 0) then
+      create = .true.
+      atomlistused = .true.
+      dg = atmp
+      call split_set_args(dg,argument)
+      call parse_atlist_new(trim(argument),j,env%nat,env%ref%at,atlist)
+      env%rednat = env%nat-j
+      write (*,'(2x,a)') trim(adjustl(btmp))
+      write (*,'(3x,a,i0)') '# of atoms considered for RMSDs:',env%rednat
+      env%includeRMSD = atlist !includeRMSD contains the atoms that are NOT included in RMSD
+      do k = 1,env%nat
+        if (env%includeRMSD(k) .lt. 1) then   !therefore the values have to be "inverted"
+          env%includeRMSD(k) = 1
+        else
+          env%includeRMSD(k) = 0
+        end if
+      end do
+    end if
+    if ((index(atmp,'$metadyn') .ne. 0)) then
+      do j = i+1,env%cts%ndim
+        btmp = env%cts%sett(j)
+        if (index(btmp,'$') .ne. 0) exit    !--- exit $metadyn-block
+        if (index(btmp,'atoms:') .ne. 0) then
+          create = .true.
+          atomlistused = .true.
+          dg = btmp
+          call split_set_args(dg,argument)
+          call parse_atlist_new(trim(argument),env%rednat,env%nat,env%ref%at,atlist)
+          write (*,'(2x,a)') trim(adjustl(btmp))
+          write (*,'(5x,a,i0)') '# of atoms considered for RMSDs:',env%rednat
+          env%includeRMSD = atlist !includeRMSD contains only the atoms that are included in RMSD
+        end if
+      end do
+    end if
+    if (index(btmp,'reference=') .ne. 0) then
+      call rdarg(btmp,'reference=',env%fixfile)
+      write (*,'(1x,a,1x,a)') 'fix file:',trim(env%fixfile)
+    end if
+    if ((index(atmp,'$wall') .ne. 0)) then
+      if (env%NCI) then
+        env%cts%sett(i) = ''
+        env%cts%pots = ''
+        write (env%cts%pots(1),'(a)') '$wall'
+        k = 2
+        do j = i+1,env%cts%ndim
+          btmp = env%cts%sett(j)
+          if (index(btmp,'$') .ne. 0) exit    !--- exit $wall-block
+          env%cts%sett(j) = ''
+          write (env%cts%pots(k),'(a)') trim(btmp)
+          k = k+1
+        end do
 
-          write (*,'(/,2x,a)') 'Automatically generated ellipsoide potential overwritten by:'
-          call write_cts_NCI(6,env%cts)
-          write (*,*)
+        write (*,'(/,2x,a)') 'Automatically generated ellipsoide potential overwritten by:'
+        call write_cts_NCI(6,env%cts)
+        write (*,*)
 
-        end if
-      end if
-    end do
+      end if
+    end if
+  end do
 
-    if (.not. atomlistused) then
-      atlist = 1
-      env%includeRMSD = atlist
-    end if
+  if (.not.atomlistused) then
+    atlist = 1
+    env%includeRMSD = atlist
+  end if
 
-    deallocate (atlist)
+  deallocate (atlist)
 
   return
 end subroutine parseRC2
@@ -2315,24 +2372,24 @@
     arg2 = env%solv_file
     call inputcoords_qcg(env,arg,arg2)
     return
-  endif
+  end if
 !>---
 
   inquire (file=arg,exist=ex)
   inquire (file='coord',exist=ex2)
-  if (.not. ex .and. .not. ex2) then
-    if(env%dryrun)then
-      write(stdout,*) 'No (valid) input file, but ignoring for dry run.'
+  if (.not.ex.and..not.ex2) then
+    if (env%dryrun) then
+      write (stdout,*) 'No (valid) input file, but ignoring for dry run.'
       return
     else
       error stop 'No (valid) input file! exit.'
-    endif
+    end if
   end if
-  if (ex2) then 
+  if (ex2) then
 !>-- save coord as reference
     call copy('coord','coord.original')
   end if
-  if (ex .and. arg(1:1) .ne. '-') then
+  if (ex.and.arg(1:1) .ne. '-') then
     call mol%open(arg)
     call mol%write('coord')
     call mol%write('struc.xyz')
@@ -2341,20 +2398,21 @@
   else
     inputfile = 'coord'
   end if
+  if(.not.allocated(env%inputcoords)) env%inputcoords = inputfile
 
 !>-- if the input was a SDF file, special handling
   env%sdfformat = .false.
   call checkcoordtype(inputfile,i)
   if (any((/31,32/) == i)) then
-     env%sdfformat = .true.
-     env%outputsdf = .true.
+    env%sdfformat = .true.
+    env%outputsdf = .true.
   end if
 
 !>-- after this point there should always be an coord file present
-  if (.not. allocated(env%inputcoords)) env%inputcoords = 'coord'
+  if (.not.allocated(env%inputcoords)) env%inputcoords = 'coord'
   call mol%open('coord')
 !>-- shift to CMA and align according to rot.const.
-  if(env%crestver /= crest_solv) call axis(mol%nat,mol%at,mol%xyz)
+  if (env%crestver /= crest_solv) call axis(mol%nat,mol%at,mol%xyz)
 !>-- overwrite coord
   call mol%write('coord')
 
@@ -2367,11 +2425,11 @@
   env%ref%at = mol%at
   env%ref%xyz = mol%xyz
   env%ref%ichrg = env%chrg
-  env%ref%uhf = env%uhf 
+  env%ref%uhf = env%uhf
 !>-- topology save
   if (any((/crest_mfmdgc,crest_imtd,crest_imtd2/) == env%crestver)) then
-    if (.not. env%autozsort) then
-      env%ref%ntopo = mol%nat * (mol%nat + 1) / 2
+    if (.not.env%autozsort) then
+      env%ref%ntopo = mol%nat*(mol%nat+1)/2
       allocate (env%ref%topo(env%ref%ntopo))
       call quicktopo(mol%nat,mol%at,mol%xyz,env%ref%ntopo,env%ref%topo)
     end if
@@ -2422,15 +2480,15 @@
   end if
   inquire (file='coord',exist=ex22)
 
-  if (.not. ex11 .and. .not. ex12 .and. .not. solu) then
+  if (.not.ex11.and..not.ex12.and..not.solu) then
     error stop 'No (valid) solute file! exit.'
-  else if (.not. ex21 .and. .not. ex22 .and. .not. solv) then
+  else if (.not.ex21.and..not.ex22.and..not.solv) then
     error stop 'No (valid) solvent file! exit.'
   end if
 
 !---------------Handling solute---------------------!
 
-  if (ex11 .and. arg1(1:1) .ne. '-') then
+  if (ex11.and.arg1(1:1) .ne. '-') then
     call mol%open(arg1)
     call mol%write('solute')
     call mol%write('solute.xyz')
@@ -2438,12 +2496,12 @@
     inputfile = trim(arg1)
     write (*,*) 'Solute-file: ',arg1
     env%solu_file = arg1
-  else if (solu .and. .not. ex11) then
+  else if (solu.and..not.ex11) then
     call copy('solute','solute.old')
     inputfile = 'solute'
     write (*,'(/,1x,a)') 'Solute-file: solute'
     env%solu_file = 'solute'
-  else if (ex12 .and. .not. ex11) then !-- save coord as reference
+  else if (ex12.and..not.ex11) then !-- save coord as reference
     call copy('coord','coord.old')
     call copy('coord','solute')
     write (*,'(/,1x,a)') 'Solute-file: coord'
@@ -2456,14 +2514,14 @@
   !--- if the input was a SDF file, special handling
   env%sdfformat = .false.
   call checkcoordtype(inputfile,i)
-  if (i == 31 .or. i == 32) then
+  if (i == 31.or.i == 32) then
 !      call inpsdf(env,inputfile)
     write (*,*) 'QCG currently does not support SDF-files.'
   end if
 
 !---------------Handling solvent---------------------!
 
-  if (ex21 .and. arg2(1:1) .ne. '-' .and. arg2(1:1) .ne. ' ') then
+  if (ex21.and.arg2(1:1) .ne. '-'.and.arg2(1:1) .ne. ' ') then
     call mol%open(arg2)
     call mol%write('solvent')
     call mol%write('solvent.xyz')
@@ -2471,12 +2529,12 @@
     inputfile = trim(arg2)
     write (*,*) 'Solvent-file: ',arg2
     env%solv_file = arg2
-  else if (solv .and. .not. ex21) then
+  else if (solv.and..not.ex21) then
     call copy('solvent','solvent.old')
     inputfile = 'solvent'
     write (*,'(/,1x,a)') 'Solvent-file: solvent'
     env%solv_file = 'solvent'
-  else if (ex22 .and. .not. ex21) then !-- save coord as reference
+  else if (ex22.and..not.ex21) then !-- save coord as reference
     call copy('coord','coord.old')
     call copy('coord','solvent')
     inputfile = 'coord'
@@ -2489,7 +2547,7 @@
   !--- if the input was a SDF file, special handling
   env%sdfformat = .false.
   call checkcoordtype(inputfile,i)
-  if (i == 31 .or. i == 32) then
+  if (i == 31.or.i == 32) then
     !call inpsdf(env,inputfile)
     write (*,*) 'QCG currently does not support SDF-files.'
   end if
@@ -2497,8 +2555,8 @@
 !-------------Checking both files and saving them---------------------------!
 
   !--- after this point there should always be a solvent and solute file present
-  if (.not. allocated(env%inputcoords_solu)) env%inputcoords_solu = 'solute'
-  if (.not. allocated(env%inputcoords_solv)) env%inputcoords_solv = 'solvent'
+  if (.not.allocated(env%inputcoords_solu)) env%inputcoords_solu = 'solute'
+  if (.not.allocated(env%inputcoords_solv)) env%inputcoords_solv = 'solvent'
 
   call mol%open('solute')
 
@@ -2508,8 +2566,8 @@
   env%qcg_solute%at = mol%at
   env%qcg_solute%xyz = mol%xyz
   if (any((/crest_mfmdgc,crest_imtd,crest_imtd2/) == env%crestver)) then
-    if (.not. env%autozsort) then
-      env%qcg_solute%ntopo = mol%nat * (mol%nat + 1) / 2
+    if (.not.env%autozsort) then
+      env%qcg_solute%ntopo = mol%nat*(mol%nat+1)/2
       allocate (env%qcg_solute%topo(env%qcg_solute%ntopo))
       call quicktopo(mol%nat,mol%at,mol%xyz,env%qcg_solute%ntopo,env%qcg_solute%topo)
     end if
@@ -2525,8 +2583,8 @@
   env%qcg_solvent%at = mol%at
   env%qcg_solvent%xyz = mol%xyz
   if (any((/crest_mfmdgc,crest_imtd,crest_imtd2/) == env%crestver)) then
-    if (.not. env%autozsort) then
-      env%qcg_solvent%ntopo = mol%nat * (mol%nat + 1) / 2
+    if (.not.env%autozsort) then
+      env%qcg_solvent%ntopo = mol%nat*(mol%nat+1)/2
       allocate (env%qcg_solvent%topo(env%qcg_solvent%ntopo))
       call quicktopo(mol%nat,mol%at,mol%xyz,env%qcg_solvent%ntopo,env%qcg_solvent%topo)
     end if
Index: src/calculator/gfn0_api.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!====================================================!\n! module gfn0_api\n! An interface to gfn0-xtb standalone calculations\n!====================================================!\n\nmodule gfn0_api\n  use iso_fortran_env,only:wp => real64,stdout => output_unit\n  use strucrd\n#ifdef WITH_GFN0\n  use gfn0_interface\n  use gfn0_module,only:gfn0_gbsa_init,generate_config\n#endif\n  use wiberg_mayer,only:get_wbo,get_wbo_rhf,density_matrix\n  implicit none\n  private\n\n#ifndef WITH_GFN0\n  !> these are placeholders if no gfn0 module is used!\n  type :: gfn0_results\n    integer :: id = 0\n  end type gfn0_results\n  type :: gfn0_data\n    integer :: id = 0\n  end type gfn0_data\n#endif\n\n  public :: gfn0_results,gfn0_data\n  public :: gfn0_setup,gfn0_addsettings\n  public :: gfn0_sp,gfn0_sp_occ\n  public :: gfn0_getwbos\n  public :: gfn0_gen_occ\n  public :: gfn0_print\n\n!========================================================================================!\n!========================================================================================!\ncontains  !>--- Module routines start here\n!========================================================================================!\n!========================================================================================!\n\n  subroutine gfn0_setup(mol,chrg,uhf,g0calc)\n    implicit none\n    type(coord),intent(in)  :: mol\n    integer,intent(in)      :: chrg\n    integer,intent(in)      :: uhf\n    type(gfn0_data),intent(inout) :: g0calc\n#ifdef WITH_GFN0\n\n    !> initialize parametrization of GFN0\n    call gfn0_init(mol%nat,mol%at,mol%xyz,chrg,uhf,g0calc)\n\n#else /* WITH_GFN0 */\n    write (stdout,*) 'Error: Compiled without GFN0-xTB support!'\n    write (stdout,*) 'Use -DWITH_GFN0=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine gfn0_setup\n\n!========================================================================================!\n!> gfn0_addsettings is used to add other settings from\n!> CRESTs calculation object to the gfn0_data\n  subroutine gfn0_addsettings(mol,g0calc,solv,model,etemp,loadwbo)\n    implicit none\n    type(coord),intent(in)  :: mol\n    type(gfn0_data),intent(inout) :: g0calc\n    character(len=*),intent(in),optional :: solv\n    character(len=*),intent(in),optional :: model\n    real(wp),intent(in),optional :: etemp\n    logical,intent(in),optional  :: loadwbo\n\n    integer :: nao\n#ifdef WITH_GFN0\n    !> add solvation?\n    if (present(solv)) then\n      if (allocated(g0calc%gbsa)) deallocate (g0calc%gbsa)\n      allocate (g0calc%gbsa)\n      if (present(model)) then\n        select case(model)\n        case('alpb')\n        call gfn0_gbsa_init(mol%nat,mol%at,.true.,solv,g0calc%gbsa)\n        case default !> default GBSA\n        call gfn0_gbsa_init(mol%nat,mol%at,.false.,solv,g0calc%gbsa)\n        end select\n      else\n        call gfn0_gbsa_init(mol%nat,mol%at,.false.,solv,g0calc%gbsa)\n      end if\n    end if\n    if(present(etemp))then\n      g0calc%xtbData%etemp = max(0.0_wp,etemp)\n    endif\n    if(present(loadwbo))then\n      if(loadwbo)then\n        nao = g0calc%basis%nao\n        if(.not.allocated(g0calc%wfn%S)) allocate(g0calc%wfn%S(nao,nao), source=0.0_wp)\n      endif\n    endif\n#else\n    write (stdout,*) 'Error: Compiled without GFN0-xTB support!'\n    write (stdout,*) 'Use -DWITH_GFN0=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine gfn0_addsettings\n\n!========================================================================================!\n\n  subroutine gfn0_sp(mol,chrg,uhf,g0calc,energy,gradient,iostatus,res)\n    implicit none\n    !> INPUT\n    type(coord),intent(in)  :: mol\n    integer,intent(in) :: chrg\n    integer,intent(in) :: uhf\n    type(gfn0_data),intent(inout) :: g0calc\n    !> OUTPUT\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: gradient(3,mol%nat)\n    integer,intent(out) :: iostatus\n    type(gfn0_results),intent(inout),optional :: res\n    !> LOCAL\n    logical :: fail \n    energy = 0.0_wp\n    gradient = 0.0_wp\n    iostatus = 0\n    fail = .false.\n#ifdef WITH_GFN0\n    if (present(res)) then\n      call gfn0_singlepoint(mol%nat,mol%at,mol%xyz,chrg,uhf,g0calc, &\n      &          energy,gradient,fail,res)\n    else\n      call gfn0_singlepoint(mol%nat,mol%at,mol%xyz,chrg,uhf,g0calc, &\n      &          energy,gradient,fail)\n    end if\n    if(fail)then\n      iostatus = -1\n    endif\n#else\n    write (stdout,*) 'Error: Compiled without GFN0-xTB support!'\n    write (stdout,*) 'Use -DWITH_GFN0=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine gfn0_sp\n\n!========================================================================================!\n\n  subroutine gfn0_sp_occ(mol,chrg,uhf,occ,g0calc,energy,gradient,iostatus,res)\n    implicit none\n    !> INPUT\n    type(coord),intent(in)  :: mol\n    integer,intent(in) :: chrg\n    integer,intent(in) :: uhf\n    type(gfn0_data),intent(inout) :: g0calc\n!    real(wp),intent(in) :: occ(g0calc%basis%nao, nlev)\n    real(wp),intent(in) :: occ(:)\n    !> OUTPUT\n    real(wp),intent(out) :: energy\n    real(wp),intent(out) :: gradient(3,mol%nat)\n    integer,intent(out) :: iostatus\n    type(gfn0_results),intent(inout),optional :: res\n    !> LOCAL\n    logical :: fail\n    energy = 0.0_wp\n    gradient = 0.0_wp\n    iostatus = 0 \n    fail = .false.\n#ifdef WITH_GFN0\n    if (present(res)) then\n      call gfn0_occ_singlepoint(mol%nat,mol%at,mol%xyz,chrg,uhf,occ,g0calc, &\n      &          energy,gradient,fail,res)\n    else\n      call gfn0_occ_singlepoint(mol%nat,mol%at,mol%xyz,chrg,uhf,occ,g0calc, &\n      &          energy,gradient,fail)\n    end if\n    if(fail)then\n      iostatus = -1\n    endif\n#else\n    write (stdout,*) 'Error: Compiled without GFN0-xTB support!'\n    write (stdout,*) 'Use -DWITH_GFN0=true in the setup to enable this function'\n    error stop\n#endif\n  end subroutine gfn0_sp_occ\n\n!========================================================================================!\n\n  subroutine gfn0_gen_occ(nel,nao,active,occ)\n    implicit none\n    integer,intent(in) :: nel\n    integer,intent(in) :: nao\n    integer,intent(in) :: active(:)\n    real(wp),intent(out) :: occ(nao)\n    integer :: i\n    occ = 0.0_wp\n#ifdef WITH_GFN0\n    call generate_config(nel,nao,occ,active)\n#endif\n  end subroutine gfn0_gen_occ\n\n\n!========================================================================================!\n\n   subroutine gfn0_print(iunit,g0calc,res)\n    implicit none\n    integer,intent(in) :: iunit\n    type(gfn0_data),intent(in) :: g0calc\n    type(gfn0_results),intent(in) :: res\n#ifdef WITH_GFN0\n    call gfn0_print_summary(iunit,g0calc,res)\n#endif\n    return\n   end subroutine gfn0_print\n\n\n!========================================================================================!\n!> obtain wbos from gfn0\n  subroutine gfn0_getwbos(g0calc,nat,wbo)\n    implicit none\n    type(gfn0_data),intent(in) :: g0calc\n    integer,intent(in) :: nat\n    real(wp),intent(out) :: wbo(nat,nat)\n    real(wp),allocatable :: Pa(:,:),Pb(:,:)\n    integer ndim\n    wbo = 0.0_wp\n#ifdef WITH_GFN0\n!    call get_wbo_rhf(nat, g0calc%basis%nao, g0calc%wfn%P, &\n!    &         g0calc%wfn%S, g0calc%basis%aoat2, wbo)\n\n    ndim=g0calc%basis%nao\n    allocate(Pa(ndim,ndim),Pb(ndim,ndim))\n    call density_matrix(ndim,g0calc%wfn%focca,g0calc%wfn%C,Pa)\n    call density_matrix(ndim,g0calc%wfn%foccb,g0calc%wfn%C,Pb)\n    wbo=0.0_wp\n    call get_wbo(nat, g0calc%basis%nao, Pa,Pb, &\n    &         g0calc%wfn%S, g0calc%basis%aoat2, wbo)\n\n    !call prmat(6,wbo,nat,nat,'WBO_uhf')\n    deallocate(Pa,Pb)\n#endif   \n\n\n  end subroutine gfn0_getwbos\n\n\n!========================================================================================!\n!========================================================================================!\nend module gfn0_api\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/calculator/gfn0_api.F90 b/src/calculator/gfn0_api.F90
--- a/src/calculator/gfn0_api.F90	
+++ b/src/calculator/gfn0_api.F90	
@@ -252,8 +252,6 @@
     !call prmat(6,wbo,nat,nat,'WBO_uhf')
     deallocate(Pa,Pb)
 #endif   
-
-
   end subroutine gfn0_getwbos
 
 
Index: src/rigidconf/tree.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht, Christopher Zurek, Christoph Bannwarth\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!\n! Routines were adapted from the xtb code (github.com/grimme-lab/xtb)\n! under the Open-source software LGPL-3.0 Licencse.\n!================================================================================!\n\n!========================================================================================!\n!========================================================================================!\nsubroutine rigidconf_tree(env,mol)\n!************************************************************\n!* Generate conformers in a straight-forward approach.\n!* Selected dihedral angles may have a set of possible values.\n!* All combinations of these values will be generated.\n!* The generation process follows a simple recursive strategy,\n!* which can be interpreted as setting up an undirected tree graph\n!* e.g., A,B,C,... being dihedral angles:\n!*\n!*  ref.\n!*   └──┐\n!*      ├──A1\n!*      │  ├──B1\n!*      ┊  │  ├──C1\n!*      ┊  │     ...\n!*      ┊  ├──B2\n!*      ┊  ┊  ├──C1\n!*      ┊        ...\n!*      ├─A2\n!*      │  ├──B1\n!*      ┊  ┊  ├─┄...\n!*      ┊     ...\n!*      etc.\n!*\n!* Input:\n!*    env  - CREST's systemdata\n!*    mol  - Input (reference) geometry\n!*\n!************************************************************\n  use crest_parameters\n  use crest_data\n  use strucrd\n  use zdata,only:readwbo\n  use adjacency\n  use INTERNALS_mod\n  use rigidconf_analyze\n  implicit none\n  !> INPUT/OUTPUT\n  type(systemdata),intent(inout) :: env\n  type(coord),intent(in) :: mol  !> by convention mol is in Bohrs\n  !> LOCAL\n  real(wp),allocatable :: wbo(:,:)\n  integer,allocatable  :: na(:),nb(:),nc(:)\n  real(wp),allocatable :: zmat(:,:),zmat_new(:,:)\n  integer,allocatable  :: Amat(:,:)\n  integer :: i,j,k,l,ich\n  character(len=124) :: stmp\n  !> number of dihedral angles that are adjusted\n  !> this defines the overall number of conformers\n  integer :: ndieder\n  !> the number of values each of the dihedral angles\n  !> can assume (equally spaced in -180°< ϕ <180° )\n  !> i.e., if dvalues(i)=3, the dihedral i will have 3 defined values,\n  !> ϕ (as in the input geometry), ϕ+120°, and ϕ+240°\n  integer,allocatable :: dvalues(:)\n  !> the step size for each dihedral angle, in Radians\n  real(wp),allocatable :: dstep(:)\n  !> mapping zmat entry to selected dihedral angles. multiple zmat entries\n  !> may coincide with the same bond, making this mapping necessary.\n  integer,allocatable :: ztod(:)\n  !> saved combinations of dihedral angles in RAM. We first generate\n  !> these \"fingerprints\" using the recursive strategy, and only\n  !> later reconstruct the molecular structures. This allows running\n  !> the structure checks in parallel\n  integer :: ncombi\n  real(wp) :: ncombi_f\n  integer(int8),allocatable :: combi(:,:)\n  !> work space array for the recursive routine and iteration variables\n  integer(int8),allocatable :: wcombi(:)\n  integer :: iteratord, iteratork\n\n  !> data for new structure and reference checks\n  logical,allocatable :: sane(:)\n  type(coord) :: newmol\n  real(wp),allocatable :: rcov(:),cnref(:)\n  real(wp) :: cthr,p \n  integer :: nremain\n\n  character(len=19),parameter :: outputfile = \"crest_rigidconf.xyz\"\n\n!========================================================================================!\n   cthr = 0.3d0 !> CN clash threshold\n\n!========================================================================================!\n!>--- generate the topology information\n  allocate (Amat(mol%nat,mol%nat),source=0) !> adjacency matrix\n\n  select case (env%rigidconf_toposource)\n    !case ( 1 ) !>\n    !\n  case default !> do a GFN0-xTB singlepoint and read WBOs\n\n    call crest_xtbsp(env,0,mol) !> writes file \"wbo\"\n    allocate (wbo(mol%nat,mol%nat),source=0.0_wp)\n    call readwbo(\"wbo\",mol%nat,wbo) !> reads file \"wbo\"\n    call wbo2adjacency(mol%nat,wbo,Amat,0.02_wp) !> setup Amat\n\n  end select\n\n!========================================================================================!\n!>--- generate zmatrix based on adjacency\n  allocate (na(mol%nat),nb(mol%nat),nc(mol%nat),source=0)\n  allocate (zmat(3,mol%nat),source=0.0_wp)\n  call BETTER_XYZINT(mol%nat,mol%xyz,Amat,na,nb,nc,zmat)\n  call smallhead('Internal coordinates:')\n  call print_zmat(stdout,mol%nat,mol%at,zmat,na,nb,nc,.true.)\n!--- Note: zmat angles (columns 2 and 3) are in Radians\n\n!========================================================================================!\n!>--- analyze dihedral angles encoded in the zmatrix to select the ones to vary\n!>    and how to vary them\n\n  !=================================================!\n  !> IMPLEMENTATION (or subroutine call) GOES HERE <!\n  !=================================================!\n\n!>--- fallback implementation for testing: All single-bonds with a corresponding\n!>    entry in the zmatrix (this excludes terminal atoms, e.g. H)\n  if (.true.) then\n    call rigidconf_count_fallback(mol%nat,na,nb,nc,wbo,ndieder)\n    if (ndieder < 1) stop 'no dihedral angles selected!'\n    allocate (dvalues(ndieder),source=0)\n    allocate (dstep(ndieder),source=0.0_wp)\n    allocate (ztod(mol%nat),source=0)\n    call rigidconf_analyze_fallback(env,mol,zmat,na,nb,nc,wbo, &\n    &                               ndieder,dvalues,dstep,ztod)\n    \n    !call prune_zmat_dihedrals(mol%nat, mol%xyz, zmat, na,nb,nc, ztod )\n    !call smallhead('New internal coordinates:')\n    !call print_zmat(stdout,mol%nat,mol%at,zmat,na,nb,nc,.true.)\n   end if\n\n\n!========================================================================================!\n!>--- For now, I am limiting the max. number of dihedral angles to 10.\n!>    At some point we will have to think about what to allow.\n  if (ndieder > 10) then\n    error stop 'Too many dihedral angles. '\n  end if\n\n!========================================================================================!\n  write (stdout,*)\n  call smallhead('Rule-based conformer genration')\n\n!>--- Allocate space for combination \"fingerprints\"\n  ncombi_f = float(dvalues(1))\n  do i = 2,ndieder\n    ncombi_f = ncombi_f*float(dvalues(i))\n  end do\n  if (ncombi_f .gt. float(huge(ncombi))) then\n    error stop 'cannot allocate combi()'\n  else\n    ncombi = nint(ncombi_f)\n    allocate (combi(ndieder,ncombi),source=1_int8)\n    write (stdout,'(\">\",1x,i0,a,i0,a)') ndieder,' dihedral angles resulting in ', &\n    &     ncombi,' possible conformers.'\n  end if\n\n!>--- Generate combinations recursively\n  write(stdout,'(\">\",1x,a)',advance='no') 'Generating combination references ...'\n  flush(stdout)\n  allocate (wcombi(ndieder),source=1_int8)\n  iteratord = 1\n  iteratork = 0\n  call generate_dihedral_combinations(ndieder,wcombi,ncombi,combi, &\n  &                    dvalues,iteratord,iteratork)\n  write(stdout,*) 'done.'\n\n\n!========================================================================================!\n!>--- Calculate reference CNs\n  allocate (rcov(94),cnref(mol%nat),source=0.0_wp)\n  call setrcov(rcov)\n  call ycoord(mol%nat,rcov,mol%at,mol%xyz,cnref,100.0d0) !> refernce CNs\n  \n!>--- Generate all the conformers and check for CN clashes\n  allocate(zmat_new(3,mol%nat), source=0.0_wp)\n  allocate(sane(ncombi), source=.false.)\n  \n  open(newunit=ich, file=outputfile)\n  write(stdout,'(\">\",1x,a)',advance='no') 'Reconstructing structures and checking for CN clashes ...'\n  flush(stdout)\n  do i=1,ncombi\n\n!>--- Generate new zmat from zmat and combi entry\n    call construct_new_zmat(mol%nat,zmat,combi(:,i),ndieder,dvalues,dstep,ztod,zmat_new) \n\n!>--- Reconstruct Cartesian coordinates for new zmat\n    call reconstruct_zmat_to_mol(mol%nat,mol%at,zmat_new,na,nb,nc,newmol)\n\n!>--- Check new structure for CN clashes w.r.t. reference and cthr\n    call ycoord2(newmol%nat,rcov,newmol%at,newmol%xyz,cnref,100.d0,cthr,sane(i)) !> CN clashes\n    sane(i) = .not.sane(i)\n\n!>--- Dump to file\n    if(sane(i))then\n    call newmol%append(ich)\n    endif\n    \n  enddo\n  write(stdout,*) 'done.'\n  close(ich) \n\n  nremain = count(sane,1)\n  p = float(nremain)/float(ncombi) * 100.0_wp\n  write(stdout,'(\">\",1x,i0,1x,a,1x,i0,1x,a,f5.1,a)') nremain,'of',ncombi, &\n  & 'structures remaining (',p,'%). Clashes discarded.'\n  write(stdout,'(\">\",1x,a,1x,a)') 'Written to file',outputfile\n\n!========================================================================================!\n!>--- Post-processing\n\n  !=================================================!\n  !> IMPLEMENTATION (or subroutine call) GOES HERE <!\n  !=================================================!\n\n!========================================================================================!\n  if (allocated(sane)) deallocate(sane)\n  if (allocated(zmat_new)) deallocate(zmat_new) \n  if (allocated(wcombi)) deallocate(wcombi)\n  if (allocated(combi)) deallocate (combi)\n  if (allocated(dvalues)) deallocate (dvalues)\n  if (allocated(dstep)) deallocate (dstep)\n  if (allocated(ztod)) deallocate (ztod)\n  if (allocated(wbo)) deallocate (wbo)\n  if (allocated(na)) deallocate (na)\n  if (allocated(nb)) deallocate (nb)\n  if (allocated(nc)) deallocate (nc)\n  if (allocated(zmat)) deallocate (zmat)\n  if (allocated(Amat)) deallocate (Amat)\n  return\n!========================================================================================!\ncontains\n!========================================================================================!\n  recursive subroutine generate_dihedral_combinations(ndieder,wcombi,ncombi,combi, &\n  &                    dvalues,iteratord,iteratork)\n    implicit none\n    integer,intent(in) :: ndieder\n    integer(int8),intent(inout) :: wcombi(ndieder)\n    integer,intent(in) :: ncombi\n    integer(int8),intent(inout) :: combi(ndieder,ncombi)\n    integer,intent(in) :: dvalues(ndieder)\n    integer,intent(inout) :: iteratord,iteratork\n\n    integer :: i,j,k\n\n    if (iteratork > ncombi) return\n!>-- if we reached the last dihedral in the list, dump and return\n    if (iteratord > ndieder) then\n      iteratork = iteratork+1\n      combi(:,iteratork) = wcombi(:)\n      return\n    end if\n\n!>-- iterate the current dihedral angle (j)\n    j = iteratord\n    k = iteratord+1\n    do i = 1,dvalues(j)\n!>--- set the combination value to\n      wcombi(j) = int(i,int8)\n!>--- go to the next dihedral angle (k)\n      call generate_dihedral_combinations(ndieder,wcombi,ncombi,combi, &\n &                    dvalues,k,iteratork)\n!>--- reset after the last value for the current dihedral angle\n      if (i == dvalues(j)) then\n        wcombi(j) = 1_int8\n      end if\n    end do\n\n  end subroutine generate_dihedral_combinations\n!========================================================================================!\n\nend subroutine rigidconf_tree\n!========================================================================================!\n!========================================================================================!\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/rigidconf/tree.f90 b/src/rigidconf/tree.f90
--- a/src/rigidconf/tree.f90	
+++ b/src/rigidconf/tree.f90	
@@ -58,6 +58,7 @@
   use adjacency
   use INTERNALS_mod
   use rigidconf_analyze
+  use miscdata,only:rcov
   implicit none
   !> INPUT/OUTPUT
   type(systemdata),intent(inout) :: env
@@ -67,7 +68,8 @@
   integer,allocatable  :: na(:),nb(:),nc(:)
   real(wp),allocatable :: zmat(:,:),zmat_new(:,:)
   integer,allocatable  :: Amat(:,:)
-  integer :: i,j,k,l,ich
+  integer :: i,j,k,l,ich,ich2
+  logical :: ex 
   character(len=124) :: stmp
   !> number of dihedral angles that are adjusted
   !> this defines the overall number of conformers
@@ -91,19 +93,19 @@
   integer(int8),allocatable :: combi(:,:)
   !> work space array for the recursive routine and iteration variables
   integer(int8),allocatable :: wcombi(:)
-  integer :: iteratord, iteratork
+  integer :: iteratord,iteratork
 
   !> data for new structure and reference checks
   logical,allocatable :: sane(:)
   type(coord) :: newmol
-  real(wp),allocatable :: rcov(:),cnref(:)
-  real(wp) :: cthr,p 
+  real(wp),allocatable :: cnref(:)
+  real(wp) :: cthr,p
   integer :: nremain
 
   character(len=19),parameter :: outputfile = "crest_rigidconf.xyz"
 
 !========================================================================================!
-   cthr = 0.3d0 !> CN clash threshold
+  cthr = 0.3d0 !> CN clash threshold
 
 !========================================================================================!
 !>--- generate the topology information
@@ -130,6 +132,11 @@
   call print_zmat(stdout,mol%nat,mol%at,zmat,na,nb,nc,.true.)
 !--- Note: zmat angles (columns 2 and 3) are in Radians
 
+!========================================================================================!
+
+  write (stdout,*)
+  call smallhead('Rule-based conformer genration')
+
 !========================================================================================!
 !>--- analyze dihedral angles encoded in the zmatrix to select the ones to vary
 !>    and how to vary them
@@ -138,9 +145,22 @@
   !> IMPLEMENTATION (or subroutine call) GOES HERE <!
   !=================================================!
 
+  !inquire(file='rigidconf.data', exist=ex)
+  !if ( ex ) then
+  if(allocated(env%rigidconf_userfile))then
+ !>--- user-defined file readout
+   ! call rigidconf_count_fallback(mol%nat,na,nb,nc,wbo,ndieder)
+   ! if (ndieder < 1) stop 'no dihedral angles selected!'
+   ! allocate (dvalues(ndieder),source=0)
+   ! allocate (dstep(ndieder),source=0.0_wp)
+   ! allocate (ztod(mol%nat),source=0)
+    !call rigidconf_user_file( 'rigidconf.data', mol%nat, na,nb,nc, &
+    call rigidconf_user_file( env%rigidconf_userfile, mol%nat, na,nb,nc, &
+    &    wbo,ndieder,ztod,dvalues,dstep)
+
+  else !if (.true.) then
 !>--- fallback implementation for testing: All single-bonds with a corresponding
 !>    entry in the zmatrix (this excludes terminal atoms, e.g. H)
-  if (.true.) then
     call rigidconf_count_fallback(mol%nat,na,nb,nc,wbo,ndieder)
     if (ndieder < 1) stop 'no dihedral angles selected!'
     allocate (dvalues(ndieder),source=0)
@@ -148,23 +168,20 @@
     allocate (ztod(mol%nat),source=0)
     call rigidconf_analyze_fallback(env,mol,zmat,na,nb,nc,wbo, &
     &                               ndieder,dvalues,dstep,ztod)
-    
+
     !call prune_zmat_dihedrals(mol%nat, mol%xyz, zmat, na,nb,nc, ztod )
     !call smallhead('New internal coordinates:')
     !call print_zmat(stdout,mol%nat,mol%at,zmat,na,nb,nc,.true.)
-   end if
 
-
-!========================================================================================!
 !>--- For now, I am limiting the max. number of dihedral angles to 10.
 !>    At some point we will have to think about what to allow.
-  if (ndieder > 10) then
-    error stop 'Too many dihedral angles. '
-  end if
+    if (ndieder > 10) then
+      error stop 'Too many dihedral angles. '
+    end if
 
+  end if
+
 !========================================================================================!
-  write (stdout,*)
-  call smallhead('Rule-based conformer genration')
 
 !>--- Allocate space for combination "fingerprints"
   ncombi_f = float(dvalues(1))
@@ -177,37 +194,36 @@
     ncombi = nint(ncombi_f)
     allocate (combi(ndieder,ncombi),source=1_int8)
     write (stdout,'(">",1x,i0,a,i0,a)') ndieder,' dihedral angles resulting in ', &
-    &     ncombi,' possible conformers.'
+    &     ncombi,' possible isomers.'
   end if
 
 !>--- Generate combinations recursively
-  write(stdout,'(">",1x,a)',advance='no') 'Generating combination references ...'
-  flush(stdout)
+  write (stdout,'(">",1x,a)',advance='no') 'Generating combination references ...'
+  flush (stdout)
   allocate (wcombi(ndieder),source=1_int8)
   iteratord = 1
   iteratork = 0
   call generate_dihedral_combinations(ndieder,wcombi,ncombi,combi, &
   &                    dvalues,iteratord,iteratork)
-  write(stdout,*) 'done.'
+  write (stdout,*) 'done.'
 
-
 !========================================================================================!
 !>--- Calculate reference CNs
-  allocate (rcov(94),cnref(mol%nat),source=0.0_wp)
-  call setrcov(rcov)
+  allocate (cnref(mol%nat),source=0.0_wp)
   call ycoord(mol%nat,rcov,mol%at,mol%xyz,cnref,100.0d0) !> refernce CNs
-  
+
 !>--- Generate all the conformers and check for CN clashes
-  allocate(zmat_new(3,mol%nat), source=0.0_wp)
-  allocate(sane(ncombi), source=.false.)
-  
-  open(newunit=ich, file=outputfile)
-  write(stdout,'(">",1x,a)',advance='no') 'Reconstructing structures and checking for CN clashes ...'
-  flush(stdout)
-  do i=1,ncombi
+  allocate (zmat_new(3,mol%nat),source=0.0_wp)
+  allocate (sane(ncombi),source=.false.)
+
+  open (newunit=ich,file=outputfile)
+  open(newunit=ich2, file='discarded.xyz')
+  write (stdout,'(">",1x,a)',advance='no') 'Reconstructing structures and checking for CN clashes ...'
+  flush (stdout)
+  do i = 1,ncombi
 
 !>--- Generate new zmat from zmat and combi entry
-    call construct_new_zmat(mol%nat,zmat,combi(:,i),ndieder,dvalues,dstep,ztod,zmat_new) 
+    call construct_new_zmat(mol%nat,zmat,combi(:,i),ndieder,dvalues,dstep,ztod,zmat_new)
 
 !>--- Reconstruct Cartesian coordinates for new zmat
     call reconstruct_zmat_to_mol(mol%nat,mol%at,zmat_new,na,nb,nc,newmol)
@@ -217,19 +233,22 @@
     sane(i) = .not.sane(i)
 
 !>--- Dump to file
-    if(sane(i))then
-    call newmol%append(ich)
-    endif
-    
-  enddo
-  write(stdout,*) 'done.'
-  close(ich) 
+    if (sane(i)) then
+      call newmol%append(ich)
+    else
+      call newmol%append(ich2)
+    end if
+
+  end do
+  write (stdout,*) 'done.'
+  close (ich)
+  close(ich2)
 
   nremain = count(sane,1)
-  p = float(nremain)/float(ncombi) * 100.0_wp
-  write(stdout,'(">",1x,i0,1x,a,1x,i0,1x,a,f5.1,a)') nremain,'of',ncombi, &
+  p = float(nremain)/float(ncombi)*100.0_wp
+  write (stdout,'(">",1x,i0,1x,a,1x,i0,1x,a,f5.1,a)') nremain,'of',ncombi, &
   & 'structures remaining (',p,'%). Clashes discarded.'
-  write(stdout,'(">",1x,a,1x,a)') 'Written to file',outputfile
+  write (stdout,'(">",1x,a,1x,a)') 'Written to file',outputfile//' and discarded.xyz'
 
 !========================================================================================!
 !>--- Post-processing
@@ -239,12 +258,10 @@
   !=================================================!
 
 !========================================================================================!
-  if (allocated(sane)) deallocate(sane)
-  if (allocated(zmat_new)) deallocate(zmat_new) 
-  if (allocated(wcombi)) deallocate(wcombi)
+  if (allocated(sane)) deallocate (sane)
+  if (allocated(zmat_new)) deallocate (zmat_new)
+  if (allocated(wcombi)) deallocate (wcombi)
   if (allocated(combi)) deallocate (combi)
-  if (allocated(dvalues)) deallocate (dvalues)
-  if (allocated(dstep)) deallocate (dstep)
   if (allocated(ztod)) deallocate (ztod)
   if (allocated(wbo)) deallocate (wbo)
   if (allocated(na)) deallocate (na)
@@ -252,12 +269,12 @@
   if (allocated(nc)) deallocate (nc)
   if (allocated(zmat)) deallocate (zmat)
   if (allocated(Amat)) deallocate (Amat)
-  return
 !========================================================================================!
 contains
 !========================================================================================!
   recursive subroutine generate_dihedral_combinations(ndieder,wcombi,ncombi,combi, &
   &                    dvalues,iteratord,iteratork)
+    use crest_parameters
     implicit none
     integer,intent(in) :: ndieder
     integer(int8),intent(inout) :: wcombi(ndieder)
@@ -297,4 +314,3 @@
 end subroutine rigidconf_tree
 !========================================================================================!
 !========================================================================================!
-
Index: src/rigidconf/analyze.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht, Christopher Zurek, Christoph Bannwarth\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!\n! Routines were adapted from the xtb code (github.com/grimme-lab/xtb)\n! under the Open-source software LGPL-3.0 Licencse.\n!================================================================================!\n\nmodule rigidconf_analyze\n  use crest_parameters\n  use crest_data\n  use strucrd\n  use geo\n  use INTERNALS_mod\n  implicit none\n  public\n\n!========================================================================================!\n!========================================================================================!\ncontains !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\nsubroutine rigidconf_analyze_fallback(env,mol,zmat,na,nb,nc,wbo, &\n&                                     ndieder,dvalues,dstep,ztod )\n!************************************************************\n!* Fallback routine for the dihedral setup.\n!* Select all single bonds corresponding to a dihedral angle\n!* in the zmatrix. \n!* This automatically excludes terminal atoms (e.g. hydrogen).\n!* All the selected dihedrals get a dvalue of 3 and corresponding\n!* dstep of 120°\n!*\n!* Input:\n!*    env,mol,zmat,na,nb,nc,wbo,ndieder\n!* \n!* Output: \n!*    dvalues, dstep, ztod\n!*   \n!************************************************************\n  implicit none\n  !> INPUT\n  type(systemdata),intent(inout) :: env\n  type(coord),intent(in) :: mol  !> by convention mol is in Bohrs\n  real(wp),intent(in) :: zmat(3,mol%nat)\n  integer,intent(in)  :: na(mol%nat),nb(mol%nat),nc(mol%nat)\n  real(wp),intent(in) :: wbo(mol%nat,mol%nat)\n  integer,intent(in)  :: ndieder\n  !> OUTPUT \n  integer,intent(out)  :: dvalues( ndieder )\n  real(wp),intent(out) :: dstep( ndieder )\n  integer,intent(out)  :: ztod( mol%nat ) \n  !> LOCAL\n  integer :: V,i,j,k,l,m\n  integer,allocatable :: Amap(:,:)\n!========================================================================================!\n!>--- Init\n  dvalues(:) = 3\n  dstep(:) = 120.0_wp*degtorad\n  ztod(:) = 0\n\n!>--- Mapping\n  V = mol%nat\n  allocate(Amap(V,V), source=0) !> mapping matrix\n  k = 0\n  do i=1,V\n    m = 0\n    if( nc(i) > 0 ) then !> to skip the three incomplete zmate entries\n      j=na(i)\n      l=nb(i)\n      if(Amap(j,l) > 0)then\n        m = Amap(j,l)\n      else\n        if( nint(wbo(j,l)) == 1)then\n         k = k + 1\n         Amap(j,l) = k\n         Amap(l,j) = k \n         m = k\n        endif\n      endif  \n    endif\n    ztod(i) = m\n  enddo\n \n  if(allocated(Amap)) deallocate(Amap)\n  return\nend subroutine rigidconf_analyze_fallback\n\n!========================================================================================!\nsubroutine rigidconf_count_fallback(nat,na,nb,nc,wbo,ndieder,ztod)\n!************************************************************\n!* Count number of unique single-bond dihedral angles that\n!* correspond to an entry in the zmat.\n!************************************************************\n  implicit none\n  !> INPUT\n  integer,intent(in)  :: nat\n  integer,intent(in)  :: na(nat),nb(nat),nc(nat)\n  real(wp),intent(in) :: wbo(nat,nat)\n  !> OUTPUT\n  integer,intent(out)  :: ndieder\n  integer,intent(out),optional :: ztod(nat)\n  !> LOCAL\n  integer :: V,i,j,k,l,m\n  integer,allocatable :: Amap(:,:)\n!>--- init\n  ndieder = 0\n!>--- Mapping\n  V = nat\n  allocate(Amap(V,V), source=0) !> mapping matrix\n  k = 0\n  do i=1,V\n    m = 0\n    if( nc(i) > 0 ) then !> to skip the three incomplete zmate entries\n      j=na(i)\n      l=nb(i)\n      if(Amap(j,l) > 0)then\n        m = Amap(j,l)\n      else\n        if( nint(wbo(j,l)) == 1)then\n         k = k + 1\n         Amap(j,l) = k\n         Amap(l,j) = k \n         m = k\n        endif\n      endif  \n    endif\n    if(present(ztod)) ztod(i) = m\n  enddo\n  ndieder = k\n  if(allocated(Amap)) deallocate(Amap)\n  return\nend subroutine rigidconf_count_fallback\n\n\n!========================================================================================!\nsubroutine prune_zmat_dihedrals(nat, xyz, zmat, na,nb,nc, ztod )\n!********************************************************\n!* Remove zmat entries that correspond\n!* to the same bond and replace them with internal\n!* dihedral angles. There you go, Christoph...\n!********************************************************\n   implicit none\n   integer,intent(in)  :: nat\n   real(wp),intent(in) :: xyz(3,nat)\n   real(wp),intent(inout) :: zmat(3,nat)\n   integer,intent(inout)  :: na(nat),nb(nat),nc(nat)\n   integer,intent(inout)  :: ztod(nat)\n   integer :: i,j,k,l\n   integer :: maxgroup,nmembers,refi\n  \n   write(*,*) ztod\n   maxgroup = maxval(ztod,1)\n   do i=1,maxgroup \n     nmembers = count(ztod(:).eq.i)\n     if(nmembers < 2) cycle\n     do j=1,nat\n       if(ztod(j)==i)then\n         refi = j \n         exit\n       endif \n     enddo\n     do j=1,nat\n        if(j==refi) cycle\n        if(ztod(j) == i)then\n           !nc(j) = nb(j)\n           nc(j) = refi\n           !call BANGLE2( xyz, j, na(j), nb(j), zmat(2,j) )\n           call DIHED2( xyz, j, na(j), nb(j), nc(j), zmat(3,j) ) \n           ztod(j) = 0\n        endif  \n     enddo\n   enddo\n   write(*,*) ztod\nend subroutine prune_zmat_dihedrals\n!========================================================================================!\n!========================================================================================!\nend module rigidconf_analyze\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/rigidconf/analyze.f90 b/src/rigidconf/analyze.f90
--- a/src/rigidconf/analyze.f90	
+++ b/src/rigidconf/analyze.f90	
@@ -35,158 +35,268 @@
 !========================================================================================!
 !========================================================================================!
 
-subroutine rigidconf_analyze_fallback(env,mol,zmat,na,nb,nc,wbo, &
-&                                     ndieder,dvalues,dstep,ztod )
+  subroutine rigidconf_analyze_fallback(env,mol,zmat,na,nb,nc,wbo, &
+  &                                     ndieder,dvalues,dstep,ztod)
 !************************************************************
 !* Fallback routine for the dihedral setup.
 !* Select all single bonds corresponding to a dihedral angle
-!* in the zmatrix. 
+!* in the zmatrix.
 !* This automatically excludes terminal atoms (e.g. hydrogen).
 !* All the selected dihedrals get a dvalue of 3 and corresponding
 !* dstep of 120°
 !*
 !* Input:
 !*    env,mol,zmat,na,nb,nc,wbo,ndieder
-!* 
-!* Output: 
+!*
+!* Output:
 !*    dvalues, dstep, ztod
-!*   
+!*
 !************************************************************
-  implicit none
-  !> INPUT
-  type(systemdata),intent(inout) :: env
-  type(coord),intent(in) :: mol  !> by convention mol is in Bohrs
-  real(wp),intent(in) :: zmat(3,mol%nat)
-  integer,intent(in)  :: na(mol%nat),nb(mol%nat),nc(mol%nat)
-  real(wp),intent(in) :: wbo(mol%nat,mol%nat)
-  integer,intent(in)  :: ndieder
-  !> OUTPUT 
-  integer,intent(out)  :: dvalues( ndieder )
-  real(wp),intent(out) :: dstep( ndieder )
-  integer,intent(out)  :: ztod( mol%nat ) 
-  !> LOCAL
-  integer :: V,i,j,k,l,m
-  integer,allocatable :: Amap(:,:)
+    implicit none
+    !> INPUT
+    type(systemdata),intent(inout) :: env
+    type(coord),intent(in) :: mol  !> by convention mol is in Bohrs
+    real(wp),intent(in) :: zmat(3,mol%nat)
+    integer,intent(in)  :: na(mol%nat),nb(mol%nat),nc(mol%nat)
+    real(wp),intent(in) :: wbo(mol%nat,mol%nat)
+    integer,intent(in)  :: ndieder
+    !> OUTPUT
+    integer,intent(out)  :: dvalues(ndieder)
+    real(wp),intent(out) :: dstep(ndieder)
+    integer,intent(out)  :: ztod(mol%nat)
+    !> LOCAL
+    integer :: V,i,j,k,l,m
+    integer,allocatable :: Amap(:,:)
 !========================================================================================!
 !>--- Init
-  dvalues(:) = 3
-  dstep(:) = 120.0_wp*degtorad
-  ztod(:) = 0
+    dvalues(:) = 3
+    dstep(:) = 120.0_wp*degtorad
+    ztod(:) = 0
 
 !>--- Mapping
-  V = mol%nat
-  allocate(Amap(V,V), source=0) !> mapping matrix
-  k = 0
-  do i=1,V
-    m = 0
-    if( nc(i) > 0 ) then !> to skip the three incomplete zmate entries
-      j=na(i)
-      l=nb(i)
-      if(Amap(j,l) > 0)then
-        m = Amap(j,l)
-      else
-        if( nint(wbo(j,l)) == 1)then
-         k = k + 1
-         Amap(j,l) = k
-         Amap(l,j) = k 
-         m = k
-        endif
-      endif  
-    endif
-    ztod(i) = m
-  enddo
- 
-  if(allocated(Amap)) deallocate(Amap)
-  return
-end subroutine rigidconf_analyze_fallback
+    V = mol%nat
+    allocate (Amap(V,V),source=0) !> mapping matrix
+    k = 0
+    do i = 1,V
+      m = 0
+      if (nc(i) > 0) then !> to skip the three incomplete zmate entries
+        j = na(i)
+        l = nb(i)
+        if (Amap(j,l) > 0) then
+          m = Amap(j,l)
+        else
+          if (nint(wbo(j,l)) == 1) then
+            k = k+1
+            Amap(j,l) = k
+            Amap(l,j) = k
+            m = k
+          end if
+        end if
+      end if
+      ztod(i) = m
+    end do
+
+    if (allocated(Amap)) deallocate (Amap)
+    return
+  end subroutine rigidconf_analyze_fallback
 
 !========================================================================================!
-subroutine rigidconf_count_fallback(nat,na,nb,nc,wbo,ndieder,ztod)
+  subroutine rigidconf_count_fallback(nat,na,nb,nc,wbo,ndieder,ztod)
 !************************************************************
 !* Count number of unique single-bond dihedral angles that
 !* correspond to an entry in the zmat.
 !************************************************************
-  implicit none
-  !> INPUT
-  integer,intent(in)  :: nat
-  integer,intent(in)  :: na(nat),nb(nat),nc(nat)
-  real(wp),intent(in) :: wbo(nat,nat)
-  !> OUTPUT
-  integer,intent(out)  :: ndieder
-  integer,intent(out),optional :: ztod(nat)
-  !> LOCAL
-  integer :: V,i,j,k,l,m
-  integer,allocatable :: Amap(:,:)
+    implicit none
+    !> INPUT
+    integer,intent(in)  :: nat
+    integer,intent(in)  :: na(nat),nb(nat),nc(nat)
+    real(wp),intent(in) :: wbo(nat,nat)
+    !> OUTPUT
+    integer,intent(out)  :: ndieder
+    integer,intent(out),optional :: ztod(nat)
+    !> LOCAL
+    integer :: V,i,j,k,l,m
+    integer,allocatable :: Amap(:,:)
 !>--- init
-  ndieder = 0
+    ndieder = 0
 !>--- Mapping
-  V = nat
-  allocate(Amap(V,V), source=0) !> mapping matrix
-  k = 0
-  do i=1,V
-    m = 0
-    if( nc(i) > 0 ) then !> to skip the three incomplete zmate entries
-      j=na(i)
-      l=nb(i)
-      if(Amap(j,l) > 0)then
-        m = Amap(j,l)
-      else
-        if( nint(wbo(j,l)) == 1)then
-         k = k + 1
-         Amap(j,l) = k
-         Amap(l,j) = k 
-         m = k
-        endif
-      endif  
-    endif
-    if(present(ztod)) ztod(i) = m
-  enddo
-  ndieder = k
-  if(allocated(Amap)) deallocate(Amap)
-  return
-end subroutine rigidconf_count_fallback
+    V = nat
+    allocate (Amap(V,V),source=0) !> mapping matrix
+    k = 0
+    do i = 1,V
+      m = 0
+      if (nc(i) > 0) then !> to skip the three incomplete zmate entries
+        j = na(i)
+        l = nb(i)
+        if (Amap(j,l) > 0) then
+          m = Amap(j,l)
+        else
+          if (nint(wbo(j,l)) == 1) then
+            k = k+1
+            Amap(j,l) = k
+            Amap(l,j) = k
+            m = k
+          end if
+        end if
+      end if
+      if (present(ztod)) ztod(i) = m
+    end do
+    ndieder = k
+    if (allocated(Amap)) deallocate (Amap)
+    return
+  end subroutine rigidconf_count_fallback
 
-
 !========================================================================================!
-subroutine prune_zmat_dihedrals(nat, xyz, zmat, na,nb,nc, ztod )
+  subroutine prune_zmat_dihedrals(nat,xyz,zmat,na,nb,nc,ztod)
 !********************************************************
 !* Remove zmat entries that correspond
 !* to the same bond and replace them with internal
 !* dihedral angles. There you go, Christoph...
 !********************************************************
-   implicit none
-   integer,intent(in)  :: nat
-   real(wp),intent(in) :: xyz(3,nat)
-   real(wp),intent(inout) :: zmat(3,nat)
-   integer,intent(inout)  :: na(nat),nb(nat),nc(nat)
-   integer,intent(inout)  :: ztod(nat)
-   integer :: i,j,k,l
-   integer :: maxgroup,nmembers,refi
-  
-   write(*,*) ztod
-   maxgroup = maxval(ztod,1)
-   do i=1,maxgroup 
-     nmembers = count(ztod(:).eq.i)
-     if(nmembers < 2) cycle
-     do j=1,nat
-       if(ztod(j)==i)then
-         refi = j 
-         exit
-       endif 
-     enddo
-     do j=1,nat
-        if(j==refi) cycle
-        if(ztod(j) == i)then
-           !nc(j) = nb(j)
-           nc(j) = refi
-           !call BANGLE2( xyz, j, na(j), nb(j), zmat(2,j) )
-           call DIHED2( xyz, j, na(j), nb(j), nc(j), zmat(3,j) ) 
-           ztod(j) = 0
-        endif  
-     enddo
-   enddo
-   write(*,*) ztod
-end subroutine prune_zmat_dihedrals
+    implicit none
+    integer,intent(in)  :: nat
+    real(wp),intent(in) :: xyz(3,nat)
+    real(wp),intent(inout) :: zmat(3,nat)
+    integer,intent(inout)  :: na(nat),nb(nat),nc(nat)
+    integer,intent(inout)  :: ztod(nat)
+    integer :: i,j,k,l
+    integer :: maxgroup,nmembers,refi
+
+    write (*,*) ztod
+    maxgroup = maxval(ztod,1)
+    do i = 1,maxgroup
+      nmembers = count(ztod(:) .eq. i)
+      if (nmembers < 2) cycle
+      do j = 1,nat
+        if (ztod(j) == i) then
+          refi = j
+          exit
+        end if
+      end do
+      do j = 1,nat
+        if (j == refi) cycle
+        if (ztod(j) == i) then
+          !nc(j) = nb(j)
+          nc(j) = refi
+          !call BANGLE2( xyz, j, na(j), nb(j), zmat(2,j) )
+          call DIHED2(xyz,j,na(j),nb(j),nc(j),zmat(3,j))
+          ztod(j) = 0
+        end if
+      end do
+    end do
+    write (*,*) ztod
+  end subroutine prune_zmat_dihedrals
+
+!========================================================================================!
+  subroutine rigidconf_user_file(fname,nat,na,nb,nc,wbo,ndieder,ztod,dvalues,dstep)
+!************************************************************
+!* Read a user-defined file to access which bonds should be
+!* used for the isomer generation and how many points per
+!* bond shall be used.
+!* The file must contain one line per bond, with three integer
+!* entries: atoms A and B defining the bond, and the number of
+!* points to generate
+!************************************************************
+    implicit none
+    !> INPUT
+    character(len=*),intent(in) :: fname
+    integer,intent(in)  :: nat
+    integer,intent(in)  :: na(nat),nb(nat),nc(nat)
+    real(wp),intent(in) :: wbo(nat,nat)
+    !> OUTPUT
+    integer,intent(out)  :: ndieder
+    integer,intent(out),allocatable  :: ztod(:)
+    integer,intent(out),allocatable  :: dvalues(:)
+    real(wp),intent(out),allocatable :: dstep(:)
+    !integer,intent(in)  :: ndieder
+    !integer,intent(out)  :: ztod(nat)
+    !integer,intent(out)  :: dvalues(ndieder)
+    !real(wp),intent(out) :: dstep(ndieder)
+    !> LOCAL
+    integer :: V,i,j,k,l,m,ich,io,n
+    integer,allocatable :: Amap(:,:)
+    integer,allocatable :: tmppairs(:,:)
+    logical :: ex
+!>--- init
+    ndieder = 0
+    allocate (ztod(nat),source=0)
+!>--- Mapping
+    V = nat
+    allocate (Amap(V,V),source=0) !> mapping matrix
+    k = 0
+    do i = 1,V
+      m = 0
+      if (nc(i) > 0) then !> to skip the three incomplete zmate entries
+        j = na(i)
+        l = nb(i)
+        if (Amap(j,l) > 0) then
+          m = Amap(j,l)
+        else
+          if (nint(wbo(j,l)) > 0) then
+            k = k+1
+            Amap(j,l) = k
+            Amap(l,j) = k
+            m = k
+          end if
+        end if
+      end if
+      ztod(i) = m
+    end do
+    ndieder = k
+    allocate (tmppairs(nat,nat),source=1)
+    inquire (file=fname,exist=ex)
+    if (.not.ex) then
+      write (stdout,'(a,a,a)') '**ERROR** file ',fname,' not found!'
+      error stop
+    else
+      write (stdout,'(">",1x,a,a)') 'reading file ',fname
+    end if
+    open (newunit=ich,file=fname)
+    do
+      read (ich,*,iostat=io) i,j,n
+      if (io > 0) cycle !> invalid line
+      if (io < 0) exit !> EOF
+      if (i > nat) then
+        write (stdout,'(a,i0)') '**WARNING** invalid atom ',i
+        cycle
+      end if
+      if (j > nat) then
+        write (stdout,'(a,i0)') '**WARNING** invalid atom ',j
+        cycle
+      end if
+      if (nint(wbo(i,j)) == 0) then
+        write (stdout,'(a,i0,1x,i0)') '**WARNING** no bond defined for atoms ',i,j
+        cycle
+      end if
+      write(stdout,'(">",1x,a,i0,a,i0,a,i0)') 'adding ',abs(n),' points for bond between atoms ', &
+      & i,' and ',j
+      tmppairs(i,j) = abs(n)
+      tmppairs(j,i) = abs(n)
+    end do
+    close (ich)
+    if (ndieder > 0) then
+      allocate (dvalues(ndieder),source=0)
+      allocate (dstep(ndieder),source=0.0_wp)
+      dvalues(:) = 0
+      dstep(:) = 360.0_wp * degtorad
+      k = 0
+      do i = 1,nat
+        do j = 1,i-1
+          if (tmppairs(j,i) > 0) then
+            m = Amap(j,i)
+            if(m == 0) cycle
+            n = tmppairs(j,i)
+            dvalues(m) = n
+            dstep(m) = (360.0_wp / real(n)) * degtorad  
+          end if
+        end do
+      end do
+    end if
+    if (allocated(tmppairs)) deallocate (tmppairs)
+    if (allocated(Amap)) deallocate (Amap)
+    return
+  end subroutine rigidconf_user_file
+
 !========================================================================================!
 !========================================================================================!
 end module rigidconf_analyze
Index: src/filemod.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!######################################################################################################\n!# MODULE FOR FILE HANDLING IN FORTRAN,   P.Pracht,2019\n!######################################################################################################\nmodule filemod\n   use iso_fortran_env, wp => real64\n\n   implicit none\n\n   public :: filetype\n   public :: nlines\n   public :: lwidth\n   public :: getlarg\n   public :: clearcomment\n\n   private\n!-----------------------------------------------------------------------------------------------------\n!--- dummy variables to use thoughout the module\n   integer :: i\n   logical :: ex\n\n!-----------------------------------------------------------------------------------------------------\n! The File class & procedures\n!-----------------------------------------------------------------------------------------------------\n   type :: filetype\n\n      integer :: nlines   ! number of lines in the file\n      integer :: lwidth     ! maximum line length (used to allocate the file)\n      character(:),allocatable :: f(:)  !The entire file content\n       \n      character(:),allocatable :: filename   !name of the file\n      integer :: lcursor                     !\"cursor\" postion within the file lines\n      integer :: current_line = 1            ! current line within the file\n \n    contains\n      procedure :: allocate => allocate_file      !allocate memory for file      \n      procedure :: deallocate => deallocate_file  !deallocate memory\n      procedure :: close => deallocate_file\n      procedure :: read=> read_file               !read the file into memory\n      procedure :: init=> initialize_file         !combination ofallocate + read file \n      procedure :: open=> initialize_file\n      procedure :: print => print_file            !print the entire file into some io channel\n      procedure :: line => getline_file           !get the n-th line of the file\n      procedure :: write => write_to_file         !append a line to the file\n      procedure :: insert => insert_to_file       !insert line into file at a given position\n      procedure :: flush => flush_file            !instantly write the file from memory to disk under 'filename'\n      procedure :: flushclose => flush_file_close !instantly write the file from memory and deallocate afterwards\n      procedure :: findall => grep_all_lines      !grep all occurences of a substring and return postions\n      procedure :: grephead => grep_first_appearance\n      procedure :: overwrite => replace_line      !replace a line in the file by a new one\n      procedure :: replace => replace_line\n      procedure :: rename => rename_file          !change the filename\n      procedure :: clearblanks => clear_blanklines_from_file !\"clear\" blanklines from file\n\n   end type filetype\n\n!---------------------------------------------------------------------------------------------------\n!---------------------------------------------------------------------------------------------------\n\ncontains\n!---------------------------------------------------------------------------------------------------\n! PROCEDURES\n!---------------------------------------------------------------------------------------------------\nsubroutine allocate_file(self,fname)\n   implicit none\n   class(filetype) :: self\n   character(len=*) :: fname\n   character(len=:),allocatable :: dummy\n   integer :: a,b\n   inquire(file=fname,exist=ex)\n   if(ex)then\n     b =lwidth(fname)\n     a = nlines(fname)\n     self%lcursor=a+1\n   else !-for new file\n     b=0\n     a=1\n     self%lcursor=1\n   endif\n   self%lwidth= b\n   dummy=repeat(' ',b+5)\n   self%nlines      = a\n   self%current_line = 1\n   allocate( self%f(a), source=dummy)\n   self%filename = fname\nend subroutine allocate_file\n!----------------------------------------------------------------------------------------------------\nsubroutine deallocate_file(self)\n   implicit none\n   class(filetype) :: self\n   if (allocated( self%f)) deallocate( self%f )\nend subroutine deallocate_file\n!----------------------------------------------------------------------------------------------------\nsubroutine print_file(self,ich)\n   implicit none\n   class(filetype) :: self\n   integer,intent(in) :: ich\n   do i=1,self%nlines\n      write(ich,'(a)')trim(self%f(i))\n   enddo\nend subroutine print_file\n!-------------------------------------------------------------------------------------------------------------\nsubroutine read_file(self,fname)\n   implicit none\n   class(filetype)  :: self\n   character(len=*) :: fname\n   integer :: ich\n   open(newunit=ich,file=fname)\n   do i=1,self%nlines\n      read(ich,'(a)')self%f(i)\n   enddo\n   close(ich)\nend subroutine read_file\n!-------------------------------------------------------------------------------------------------------------\nsubroutine initialize_file(self,fname)\n   implicit none\n   class(filetype)  :: self\n   character(len=*) :: fname\n   call self%allocate(fname)\n   inquire(file=fname,exist=ex)\n   if(ex)then\n   call self%read(fname)\n   endif\n   return\nend subroutine initialize_file\n!-------------------------------------------------------------------------------------------------------------\nfunction getline_file(self,n)\n   implicit none\n   class(filetype) :: self\n   character(len=:),allocatable :: getline_file\n   integer :: n\n   if(n.le.self%nlines .and. n.gt.0)then\n     getline_file = trim(self%f(n))\n   else\n     getline_file=''\n   endif\n   return\nend function getline_file\n!-----------------------------------------------------------------------------------------------------\nsubroutine write_to_file(self,str)\n   implicit none\n   class(filetype)  :: self\n   character(len=*) :: str\n   character(len=:),allocatable :: tmp(:)  !dummey file\n   character(len=:),allocatable :: dummy\n   integer :: maxwidth\n   integer :: newlines\n   integer :: cursor\n   newlines=self%nlines+1\n   if(len(str).lt.1)then\n     maxwidth=self%lwidth+5\n   else\n     maxwidth=max((len(str)+5),self%lwidth)\n   endif\n   cursor=self%lcursor\n   dummy=repeat(' ',maxwidth)\n   allocate(tmp(newlines), source=dummy)\n   tmp(1:self%nlines) = self%f(1:self%nlines)\n   tmp(cursor) = str\n   self%nlines=newlines\n   self%lwidth=maxwidth\n   self%lcursor=cursor+1\n   call move_alloc(tmp,self%f)\n   return\nend subroutine write_to_file\n!-----------------------------------------------------------------------------------------------------\nsubroutine insert_to_file(self,str,pos)\n   implicit none\n   class(filetype)  :: self\n   character(len=*) :: str\n   integer :: pos\n   character(len=:),allocatable :: tmp(:)  !dummey file\n   character(len=:),allocatable :: dummy\n   integer :: maxwidth\n   integer :: newlines\n   integer :: cursor\n   newlines=self%nlines+1\n   if(len(str).lt.1)then\n     maxwidth=self%lwidth+5\n   else\n     maxwidth=max((len(str)+5),self%lwidth)\n   endif\n   if(pos.gt.self%nlines)then\n     cursor=newlines\n   elseif(pos.le.1)then\n     cursor=1\n   else\n     cursor=pos\n   endif\n   dummy=repeat(' ',maxwidth)\n   allocate(tmp(newlines), source=dummy)\n   if(cursor.gt.1)tmp(1:cursor-1) = self%f(1:cursor-1)\n   tmp(cursor) = str\n   if(cursor.lt.newlines)tmp(cursor+1:newlines)=self%f(cursor:self%nlines)\n   self%nlines=newlines\n   self%lwidth=maxwidth\n   self%lcursor=self%lcursor+1\n   call move_alloc(tmp, self%f)\n   return\nend subroutine insert_to_file\n!-------------------------------------------------------------------------------------------------------------\nsubroutine flush_file(self)\n   implicit none\n   class(filetype) :: self\n   integer :: ich\n   open(newunit=ich,file=self%filename)\n   do i=1,self%nlines\n      write(ich,'(a)')trim(self%f(i))\n   enddo\n   close(ich)\n   return\nend subroutine flush_file\n!-------------------------------------------------------------------------------------------------------------\nsubroutine flush_file_close(self)\n   implicit none\n   class(filetype) :: self\n   integer :: ich\n   open(newunit=ich,file=self%filename)\n   do i=1,self%nlines\n      write(ich,'(a)')trim(self%f(i))\n   enddo\n   close(ich)\n   if (allocated( self%f)) deallocate( self%f )\n   return\nend subroutine flush_file_close\n!-------------------------------------------------------------------------------------------------------------\nfunction grep_first_appearance(self,str)\n   implicit none\n   class(filetype) :: self\n   character(len=*) :: str\n   integer :: grep_first_appearance\n   integer :: j\n   do j=1,self%nlines\n      if(index(self%line(j),str).ne.0)then\n         grep_first_appearance=j\n         exit\n      endif\n   enddo\n   return\nend function grep_first_appearance\n!-------------------------------------------------------------------------------------------------------------\n! the function return value is an array of rank 1 with the dimension k. the entries are the line numbers \n! in which the string str is present.\nfunction grep_all_lines(self,str,k)\n   implicit none\n   class(filetype) :: self\n   character(len=*) :: str\n   integer,allocatable :: grep_all_lines(:)\n   integer,allocatable :: pos(:),tmp(:)\n   integer,intent(out) :: k\n   integer :: j\n   k=0\n   do j=1,self%nlines\n      if(index(self%line(j),str).ne.0)then\n         if(k.gt.0)then\n           allocate(tmp(k+1))\n           tmp(1:k)=pos(1:k)\n           tmp(k+1)=j\n           call move_alloc(tmp, pos)\n         else\n           allocate(pos(1))\n           pos(1)=j\n         endif\n         k=k+1\n      endif\n   enddo\n   if(k==0)then\n      grep_all_lines=(/0/)\n     return\n   endif\n   grep_all_lines=pos\n   return\nend function grep_all_lines\n!-------------------------------------------------------------------------------------------------------------\n!replaces line K in file SELF by STR. \nsubroutine replace_line(self,k,str)\n   implicit none\n   class(filetype) :: self\n   character(len=*) :: str\n   integer :: k\n   character(len=:),allocatable :: tmp(:)  !dummey \"file\"\n   character(len=:),allocatable :: dum\n   integer :: maxlen\n   if(k.gt.self%nlines .or. k.lt.1)return !k is not in a valid linenumber\n   if(len(str).gt.self%lwidth)then\n      maxlen=len(str)\n      dum=repeat(' ',maxlen+5)\n      allocate(tmp(self%nlines), source=dum)\n      tmp(1:self%nlines) = self%f(1:self%nlines)\n      self%lwidth=maxlen\n      call move_alloc(tmp, self%f)\n   endif\n   self%f(k)=str\n   return\nend subroutine replace_line\n\n!-------------------------------------------------------------------------------------------------------------\n!replaces the internal file name by STR\nsubroutine rename_file(self,str)\n   implicit none\n   class(filetype) :: self\n   character(len=*) :: str\n   if(len_trim(str).lt.0)return\n   self%filename=trim(adjustl(str))\n   return\nend subroutine rename_file\n!-------------------------------------------------------------------------------------------------------------\n! removes all blank lines from file\nsubroutine clear_blanklines_from_file(self)\n   implicit none\n   class(filetype)  :: self\n   character(len=:),allocatable :: tmp(:)  !dummey file\n   character(len=:),allocatable :: dummy\n   integer :: maxwidth\n   integer :: newlines\n   integer :: i,k\n   !--- set the stage\n   newlines=self%nlines\n   maxwidth=self%lwidth\n   dummy=repeat(' ',maxwidth)\n   allocate(tmp(newlines), source=dummy)\n   k=1\n   do i=1,self%nlines\n      dummy=self%f(i)\n      if(len_trim(dummy).lt.1)then\n         newlines=newlines-1\n         cycle\n      endif\n      tmp(k)=dummy\n      k=k+1\n   enddo\n   self%f(1:self%nlines) = tmp(1:self%nlines)\n   self%nlines=newlines\n   self%lcursor=newlines+1\n   deallocate(tmp)\n   return\nend subroutine clear_blanklines_from_file\n\n\n!---------------------------------------------------------------------------------------------------\n!---------------------------------------------------------------------------------------------------\n!---------------------------------------------------------------------------------------------------\n! PUBLIC subroutines from the module\n!---------------------------------------------------------------------------------------------------\n!---------------------------------------------------------------------------------------------------\n!---------------------------------------------------------------------------------------------------\n\n!----------------------------------------------------------------------------\n! get the number of lines of a file\nfunction nlines(fname)\n      implicit none\n      integer :: nlines\n      character(len=*) :: fname\n      integer :: ich,io\n      character(len=1024) :: str\n      open(newunit=ich,file=fname)\n      nlines=0\n      do\n         read(ich,'(a)',iostat=io)str\n         if(io < 0) exit !--- EOF\n         nlines=nlines+1\n      enddo\n      close(ich)\nend function nlines\n!----------------------------------------------------------------------------\n! get the maximum file width in a file\nfunction lwidth(fname)\n      implicit none\n      integer :: lwidth\n      character(len=*) :: fname\n      integer :: ich,io\n      character(len=1024) :: str\n      open(newunit=ich,file=fname)\n      lwidth=0\n      do\n         read(ich,'(a)',iostat=io)str\n         if(io < 0) exit !--- EOF\n         lwidth=max(lwidth,len_trim(str))\n      enddo\n      close(ich)\nend function lwidth\n\n!----------------------------------------------------------------------------\n!get n-th element of a line (seperated by blanks)\nfunction getlarg(line,n)\n     implicit none\n     character(len=*) :: line\n     character(len=:),allocatable :: getlarg\n     character(len=:),allocatable :: dum\n     character(len=1) :: c\n     integer :: n\n     integer :: lw,nt\n     integer :: i\n     logical :: rd\n     getlarg=''\n     lw=len_trim(line)\n     nt=0\n     rd=.false.\n     dum=''\n     if(lw.lt.1 .or. n.lt.1)return\n     do i=1,lw\n        c=line(i:i)\n        if(c.eq.' ')then\n            if(rd)then\n               if(nt.eq.n)then\n                 getlarg=dum\n                 exit\n               endif\n               dum=''\n            endif\n            rd=.false.\n            cycle\n        else\n            dum=dum//c\n            if(.not.rd)nt=nt+1\n            rd=.true.\n        endif\n        if(rd .and. i.eq.lw)then\n            getlarg=dum\n        endif    \n     enddo\n     if(nt.lt.n)getlarg=''\n     return\nend function\n\n!========================================================================================!\n!> remove any comment from a given line.\n!> comments are identified by the \"id\" character\nsubroutine clearcomment(str,id)\n     implicit none\n     character(len=*),intent(inout) :: str\n     character(len=1),intent(in) :: id \n     character(len=:),allocatable :: atmp\n     integer :: k\n     atmp = str\n     k = index(str,id) \n     if(k == 1)then\n       atmp =  ''\n     else if(k > 0) then\n       atmp = str(1:k-1)\n     endif\n     str = trim(atmp)\n     deallocate(atmp)\n     return\nend subroutine clearcomment\n\n\n!========================================================================================!\nend module filemod\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/filemod.f90 b/src/filemod.f90
--- a/src/filemod.f90	
+++ b/src/filemod.f90	
@@ -17,451 +17,480 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-!######################################################################################################
-!# MODULE FOR FILE HANDLING IN FORTRAN,   P.Pracht,2019
-!######################################################################################################
+
+!> fortran module for simple plain-text file handling
+
 module filemod
-   use iso_fortran_env, wp => real64
+  use iso_fortran_env,wp => real64
 
-   implicit none
+  implicit none
 
-   public :: filetype
-   public :: nlines
-   public :: lwidth
-   public :: getlarg
-   public :: clearcomment
+  public :: filetype
+  public :: nlines
+  public :: lwidth
+  public :: getlarg
+  public :: clearcomment
 
-   private
-!-----------------------------------------------------------------------------------------------------
-!--- dummy variables to use thoughout the module
-   integer :: i
-   logical :: ex
+  private
 
-!-----------------------------------------------------------------------------------------------------
-! The File class & procedures
-!-----------------------------------------------------------------------------------------------------
-   type :: filetype
+!========================================================================================!
+!> the File class & procedures
+  type :: filetype
 
-      integer :: nlines   ! number of lines in the file
-      integer :: lwidth     ! maximum line length (used to allocate the file)
-      character(:),allocatable :: f(:)  !The entire file content
-       
-      character(:),allocatable :: filename   !name of the file
-      integer :: lcursor                     !"cursor" postion within the file lines
-      integer :: current_line = 1            ! current line within the file
- 
-    contains
-      procedure :: allocate => allocate_file      !allocate memory for file      
-      procedure :: deallocate => deallocate_file  !deallocate memory
-      procedure :: close => deallocate_file
-      procedure :: read=> read_file               !read the file into memory
-      procedure :: init=> initialize_file         !combination ofallocate + read file 
-      procedure :: open=> initialize_file
-      procedure :: print => print_file            !print the entire file into some io channel
-      procedure :: line => getline_file           !get the n-th line of the file
-      procedure :: write => write_to_file         !append a line to the file
-      procedure :: insert => insert_to_file       !insert line into file at a given position
-      procedure :: flush => flush_file            !instantly write the file from memory to disk under 'filename'
-      procedure :: flushclose => flush_file_close !instantly write the file from memory and deallocate afterwards
-      procedure :: findall => grep_all_lines      !grep all occurences of a substring and return postions
-      procedure :: grephead => grep_first_appearance
-      procedure :: overwrite => replace_line      !replace a line in the file by a new one
-      procedure :: replace => replace_line
-      procedure :: rename => rename_file          !change the filename
-      procedure :: clearblanks => clear_blanklines_from_file !"clear" blanklines from file
-
-   end type filetype
+    integer :: nlines   !> number of lines in the file
+    integer :: lwidth   !> maximum line length (used to allocate the file)
+    character(:),allocatable :: f(:)  !> The entire file content
+
+    character(:),allocatable :: filename   !> name of the file
+    integer :: lcursor                     !> "cursor" postion within the file lines
+    integer :: current_line = 1            !> current line within the file
+
+  contains
+    procedure :: allocate => allocate_file      !> allocate memory for file
+    procedure :: deallocate => deallocate_file  !> deallocate memory
+    procedure :: close => deallocate_file       !> deallocate memory
+    procedure :: read => read_file              !> read the file into memory
+    procedure :: init => initialize_file        !> combination of allocate + read file
+    procedure :: open => initialize_file        !> combination of allocate + read file
+    procedure :: print => print_file            !> print the entire file into some io channel
+    procedure :: line => getline_file           !> get the n-th line of the file
+    procedure :: write => write_to_file         !> append a line to the file
+    procedure :: insert => insert_to_file       !> insert line into file at a given position
+    procedure :: flush => flush_file            !> instantly write the file from memory to disk under 'filename'
+    procedure :: flushclose => flush_file_close !> instantly write the file from memory and deallocate afterwards
+    procedure :: findall => grep_all_lines      !> grep all occurences of a substring and return postions
+    procedure :: grephead => grep_first_appearance
+    procedure :: overwrite => replace_line      !> replace a line in the file by a new one
+    procedure :: replace => replace_line
+    procedure :: rename => rename_file          !> change the filename
+    procedure :: clearblanks => clear_blanklines_from_file !> "clear" blanklines from file
+  end type filetype
 
-!---------------------------------------------------------------------------------------------------
-!---------------------------------------------------------------------------------------------------
+!========================================================================================!
+!========================================================================================!
+contains  !> MODULE PROCEDURES START HERE
+!========================================================================================!
+!========================================================================================!
 
-contains
-!---------------------------------------------------------------------------------------------------
-! PROCEDURES
-!---------------------------------------------------------------------------------------------------
-subroutine allocate_file(self,fname)
-   implicit none
-   class(filetype) :: self
-   character(len=*) :: fname
-   character(len=:),allocatable :: dummy
-   integer :: a,b
-   inquire(file=fname,exist=ex)
-   if(ex)then
-     b =lwidth(fname)
-     a = nlines(fname)
-     self%lcursor=a+1
-   else !-for new file
-     b=0
-     a=1
-     self%lcursor=1
-   endif
-   self%lwidth= b
-   dummy=repeat(' ',b+5)
-   self%nlines      = a
-   self%current_line = 1
-   allocate( self%f(a), source=dummy)
-   self%filename = fname
-end subroutine allocate_file
-!----------------------------------------------------------------------------------------------------
-subroutine deallocate_file(self)
-   implicit none
-   class(filetype) :: self
-   if (allocated( self%f)) deallocate( self%f )
-end subroutine deallocate_file
-!----------------------------------------------------------------------------------------------------
-subroutine print_file(self,ich)
-   implicit none
-   class(filetype) :: self
-   integer,intent(in) :: ich
-   do i=1,self%nlines
-      write(ich,'(a)')trim(self%f(i))
-   enddo
-end subroutine print_file
-!-------------------------------------------------------------------------------------------------------------
-subroutine read_file(self,fname)
-   implicit none
-   class(filetype)  :: self
-   character(len=*) :: fname
-   integer :: ich
-   open(newunit=ich,file=fname)
-   do i=1,self%nlines
-      read(ich,'(a)')self%f(i)
-   enddo
-   close(ich)
-end subroutine read_file
-!-------------------------------------------------------------------------------------------------------------
-subroutine initialize_file(self,fname)
-   implicit none
-   class(filetype)  :: self
-   character(len=*) :: fname
-   call self%allocate(fname)
-   inquire(file=fname,exist=ex)
-   if(ex)then
-   call self%read(fname)
-   endif
-   return
-end subroutine initialize_file
-!-------------------------------------------------------------------------------------------------------------
-function getline_file(self,n)
-   implicit none
-   class(filetype) :: self
-   character(len=:),allocatable :: getline_file
-   integer :: n
-   if(n.le.self%nlines .and. n.gt.0)then
-     getline_file = trim(self%f(n))
-   else
-     getline_file=''
-   endif
-   return
-end function getline_file
-!-----------------------------------------------------------------------------------------------------
-subroutine write_to_file(self,str)
-   implicit none
-   class(filetype)  :: self
-   character(len=*) :: str
-   character(len=:),allocatable :: tmp(:)  !dummey file
-   character(len=:),allocatable :: dummy
-   integer :: maxwidth
-   integer :: newlines
-   integer :: cursor
-   newlines=self%nlines+1
-   if(len(str).lt.1)then
-     maxwidth=self%lwidth+5
-   else
-     maxwidth=max((len(str)+5),self%lwidth)
-   endif
-   cursor=self%lcursor
-   dummy=repeat(' ',maxwidth)
-   allocate(tmp(newlines), source=dummy)
-   tmp(1:self%nlines) = self%f(1:self%nlines)
-   tmp(cursor) = str
-   self%nlines=newlines
-   self%lwidth=maxwidth
-   self%lcursor=cursor+1
-   call move_alloc(tmp,self%f)
-   return
-end subroutine write_to_file
-!-----------------------------------------------------------------------------------------------------
-subroutine insert_to_file(self,str,pos)
-   implicit none
-   class(filetype)  :: self
-   character(len=*) :: str
-   integer :: pos
-   character(len=:),allocatable :: tmp(:)  !dummey file
-   character(len=:),allocatable :: dummy
-   integer :: maxwidth
-   integer :: newlines
-   integer :: cursor
-   newlines=self%nlines+1
-   if(len(str).lt.1)then
-     maxwidth=self%lwidth+5
-   else
-     maxwidth=max((len(str)+5),self%lwidth)
-   endif
-   if(pos.gt.self%nlines)then
-     cursor=newlines
-   elseif(pos.le.1)then
-     cursor=1
-   else
-     cursor=pos
-   endif
-   dummy=repeat(' ',maxwidth)
-   allocate(tmp(newlines), source=dummy)
-   if(cursor.gt.1)tmp(1:cursor-1) = self%f(1:cursor-1)
-   tmp(cursor) = str
-   if(cursor.lt.newlines)tmp(cursor+1:newlines)=self%f(cursor:self%nlines)
-   self%nlines=newlines
-   self%lwidth=maxwidth
-   self%lcursor=self%lcursor+1
-   call move_alloc(tmp, self%f)
-   return
-end subroutine insert_to_file
-!-------------------------------------------------------------------------------------------------------------
-subroutine flush_file(self)
-   implicit none
-   class(filetype) :: self
-   integer :: ich
-   open(newunit=ich,file=self%filename)
-   do i=1,self%nlines
-      write(ich,'(a)')trim(self%f(i))
-   enddo
-   close(ich)
-   return
-end subroutine flush_file
-!-------------------------------------------------------------------------------------------------------------
-subroutine flush_file_close(self)
-   implicit none
-   class(filetype) :: self
-   integer :: ich
-   open(newunit=ich,file=self%filename)
-   do i=1,self%nlines
-      write(ich,'(a)')trim(self%f(i))
-   enddo
-   close(ich)
-   if (allocated( self%f)) deallocate( self%f )
-   return
-end subroutine flush_file_close
-!-------------------------------------------------------------------------------------------------------------
-function grep_first_appearance(self,str)
-   implicit none
-   class(filetype) :: self
-   character(len=*) :: str
-   integer :: grep_first_appearance
-   integer :: j
-   do j=1,self%nlines
-      if(index(self%line(j),str).ne.0)then
-         grep_first_appearance=j
-         exit
-      endif
-   enddo
-   return
-end function grep_first_appearance
-!-------------------------------------------------------------------------------------------------------------
-! the function return value is an array of rank 1 with the dimension k. the entries are the line numbers 
+  subroutine allocate_file(self,fname)
+    implicit none
+    class(filetype) :: self
+    character(len=*) :: fname
+    character(len=:),allocatable :: dummy
+    integer :: a,b
+    integer :: i
+    logical :: ex
+    inquire (file=fname,exist=ex)
+    if (ex) then
+      b = lwidth(fname)
+      a = nlines(fname)
+      self%lcursor = a+1
+    else !-for new file
+      b = 0
+      a = 1
+      self%lcursor = 1
+    end if
+    self%lwidth = b
+    dummy = repeat(' ',b+5)
+    self%nlines = a
+    self%current_line = 1
+    allocate (self%f(a),source=dummy)
+    self%filename = fname
+  end subroutine allocate_file
+
+!========================================================================================!
+  subroutine deallocate_file(self)
+    implicit none
+    class(filetype) :: self
+    if (allocated(self%f)) deallocate (self%f)
+  end subroutine deallocate_file
+
+!========================================================================================!
+  subroutine print_file(self,ich)
+    implicit none
+    class(filetype) :: self
+    integer,intent(in) :: ich
+    integer :: i
+    logical :: ex
+    do i = 1,self%nlines
+      write (ich,'(a)') trim(self%f(i))
+    end do
+  end subroutine print_file
+
+!========================================================================================!
+  subroutine read_file(self,fname)
+    implicit none
+    class(filetype)  :: self
+    character(len=*) :: fname
+    integer :: ich
+    integer :: i
+    logical :: ex
+    open (newunit=ich,file=fname)
+    do i = 1,self%nlines
+      read (ich,'(a)') self%f(i)
+    end do
+    close (ich)
+  end subroutine read_file
+
+!========================================================================================!
+  subroutine initialize_file(self,fname)
+    implicit none
+    class(filetype)  :: self
+    character(len=*) :: fname
+    integer :: i
+    logical :: ex
+    call self%allocate(fname)
+    inquire (file=fname,exist=ex)
+    if (ex) then
+      call self%read(fname)
+    end if
+    return
+  end subroutine initialize_file
+
+!========================================================================================!
+  function getline_file(self,n)
+    implicit none
+    class(filetype) :: self
+    character(len=:),allocatable :: getline_file
+    integer :: n
+    if (n .le. self%nlines.and.n .gt. 0) then
+      getline_file = trim(self%f(n))
+    else
+      getline_file = ''
+    end if
+    return
+  end function getline_file
+
+!========================================================================================!
+  subroutine write_to_file(self,str)
+    implicit none
+    class(filetype)  :: self
+    character(len=*) :: str
+    character(len=:),allocatable :: tmp(:)  !dummey file
+    character(len=:),allocatable :: dummy
+    integer :: maxwidth
+    integer :: newlines
+    integer :: cursor
+    integer :: i
+    logical :: ex
+    newlines = self%nlines+1
+    if (len(str) .lt. 1) then
+      maxwidth = self%lwidth+5
+    else
+      maxwidth = max((len(str)+5),self%lwidth)
+    end if
+    cursor = self%lcursor
+    dummy = repeat(' ',maxwidth)
+    allocate (tmp(newlines),source=dummy)
+    tmp(1:self%nlines) = self%f(1:self%nlines)
+    tmp(cursor) = str
+    self%nlines = newlines
+    self%lwidth = maxwidth
+    self%lcursor = cursor+1
+    call move_alloc(tmp,self%f)
+    return
+  end subroutine write_to_file
+
+!========================================================================================!
+  subroutine insert_to_file(self,str,pos)
+    implicit none
+    class(filetype)  :: self
+    character(len=*) :: str
+    integer :: pos
+    character(len=:),allocatable :: tmp(:)  !dummey file
+    character(len=:),allocatable :: dummy
+    integer :: maxwidth
+    integer :: newlines
+    integer :: cursor
+    integer :: i
+    logical :: ex
+    newlines = self%nlines+1
+    if (len(str) .lt. 1) then
+      maxwidth = self%lwidth+5
+    else
+      maxwidth = max((len(str)+5),self%lwidth)
+    end if
+    if (pos .gt. self%nlines) then
+      cursor = newlines
+    elseif (pos .le. 1) then
+      cursor = 1
+    else
+      cursor = pos
+    end if
+    dummy = repeat(' ',maxwidth)
+    allocate (tmp(newlines),source=dummy)
+    if (cursor .gt. 1) tmp(1:cursor-1) = self%f(1:cursor-1)
+    tmp(cursor) = str
+    if (cursor .lt. newlines) tmp(cursor+1:newlines) = self%f(cursor:self%nlines)
+    self%nlines = newlines
+    self%lwidth = maxwidth
+    self%lcursor = self%lcursor+1
+    call move_alloc(tmp,self%f)
+    return
+  end subroutine insert_to_file
+
+!========================================================================================!
+  subroutine flush_file(self)
+    implicit none
+    class(filetype) :: self
+    integer :: ich
+    integer :: i
+    logical :: ex
+    open (newunit=ich,file=self%filename)
+    do i = 1,self%nlines
+      write (ich,'(a)') trim(self%f(i))
+    end do
+    close (ich)
+    return
+  end subroutine flush_file
+
+!========================================================================================!
+  subroutine flush_file_close(self)
+    implicit none
+    class(filetype) :: self
+    integer :: ich
+    integer :: i
+    logical :: ex
+    open (newunit=ich,file=self%filename)
+    do i = 1,self%nlines
+      write (ich,'(a)') trim(self%f(i))
+    end do
+    close (ich)
+    if (allocated(self%f)) deallocate (self%f)
+    return
+  end subroutine flush_file_close
+
+!========================================================================================!
+  function grep_first_appearance(self,str)
+    implicit none
+    class(filetype) :: self
+    character(len=*) :: str
+    integer :: grep_first_appearance
+    integer :: j
+    integer :: i
+    logical :: ex
+    do j = 1,self%nlines
+      if (index(self%line(j),str) .ne. 0) then
+        grep_first_appearance = j
+        exit
+      end if
+    end do
+    return
+  end function grep_first_appearance
+
+!========================================================================================!
+! the function return value is an array of rank 1 with the dimension k. the entries are the line numbers
 ! in which the string str is present.
-function grep_all_lines(self,str,k)
-   implicit none
-   class(filetype) :: self
-   character(len=*) :: str
-   integer,allocatable :: grep_all_lines(:)
-   integer,allocatable :: pos(:),tmp(:)
-   integer,intent(out) :: k
-   integer :: j
-   k=0
-   do j=1,self%nlines
-      if(index(self%line(j),str).ne.0)then
-         if(k.gt.0)then
-           allocate(tmp(k+1))
-           tmp(1:k)=pos(1:k)
-           tmp(k+1)=j
-           call move_alloc(tmp, pos)
-         else
-           allocate(pos(1))
-           pos(1)=j
-         endif
-         k=k+1
-      endif
-   enddo
-   if(k==0)then
-      grep_all_lines=(/0/)
-     return
-   endif
-   grep_all_lines=pos
-   return
-end function grep_all_lines
-!-------------------------------------------------------------------------------------------------------------
-!replaces line K in file SELF by STR. 
-subroutine replace_line(self,k,str)
-   implicit none
-   class(filetype) :: self
-   character(len=*) :: str
-   integer :: k
-   character(len=:),allocatable :: tmp(:)  !dummey "file"
-   character(len=:),allocatable :: dum
-   integer :: maxlen
-   if(k.gt.self%nlines .or. k.lt.1)return !k is not in a valid linenumber
-   if(len(str).gt.self%lwidth)then
-      maxlen=len(str)
-      dum=repeat(' ',maxlen+5)
-      allocate(tmp(self%nlines), source=dum)
+  function grep_all_lines(self,str,k)
+    implicit none
+    class(filetype) :: self
+    character(len=*) :: str
+    integer,allocatable :: grep_all_lines(:)
+    integer,allocatable :: pos(:),tmp(:)
+    integer,intent(out) :: k
+    integer :: j
+    integer :: i
+    logical :: ex
+    k = 0
+    do j = 1,self%nlines
+      if (index(self%line(j),str) .ne. 0) then
+        if (k .gt. 0) then
+          allocate (tmp(k+1))
+          tmp(1:k) = pos(1:k)
+          tmp(k+1) = j
+          call move_alloc(tmp,pos)
+        else
+          allocate (pos(1))
+          pos(1) = j
+        end if
+        k = k+1
+      end if
+    end do
+    if (k == 0) then
+      grep_all_lines = (/0/)
+      return
+    end if
+    grep_all_lines = pos
+    return
+  end function grep_all_lines
+
+!========================================================================================!
+!replaces line K in file SELF by STR.
+  subroutine replace_line(self,k,str)
+    implicit none
+    class(filetype) :: self
+    character(len=*) :: str
+    integer :: k
+    character(len=:),allocatable :: tmp(:)  !dummey "file"
+    character(len=:),allocatable :: dum
+    integer :: maxlen
+    integer :: i
+    logical :: ex
+    if (k .gt. self%nlines.or.k .lt. 1) return !k is not in a valid linenumber
+    if (len(str) .gt. self%lwidth) then
+      maxlen = len(str)
+      dum = repeat(' ',maxlen+5)
+      allocate (tmp(self%nlines),source=dum)
       tmp(1:self%nlines) = self%f(1:self%nlines)
-      self%lwidth=maxlen
-      call move_alloc(tmp, self%f)
-   endif
-   self%f(k)=str
-   return
-end subroutine replace_line
+      self%lwidth = maxlen
+      call move_alloc(tmp,self%f)
+    end if
+    self%f(k) = str
+    return
+  end subroutine replace_line
 
-!-------------------------------------------------------------------------------------------------------------
+!========================================================================================!
 !replaces the internal file name by STR
-subroutine rename_file(self,str)
-   implicit none
-   class(filetype) :: self
-   character(len=*) :: str
-   if(len_trim(str).lt.0)return
-   self%filename=trim(adjustl(str))
-   return
-end subroutine rename_file
-!-------------------------------------------------------------------------------------------------------------
+  subroutine rename_file(self,str)
+    implicit none
+    class(filetype) :: self
+    character(len=*) :: str
+    integer :: i
+    logical :: ex
+    if (len_trim(str) .lt. 0) return
+    self%filename = trim(adjustl(str))
+    return
+  end subroutine rename_file
+
+!========================================================================================!
 ! removes all blank lines from file
-subroutine clear_blanklines_from_file(self)
-   implicit none
-   class(filetype)  :: self
-   character(len=:),allocatable :: tmp(:)  !dummey file
-   character(len=:),allocatable :: dummy
-   integer :: maxwidth
-   integer :: newlines
-   integer :: i,k
-   !--- set the stage
-   newlines=self%nlines
-   maxwidth=self%lwidth
-   dummy=repeat(' ',maxwidth)
-   allocate(tmp(newlines), source=dummy)
-   k=1
-   do i=1,self%nlines
-      dummy=self%f(i)
-      if(len_trim(dummy).lt.1)then
-         newlines=newlines-1
-         cycle
-      endif
-      tmp(k)=dummy
-      k=k+1
-   enddo
-   self%f(1:self%nlines) = tmp(1:self%nlines)
-   self%nlines=newlines
-   self%lcursor=newlines+1
-   deallocate(tmp)
-   return
-end subroutine clear_blanklines_from_file
+  subroutine clear_blanklines_from_file(self)
+    implicit none
+    class(filetype)  :: self
+    character(len=:),allocatable :: tmp(:)  !dummey file
+    character(len=:),allocatable :: dummy
+    integer :: maxwidth
+    integer :: newlines
+    integer :: i,k
+    logical :: ex
+    !--- set the stage
+    newlines = self%nlines
+    maxwidth = self%lwidth
+    dummy = repeat(' ',maxwidth)
+    allocate (tmp(newlines),source=dummy)
+    k = 1
+    do i = 1,self%nlines
+      dummy = self%f(i)
+      if (len_trim(dummy) .lt. 1) then
+        newlines = newlines-1
+        cycle
+      end if
+      tmp(k) = dummy
+      k = k+1
+    end do
+    self%f(1:self%nlines) = tmp(1:self%nlines)
+    self%nlines = newlines
+    self%lcursor = newlines+1
+    deallocate (tmp)
+    return
+  end subroutine clear_blanklines_from_file
 
+!========================================================================================!
+!========================================================================================!
+!> PUBLIC subroutines from the module
+!========================================================================================!
+!========================================================================================!
 
-!---------------------------------------------------------------------------------------------------
-!---------------------------------------------------------------------------------------------------
-!---------------------------------------------------------------------------------------------------
-! PUBLIC subroutines from the module
-!---------------------------------------------------------------------------------------------------
-!---------------------------------------------------------------------------------------------------
-!---------------------------------------------------------------------------------------------------
-
-!----------------------------------------------------------------------------
 ! get the number of lines of a file
-function nlines(fname)
-      implicit none
-      integer :: nlines
-      character(len=*) :: fname
-      integer :: ich,io
-      character(len=1024) :: str
-      open(newunit=ich,file=fname)
-      nlines=0
-      do
-         read(ich,'(a)',iostat=io)str
-         if(io < 0) exit !--- EOF
-         nlines=nlines+1
-      enddo
-      close(ich)
-end function nlines
-!----------------------------------------------------------------------------
+  function nlines(fname)
+    implicit none
+    integer :: nlines
+    character(len=*) :: fname
+    integer :: ich,io
+    character(len=1024) :: str
+    open (newunit=ich,file=fname)
+    nlines = 0
+    do
+      read (ich,'(a)',iostat=io) str
+      if (io < 0) exit !--- EOF
+      nlines = nlines+1
+    end do
+    close (ich)
+  end function nlines
+
+!========================================================================================!
 ! get the maximum file width in a file
-function lwidth(fname)
-      implicit none
-      integer :: lwidth
-      character(len=*) :: fname
-      integer :: ich,io
-      character(len=1024) :: str
-      open(newunit=ich,file=fname)
-      lwidth=0
-      do
-         read(ich,'(a)',iostat=io)str
-         if(io < 0) exit !--- EOF
-         lwidth=max(lwidth,len_trim(str))
-      enddo
-      close(ich)
-end function lwidth
+  function lwidth(fname)
+    implicit none
+    integer :: lwidth
+    character(len=*) :: fname
+    integer :: ich,io
+    character(len=1024) :: str
+    open (newunit=ich,file=fname)
+    lwidth = 0
+    do
+      read (ich,'(a)',iostat=io) str
+      if (io < 0) exit !--- EOF
+      lwidth = max(lwidth,len_trim(str))
+    end do
+    close (ich)
+  end function lwidth
 
-!----------------------------------------------------------------------------
+
+!========================================================================================!
 !get n-th element of a line (seperated by blanks)
-function getlarg(line,n)
-     implicit none
-     character(len=*) :: line
-     character(len=:),allocatable :: getlarg
-     character(len=:),allocatable :: dum
-     character(len=1) :: c
-     integer :: n
-     integer :: lw,nt
-     integer :: i
-     logical :: rd
-     getlarg=''
-     lw=len_trim(line)
-     nt=0
-     rd=.false.
-     dum=''
-     if(lw.lt.1 .or. n.lt.1)return
-     do i=1,lw
-        c=line(i:i)
-        if(c.eq.' ')then
-            if(rd)then
-               if(nt.eq.n)then
-                 getlarg=dum
-                 exit
-               endif
-               dum=''
-            endif
-            rd=.false.
-            cycle
-        else
-            dum=dum//c
-            if(.not.rd)nt=nt+1
-            rd=.true.
-        endif
-        if(rd .and. i.eq.lw)then
-            getlarg=dum
-        endif    
-     enddo
-     if(nt.lt.n)getlarg=''
-     return
-end function
+  function getlarg(line,n)
+    implicit none
+    character(len=*) :: line
+    character(len=:),allocatable :: getlarg
+    character(len=:),allocatable :: dum
+    character(len=1) :: c
+    integer :: n
+    integer :: lw,nt
+    integer :: i
+    logical :: rd
+    getlarg = ''
+    lw = len_trim(line)
+    nt = 0
+    rd = .false.
+    dum = ''
+    if (lw .lt. 1.or.n .lt. 1) return
+    do i = 1,lw
+      c = line(i:i)
+      if (c .eq. ' ') then
+        if (rd) then
+          if (nt .eq. n) then
+            getlarg = dum
+            exit
+          end if
+          dum = ''
+        end if
+        rd = .false.
+        cycle
+      else
+        dum = dum//c
+        if (.not.rd) nt = nt+1
+        rd = .true.
+      end if
+      if (rd.and.i .eq. lw) then
+        getlarg = dum
+      end if
+    end do
+    if (nt .lt. n) getlarg = ''
+    return
+  end function
 
 !========================================================================================!
 !> remove any comment from a given line.
 !> comments are identified by the "id" character
-subroutine clearcomment(str,id)
-     implicit none
-     character(len=*),intent(inout) :: str
-     character(len=1),intent(in) :: id 
-     character(len=:),allocatable :: atmp
-     integer :: k
-     atmp = str
-     k = index(str,id) 
-     if(k == 1)then
-       atmp =  ''
-     else if(k > 0) then
-       atmp = str(1:k-1)
-     endif
-     str = trim(atmp)
-     deallocate(atmp)
-     return
-end subroutine clearcomment
+  subroutine clearcomment(str,id)
+    implicit none
+    character(len=*),intent(inout) :: str
+    character(len=*),intent(in) :: id
+    character(len=:),allocatable :: atmp
+    integer :: k
+    atmp = str
+    k = index(str,id)
+    if (k == 1) then
+      atmp = ''
+    else if (k > 0) then
+      atmp = str(1:k-1)
+    end if
+    str = trim(atmp)
+    deallocate (atmp)
+    return
+  end subroutine clearcomment
 
-
+!========================================================================================!
 !========================================================================================!
 end module filemod
Index: src/rigidconf/reconstruct.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht, Christopher Zurek, Christoph Bannwarth\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!\n! Routines were adapted from the xtb code (github.com/grimme-lab/xtb)\n! under the Open-source software LGPL-3.0 Licencse.\n!================================================================================!\n\n!========================================================================================!\n!========================================================================================!\nsubroutine construct_new_zmat(nat,zmat,combi,ndieder,dvalues,dstep,ztod,zmat_new)\n!************************************************************\n!* Given a reference zmatrix and information about\n!* dihedral angles, this routine constructs a new zmatrix\n!*\n!* Input:\n!*    zmat,ndieder,dvalues,ztod,dstep,combi\n!* \n!* Output: \n!*    zmat_new\n!*   \n!************************************************************\n  use crest_parameters\n  use geo\n  implicit none\n  !> INPUT\n  integer,intent(in)  :: nat\n  real(wp),intent(in) :: zmat(3,nat)\n  integer,intent(in)  :: ndieder\n  integer(int8),intent(in) :: combi( ndieder )\n  integer,intent(in)  :: dvalues( ndieder )\n  real(wp),intent(in) :: dstep( ndieder )\n  integer,intent(in)  :: ztod( nat ) \n  !> OUTPUT\n  real(wp),intent(out) :: zmat_new(3,nat)\n  !> LOCAL\n  integer :: V,i,j,k,l,m\n  real(wp) :: xref, xnew\n!========================================================================================!\n\n  zmat_new(:,:) = zmat(:,:) \n  do i=1,ndieder\n    do j=1,nat\n       if(ztod(j) == i)then\n         xref = zmat(3,j)+((float(combi(i))-1.0_wp)*dstep(i))\n         xnew = angleshift(xref)\n         zmat_new(3,j) = xnew\n       endif\n    enddo\n  enddo\n\n  return\nend subroutine construct_new_zmat\n!========================================================================================!\n!========================================================================================!\nsubroutine reconstruct_zmat_to_mol(nat,at,zmat,na,nb,nc,mol)\n   use crest_parameters\n   use strucrd\n   use INTERNALS_mod, only: GMETRY2\n   implicit none\n   !> INPUT\n   integer,intent(in)  :: nat\n   integer,intent(in)  :: at(nat)\n   real(wp),intent(in) :: zmat(3,nat)\n   integer,intent(in)  :: na(nat),nb(nat),nc(nat)\n   !> OUTPUT\n   type(coord),intent(out) :: mol\n   \n   call mol%deallocate() \n   allocate(mol%at(nat))\n   allocate(mol%xyz(3,nat)) \n   mol%nat = nat\n   mol%at = at\n   call  GMETRY2(nat,zmat,mol%xyz,na,nb,nc)\nend subroutine reconstruct_zmat_to_mol\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/rigidconf/reconstruct.f90 b/src/rigidconf/reconstruct.f90
--- a/src/rigidconf/reconstruct.f90	
+++ b/src/rigidconf/reconstruct.f90	
@@ -29,10 +29,10 @@
 !*
 !* Input:
 !*    zmat,ndieder,dvalues,ztod,dstep,combi
-!* 
-!* Output: 
+!*
+!* Output:
 !*    zmat_new
-!*   
+!*
 !************************************************************
   use crest_parameters
   use geo
@@ -41,52 +41,50 @@
   integer,intent(in)  :: nat
   real(wp),intent(in) :: zmat(3,nat)
   integer,intent(in)  :: ndieder
-  integer(int8),intent(in) :: combi( ndieder )
-  integer,intent(in)  :: dvalues( ndieder )
-  real(wp),intent(in) :: dstep( ndieder )
-  integer,intent(in)  :: ztod( nat ) 
+  integer(int8),intent(in) :: combi(ndieder)
+  integer,intent(in)  :: dvalues(ndieder)
+  real(wp),intent(in) :: dstep(ndieder)
+  integer,intent(in)  :: ztod(nat)
   !> OUTPUT
   real(wp),intent(out) :: zmat_new(3,nat)
   !> LOCAL
   integer :: V,i,j,k,l,m
-  real(wp) :: xref, xnew
+  real(wp) :: xref,xnew
 !========================================================================================!
 
-  zmat_new(:,:) = zmat(:,:) 
-  do i=1,ndieder
-    do j=1,nat
-       if(ztod(j) == i)then
-         xref = zmat(3,j)+((float(combi(i))-1.0_wp)*dstep(i))
-         xnew = angleshift(xref)
-         zmat_new(3,j) = xnew
-       endif
-    enddo
-  enddo
+  zmat_new(:,:) = zmat(:,:)
+  do i = 1,ndieder
+    do j = 1,nat
+      if (ztod(j) == i) then
+        xref = zmat(3,j)+((float(combi(i))-1.0_wp)*dstep(i))
+        xnew = angleshift(xref)
+        zmat_new(3,j) = xnew
+      end if
+    end do
+  end do
 
   return
 end subroutine construct_new_zmat
 !========================================================================================!
 !========================================================================================!
 subroutine reconstruct_zmat_to_mol(nat,at,zmat,na,nb,nc,mol)
-   use crest_parameters
-   use strucrd
-   use INTERNALS_mod, only: GMETRY2
-   implicit none
-   !> INPUT
-   integer,intent(in)  :: nat
-   integer,intent(in)  :: at(nat)
-   real(wp),intent(in) :: zmat(3,nat)
-   integer,intent(in)  :: na(nat),nb(nat),nc(nat)
-   !> OUTPUT
-   type(coord),intent(out) :: mol
-   
-   call mol%deallocate() 
-   allocate(mol%at(nat))
-   allocate(mol%xyz(3,nat)) 
-   mol%nat = nat
-   mol%at = at
-   call  GMETRY2(nat,zmat,mol%xyz,na,nb,nc)
+  use crest_parameters
+  use strucrd
+  use INTERNALS_mod,only:GMETRY2
+  implicit none
+  !> INPUT
+  integer,intent(in)  :: nat
+  integer,intent(in)  :: at(nat)
+  real(wp),intent(in) :: zmat(3,nat)
+  integer,intent(in)  :: na(nat),nb(nat),nc(nat)
+  !> OUTPUT
+  type(coord),intent(out) :: mol
+
+  call mol%deallocate()
+  allocate (mol%at(nat))
+  allocate (mol%xyz(3,nat))
+  mol%nat = nat
+  mol%at = at
+  call GMETRY2(nat,zmat,mol%xyz,na,nb,nc)
 end subroutine reconstruct_zmat_to_mol
 
-
-
Index: src/rigidconf/rigidconf.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht, Christopher Zurek, Christoph Bannwarth\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!\n! Routines were adapted from the xtb code (github.com/grimme-lab/xtb)\n! under the Open-source software LGPL-3.0 Licencse.\n!================================================================================!\n\n!========================================================================================!\n!========================================================================================!\nsubroutine crest_rigidconf(env,tim)\n!************************************************************\n!* Standalone runtype for conformer generation\n!* based on chemoinformatic principles.\n!*\n!* Input:\n!*    env  - CREST's systemdata\n!*    tim  - CREST's timer object\n!*\n!************************************************************\n  use crest_parameters\n  use crest_data\n  use strucrd\n  implicit none\n  !> INPUT/OUTPUT\n  type(systemdata),intent(inout) :: env\n  type(timer),intent(inout)      :: tim\n  !> LOCAL \n  type(coord) :: start_mol\n\n\n!========================================================================================!\n  call this_header()\n  call tim%start(14,'rule-based conf.')\n\n!>--- some calculation info should be printed out at this point. TODO\n\n!========================================================================================!\n!>--- get structure from reference\n  call env%ref%to(start_mol)\n  write (stdout,*)\n  call smallhead('Input structure:')\n  call start_mol % append(stdout)\n  write (stdout,*)   \n\n!========================================================================================!\n!>--- pass the structure to the desired algorithm\n  select case( env%rigidconf_algo ) \n  !case ( 1 ) !> \"genetic crossing\"-type algo\n\n  !  \n\n  case default !> straight-forward generation (\"tree\"-type algo)\n\n    call rigidconf_tree(env,start_mol)\n\n  end select\n\n!========================================================================================!\n  call tim%stop(14)\n  return\n!========================================================================================!\n  contains\n!========================================================================================!\n  subroutine this_header\n     implicit none\n      write(stdout,'(/)')\n      write(stdout,'(7x,\"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\")')\n      write(stdout,'(7x,\"┃          R I G I D C O N F           ┃ \")')\n      write(stdout,'(7x,\"┃     (name is work-in-progress)       ┃ \")')\n      !write(stdout,'(7x,\"┃               R i C o                ┃\")')\n      !write(stdout,'(7x,\"┃              ConfAcc                 ┃\")')\n      write(stdout,'(7x,\"┃    rule-based conformer generator    ┃\")')\n      write(stdout,'(7x,\"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\")')\n      write(stdout,'(12x,\"C.Zurek, C.Bannwarth, P.Pracht\")')\n      write(stdout,*)\n  end subroutine this_header\nend subroutine crest_rigidconf\n!========================================================================================!\n!========================================================================================!\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/rigidconf/rigidconf.f90 b/src/rigidconf/rigidconf.f90
--- a/src/rigidconf/rigidconf.f90	
+++ b/src/rigidconf/rigidconf.f90	
@@ -39,13 +39,12 @@
   !> INPUT/OUTPUT
   type(systemdata),intent(inout) :: env
   type(timer),intent(inout)      :: tim
-  !> LOCAL 
+  !> LOCAL
   type(coord) :: start_mol
 
-
 !========================================================================================!
   call this_header()
-  call tim%start(14,'rule-based conf.')
+  call tim%start(14,'rule-based isomer generation')
 
 !>--- some calculation info should be printed out at this point. TODO
 
@@ -54,15 +53,15 @@
   call env%ref%to(start_mol)
   write (stdout,*)
   call smallhead('Input structure:')
-  call start_mol % append(stdout)
-  write (stdout,*)   
+  call start_mol%append(stdout)
+  write (stdout,*)
 
 !========================================================================================!
 !>--- pass the structure to the desired algorithm
-  select case( env%rigidconf_algo ) 
-  !case ( 1 ) !> "genetic crossing"-type algo
+  select case (env%rigidconf_algo)
+    !case ( 1 ) !> "genetic crossing"-type algo
 
-  !  
+    !
 
   case default !> straight-forward generation ("tree"-type algo)
 
@@ -74,20 +73,20 @@
   call tim%stop(14)
   return
 !========================================================================================!
-  contains
+contains
 !========================================================================================!
   subroutine this_header
-     implicit none
-      write(stdout,'(/)')
-      write(stdout,'(7x,"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓")')
-      write(stdout,'(7x,"┃          R I G I D C O N F           ┃ ")')
-      write(stdout,'(7x,"┃     (name is work-in-progress)       ┃ ")')
-      !write(stdout,'(7x,"┃               R i C o                ┃")')
-      !write(stdout,'(7x,"┃              ConfAcc                 ┃")')
-      write(stdout,'(7x,"┃    rule-based conformer generator    ┃")')
-      write(stdout,'(7x,"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛")')
-      write(stdout,'(12x,"C.Zurek, C.Bannwarth, P.Pracht")')
-      write(stdout,*)
+    implicit none
+    write (stdout,'(/)')
+    write (stdout,'(7x,"┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓")')
+    write (stdout,'(7x,"┃          R I G I D C O N F           ┃ ")')
+    write (stdout,'(7x,"┃     (name is work-in-progress)       ┃ ")')
+    !write(stdout,'(7x,"┃               R i C o                ┃")')
+    !write(stdout,'(7x,"┃              ConfAcc                 ┃")')
+    write (stdout,'(7x,"┃    rule-based conformer generator    ┃")')
+    write (stdout,'(7x,"┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛")')
+    !write(stdout,'(12x,"C.Zurek, C.Bannwarth, P.Pracht")')
+    !write(stdout,*)
   end subroutine this_header
 end subroutine crest_rigidconf
 !========================================================================================!
Index: src/optimize/optimize_maths.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!\n! Routines were adapted from the xtb code (github.com/grimme-lab/xtb)\n! under the Open-source software LGPL-3.0 Licencse.\n!================================================================================!\n\n!> Implementation of linear algebra & co. needed for optimization routines\nmodule optimize_maths\n  use iso_fortran_env,only:wp => real64,sp => real32\n  implicit none\n  private\n\n  public :: trproj\n  public :: detrotra8\n  public :: solver_sdavidson\n  public :: solver_sspevx\n  public :: solver_ssyevx\n\ncontains\n!========================================================================================!\n  subroutine detrotra8(linear,n,xyz,h,eig)\n    implicit none\n    integer,intent(in)     :: n\n    real(wp),intent(in)    :: xyz(3,n)    !> values from projected Lindh diag\n    real(wp),intent(in)    :: h(3 * n,3 * n)  !> values from projected Lindh diag\n    real(wp),intent(inout) :: eig(3 * n)    !> eigenvectors from projected Lindh diag\n    logical,intent(in)     :: linear\n    integer               :: i,j,k,kk,ii,nn,n3,nend\n    integer,allocatable   :: ind(:)\n    real(wp),allocatable  :: tmp(:,:)\n    real(wp),allocatable  :: e(:)\n    real(wp)              :: a0,b0,c0\n\n    n3 = 3 * n\n    allocate (tmp(3,n),e(n3),ind(n3))\n    nn = 0\n    do ii = 1,n3\n      if (eig(ii) .gt. 0.05_wp) cycle  !> only lowest checked\n      kk = 0\n      do j = 1,n\n        do k = 1,3\n          kk = kk + 1\n          tmp(k,j) = xyz(k,j) + h(kk,ii) !> distort along mode ii\n        end do\n      end do\n      c0 = 0            !> compared all interatomic distances of original and distortet geom.\n      do i = 2,n\n        do j = 1,i - 1\n          a0 = sqrt((xyz(1,i) - xyz(1,j))**2 + (xyz(2,i) - xyz(2,j))**2 + (xyz(3,i) - xyz(3,j))**2)\n          b0 = sqrt((tmp(1,i) - tmp(1,j))**2 + (tmp(2,i) - tmp(2,j))**2 + (tmp(3,i) - tmp(3,j))**2)\n          c0 = c0 + (a0 - b0)**2\n        end do\n      end do\n      nn = nn + 1\n      e(nn) = sqrt(c0 / n) * abs(eig(ii))  !> weight by Lindh eigenvalue\n      ind(nn) = nn\n    end do\n\n    call detrotra_qsort(e,1,nn,ind)   !> sort\n\n    nend = 6\n    if (linear) nend = 5\n\n    do i = 1,nend\n      eig(ind(i)) = 0.0_wp  !> identifier for rot/tra\n    end do\n    deallocate(ind,e,tmp) \n    return\n  contains\n    recursive subroutine detrotra_qsort(a,first,last,ind)\n      implicit none\n      real(wp) :: a(*),x,t\n      integer  :: ind(*)\n      integer  :: first,last\n      integer  :: i,j,ii\n      x = a((first + last) / 2)\n      i = first\n      j = last\n      do\n        do while (a(i) < x)\n          i = i + 1\n        end do\n        do while (x < a(j))\n          j = j - 1\n        end do\n        if (i >= j) exit\n        t = a(i); a(i) = a(j); a(j) = t\n        ii = ind(i); ind(i) = ind(j); ind(j) = ii\n        i = i + 1\n        j = j - 1\n      end do\n      if (first < i - 1) call qsort(a,first,i - 1,ind)\n      if (j + 1 < last) call qsort(a,j + 1,last,ind)\n    end subroutine detrotra_qsort\n  end subroutine detrotra8\n\n!========================================================================================!\n!>  subroutine trproj drives projection of hessian out of the\n!>  space of translational and rotational motions:\n!>  first get xyz c.m.; second get transl. and rot. projection matrix\n!>\n!>  get center of mass coordinates with unit mass\n!>\n!> Input\n!>   natoms  = number of atoms\n!>   nat3    = 3*natoms\n!>   xyz     = cartesian coordinates\n!>   ldebug  = debug flag = .true. for debugging\n!>\n!> Ouput\n!>       xyzucm  = temporary c.m. coordinates\n!>\n!>       hess    = projected hessian out of space of transl. and rot.\n!>                 motion\n!-----------------------------------------------------------------\n  subroutine trproj(natoms,nat3,xyz,hess,ldebug,nmode,mode,ndim)\n    implicit none\n    !> Input\n    logical,intent(in) :: ldebug\n    integer,intent(in) :: natoms,nat3,nmode,ndim\n    real(wp),dimension(3,natoms) :: xyz\n    real(wp),dimension(nat3,ndim) :: mode\n    !> Ouput\n    real(wp),dimension(nat3*(nat3 + 1)/2) :: hess\n    !> Local\n    integer :: i\n    real(wp) :: xm,ym,zm\n    real(wp),dimension(3,natoms) :: xyzucm\n\n    !> temporary coordinates, c.m. shifted\n    xyzucm(:,:) = xyz(:,:)\n    xm = 0.0_wp\n    ym = 0.0_wp\n    zm = 0.0_wp\n    do i = 1,natoms\n      xm = xm + xyzucm(1,i)\n      ym = ym + xyzucm(2,i)\n      zm = zm + xyzucm(3,i)\n    end do\n    xm = xm / natoms\n    ym = ym / natoms\n    zm = zm / natoms\n    do i = 1,natoms\n      xyzucm(1,i) = xyzucm(1,i) - xm\n      xyzucm(2,i) = xyzucm(2,i) - ym\n      xyzucm(3,i) = xyzucm(3,i) - zm\n    end do\n\n    !> get translational and rotational projection matrix\n    call gtrprojm(natoms,nat3,xyzucm,hess,ldebug,nmode,mode,ndim)\n\n    return\n  end subroutine trproj\n\n!========================================================================================!\n!> calculating the translational-rotational projection matrix\n!>\n!> Input\n!>   natoms  = number of atoms\n!>   nat3    = 3*natoms\n!>   xyzucm  = coords c.m. from gxyzucm.f\n!>   hess    = hessian\n!>   ldebug  = debug flag = .true. for debugging\n!>\n!> Ouput\n!>   fmat    = F-matrix with translational and rotational vectors\n!>   pmat    = projection matrix P = (1-FFt)\n!>   hess    = projected hessian\n!-----------------------------------------------------------------\n  subroutine gtrprojm(natoms,nat3,xyzucm,hess,ldebug,nmode,mode,ndim)\n    implicit none\n    !> Input\n    logical,intent(in) :: ldebug\n    integer,intent(in) :: natoms,nat3,nmode,ndim\n    real(wp),dimension(3,natoms) :: xyzucm\n    real(wp),dimension(nat3,ndim) :: mode\n    !> Ouput\n    real(wp),dimension(nat3*(nat3 + 1)/2) :: hess\n    !> Local\n    integer :: i,ii,iii\n    real(wp),allocatable :: fmat(:,:)\n    integer :: nprj\n\n    nprj = 6\n    if (nmode .gt. 0) nprj = nprj + nmode\n    !if (nmode .lt. 0) nprj = nprj + fixset%n * 3\n    allocate (fmat(nat3,nprj))\n    fmat(:,:) = 0.0_wp\n\n    if (nmode .ge. 0) then\n      do i = 1,natoms\n        !> translation vectors\n        do ii = 1,3\n          fmat(3 * (i - 1) + ii,ii) = 1.0_wp\n        end do\n        !> rotational vectors\n        fmat(3 * (i - 1) + 1,4) = 0.0_wp\n        fmat(3 * (i - 1) + 2,4) = -xyzucm(3,i)\n        fmat(3 * (i - 1) + 3,4) = xyzucm(2,i)\n        fmat(3 * (i - 1) + 1,5) = xyzucm(3,i)\n        fmat(3 * (i - 1) + 2,5) = 0.0_wp\n        fmat(3 * (i - 1) + 3,5) = -xyzucm(1,i)\n        fmat(3 * (i - 1) + 1,6) = -xyzucm(2,i)\n        fmat(3 * (i - 1) + 2,6) = xyzucm(1,i)\n        fmat(3 * (i - 1) + 3,6) = 0.0_wp\n      end do\n    end if\n\n    !> NMF\n    if (nmode .gt. 0) then\n      do i = 1,nmode\n        fmat(1:nat3,6 + i) = mode(1:nat3,i)\n      end do\n    end if\n    !!> exact fixing\n    !if (nmode .lt. 0) then\n    !  do i = 1,natoms\n    !    !> rotational vectors\n    !    fmat(3 * (i - 1) + 1,1) = 0.0_wp\n    !    fmat(3 * (i - 1) + 2,1) = -xyzucm(3,i)\n    !    fmat(3 * (i - 1) + 3,1) = xyzucm(2,i)\n    !    fmat(3 * (i - 1) + 1,2) = xyzucm(3,i)\n    !    fmat(3 * (i - 1) + 2,2) = 0.0_wp\n    !    fmat(3 * (i - 1) + 3,2) = -xyzucm(1,i)\n    !    fmat(3 * (i - 1) + 1,3) = -xyzucm(2,i)\n    !    fmat(3 * (i - 1) + 2,3) = xyzucm(1,i)\n    !    fmat(3 * (i - 1) + 3,3) = 0.0_wp\n    !  end do\n    !  do i = 1,fixset%n\n    !    iii = fixset%atoms(i)\n    !    do ii = 1,3\n    !      fmat(3 * (iii - 1) + ii,3 + (i - 1) * 3 + ii) = 1.0_wp\n    !    end do\n    !  end do\n    !end if\n\n    if (ldebug) then\n      write (*,'(a)')\n      write (*,'(a)') ' Basis vectors before orthonormalization'\n      write (*,'(3e22.14)') fmat\n    end if\n\n    !> do Gramm-Schmidt orthogonalization\n    call dblckmgs(nat3,nprj,nat3,fmat)\n\n    !> do projection\n    call dsyprj(nat3,nprj,fmat,nat3,hess)\n\n    deallocate (fmat)\n    return\n  end subroutine gtrprojm\n\n!========================================================================================!\n!> expand trigonal matrix b to full matrix a\n!> a and b may refer to the same address\n!----------------------------------------------\n  subroutine dhtosq(n,a,b)\n    implicit none\n    integer,intent(in)  :: n\n    real(wp),intent(out) :: a(n,n)\n    real(wp),intent(in)  :: b(n * (n + 1) / 2)\n    integer :: i,j,ioff\n\n    do i = n,1,-1\n      ioff = i * (i - 1) / 2\n      do j = i,1,-1\n        a(j,i) = b(ioff + j)\n      end do\n    end do\n\n    do i = 1,n\n      do j = 1,i - 1\n        a(i,j) = a(j,i)\n      end do\n    end do\n    return\n  end subroutine dhtosq\n\n!========================================================================================!\n!> subroutine dsyprj\n!> Performs projection of a real symmetric matrix asym packed in an\n!> upper triangular form:\n!>\n!>     asym = (1 - bmat*bmat')*asym*(1 - bmat*bmat')\n!>\n!> where (1 - bmat*bmat') is a projector constructed from bmat\n!> The matrix asym is overwritten on output; bmat is left unchanged.\n!> Operation count is proportional to n*n*m\n!>\n!> Input/Output:\n!> nbdim - First dimension of bmat as declared in the calling routine\n!> m     - Number of columns in the matrix bmat\n!> bmat  - n*m matrix used to build projector\n!> n     - Dimension of the matrix asym\n!> asym  - Symmetric matrix in packed upper triangular form\n!-----------------------------------------------------------------\n  subroutine dsyprj(nbdim,m,bmat,n,asym)\n    implicit none\n!> Input/Output:\n    integer,intent(in)    :: nbdim,m,n\n    real(wp),intent(in)    :: bmat(nbdim,m)\n    real(wp),intent(inout) :: asym(n * (n + 1) / 2)\n!> Local:\n    integer  :: i,j,ij\n    real(wp),allocatable :: scrb(:,:)\n    real(wp),allocatable :: scra(:,:)\n!> external BLAS routines\n    external :: dsymm\n    external :: dgemm\n!-----------------------------------------------------------------\n    allocate (scrb(n,m),scra(n,n))\n\n!> Expand trigonal matrix asym to full matrix on scra\n    call dhtosq(n,scra,asym)\n!> Calculate scrb = asym*bmat (BLAS)\n    call dsymm('l','u',n,m,1.0_wp,scra,n,bmat,nbdim,0.0_wp,scrb,n)\n!> Calculate scra = scrb*bmat' (BLAS)\n    call dgemm('n','t',n,n,m,1.0_wp,scrb,n,bmat,nbdim,0.0_wp,scra,n)\n\n!> Calculate asym = asym - scra - scra'\n    do i = 1,n\n      do j = 1,i\n        ij = i * (i - 1) / 2 + j\n        asym(ij) = asym(ij) - scra(i,j) - scra(j,i)\n      end do\n    end do\n\n!> Calculate scrb' = scra'*bmat (BLAS)\n    call dgemm('t','n',n,m,n,1.0_wp,scra,n,bmat,nbdim,0.0_wp,scrb,n)\n!> Calculate scra = bmat*scrb' (BLAS)\n    call dgemm('n','t',n,n,m,1.0_wp,bmat,nbdim,scrb,n,0.0_wp,scra,n)\n\n!> Calculate asym = asym + scra\n    do i = 1,n\n      do j = 1,i\n        ij = i * (i - 1) / 2 + j\n        asym(ij) = asym(ij) + scra(i,j)\n      end do\n    end do\n\n    deallocate (scra,scrb)\n    return\n  end subroutine dsyprj\n\n!========================================================================================!\n! subroutine dblckmgs\n! Subroutine performs modified Gramm-Schmidt orthonormalization of a\n! real matrix. Orthonormalization is done in-place, so the darray is\n! overwritten on exit. Linearly dependent vectors are set to zero.\n!\n! Input:\n! m      - Number of rows in the matrix darray\n! n      - Number of columns in the matrix darray\n! ndim   - First array dimension as declared in the calling routine\n! darray - Array to be orthonormalized\n!\n! Output:\n! darray - Orthonormalized array\n!-----------------------------------------------------------------\n  subroutine dblckmgs(m,n,ndim,darray)\n    implicit none\n!> Input/Output:\n    integer,intent(in) :: m,n,ndim\n    real(wp),dimension(ndim,n),intent(out) :: darray\n!> Local:\n    integer :: ii,jj,kk,ll,ibsize,nblcks,istrt,jstrt,iend,ncol,ierr\n    real(wp) :: tmp\n    real(wp),dimension(:,:),allocatable :: smat\n    real(wp) :: thr\n!> external BLAS routines\n    external :: dgemm\n    real(wp),external :: ddot\n    external :: dscal\n    external :: daxpy\n!-----------------------------------------------------------------\n    thr = epsilon(1.0_wp) !Threshold for zero vectors\n!-----------------------------------------------------------------\n! Block size optimized for Athlon 1200 MHz with 2.0GB memory for\n! matrices up to 5000x5000\n    ibsize = 60\n!-----------------------------------------------------------------\n\n!-----------------------------------------------------------------\n! Allocate overlap matrix\n!-----------------------------------------------------------------\n    allocate (smat(ibsize,ibsize))\n\n!-----------------------------------------------------------------\n! Calculate the number of blocks\n!-----------------------------------------------------------------\n    nblcks = (n + ibsize - 1) / ibsize\n    ibsize = min(n,ibsize)\n\n!-----------------------------------------------------------------\n! Orthogonalize the first block using modified Schmidt\n!-----------------------------------------------------------------\n    do ii = 1,ibsize\n      !> Linear dependence check by\n      !> dot product of the column vector (BLAS)\n      tmp = ddot(m,darray(:,ii),1,darray(:,ii),1)\n      if (tmp < thr) then\n        darray(1:m,ii) = 0.0_wp\n        cycle\n      end if\n      !> scale column vectors\n      tmp = 1.0_wp / sqrt(tmp)\n      call dscal(m,tmp,darray(:,ii),1)\n      do jj = ii + 1,ibsize\n        tmp = ddot(m,darray(:,ii),1,darray(:,jj),1)\n        call daxpy(m,-tmp,darray(:,ii),1,darray(:,jj),1)\n      end do\n    end do\n!-----------------------------------------------------------------\n! Loop over remaining blocks\n!-----------------------------------------------------------------\n    do ii = 1,nblcks - 1\n!> Initial and final column and number of columns in the block ii+1\n      istrt = ii * ibsize + 1\n      iend = (ii + 1) * ibsize\n      iend = min(n,iend)\n      ncol = iend - istrt + 1\n!> Orthogonalize the block ii+1 against the previous ones\n      do jj = 1,ii\n!> Initial index of the block jj\n        jstrt = (jj - 1) * ibsize + 1\n        call dgemm('t','n',ibsize,ncol,m,1.0_wp,darray(1,jstrt), &\n        &          ndim,darray(1,istrt),ndim,0.0_wp,smat,ibsize)\n        call dgemm('n','n',m,ncol,ibsize,-1.0_wp,darray(1,jstrt), &\n        &          ndim,smat,ibsize,1.0_wp,darray(1,istrt),ndim)\n      end do\n\n!> Othogonalize vectors on the block ii+1 among themselves using modified Schmidt\n      do kk = istrt,iend\n        tmp = ddot(m,darray(:,kk),1,darray(:,kk),1)\n!> Linear dependence case\n        if (tmp < thr) then\n          darray(1:m,kk) = 0.0_wp\n          cycle\n        end if\n        tmp = 1.0_wp / sqrt(tmp)\n        call dscal(m,tmp,darray(:,kk),1)\n        do ll = kk + 1,iend\n          tmp = ddot(m,darray(:,kk),1,darray(:,ll),1)\n          call daxpy(m,-tmp,darray(:,kk),1,darray(:,ll),1)\n        end do\n      end do\n    end do\n\n!> Clean up and return\n    deallocate (smat)\n    return\n  end subroutine dblckmgs\n\n!========================================================================================!\n!> subroutine solver_sdavidson\n!>\n!> Davidson method to iteratively diagonalize\n!> a subspace of a matrix to provide its first\n!> few lowest (or highest) eigenvalues.\n!> In this version it is hard-coded to the lowest eigenvalue.\n!>\n!> Input:\n!>      n -  dimension of the matrix to be diagonalized\n!>  crite - eigenvalue convergence threshold\n!>     Hp - the matrix to be diagonalized in packed form \n!>      C - eigenvevtor(s)\n!>     pr - print statement\n!> Output:   \n!>      e - eigenvalues\n!>   fail - exit status boolean\n!>\n!> Note the SINGLE PRECISION!\n!>---------------------------------------\n  subroutine solver_sdavidson(n,crite,Hp,C,e,fail,pr)\n    implicit none\n    logical,intent(in) :: pr\n    logical,parameter :: ini = .false.\n    integer :: n       ! dimension\n    integer,parameter :: nr = 1\n    real(sp) :: crite   ! eigenvalue convergence threshold\n    real(sp) :: Hp(n * (n + 1) / 2)  ! matrix to be diagonalized\n    real(sp) :: C(n,nr) ! eigenvectors\n    real(sp) :: e(nr)   ! eigenvalues\n    logical,intent(out) :: fail\n    !> Local\n    integer,parameter :: maxiter = 100        ! maximum # of iterations\n    integer :: iter,ineue(1),janf!,lun1,lun2\n    integer :: iideks(maxiter),idum,j,jalt,ilauf,jneu\n    integer :: l1,l2,k,LWORK,LIWORK,INFO,i,ien,ialt,memlun2\n    integer,allocatable :: iwork(:)\n    logical :: lconf\n    real(sp),allocatable :: lun1(:,:),lun2(:,:)\n    integer,parameter :: initial_dyn_array_size = 10\n    real(sp) :: valn(1),uim,s,denerg\n    real(sp),allocatable :: adiag(:),vecf1(:),vecf2(:),w(:)\n    real(sp),allocatable :: Uaug(:,:),d(:),aux(:)\n    real(sp),allocatable :: AB(:,:),av(:),tmpav(:,:)\n    !> LAPACK & BLAS\n    external :: sspmv\n    real(sp),external :: sdot\n    external :: ssyevd\n    external :: saxpy\n\n    fail = .true.\n\n    if (pr) then\n      write (*,'(/,10x,''******************************************'')')\n      write (*,'(10x,''*            multi-root davidson (R4)    *'')')\n      write (*,'(10x,''******************************************'',/)')\n      write (*,*) 'dim ',n,' # roots ',1\n    end if\n\n    allocate (adiag(n),vecf1(n),vecf2(n),w(n),av(maxiter * (maxiter + 1) / 2))\n\n    allocate (lun1(n,initial_dyn_array_size),lun2(n,initial_dyn_array_size), &\n       &     source=0.0_sp)\n\n    !> H * C for initialization\n    call smwrite(n,lun1,C(:,1),1)\n    call sspmv('u',n,1.0_sp,Hp,C(:,1),1,0.0_sp,vecf2,1)\n    call smwrite(n,lun2,vecf2,1)\n\n    !> make array iideks\n    iideks(1) = 1\n    do idum = 2,maxiter\n      iideks(idum) = iideks(idum - 1) + idum\n    end do\n    valn = 0\n    lconf = .false.\n    e = 0\n    do i = 1,n\n      adiag(i) = HP(i * (i + 1) / 2)\n    end do\n    av(1) = sdot(n,C(:,1),1,vecf2,1)\n\n!>--------------------------------\n!> Davidson algo loop\n!>--------------------------------\n    j = 1\n    DAVIDSON :do iter = 1,maxiter - 1\n      lwork = 1 + 6 * j + 2 * j**2\n      liwork = 8 * j\n      allocate (Uaug(j,j),d(j),iwork(liwork),aux(lwork))\n      k = 0\n      do l1 = 1,j\n        do l2 = 1,l1\n          k = k + 1\n          Uaug(l2,l1) = av(k)\n          Uaug(l1,l2) = av(k)\n        end do\n      end do\n      call ssyevd('V','U',j,Uaug,j,d,aux,LWORK,IWORK,LIWORK,INFO)\n      valn(1:1) = d(1:1)\n\n      !> create and save vectors on vecf1\n      vecf1 = 0.0_sp\n      do i = 1,j\n        call smread(n,lun1,w,i)\n        uim = Uaug(i,1)\n        call saxpy(n,uim,w,1,vecf1,1)\n      end do\n\n      !> calculate E*bi\n      vecf2 = -valn(1) * vecf1\n      !> calculate h*bi-e*bi (overwrites vecf2)\n      do i = 1,j\n        call smread(n,lun2,w,i)\n        memlun2 = i\n        uim = Uaug(i,1)\n        call saxpy(n,uim,w,1,vecf2,1)\n      end do\n      deallocate (aux,iwork,d,Uaug)\n      C(1:n,1) = vecf1\n\n      !> calculate (h*bi - e*bi)/(e - haa); (saved as vecf2)\n      vecf1 = vecf2 / (valn(1) - adiag)\n\n      !> check for convergence of Davidson algo\n      denerg = abs(valn(1) - e(1))\n      lconf = denerg .lt. crite\n      if (pr) write (*,*) iter,lconf,denerg,valn(1:1)\n      if (lconf) then\n        if (pr) write (*,*) 'all roots converged'\n        fail = .false.\n        exit DAVIDSON\n      end if\n\n      if (j .gt. 0) then\n        ialt = j\n        !> orthogonalize\n        do jalt = 1,ialt\n          call smread(n,lun1,w,jalt)\n          s = -sdot(n,w,1,vecf1,1)\n          call saxpy(n,s,w,1,vecf1,1)\n        end do\n        !> normalize remaining\n        s = sdot(n,vecf1,1,vecf1,1)\n        if (s .gt. 0.00000001) then\n          s = 1.0_sp / sqrt(s)\n          vecf1 = vecf1 * s\n          ialt = ialt + 1\n          call smwrite(n,lun1,vecf1,jalt)\n        else\n          fail = .false.\n          exit DAVIDSON\n        end if\n      end if\n\n      !> H * C\n      call sspmv('u',n,1.0_sp,Hp,vecf1,1,0.0_sp,vecf2,1)\n      call smwrite(n,lun2,vecf2,memlun2 + 1)\n\n      !> calculate matrix elements for next iteration\n      do jalt = 1,j\n        call smread(n,lun1,w,jalt)\n        ilauf = iideks(j) + jalt\n        av(ilauf) = sdot(n,w,1,vecf2,1)\n        ilauf = ilauf + 1 + j\n      end do\n      av(iideks(j + 1)) = sdot(n,vecf2,1,vecf1,1)\n      !> increase expansion space and iterate further\n      e = valn\n      j = j + 1\n    end do DAVIDSON\n!>--------------------------------\n!> end algo loop\n!>--------------------------------\n    if (pr .and. fail) write (*,*) 'Warning: davidson not properly converged'\n\n    deallocate (adiag,vecf1,vecf2,w,av,lun1,lun2)\n    return\n  contains\n    !> write array v onto iwo\n    subroutine smwrite(n,iwo,v,irec)\n      implicit none\n      real(sp),intent(inout),allocatable :: iwo(:,:)\n      real(sp),intent(in)  :: v(n)\n      integer,intent(in)  :: n,irec\n      real(sp),allocatable :: tmp(:,:)\n      integer :: d2,dn\n      d2 = size(iwo,2)\n      if (irec > d2) then\n        dn = d2 + d2 / 2 + 1\n        allocate (tmp(n,dn))\n        tmp(:,:d2) = iwo\n        deallocate (iwo)\n        call move_alloc(tmp,iwo)\n      end if\n      iwo(:,irec) = v\n      return\n    end subroutine smwrite\n    !> read array v from iwo\n    subroutine smread(n,iwo,v,irec)\n      implicit none\n      real(sp),intent(out) :: v(n)\n      real(sp),intent(in)  :: iwo(:,:)\n      integer,intent(in)  :: n,irec\n      v = iwo(:,irec)\n      return\n    end subroutine smread\n  end subroutine solver_sdavidson\n!========================================================================================!\n!> subroutine solver_ssyevx\n!> Wrapper for LAPACK's ssyevx routine:\n!> SSYEVD computes all eigenvalues and eigenvectors of a\n!> real symmetric matrix A using a divide and conquer algorithm.\n!>---------------------------------------------------------------\n    subroutine solver_ssyevx(n,thr,A,U,e,fail)\n      implicit none\n      integer,intent(in) :: n\n      real(sp),intent(in) :: thr\n      real(sp),intent(inout) :: A(:,:)\n      real(sp),intent(inout) :: U(:,:)\n      real(sp),intent(inout) :: e(:)\n      logical,intent(out) :: fail\n      integer :: i,j,k\n      integer :: lwork,info\n      real(sp),allocatable :: work(:)\n      integer,allocatable :: iwork(:)\n      integer,allocatable :: ifail(:)\n      real(sp) :: dum\n      !> LAPACK\n      external :: ssyevx\n\n      lwork = 1 + 8 * n + n**2\n      allocate (iwork(5 * n),work(lwork),ifail(n))\n      j = 1\n      call ssyevx('V','I','U',n,A,n,dum,dum,j,j,thr, &\n      &           i,e,U,n,work,lwork,iwork,ifail,info)\n      if (info .ne. 0) fail = .true.\n\n      deallocate (iwork,work,ifail)\n    end subroutine solver_ssyevx\n!========================================================================================!\n!> subroutine solver_sspevx\n!> wrapper for LAPACK's sspevx routine:\n!> SSPEVX computes all eigenvalues and eigenvectors of a\n!> real symmetric matrix A in packed storage using a \n!> divide and conquer algorithm.\n!>-------------------------------------------------------\n    subroutine solver_sspevx(n,thr,A,U,e,fail)\n      implicit none\n      integer,intent(in) :: n\n      real(sp),intent(in) :: thr\n      real(sp),intent(inout) :: A(:)\n      real(sp),intent(inout) :: U(:,:)\n      real(sp),intent(inout) :: e(:)\n      logical,intent(out) :: fail\n      integer :: i,j,k\n      integer :: info\n      real(sp),allocatable :: work(:)\n      integer,allocatable :: iwork(:)\n      integer,allocatable :: ifail(:)\n      real(sp) :: dum\n      !> LAPACK\n      external :: sspevx\n      allocate (iwork(5 * n),work(8 * n),ifail(n))\n      j = 1\n      call sspevx('V','I','U',n,A,dum,dum,j,j,thr,i,e,U,n,work,iwork,ifail,info)\n      if (info .ne. 0) fail = .true.\n      deallocate (iwork,work,ifail)\n    end subroutine solver_sspevx\n\n!========================================================================================!\nend module optimize_maths\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/optimize/optimize_maths.f90 b/src/optimize/optimize_maths.f90
--- a/src/optimize/optimize_maths.f90	
+++ b/src/optimize/optimize_maths.f90	
@@ -27,6 +27,10 @@
   private
 
   public :: trproj
+  interface trproj
+    module procedure :: trproj_normal
+    module procedure :: trproj_frozen
+  end interface
   public :: detrotra8
   public :: solver_sdavidson
   public :: solver_sspevx
@@ -129,7 +133,7 @@
 !>       hess    = projected hessian out of space of transl. and rot.
 !>                 motion
 !-----------------------------------------------------------------
-  subroutine trproj(natoms,nat3,xyz,hess,ldebug,nmode,mode,ndim)
+  subroutine trproj_normal(natoms,nat3,xyz,hess,ldebug,nmode,mode,ndim)
     implicit none
     !> Input
     logical,intent(in) :: ldebug
@@ -166,7 +170,7 @@
     call gtrprojm(natoms,nat3,xyzucm,hess,ldebug,nmode,mode,ndim)
 
     return
-  end subroutine trproj
+  end subroutine trproj_normal
 
 !========================================================================================!
 !> calculating the translational-rotational projection matrix
@@ -195,7 +199,7 @@
     !> Local
     integer :: i,ii,iii
     real(wp),allocatable :: fmat(:,:)
-    integer :: nprj
+    integer :: nprj,fnrozen
 
     nprj = 6
     if (nmode .gt. 0) nprj = nprj + nmode
@@ -228,27 +232,6 @@
         fmat(1:nat3,6 + i) = mode(1:nat3,i)
       end do
     end if
-    !!> exact fixing
-    !if (nmode .lt. 0) then
-    !  do i = 1,natoms
-    !    !> rotational vectors
-    !    fmat(3 * (i - 1) + 1,1) = 0.0_wp
-    !    fmat(3 * (i - 1) + 2,1) = -xyzucm(3,i)
-    !    fmat(3 * (i - 1) + 3,1) = xyzucm(2,i)
-    !    fmat(3 * (i - 1) + 1,2) = xyzucm(3,i)
-    !    fmat(3 * (i - 1) + 2,2) = 0.0_wp
-    !    fmat(3 * (i - 1) + 3,2) = -xyzucm(1,i)
-    !    fmat(3 * (i - 1) + 1,3) = -xyzucm(2,i)
-    !    fmat(3 * (i - 1) + 2,3) = xyzucm(1,i)
-    !    fmat(3 * (i - 1) + 3,3) = 0.0_wp
-    !  end do
-    !  do i = 1,fixset%n
-    !    iii = fixset%atoms(i)
-    !    do ii = 1,3
-    !      fmat(3 * (iii - 1) + ii,3 + (i - 1) * 3 + ii) = 1.0_wp
-    !    end do
-    !  end do
-    !end if
 
     if (ldebug) then
       write (*,'(a)')
@@ -266,6 +249,142 @@
     return
   end subroutine gtrprojm
 
+
+!========================================================================================!
+!>  subroutine trproj drives projection of hessian out of the
+!>  space of translational and rotational motions:
+!>  first get xyz c.m.; second get transl. and rot. projection matrix
+!>  This is the frozen atom version
+!>  get center of mass coordinates with unit mass
+!>
+!> Input
+!>   natoms  = number of atoms
+!>   nat3    = 3*natoms
+!>   xyz     = cartesian coordinates
+!>   ldebug  = debug flag = .true. for debugging
+!>   freezelist = an array of booleans that are .true. for frozen atoms
+!>
+!> Ouput
+!>       xyzucm  = temporary c.m. coordinates
+!>
+!>       hess    = projected hessian out of space of transl. and rot.
+!>                 motion
+!-----------------------------------------------------------------
+  subroutine trproj_frozen(natoms,nat3,xyz,hess,ldebug,freezelist)
+    implicit none
+    !> Input
+    logical,intent(in) :: ldebug
+    integer,intent(in) :: natoms,nat3
+    logical,intent(in) :: freezelist(natoms)
+    real(wp),dimension(3,natoms) :: xyz
+    !> Ouput
+    real(wp),dimension(nat3*(nat3 + 1)/2) :: hess
+    !> Local
+    integer :: i
+    real(wp) :: xm,ym,zm
+    real(wp),dimension(3,natoms) :: xyzucm
+
+    !> temporary coordinates, c.m. shifted
+    xyzucm(:,:) = xyz(:,:)
+    xm = 0.0_wp
+    ym = 0.0_wp
+    zm = 0.0_wp
+    do i = 1,natoms
+      xm = xm + xyzucm(1,i)
+      ym = ym + xyzucm(2,i)
+      zm = zm + xyzucm(3,i)
+    end do
+    xm = xm / natoms
+    ym = ym / natoms
+    zm = zm / natoms
+    do i = 1,natoms
+      xyzucm(1,i) = xyzucm(1,i) - xm
+      xyzucm(2,i) = xyzucm(2,i) - ym
+      xyzucm(3,i) = xyzucm(3,i) - zm
+    end do
+
+    !> get translational and rotational projection matrix
+    call gtrprojm_frozen(natoms,nat3,xyzucm,hess,ldebug,freezelist)
+
+    return
+  end subroutine trproj_frozen
+
+!========================================================================================!
+!> calculating the translational-rotational projection matrix
+!> taking into account frozen atoms 
+!> 
+!> Input
+!>   natoms  = number of atoms
+!>   nat3    = 3*natoms
+!>   xyzucm  = coords c.m. from gxyzucm.f
+!>   hess    = hessian
+!>   ldebug  = debug flag = .true. for debugging
+!>
+!> Ouput
+!>   fmat    = F-matrix with translational and rotational vectors
+!>   pmat    = projection matrix P = (1-FFt)
+!>   hess    = projected hessian
+!-----------------------------------------------------------------
+  subroutine gtrprojm_frozen(natoms,nat3,xyzucm,hess,ldebug,freezelist)
+    implicit none
+    !> Input
+    logical,intent(in) :: ldebug
+    integer,intent(in) :: natoms,nat3
+    logical,intent(in) :: freezelist(natoms)
+    real(wp),dimension(3,natoms) :: xyzucm
+    !> Ouput
+    real(wp),dimension(nat3*(nat3 + 1)/2) :: hess
+    !> Local
+    integer :: i,ii,iii,f
+    real(wp),allocatable :: fmat(:,:)
+    integer :: nprj,nfrozen
+   
+    nfrozen = count(freezelist,1)
+    nprj = 6
+    nprj = nprj + nfrozen * 3  !> correct dimension with frozen deg. of freedom
+    allocate (fmat(nat3,nprj))
+    fmat(:,:) = 0.0_wp
+
+    !> exact fixing version
+      do i = 1,natoms
+        !> rotational vectors
+        fmat(3 * (i - 1) + 1,1) = 0.0_wp
+        fmat(3 * (i - 1) + 2,1) = -xyzucm(3,i)
+        fmat(3 * (i - 1) + 3,1) = xyzucm(2,i)
+        fmat(3 * (i - 1) + 1,2) = xyzucm(3,i)
+        fmat(3 * (i - 1) + 2,2) = 0.0_wp
+        fmat(3 * (i - 1) + 3,2) = -xyzucm(1,i)
+        fmat(3 * (i - 1) + 1,3) = -xyzucm(2,i)
+        fmat(3 * (i - 1) + 2,3) = xyzucm(1,i)
+        fmat(3 * (i - 1) + 3,3) = 0.0_wp
+      end do
+      i = 0
+      do f = 1,natoms
+        if(freezelist(f))then
+         i = i + 1
+         iii = f
+         do ii = 1,3
+           fmat(3 * (iii - 1) + ii,3 + (i - 1) * 3 + ii) = 1.0_wp
+         end do
+        endif
+      end do
+
+    if (ldebug) then
+      write (*,'(a)')
+      write (*,'(a)') ' Basis vectors before orthonormalization'
+      write (*,'(3e22.14)') fmat
+    end if
+
+    !> do Gramm-Schmidt orthogonalization
+    call dblckmgs(nat3,nprj,nat3,fmat)
+
+    !> do projection
+    call dsyprj(nat3,nprj,fmat,nat3,hess)
+
+    deallocate (fmat)
+    return
+  end subroutine gtrprojm_frozen
+
 !========================================================================================!
 !> expand trigonal matrix b to full matrix a
 !> a and b may refer to the same address
Index: src/optimize/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nset(dir \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\nlist(APPEND srcs\n  \"${dir}/ancopt.f90\"\n  \"${dir}/hessupdate.f90\"\n  \"${dir}/modelhessian.f90\"\n  \"${dir}/optimize_maths.f90\"\n  \"${dir}/optimize_module.f90\"\n  \"${dir}/type_anc.f90\"\n)\n\nset(srcs ${srcs} PARENT_SCOPE)\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/optimize/CMakeLists.txt b/src/optimize/CMakeLists.txt
--- a/src/optimize/CMakeLists.txt	
+++ b/src/optimize/CMakeLists.txt	
@@ -22,7 +22,7 @@
   "${dir}/modelhessian.f90"
   "${dir}/optimize_maths.f90"
   "${dir}/optimize_module.f90"
-  "${dir}/type_anc.f90"
+  "${dir}/optimize_type.f90"
 )
 
 set(srcs ${srcs} PARENT_SCOPE)
Index: src/optimize/optimize_module.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!\n! Routines were adapted from the xtb code (github.com/grimme-lab/xtb)\n! under the Open-source software LGPL-3.0 Licencse.\n!================================================================================!\n\nmodule optimize_module\n  use iso_fortran_env,only:wp => real64\n  use crest_calculator\n  use strucrd\n  use ancopt_module,only:ancopt\n  implicit none\n\n  real(wp),private,parameter :: autoaa = 0.52917726_wp\n  real(wp),private,parameter :: aatoau = 1.0_wp/autoaa\n\n  public :: optimize_geometry\n\n!========================================================================================!\n!========================================================================================!\ncontains  !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\n  subroutine optimize_geometry(mol,molnew,calc,etot,grd,pr,wr,iostatus)\n    implicit none\n    !> Input\n    type(coord)    :: mol\n    type(calcdata) :: calc\n    logical,intent(in)        :: pr\n    logical,intent(in)        :: wr\n    !> Output\n    type(coord)   :: molnew\n    integer,intent(out)       :: iostatus\n    real(wp),intent(inout)    :: etot\n    real(wp),intent(inout)    :: grd(3,mol%nat)\n\n    iostatus = -1\n    !$omp critical\n    molnew%at = mol%at  !> do not overwrite original geometry\n    molnew%xyz = mol%xyz\n    molnew%nat = mol%nat\n    !$omp end critical\n\n    !> initial singlepoint\n    call engrad(molnew,calc,etot,grd,iostatus)\n\n    !> optimization\n    call ancopt(molnew,calc,etot,grd,pr,wr,iostatus)\n\n    return\n  end subroutine optimize_geometry\n\n!========================================================================================!\nend module optimize_module\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/optimize/optimize_module.f90 b/src/optimize/optimize_module.f90
--- a/src/optimize/optimize_module.f90	
+++ b/src/optimize/optimize_module.f90	
@@ -24,13 +24,14 @@
   use iso_fortran_env,only:wp => real64
   use crest_calculator
   use strucrd
-  use ancopt_module,only:ancopt
+  use ancopt_module,only:ancopt,get_optthr
   implicit none
 
   real(wp),private,parameter :: autoaa = 0.52917726_wp
   real(wp),private,parameter :: aatoau = 1.0_wp/autoaa
 
   public :: optimize_geometry
+  public :: print_opt_data
 
 !========================================================================================!
 !========================================================================================!
@@ -52,8 +53,9 @@
     real(wp),intent(inout)    :: grd(3,mol%nat)
 
     iostatus = -1
+    !> do not overwrite original geometry
     !$omp critical
-    molnew%at = mol%at  !> do not overwrite original geometry
+    molnew%at = mol%at
     molnew%xyz = mol%xyz
     molnew%nat = mol%nat
     !$omp end critical
@@ -62,10 +64,47 @@
     call engrad(molnew,calc,etot,grd,iostatus)
 
     !> optimization
+    select case( calc%opt_engine )
+    case default
     call ancopt(molnew,calc,etot,grd,pr,wr,iostatus)
-
+    end select
+ 
     return
   end subroutine optimize_geometry
 
+!========================================================================================!
+  
+   subroutine print_opt_data(calc,ich)
+      implicit none
+      type(calcdata) :: calc
+      integer,intent(in) :: ich
+      integer :: tight
+      real(wp) :: ethr,gthr
+
+       write(ich,'(1x,a)',advance='no') 'Optimization engine: '
+       select case (calc%opt_engine)
+       case default
+         write(ich,'(a)') 'ANCOPT'   
+       end select
+       write(ich,'(1x,a)',advance='no') 'Hessian update type: '
+       select case(calc%iupdat)
+       case ( 0 )
+         write(ich,'(a)') 'BFGS'
+       case ( 1 ) 
+         write(ich,'(a)') 'Powell'
+       case ( 2 )
+         write(ich,'(a)') 'SR1'
+       case ( 3 )
+         write(ich,'(a)') 'Bofill'
+       case ( 4 )
+         write(ich,'(a)') 'Farkas-Schlegel' 
+       end select
+       
+       tight = calc%optlev
+       call get_optthr(0,tight,calc,ethr,gthr)
+       write(ich,'(1x,a,e10.3,a,e10.3,a)') 'E/G convergence criteria: ',& 
+       & ethr,' Eh,',gthr,' Eh/a0'
+
+   end subroutine print_opt_data
 !========================================================================================!
 end module optimize_module
Index: src/optimize/meson.build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nsrcs += files(\n  'ancopt.f90',\n  'hessupdate.f90',\n  'modelhessian.f90',\n  'optimize_maths.f90',\n  'optimize_module.f90',\n  'type_anc.f90',\n)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/optimize/meson.build b/src/optimize/meson.build
--- a/src/optimize/meson.build	
+++ b/src/optimize/meson.build	
@@ -20,5 +20,5 @@
   'modelhessian.f90',
   'optimize_maths.f90',
   'optimize_module.f90',
-  'type_anc.f90',
+  'optimize_type.f90',
 )
Index: src/optimize/ancopt.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!\n! Routines were adapted from the xtb code (github.com/grimme-lab/xtb)\n! under the Open-source software LGPL-3.0 Licencse.\n!================================================================================!\n\nmodule ancopt_module\n  use iso_fortran_env,only:wp => real64,sp => real32\n  use crest_calculator\n  use axis_module\n  use strucrd\n  use ls_rmsd\n  use testmol\n\n  use type_anc\n  use optimize_maths\n  use modelhessian_module\n  use hessupdate_module\n  implicit none\n\n  integer,parameter :: olev_crude = -3\n  integer,parameter :: olev_sloppy = -2\n  integer,parameter :: olev_loose = -1\n  integer,parameter :: olev_lax = -4\n  integer,parameter :: olev_normal = 0\n  integer,parameter :: olev_tight = 1\n  integer,parameter :: olev_vtight = 2\n  integer,parameter :: olev_extreme = 3\n\n  real(wp),parameter :: autoaa = 0.52917726_wp\n  real(wp),parameter :: aatoau = 1.0_wp / autoaa\n  real(wp),parameter :: autokcal = 627.509541_wp\n\n  type :: convergence_log\n    integer :: nlog\n    real(wp),allocatable :: elog(:)\n    real(wp),allocatable :: glog(:)\n  contains\n    procedure :: set_eg_log\n    procedure :: get_averaged_energy\n    procedure :: get_averaged_gradient\n  end type convergence_log\n  interface convergence_log\n    module procedure new_convergence_log\n  end interface convergence_log\n\n  public :: ancopt\ncontains\n!========================================================================================!\n!> subroutine ancopt\n!> Implementation of the Aproximate Normal Coordinate (ANC) optimizer\n!>\n!> Input/Output:\n!>      mol  - object containing the molecule,\n!>             Cartesian coordinates in Bohrs.\n!>             will be overwritten on output\n!>     calc  - object containing calculation settings\n!>             and optimization thresholds (look for calc% )\n!>     etot  - on input initial energy (do a singlepoint before ancopt)\n!>             on output final energy\n!>      grd  - Cartesian gradient\n!>       pr  - printout bool\n!>       wr  - logfile (crestopt.log) bool\n!>  iostatus - return status of the routine\n!>             (success=0, error<0, not converged>0)\n!>-----------------------------------------------------------------------\n  subroutine ancopt(mol,calc,etot,grd,pr,wr,iostatus)\n    implicit none\n    !> Inputs\n    type(coord),intent(inout) :: mol\n    type(calcdata),intent(in) :: calc\n    real(wp),intent(inout) :: etot\n    real(wp),intent(inout) :: grd(3,mol%nat)\n    logical,intent(in) :: pr\n    logical,intent(in) :: wr\n    integer,intent(out) :: iostatus\n    !> Local\n    integer  :: tight\n    real(wp) :: eel\n    real(wp) :: et\n    real(wp) :: egap\n    logical :: fail\n    !> Local objects\n    type(coord)   :: molopt\n    type(tb_anc)  :: anc\n    type(mhparam) :: mhset\n\n    real(wp) :: step,amu2au,au2cm,dumi,dumj,damp,hlow,edum,s6,thr\n    real(wp) :: maxdispl,gthr,ethr,hmax,energy,rij(3),t1,t0,w1,w0\n    real(wp) :: rot(3)\n    integer :: n3,i,j,k,l,jjj,ic,jc,ia,ja,ii,jj,info,nat3\n    integer :: nvar,iter,nread,maxcycle,maxmicro,itry,maxopt,iupdat,iii\n    integer :: id,ihess,error\n    integer :: ilog\n    real(wp),allocatable :: h(:,:)\n    real(wp),allocatable :: b(:,:)\n    real(wp),allocatable :: fc(:)\n    real(wp),allocatable :: eig(:)\n    real(wp),allocatable :: aux(:)\n    real(wp),allocatable :: hess(:)\n    integer,allocatable :: iwork(:)\n    integer,allocatable :: totsym(:)\n    real(wp),allocatable :: pmode(:,:)\n    real(wp),allocatable :: grmsd(:,:)\n    type(convergence_log),allocatable :: avconv\n    real(wp) :: U(3,3),x_center(3),y_center(3),rmsdval\n    integer :: modef\n    logical :: ex,converged,linear\n    real(wp) :: estart,esave\n    character(len=*),parameter :: scifmt = &\n                                  '(10x,\"│\",3x,a,e22.7,1x,a,1x,\"│\")'\n    character(len=*),parameter :: dblfmt = &\n                                  '(10x,\"│\",3x,a,f18.7,5x,a,1x,\"│\")'\n    character(len=*),parameter :: intfmt = &\n                                  '(10x,\"│\",3x,a,i18,      10x,\"│\")'\n    character(len=*),parameter :: chrfmt = &\n                                  '(10x,\"│\",3x,a,a18,      10x,\"│\")'\n\n    iostatus = 0\n    fail = .false.\n    converged = .false.\n    if (mol%nat .eq. 1) return\n!>  defaults\n    tight = calc%optlev\n    modef = 0\n    call get_optthr(mol%nat,tight,calc,ethr,gthr)\n    iupdat = calc%iupdat\n    hlow = calc%hlow_opt !optset%hlow_opt !> 0.01 in ancopt, 0.002 too small\n    hmax = calc%hmax_opt\n    maxdispl = calc%maxdispl_opt !optset%maxdispl_opt\n    s6 = mhset%s6 !> slightly better than 30 for various proteins\n\n!> initial number of steps in relax() routine before\n!> new ANC are made by model Hessian\n!> increased during opt.\n    maxmicro = calc%micro_opt\n    maxcycle = calc%maxcycle\n    if (maxcycle .lt. maxmicro) maxmicro = maxcycle\n\n    !> check if the molecule is linear\n    call axis(mol%nat,mol%at,mol%xyz,rot,dumi)\n    linear = rot(3) .lt. 1.d-10\n\n    !> set degrees of freedom\n    nat3 = 3 * mol%nat\n    nvar = nat3 - 6\n    if (linear) then\n      nvar = nat3 - 5\n    end if\n    !if (fixset%n .gt. 0) then ! exact fixing\n    !  nvar = nat3 - 3 * fixset%n - 3\n    !  if (nvar .le. 0) nvar = 1\n    !end if\n    \n    !$omp critical\n    allocate (pmode(nat3,1),grmsd(3,mol%nat)) ! dummy allocated\n    !$omp end critical\n\n!>--- print a summary of settings, if desired\n    if (pr) then\n      write (*,'(/,10x,\"┍\",49(\"━\"),\"┑\")')\n      write (*,'(10x,\"│\",11x,a,11x,\"│\")') \"GEOMETRY OPTIMIZATION SETUP\"\n      write (*,'(10x,\"┝\",49(\"━\"),\"┥\")')\n      !write (*,chrfmt) \"optimization level\",int2optlevel(tight)\n      write (*,intfmt) \"optimization level\",tight\n      write (*,intfmt) \"max. optcycles    \",maxcycle\n      write (*,intfmt) \"ANC micro-cycles  \",maxmicro\n      write (*,intfmt) \"degrees of freedom\",nvar\n      if (modef > 0) then\n        write (*,intfmt) \"# mode follow     \",modef\n      end if\n      write (*,'(10x,\"├\",49(\"─\"),\"┤\")')\n      if (calc%exact_rf) then\n        write (*,chrfmt) \"RF solver         \",\"spevx\"\n      else\n        write (*,chrfmt) \"RF solver         \",\"davidson\"\n      end if\n      select case( iupdat )\n      case( 0 )\n       write (*,chrfmt) \"Hessian update    \",\"bfgs\"\n      case( 1 )\n       write (*,chrfmt) \"Hessian update    \",\"powell\"\n      case( 2 )\n       write (*,chrfmt) \"Hessian update    \",\"sr1\"\n      case( 3 )\n       write (*,chrfmt) \"Hessian update    \",\"bofill\"\n      case( 4 )\n       write (*,chrfmt) \"Hessian update    \",\"schlegel\"\n      end select\n      write (*,chrfmt) \"write crestopt.log\",bool2string(wr)\n      if (linear) then\n        write (*,chrfmt) \"linear (good luck)\",bool2string(linear)\n      else\n        write (*,chrfmt) \"linear?           \",bool2string(linear)\n      end if\n      write (*,scifmt) \"energy convergence\",ethr,\"Eh  \"\n      write (*,scifmt) \"grad. convergence \",gthr,\"Eh/α\"\n      write (*,dblfmt) \"maximium RF displ.\",maxdispl,\"    \"\n      write (*,scifmt) \"Hlow (freq-cutoff)\",hlow,\"    \"\n      write (*,dblfmt) \"Hmax (freq-cutoff)\",hmax,\"    \"\n      write (*,dblfmt) \"S6 in model hess. \",s6,\"    \"\n      write (*,'(10x,\"└\",49(\"─\"),\"┘\")')\n    end if\n\n!>--- initialize anc object\n    !$omp critical\n    allocate (h(nat3,nat3),hess(nat3 * (nat3 + 1) / 2),eig(nat3))\n    call anc%allocate(mol%nat,nvar,hlow,hmax)\n    allocate(molopt%at(mol%nat),molopt%xyz(3,mol%nat))\n    !$omp end critical\n\n!>--- backup coordinates, and starting energy\n    molopt%nat = mol%nat\n    molopt%at  = mol%at\n    molopt%xyz = mol%xyz\n    estart = etot\n\n!>--- initialize .log file, if desired\n    ilog = 942\n    if (wr) then\n      open (newunit=ilog,file='crestopt.log')\n    end if\n\n!>--- The ANCOPT iteration loop. \"iter\" is updated in relax() subroutine\n    iter = 0\n!>======================================================================\n    ANC_microiter: do while (iter < maxcycle .and. .not. converged)\n!>======================================================================\n!>--- generate model Hessian\n      if (pr) write (*,'(/,''generating ANC from model Hessian ...'')')\n      call modhes(calc,mhset,molopt%nat,molopt%xyz,molopt%at,hess,pr)\n\n!>--- project trans. and rot. from Hessian\n      if (.not. linear) then\n        call trproj(molopt%nat,nat3,molopt%xyz,hess,.false.,0,pmode,1) ! normal\n      end if\n\n!>--- ANC generation (requires blowup)\n      k = 0\n      do i = 1,nat3\n        do j = 1,i\n          k = k + 1\n          h(i,j) = hess(k)\n          h(j,i) = hess(k)\n        end do\n      end do\n      call anc%new(molopt%xyz,h,pr,linear,fail)\n      if (fail) then\n        iostatus = -1\n        exit ANC_microiter\n      end if\n\n      esave = etot !> save energy before relaxation\n!>--- call the actual relaxation routine\n!>    this routine will perform [maxmicro] relaxation steps\n      call relax(molopt,calc,anc,iter,maxmicro,etot,grd,  &\n            &      ethr,gthr,converged,                  &\n            &      pr,wr,ilog,iostatus,avconv)\n      if (iostatus .ne. 0) then\n        if (pr) write (*,*) 'Structure relaxation failed'\n        exit ANC_microiter\n      end if\n\n!>--- update max. iterations for next relax() call\n      maxmicro = min(int(float(maxmicro) * 1.1_wp),2 * calc%micro_opt)\n\n!>--- check structural change by RMSD\n      call rmsd(molopt%nat,anc%xyz,molopt%xyz,1,U,x_center,y_center,rmsdval,.false.,grmsd)\n      if (.not. converged .and. pr) then\n        write (*,'(\" * RMSD in coord.:\",f14.7,1x,\"α\")',advance='no') rmsdval\n        write (*,'(6x,\"energy gain\",e16.7,1x,\"Eh\")') etot - esave\n      end if\n!>======================================================================\n    end do ANC_microiter\n!>======================================================================\n\n!>--- close .log file\n    if (wr) then\n      close (ilog)\n    end if\n\n    if (converged) then\n!>--- if the relaxation converged properly do this\n      iostatus = 0\n      if (pr) then\n        call rmsd(mol%nat,mol%xyz,molopt%xyz,1,U,x_center,y_center,rmsdval,.false.,grmsd)\n        write (*,'(/,3x,\"***\",1x,a,1x,i0,1x,a,1x,\"***\",/)') &\n          \"GEOMETRY OPTIMIZATION CONVERGED AFTER\",iter,\"ITERATIONS\"\n        write (*,'(72(\"-\"))')\n        write (*,'(1x,\"total energy gain   :\",F18.7,1x,\"Eh\",F14.4,1x,\"kcal/mol\")') &\n          etot - estart, (etot - estart) * autokcal\n        write (*,'(1x,\"total RMSD          :\",F18.7,1x,\"a0\",F14.4,1x,\"Å\")') &\n          rmsdval,rmsdval * autoaa\n        write (*,'(72(\"-\"))')\n      end if\n    else if (iostatus .ne. 0) then\n!>--- if iostatus =/= 0, something went wrong in the relaxation\n      if (pr) then\n        write (*,'(/,3x,\"***\",1x,a,1x,\"***\",/)') &\n          \"GEOMETRY RELAXATION FAILED\"\n      end if\n    else\n!>--- not converging in the given cycles is considered a FAILURE\n      !> some iostatus>0 is selected to signal this\n      iostatus = iter\n      if (pr) then\n        write (*,'(/,3x,\"***\",1x,a,1x,i0,1x,a,1x,\"***\",/)') &\n          \"FAILED TO CONVERGE GEOMETRY OPTIMIZATION IN\",iter,\"ITERATIONS\"\n      end if\n    end if\n\n!>--- overwrite input structure with optimized one\n    mol%nat = molopt%nat\n    mol%at  = molopt%at\n    mol%xyz = molopt%xyz\n\n\n!> deallocate data\n    !$omp critical\n    if (allocated(grmsd)) deallocate (grmsd)\n    if (allocated(pmode)) deallocate (pmode)\n    if (allocated(h)) deallocate (h)\n    if (allocated(hess)) deallocate (hess)\n    if(allocated(molopt%at)) deallocate( molopt%at )\n    if(allocated(molopt%xyz)) deallocate(molopt%xyz)\n    call anc%deallocate\n    !$omp end critical\n\n    return\n  end subroutine ancopt\n\n!========================================================================================!\n!> subroutine relax\n!>\n!> Implements the microiteration relaxation cycles, i.e.,\n!> the update steps and diagonalizations between the\n!> new ANC generation.\n!>--------------------------------------------------------\n  subroutine relax(mol,calc,anc,iter,maxmicro,etot,grd,  &\n            &      ethr,gthr,converged,                  &\n            &      pr,wr,ilog,iostatus,avconv)\n    implicit none\n\n    type(coord) :: mol\n    type(calcdata) :: calc\n    type(tb_anc) :: anc\n    integer,intent(inout) :: iter\n    integer,intent(in)    :: maxmicro\n    real(wp),intent(inout) :: etot\n    real(wp),intent(inout) :: grd(3,mol%nat)\n    real(wp),intent(in) :: ethr\n    real(wp),intent(in) :: gthr\n    logical,intent(in) :: pr\n    logical,intent(in) :: wr\n    integer,intent(in) :: ilog\n    logical,intent(out) :: converged\n    integer,intent(out) :: iostatus\n    type(convergence_log),intent(inout),optional :: avconv\n\n    integer :: maxiter\n    integer :: iupdat\n\n    real(wp) :: et\n    real(wp) :: egap\n    real(wp) :: acc_in\n\n    logical :: exact\n    integer :: nvar1,npvar,npvar1\n    logical :: fail\n    logical :: econverged\n    logical :: gconverged\n    logical :: lowered\n    integer :: i,j,ii,jj,k,lwork,info,m,idum,imax(3)\n    real(wp) :: energy,dsnrm,maxdispl,t0,w0,t1,w1\n    real(wp) :: lambda,gnorm,dnorm,ddot,eold,xdum,estart,acc,e_in\n    real(wp) :: depred,echng,dummy,maxd,alp,gchng,gnold\n    real(wp),allocatable :: gold(:)\n    real(wp),allocatable :: displ(:),gint(:)\n    real(sp),allocatable :: eaug(:)\n    real(sp),allocatable :: Uaug(:,:)\n    real(sp),allocatable :: Aaug(:)\n    real(sp),parameter :: r4dum = 1.e-8\n    !> LAPACK & BLAS\n    external :: dgemv\n    real(sp),external :: sdot\n\n    iostatus = 0\n\n    !$omp critical\n    allocate (gold(anc%nvar),displ(anc%nvar),gint(anc%nvar),source=0.0_wp)\n\n    gnorm = 0.0_wp\n    depred = 0.0_wp\n    echng = 0.0_wp\n    maxdispl = calc%maxdispl_opt\n    acc_in = calc%acc_opt\n    energy = etot\n    e_in = etot\n    alp = 1.0_wp\n    converged = .false.\n    exact = calc%exact_rf\n    iupdat = calc%iupdat\n\n    nvar1 = anc%nvar + 1             !> dimension of RF calculation\n    npvar = anc%nvar * (nvar1) / 2   !> packed size of Hessian (note the abuse of nvar1!)\n    npvar1 = nvar1 * (nvar1 + 1) / 2 !> packed size of augmented Hessian\n    allocate (Uaug(nvar1,1),eaug(nvar1),Aaug(npvar1))\n    !$omp end critical\n\n!! ========================================================================\n    main_loop: do ii = 1,maxmicro\n!! ========================================================================\n      iter = iter + 1\n      if (pr) &\n        write (*,'(/,\"┌\",76(\"─\"),\"┐\",/,\"│\",32(\" \"),\" CYCLE\",i5,1x,32(\" \"),\"│\",/,\"└\",76(\"─\"),\"┘\")') iter\n\n      gold = gint\n      gnold = gnorm\n      eold = energy\n!>--- calc predicted energy change based on E = E0 + delta * G + delta^2 * H\n      if (ii > 1) then\n        call prdechng(anc%nvar,gold,displ,anc%hess,depred)\n      end if\n\n!>------------------------------------------------------------------------\n!>--- SINGLEPOINT CALCULATION\n!>------------------------------------------------------------------------\n      !> get Cartestian coordinates and gradient\n      call anc%get_cartesian(mol%xyz)\n\n      grd = 0.0_wp\n      call engrad(mol,calc,energy,grd,iostatus)\n      if (iostatus .ne. 0) then\n        fail = .true.\n        exit main_loop\n      end if\n!>------------------------------------------------------------------------\n\n!>--- dump to .log file\n      if (wr) then\n        call mol%appendlog(ilog,energy)\n      end if\n!>--- transform Cartesian xyz to internal gradient\n      call dgemv('t',anc%n3,anc%nvar,1.0_wp,anc%B,anc%n3,grd,1,0.0_wp,gint,1)\n      gnorm = norm2(gint)\n\n      if (gnorm .gt. 500.0_wp) then\n        if (pr) write (*,*) '|grad| > 500, something is totally wrong!'\n        fail = .true.\n        iostatus = -1\n        exit main_loop\n      end if\n\n      !if (present(avconv)) then\n      !  call avconv%set_eg_log(energy,gnorm)\n      !  energy = avconv%get_averaged_energy()\n      !  gnorm = avconv%get_averaged_gradient()\n      !  if (pr) then\n      !    write (*,'(\"av. E:\",1x,f14.7,1x,\"->\",1x,f14.7)') &\n      !      avconv%elog(avconv%nlog),energy\n      !    write (*,'(\"av. G:\",1x,f14.7,1x,\"->\",1x,f14.7)') &\n      !      avconv%glog(avconv%nlog),gnorm\n      !  end if\n      !end if\n\n!>--- check for convergence\n      gchng = gnorm - gnold\n      echng = energy - eold\n      econverged = abs(echng) .lt. ethr\n      gconverged = gnorm .lt. gthr\n      lowered = echng .lt. 0.0_wp\n\n!>--- optimization step printout\n      if (pr) then\n        write (*,'(\" * total energy  :\",f14.7,1x,\"Eh\")',advance='no') energy\n        write (*,'(5x,\"change   \",e18.7,1x,\"Eh\")') echng\n        write (*,'(3x,\"gradient norm :\",f14.7,1x,\"Eh/α\")',advance='no') gnorm\n        write (*,'(3x,\"predicted\",e18.7)',advance='no') depred\n        if (ii > 1) then\n          dummy = (depred - echng) / echng * 100.0_wp\n          if (abs(dummy) < 1000.0_wp) then\n            write (*,'(1x,\"(\"f7.2\"%)\")') dummy\n          else\n            write (*,'(1x,\"(*******%)\")')\n          end if\n        else\n          write (*,'(1x,\"(\"f7.2\"%)\")') - 100.0_wp\n        end if\n      end if\n\n      if (gnorm .lt. 0.002) then ! 0.002\n        alp = 1.5d0 ! 1.5\n      elseif (gnorm .lt. 0.0006) then\n        alp = 2.0d0 ! 2\n      elseif (gnorm .lt. 0.0003) then\n        alp = 3.0d0 ! 3\n      else\n        alp = 1.0d0\n      end if\n\n!>------------------------------------------------------------------------\n!> Update the Hessian\n!>------------------------------------------------------------------------\n      if (ii .gt. 1) then\n!>--- Hessian update, but only after first iteration (ii > 1)\n        select case( iupdat )\n        case( 0 )\n           call bfgs(anc%nvar,gnorm,gint,gold,displ,anc%hess)\n        case( 1 )\n           call powell(anc%nvar,gnorm,gint,gold,displ,anc%hess)\n        case( 2 )\n           call sr1(anc%nvar,gnorm,gint,gold,displ,anc%hess)\n        case( 3 )\n           call bofill(anc%nvar,gnorm,gint,gold,displ,anc%hess)\n        case( 4 )\n           call schlegel(anc%nvar,gnorm,gint,gold,displ,anc%hess)\n        case default\n           write(*,*) 'invalid hessian update selection'\n           stop\n        end select\n      end if\n\n!>------------------------------------------------------------------------\n!>  rational function (RF) method\n!>------------------------------------------------------------------------\n!>  To get initial guess for the displacement solve this:\n!>  (Note: SINGLE PRECISION accuracy, there are some typecasts!)\n!>\n!>   ⎛ H  g ⎞ ⎛ dx ⎞     ⎛ dx ⎞\n!>   ⎝ g  0 ⎠ ⎝  1 ⎠ = λ ⎝  1 ⎠\n!>     Aaug    Uaug       Uaug\n\n!>--- first, augment Hessian by gradient, everything packed, no blowup\n      Aaug(1:npvar) = real(anc%hess(1:npvar),sp)\n      Aaug(npvar + 1:npvar1 - 1) = real(gint(1:anc%nvar),sp)\n      Aaug(npvar1) = 0.0_sp\n\n!>--- choose solver\n      if (exact .or. nvar1 .lt. 50) then\n        call solver_sspevx(nvar1,r4dum,Aaug,Uaug,eaug,fail)\n      else\n        !>--- steepest decent guess for displacement\n        if (ii .eq. 1) then\n          Uaug(:,1) = [-real(gint(1:anc%nvar),sp),1.0_sp]\n          dsnrm = sqrt(sdot(nvar1,Uaug,1,Uaug,1))\n          Uaug = Uaug / real(dsnrm,sp)\n        end if\n        call solver_sdavidson(nvar1,r4dum,Aaug,Uaug,eaug,fail,.false.)\n        !>--- if that failed, retry with better solver\n        if (fail) then\n          call solver_sspevx(nvar1,r4dum,Aaug,Uaug,eaug,fail)\n        end if\n      end if\n\n!>--- divide by last element(=λ) to get the displacement vector dx\n      if (fail .or. abs(Uaug(nvar1,1)) .lt. 1.e-10) then\n        if (pr) write (*,*) \"internal rational function error\"\n        iostatus = -1\n        exit main_loop\n      end if\n      displ(1:anc%nvar) = Uaug(1:anc%nvar,1) / Uaug(nvar1,1)\n\n!>--- check if step is too large, just cut off everything thats to large\n      !do j = 1,anc%nvar\n      !  if (abs(displ(j)) .gt. maxdispl) then\n      !    if (displ(j) < 0) displ(j) = -maxdispl\n      !    if (displ(j) > 0) displ(j) = maxdispl\n      !  end if\n      !end do\n!>--- maybe more consistent version is to rescale displacement\n      maxd = alp * sqrt(ddot(anc%nvar,displ,1,displ,1))\n      if (maxd > maxdispl) then\n        if (pr) write (*,'(\" * rescaling step by\",f14.7)') maxdispl / maxd\n        displ = maxdispl * displ / maxd\n      end if\n\n!>--- now some output\n      dsnrm = sqrt(ddot(anc%nvar,displ,1,displ,1))\n      if (pr) then\n        !> this array is currently not used and will be overwritten in next step\n        gold = abs(displ)\n        imax(1) = maxloc(gold,1); gold(imax(1)) = 0.0_wp\n        imax(2) = maxloc(gold,1); gold(imax(2)) = 0.0_wp\n        imax(3) = maxloc(gold,1)\n        write (*,'(3x,\"displ. norm   :\",f14.7,1x,\"α\")',advance='no') &\n          dsnrm * alp\n        write (*,'(6x,\"lambda   \",e18.7)') eaug(1)\n        write (*,'(3x,\"maximum displ.:\",f14.7,1x,\"α\")',advance='no') &\n          abs(displ(imax(1))) * alp\n        write (*,'(6x,\"in ANC''s \",3(\"#\",i0,\", \"),\"...\")') imax\n        !call prdispl(anc%nvar,displ)\n      end if\n!>------------------------------------------------------------------------\n\n!>--- 2nd: exit and redo hessian (internal restart)\n      if (ii .gt. 2 .and. dsnrm .gt. 2.0) then\n        if (pr) write (*,*) 'exit because of too large step'\n        exit main_loop\n      end if\n\n!>--- new coordinates\n      anc%coord = anc%coord + displ * alp\n\n!>--- converged ?\n      econverged = abs(echng) .lt. ethr\n      gconverged = gnorm .lt. gthr\n      lowered = echng .lt. 0.0_wp\n      converged = econverged .and. gconverged .and. lowered\n      if (pr) then\n        write (*,'(3x,\"converged δE/grad :\",1x,l,\" /\",l)') econverged,gconverged\n      end if\n      if (converged) then\n        !if (econverged .and. gconverged .and. lowered) then\n        converged = .true.\n        etot = energy\n        !return\n        exit main_loop\n      end if\n!>========================================================================\n    end do main_loop\n!>========================================================================\n    !$omp critical\n    if (allocated(Uaug)) deallocate (Uaug)\n    if (allocated(eaug)) deallocate (eaug)\n    if (allocated(Aaug)) deallocate (Aaug)\n    !$omp end critical\n\n    etot = energy\n    call anc%get_cartesian(mol%xyz)\n\n    return\n  end subroutine relax\n\n!========================================================================================!\n!> subroutine get_optthr\n!> routine to set some optimization thresholds\n  subroutine get_optthr(n,olev,calc,ethr,gthr)\n    implicit none\n    integer,intent(in) :: n\n    integer,intent(in) :: olev\n    type(calcdata) :: calc\n    real(wp),intent(out) :: ethr\n    real(wp),intent(out) :: gthr\n    integer :: maxcycle\n    real(wp) :: acc\n    select case (olev)\n!> very approximate = crude\n    case (olev_crude)\n      ethr = 5.d-4\n      gthr = 1.d-2\n      maxcycle = n\n      acc = 3.00d0\n!> approximate = sloopy\n    case (olev_sloppy)\n      ethr = 1.d-4\n      gthr = 6.d-3\n      maxcycle = n\n      acc = 3.00d0\n!> loose\n    case (olev_loose)\n      ethr = 5.d-5\n      gthr = 4.d-3\n      maxcycle = n * 2\n      acc = 2.00d0\n!>  for DCOSMO-RS opts with TM i.e. between loose and normal, keyword \"lax\"\n    case (olev_lax)\n      ethr = 2.d-5\n      gthr = 2.5d-3\n      maxcycle = n * 2\n      acc = 2.00d0\n!> normal\n    case default\n      ethr = 5.d-6\n      gthr = 1.d-3\n      maxcycle = n * 3\n      acc = 1.0d0\n!> tight\n    case (olev_tight)\n      ethr = 1.d-6\n      gthr = 8.d-4\n      maxcycle = n * 5\n      acc = 0.20d0\n!> very tight\n    case (olev_vtight)\n      ethr = 1.d-7\n      gthr = 2.d-4\n      maxcycle = n * 20\n      acc = 0.05d0\n!> extreme\n    case (olev_extreme)\n      ethr = 5.d-8\n      gthr = 5.d-5\n      maxcycle = n * 20\n      acc = 0.01d0\n    end select\n    maxcycle = min(maxcycle,10000)\n    maxcycle = max(maxcycle,200)\n    if (calc%maxcycle <= 0) then\n      calc%maxcycle = maxcycle\n    end if\n    !calc%iupdat = 0 !0=BFGS, 1=Powell\n    if (calc%tsopt) then\n      calc%hlow_opt = max(calc%hlow_opt,0.250d0)\n      calc%iupdat = 1\n    end if\n    return\n  end subroutine get_optthr\n\n!========================================================================================!\n!> Purpose:\n!> Calculates predicted energy change according to the second order\n!> model.\n!>\n!> Input:\n!> nat3  - 3*natoms\n!> hess  - Hessian matrix stored as lower triangle\n!> grad  - Gradient vector\n!> displ - Displacement vector\n!>\n!> Output:\n!> depred - Predicted energy change\n!---------------------------------------------------------------------\n  subroutine prdechng(nat3,grad,displ,hess,depred)\n    implicit none\n    !> Input:\n    integer,intent(in) :: nat3\n    real(wp),intent(in) :: grad(nat3)\n    real(wp),intent(in) :: displ(nat3)\n    real(wp),intent(in) :: hess(nat3 * (nat3 + 1) / 2)\n    !> Output:\n    real(wp),intent(out) :: depred\n    !> Local:\n    real(wp),allocatable :: hdx(:)\n    real(wp) :: gtmp,htmp\n    !> BLAS functions:\n    real(wp),external :: ddot\n    external :: dspmv\n    allocate (hdx(nat3),source=0.0_wp)\n    call dspmv('u',nat3,0.5d0,hess,displ,1,0.0d0,hdx,1)\n    gtmp = ddot(nat3,displ,1,grad,1)\n    htmp = ddot(nat3,displ,1,hdx,1)\n    depred = htmp + gtmp\n    return\n  end subroutine prdechng\n\n  subroutine trfp2xyz(nvar,nat3,p,xyz0,h,dspl)\n    implicit none\n    integer,intent(in) :: nat3\n    integer,intent(in) :: nvar\n    integer :: nat,icount,i,j,k\n    real(wp),intent(in) :: xyz0(3,nat3 / 3)\n    real(wp),intent(out) :: dspl(3,nat3 / 3)\n    real(wp),intent(in) :: h(nat3,nat3)\n    real(wp),intent(in) :: p(nvar)\n    real(wp) :: dum\n\n    dspl = 0.0d0\n    nat = nat3 / 3\n\n! generate cartesian displacement vector\n    do i = 1,nvar\n      icount = 0\n      do j = 1,nat\n        do k = 1,3\n          icount = icount + 1\n          dum = h(icount,i) * p(i)\n          dspl(k,j) = dspl(k,j) + dum\n        end do\n      end do\n    end do\n\n    dspl = dspl + xyz0\n\n    return\n  end subroutine trfp2xyz\n\n  subroutine prdispl(nvar,displ)\n    implicit none\n    integer,intent(in) :: nvar\n    real(wp),intent(in) :: displ(nvar)\n    real(wp),allocatable :: er(:)\n    integer,allocatable :: merk(:)\n    integer :: i,j,ii,k\n    integer :: ihilf\n    real(wp) :: pp\n    allocate (er(nvar),source=0.0_wp)\n    allocate (merk(nvar),source=0)\n\n    er = abs(displ)\n\n    do i = 1,nvar\n      merk(i) = i\n    end do\n    do ii = 2,nvar\n      i = ii - 1\n      k = i\n      pp = er(i)\n      do j = ii,nvar\n        if (er(j) .le. pp) cycle\n        k = j\n        pp = er(j)\n      end do\n      if (k .eq. i) cycle\n      er(k) = er(i)\n      er(i) = pp\n      ihilf = merk(i)\n      merk(i) = merk(k)\n      merk(k) = ihilf\n    end do\n\n    write (*,'(''Largest |displ|/coords:'',5(f8.4,'' ('',i4,'')''))') &\n      (er(i),merk(i),i=1,min(3,nvar))\n\n  end subroutine prdispl\n\n!========================================================================================!\n  function bool2string(bool)\n    implicit none\n    character(len=:),allocatable :: bool2string\n    logical :: bool\n    if (bool) then\n      bool2string = \"True\"\n    else\n      bool2string = \"False\"\n    end if\n  end function bool2string\n\n!========================================================================================!\n  subroutine geoconvav(nc,e,g,val,deriv)\n    implicit none\n    integer :: nc     !> total number of E/G points\n    real(wp) :: e(*)  !> total energy in Eh\n    real(wp) :: g(*)  !> norm of Cartesian gradient (in TM: |dE/dxyz|)\n    real(wp) :: val   !> av. energy in Eh to be used further\n    real(wp) :: deriv !> av. gradient\n\n    integer :: low\n    integer :: i,j\n    integer,parameter:: nav = 5 !> average over last nav\n    real(wp) :: eav,gav\n\n    !> only apply it if sufficient number of points i.e. a \"tail\" can exist\n    !> with the censo blockl = 8 default, this can first be effective in the second\n    if (nc .lt. 3 * nav) then\n      val = e(nc)\n      deriv = g(nc)\n      return\n    end if\n\n    low = max(1,nc - nav + 1)\n    j = 0\n    eav = 0\n    do i = nc,low,-1\n      j = j + 1\n      eav = eav + e(i)\n      gav = gav + g(i)\n    end do\n    val = eav / float(j)\n\n    low = max(1,nc - nav + 1)\n    j = 0\n    gav = 0\n    do i = nc,low,-1\n      j = j + 1\n      gav = gav + g(i)\n    end do\n    ! adjust the gradient norm to xtb \"conventions\" because e.g. a noisy\n    ! DCOSMO-RS gradient for large cases can never (even on average)\n    ! become lower than the \"-opt normal\" thresholds\n    deriv = gav / float(j) / 2.d0\n  end subroutine geoconvav\n\n  pure function new_convergence_log(nmax) result(self)\n    integer,intent(in) :: nmax\n    type(convergence_log) :: self\n    self%nlog = 0\n    allocate (self%elog(nmax))\n    allocate (self%glog(nmax))\n  end function new_convergence_log\n\n  pure function get_averaged_energy(self) result(val)\n    class(convergence_log),intent(in) :: self\n    real(wp) :: eav,val\n    integer :: i,j,low\n    integer,parameter :: nav = 5\n\n    ! only apply it if sufficient number of points i.e. a \"tail\" can exist\n    ! with the censo blockl = 8 default, this can first be effective in the second\n    if (self%nlog .lt. 3 * nav) then\n      val = self%elog(self%nlog)\n    else\n      low = max(1,self%nlog - nav + 1)\n      j = 0\n      eav = 0\n      do i = self%nlog,low,-1\n        j = j + 1\n        eav = eav + self%elog(i)\n      end do\n      val = eav / float(j)\n    end if\n\n  end function get_averaged_energy\n\n  pure function get_averaged_gradient(self) result(deriv)\n    class(convergence_log),intent(in) :: self\n    real(wp) :: gav,deriv\n    integer :: i,j,low\n    integer,parameter :: nav = 5\n\n    ! only apply it if sufficient number of points i.e. a \"tail\" can exist\n    ! with the censo blockl = 8 default, this can first be effective in the second\n    if (self%nlog .lt. 3 * nav) then\n      deriv = self%glog(self%nlog)\n    else\n      low = max(1,self%nlog - nav + 1)\n      j = 0\n      gav = 0\n      do i = self%nlog,low,-1\n        j = j + 1\n        gav = gav + self%glog(i)\n      end do\n      ! adjust the gradient norm to xtb \"conventions\" because e.g. a noisy\n      ! DCOSMO-RS gradient for large cases can never (even on average)\n      ! become lower than the \"-opt normal\" thresholds\n      deriv = gav / float(j) / 2.d0\n    end if\n\n  end function get_averaged_gradient\n\n  pure subroutine set_eg_log(self,e,g)\n    class(convergence_log),intent(inout) :: self\n    real(wp),intent(in) :: e,g\n    real(wp),allocatable :: dum(:)\n    integer :: k,k2\n    k = size(self%elog)\n    if (self%nlog >= k) then\n      k2 = k + 1\n      allocate (dum(k2))\n      dum(1:k) = self%elog(1:k)\n      call move_alloc(dum,self%elog)\n      allocate (dum(k2))\n      dum(1:k) = self%glog(1:k)\n      call move_alloc(dum,self%glog)\n    end if\n    self%nlog = self%nlog + 1\n    self%elog(self%nlog) = e\n    self%glog(self%nlog) = g\n  end subroutine set_eg_log\n\n!========================================================================================!\n  subroutine rdhess(nat3,h,fname)\n    integer,intent(in)  :: nat3\n    real(wp),intent(out) :: h(nat3,nat3)\n    character(len=*),intent(in) :: fname\n    integer  :: iunit,i,j,mincol,maxcol\n    character(len=5)  :: adum\n    character(len=80) :: a80\n\n    !     write(*,*) 'Reading Hessian <',trim(fname),'>'\n    open (newunit=iunit,file=fname)\n50  read (iunit,'(a)') a80\n    if (index(a80,'$hessian') .ne. 0) then\n      do i = 1,nat3\n        maxcol = 0\n200     mincol = maxcol + 1\n        maxcol = min(maxcol + 5,nat3)\n        read (iunit,*) (h(j,i),j=mincol,maxcol)\n        if (maxcol .lt. nat3) goto 200\n      end do\n      close (iunit)\n      goto 300\n    end if\n    goto 50\n\n300 return\n  end subroutine rdhess\n\n!========================================================================================!\nend module ancopt_module\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/optimize/ancopt.f90 b/src/optimize/ancopt.f90
--- a/src/optimize/ancopt.f90	
+++ b/src/optimize/ancopt.f90	
@@ -28,7 +28,7 @@
   use ls_rmsd
   use testmol
 
-  use type_anc
+  use optimize_type
   use optimize_maths
   use modelhessian_module
   use hessupdate_module
@@ -60,6 +60,7 @@
     module procedure new_convergence_log
   end interface convergence_log
 
+  public :: get_optthr
   public :: ancopt
 contains
 !========================================================================================!
@@ -98,7 +99,7 @@
     logical :: fail
     !> Local objects
     type(coord)   :: molopt
-    type(tb_anc)  :: anc
+    type(optimizer)  :: anc
     type(mhparam) :: mhset
 
     real(wp) :: step,amu2au,au2cm,dumi,dumj,damp,hlow,edum,s6,thr
@@ -158,15 +159,15 @@
     linear = rot(3) .lt. 1.d-10
 
     !> set degrees of freedom
-    nat3 = 3 * mol%nat
+    nat3 = 3 * mol%nat 
     nvar = nat3 - 6
     if (linear) then
       nvar = nat3 - 5
     end if
-    !if (fixset%n .gt. 0) then ! exact fixing
-    !  nvar = nat3 - 3 * fixset%n - 3
-    !  if (nvar .le. 0) nvar = 1
-    !end if
+    if (calc%nfreeze .gt. 0) then ! exact fixing
+      nvar = nat3 - 3 * calc%nfreeze - 3
+      if (nvar .le. 0) nvar = 1
+    end if
     
     !$omp critical
     allocate (pmode(nat3,1),grmsd(3,mol%nat)) ! dummy allocated
@@ -248,7 +249,11 @@
 
 !>--- project trans. and rot. from Hessian
       if (.not. linear) then
-        call trproj(molopt%nat,nat3,molopt%xyz,hess,.false.,0,pmode,1) ! normal
+        if(calc%nfreeze == 0)then
+          call trproj(molopt%nat,nat3,molopt%xyz,hess,.false.,0,pmode,1)  !> normal
+        else
+          call trproj(molopt%nat,nat3,molopt%xyz,hess,.false.,calc%freezelist) !> fozen atoms
+        endif
       end if
 
 !>--- ANC generation (requires blowup)
@@ -359,7 +364,7 @@
 
     type(coord) :: mol
     type(calcdata) :: calc
-    type(tb_anc) :: anc
+    type(optimizer) :: anc
     integer,intent(inout) :: iter
     integer,intent(in)    :: maxmicro
     real(wp),intent(inout) :: etot
@@ -386,7 +391,7 @@
     logical :: econverged
     logical :: gconverged
     logical :: lowered
-    integer :: i,j,ii,jj,k,lwork,info,m,idum,imax(3)
+    integer :: i,j,ii,jj,jjj,iii,k,lwork,info,m,idum,imax(3)
     real(wp) :: energy,dsnrm,maxdispl,t0,w0,t1,w1
     real(wp) :: lambda,gnorm,dnorm,ddot,eold,xdum,estart,acc,e_in
     real(wp) :: depred,echng,dummy,maxd,alp,gchng,gnold
Index: src/crest_main.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=========================================================================================!\n!  This is the code of the Conformer-Rotamer Ensemble Sampling Tool (CREST).\n!=========================================================================================!\nprogram CREST\n  use iso_fortran_env,wp => real64\n  !> module for the main data storage\n  use crest_data\n\n  implicit none\n  type(systemdata) :: env  !> MAIN STORAGE OF SYSTEM DATA\n  type(timer)   :: tim     !> timer object\n\n  integer :: i,j,l,args\n  character(len=:),allocatable :: arg(:)\n  character(len=:),allocatable :: infile\n  character(len=512) :: thisdir\n  character(len=1024) :: cmd\n  real(wp) :: dumfloat,dumfloat2,d3,d4,d5,d6,d7,d8\n  logical :: ex,ex1,ex2\n\n  intrinsic :: iargc,getarg\n\n  call initsignal() !SIGTERM catcher\n\n!=========================================================================================!\n!>  Initialize system clock time\n  call tim%init(20)\n\n!=========================================================================================!\n!> set defaults and pars flags\n  args = iargc()\n  l = len_trim(cmd)\n  allocate (arg(args),source=repeat(' ',l))\n  do i = 1,args\n    call getarg(i,arg(i))\n  end do\n  call parseflags(env,arg,args)\n  deallocate (arg)\n\n!=========================================================================================!\n!> scratch dir handling\n\n  if (env%scratch) then\n    call getcwd(thisdir)\n    call scrdir(env)\n  end if\n\n!=========================================================================================!\n!>   OMP_NUM_THREAD handling\n!=========================================================================================!\n  if (.not.env%autothreads) then\n    call ompquickset(env%omp)\n  else\n    if (.not.env%threadssetmanual) then\n      call ompgetauto(env%threads,env%omp,env%MAXRUN)\n      call ompprint()\n    end if\n    call ompautoset(env%threads,0,env%omp,env%MAXRUN,0)   !<--- default\n  end if\n\n!=========================================================================================!\n!>   DRY run stop\n!=========================================================================================!\n  if (env%dryrun) then\n    call crest_dry(env)\n  end if\n\n!=========================================================================================!\n!> SOME I/O STUFF\n!=========================================================================================!\n!>--- check for the coord file in the working directory\n  if (env%crestver .eq. crest_solv) then\n    inquire (file='solute',exist=ex1)\n    inquire (file='solvent',exist=ex2)\n    if (.not.ex1) then\n      error stop 'No solute file found. Exit.'\n    else if (.not.ex2) then\n      error stop 'No solvent file found. Exit.'\n    end if\n  else\n    inquire (file='coord',exist=ex)\n    if (.not.ex) then\n      error stop 'No coord file found. Exit.'\n    end if\n  end if\n\n!>--- call zsort subroutine?\n  if (env%autozsort) then\n    write (*,'(''-------------------------'')')\n    write (*,'(''Starting z-matrix sorting'')')\n    write (*,'(''-------------------------'')')\n    call zsort\n    if (env%onlyZsort) then\n      write (*,*)\n      write (*,*) 'The z-matrix of the input coord file has been sorted.'\n      write (*,*) 'The sorted file in the TM format is called \"zcoord\"'\n      write (*,*)\n      write (*,*) 'exit.'\n      stop\n    end if\n    call rename('zcoord','coord')\n    call rmrf('*.zmat')\n  end if\n\n!=========================================================================================!\n!>        PRE-CONFSEARCH PROPERTY CALCS\n!=========================================================================================!\n  select case (env%properties)\n    !>--- only CREGEN routine\n  case (p_cregen)\n    call tim%start(1,'CREGEN')\n    write (*,*) 'Using only the cregen sorting routine.'\n    env%cgf(6) = .true.   !write confg output to file <tmp>\n    if (env%doNMR) then\n      env%cgf(3) = .true.\n      if (.not.env%fullcre) then\n        env%cgf(2) = .false.\n      end if\n    end if\n    if (env%newcregen) then\n      call newcregen(env,0)\n    else\n      call cregen2(env)\n    end if\n    if (env%doNMR.and.env%fullcre) then\n      call entropic(env,.true.,.false.,.false.,env%ensemblename, &\n      &    env%tboltz,dumfloat,dumfloat2)\n    end if\n    if (env%cluster) then\n      call ccegen(env,.true.,ensemblefile)\n    end if\n    call tim%stop(1)\n    call propquit(tim)\n    !>--- only ensemble comparison\n  case (p_compare)\n    call compare_ensembles(env)         !compare ensembles\n    call propquit(tim)\n    !>--- protonation tool\n  case (p_protonate)\n    call protonate(env,tim)\n    call propquit(tim)\n    !>--- deprotonation\n  case (p_deprotonate)\n    call deprotonate(env,tim)\n    call propquit(tim)\n    !>--- tautomerization\n  case (p_tautomerize)\n    call tautomerize(env,tim)\n    call propquit(tim)\n    !>--- extended tautomerization\n  case (p_tautomerize2)\n    call tautomerize_ext(env%ensemblename,env,tim)\n    call propquit(tim)\n    !>--- stereoisomerization\n  case (p_isomerize)\n    call stereoisomerize(env,tim)\n    call propquit(tim)\n\n    !>--- reactor setup\n  case (p_reactorset)\n    call reactor_setup(env)\n\n    stop\n    !>--- enhanched ensemble entropy\n  case (p_CREentropy)\n    call entropic(env,.true.,.true.,.false.,env%ensemblename, &\n    &    env%tboltz,dumfloat,dumfloat2)\n    call propquit(tim)\n    !>--- calculate hessians and average thermo. contrib\n  case (p_rrhoaverage)\n    call tim%start(4,'freq+thermo')\n    call calcSrrhoav(env,env%ensemblename)\n    call tim%stop(4)\n    call propquit(tim)\n    !>--- to PCA and k-Means clustering for given file\n  case (p_cluster)\n    call ccegen(env,.true.,env%ensemblename)\n    call propquit(tim)\n    !>--- properties for enesemble file\n  case (p_propcalc)\n    call propcalc(env%ensemblename,env%properties2,env,tim)\n    call propquit(tim)\n    !>--- calculate potential correction for acid/base reaction\n  case (p_acidbase)\n    call tim%start(4,'acid/base')\n    if (env%ptb%pka_mode == 0) then\n      call acidbase(env,env%ptb%pka_acidensemble,env%ptb%pka_baseensemble,env%chrg,.true., &\n          & .false.,dumfloat,.false.,d3,d4,d5,d6,d7,d8)\n    else\n      call rewrite_AB_ensemble(env,env%ptb%pka_acidensemble,env%ptb%pka_baseensemble)\n    end if\n    call tim%stop(4)\n    call propquit(tim)\n    !>--- calculate potential correction for acid/base reaction\n  case (p_ligand)\n    call tim%start(4,'')\n    call ligandtool(env%ptb%infile,env%ptb%newligand, &\n    &    env%ptb%centeratom,env%ptb%ligand)\n    call tim%stop(4)\n    call propquit(tim)\n    !>--- wrapper for the thermo routine\n  case (p_thermo)\n    call tim%start(4,'')\n    call thermo_mini(env)\n    call tim%stop(4)\n    call propquit(tim)\n    !>--- ensemble merging tool\n  case (p_gesc1,p_gesc2)\n    call tim%start(9,'')\n    call biasmerge(env)\n    call tim%stop(9)\n    if (env%properties == -9224) call propquit(tim)\n    !>--- do nothing here\n  case default\n    continue\n  end select\n!=========================================================================================!\n!>         PRE-OPTIMIZATION OF THE GEOMETRY\n!=========================================================================================!\n  if (env%preopt) then\n    call xtbopt(env)\n  else if (env%presp) then\n    call xtbsp(env)\n  end if\n!=========================================================================================!\n!>         MAIN WORKFLOW CALLS START HERE\n!=========================================================================================!\n!> many of these routine calls take a detour through legacy_wrappers.f90 !\n  select case (env%crestver)\n  case (crest_mfmdgc)           !> MF-MD-GC algo (deprecated)\n    call confscript1(env,tim)\n  case (crest_imtd,crest_imtd2) !> MTD-GC algo\n    call confscript2i(env,tim)\n  case (crest_mdopt)\n    call mdopt(env,tim)        !> MDOPT\n  case (crest_screen)\n    call screen(env,tim)       !> SCREEN\n  case (crest_nano)\n    call reactor(env,tim)      !> NANO-REACTOR\n  case (crest_compr)\n    call compress(env,tim)     !> MTD COMPRESS mode\n  case (crest_msreac)\n    call msreact_handler(env,tim) !> MSREACT sub-program\n  case (crest_pka)\n    call pkaquick(env,tim)\n  case (crest_solv)             !> microsolvation tools\n    call crest_solvtool(env,tim)\n  case (crest_sp)\n    call crest_singlepoint(env,tim)\n  case (crest_optimize)\n    call crest_optimization(env,tim)\n  case (crest_mdopt2)\n    call crest_ensemble_optimization(env,tim)\n  case (crest_moldyn)\n    call crest_moleculardynamics(env,tim)\n  case (crest_s1)\n    call crest_search_1(env,tim)\n  case (crest_mecp)\n    call crest_search_mecp(env,tim)\n  case (crest_numhessian)\n    call crest_numhess(env,tim)\n  case (crest_scanning)\n    call crest_scan(env,tim)\n  case (crest_rigcon) !> rule-based conformer generation\n    call crest_rigidconf(env,tim)\n  case (crest_test)\n    call crest_playground(env,tim)\n  case default\n    continue\n  end select\n\n  if (env%outputsdf.or.env%sdfformat) then\n    if (any((/crest_mfmdgc,crest_imtd,crest_imtd2/) == env%crestver)) then\n      call new_wrsdfens(env,conformerfile,conformerfilebase//'.sdf',.false.)\n    end if\n    if (any((/crest_screen,crest_mdopt/) == env%crestver)) then\n      call new_wrsdfens(env,'crest_ensemble.xyz','crest_ensemble.sdf',.false.)\n    end if\n  end if\n\n!=========================================================================================!\n!>        POST-CONFSEARCH PROPERTY CALCS\n!=========================================================================================!\n  if (env%npq .gt. 0) then\n    infile = \"crest_rotamers.xyz\"\n    do i = 1,env%npq\n      j = env%pqueue(i)\n      select case (j)\n      case (1:8,10,20,100,998)\n        call propcalc(conformerfile,j,env,tim)\n      case (45)\n        call tim%start(15,'entropy eval.')\n        call newentropyextrapol(env)\n        call tim%stop(15)\n      case (50:59)  !hybrid reoptimization (e.g. gfn2@gff)\n        call propcalc(infile,j,env,tim)\n        infile = 'crest_reopt.xyz'\n      case (70) !PCA and clustering\n        call ccegen(env,.true.,conformerfile)\n      case (555)\n        call tautomerize_ext(infile,env,tim)\n      case default\n        continue\n      end select\n    end do\n  end if\n\n!=========================================================================================!\n!> go back from scratch directory\n  if (env%scratch) then\n    call chdir(thisdir)\n    call scrend(env)\n  end if\n\n!=========================================================================================!\n!> Evaluate and print timings\n  call eval_timer(tim)\n  write (*,*) 'CREST terminated normally.'\n!> end of main program\nend program CREST\n\n!=========================================================================================!\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!=========================================================================================!\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/crest_main.f90 b/src/crest_main.f90
--- a/src/crest_main.f90	
+++ b/src/crest_main.f90	
@@ -24,12 +24,12 @@
   use iso_fortran_env,wp => real64
   !> module for the main data storage
   use crest_data
-
+  use crest_restartlog
   implicit none
   type(systemdata) :: env  !> MAIN STORAGE OF SYSTEM DATA
   type(timer)   :: tim     !> timer object
 
-  integer :: i,j,l,args
+  integer :: i,j,l,args,io
   character(len=:),allocatable :: arg(:)
   character(len=:),allocatable :: infile
   character(len=512) :: thisdir
@@ -55,7 +55,7 @@
   end do
   call parseflags(env,arg,args)
   deallocate (arg)
-
+  call restart_save_env(env)
 !=========================================================================================!
 !> scratch dir handling
 
@@ -72,7 +72,7 @@
   else
     if (.not.env%threadssetmanual) then
       call ompgetauto(env%threads,env%omp,env%MAXRUN)
-      call ompprint()
+      !call ompprint()
     end if
     call ompautoset(env%threads,0,env%omp,env%MAXRUN,0)   !<--- default
   end if
@@ -102,30 +102,12 @@
       error stop 'No coord file found. Exit.'
     end if
   end if
-
-!>--- call zsort subroutine?
-  if (env%autozsort) then
-    write (*,'(''-------------------------'')')
-    write (*,'(''Starting z-matrix sorting'')')
-    write (*,'(''-------------------------'')')
-    call zsort
-    if (env%onlyZsort) then
-      write (*,*)
-      write (*,*) 'The z-matrix of the input coord file has been sorted.'
-      write (*,*) 'The sorted file in the TM format is called "zcoord"'
-      write (*,*)
-      write (*,*) 'exit.'
-      stop
-    end if
-    call rename('zcoord','coord')
-    call rmrf('*.zmat')
-  end if
 
 !=========================================================================================!
 !>        PRE-CONFSEARCH PROPERTY CALCS
 !=========================================================================================!
   select case (env%properties)
-    !>--- only CREGEN routine
+!>--- only CREGEN routine
   case (p_cregen)
     call tim%start(1,'CREGEN')
     write (*,*) 'Using only the cregen sorting routine.'
@@ -150,56 +132,66 @@
     end if
     call tim%stop(1)
     call propquit(tim)
-    !>--- only ensemble comparison
+!>--- zsort routine
+  case(p_zsort) 
+    call zsort
+    write (*,*)
+    write (*,*) 'The z-matrix of the input coord file has been sorted.'
+    write (*,*) 'The sorted file in TM format is called "zcoord"'
+    write (*,*)
+    write (*,*) 'exit.'
+    call propquit(tim)
+
+!>--- only ensemble comparison
   case (p_compare)
-    call compare_ensembles(env)         !compare ensembles
+    call compare_ensembles(env)     
     call propquit(tim)
-    !>--- protonation tool
+ !>--- protonation tool
   case (p_protonate)
     call protonate(env,tim)
     call propquit(tim)
-    !>--- deprotonation
+!>--- deprotonation
   case (p_deprotonate)
     call deprotonate(env,tim)
     call propquit(tim)
-    !>--- tautomerization
+!>--- tautomerization
   case (p_tautomerize)
     call tautomerize(env,tim)
     call propquit(tim)
-    !>--- extended tautomerization
+!>--- extended tautomerization
   case (p_tautomerize2)
     call tautomerize_ext(env%ensemblename,env,tim)
     call propquit(tim)
-    !>--- stereoisomerization
+!>--- stereoisomerization
   case (p_isomerize)
     call stereoisomerize(env,tim)
     call propquit(tim)
 
-    !>--- reactor setup
+!>--- reactor setup
   case (p_reactorset)
     call reactor_setup(env)
 
     stop
-    !>--- enhanched ensemble entropy
+!>--- enhanched ensemble entropy
   case (p_CREentropy)
     call entropic(env,.true.,.true.,.false.,env%ensemblename, &
     &    env%tboltz,dumfloat,dumfloat2)
     call propquit(tim)
-    !>--- calculate hessians and average thermo. contrib
+!>--- calculate hessians and average thermo. contrib
   case (p_rrhoaverage)
     call tim%start(4,'freq+thermo')
     call calcSrrhoav(env,env%ensemblename)
     call tim%stop(4)
     call propquit(tim)
-    !>--- to PCA and k-Means clustering for given file
+!>--- to PCA and k-Means clustering for given file
   case (p_cluster)
     call ccegen(env,.true.,env%ensemblename)
     call propquit(tim)
-    !>--- properties for enesemble file
+!>--- properties for enesemble file
   case (p_propcalc)
     call propcalc(env%ensemblename,env%properties2,env,tim)
     call propquit(tim)
-    !>--- calculate potential correction for acid/base reaction
+!>--- calculate potential correction for acid/base reaction
   case (p_acidbase)
     call tim%start(4,'acid/base')
     if (env%ptb%pka_mode == 0) then
@@ -210,26 +202,26 @@
     end if
     call tim%stop(4)
     call propquit(tim)
-    !>--- calculate potential correction for acid/base reaction
+!>--- calculate potential correction for acid/base reaction
   case (p_ligand)
     call tim%start(4,'')
     call ligandtool(env%ptb%infile,env%ptb%newligand, &
     &    env%ptb%centeratom,env%ptb%ligand)
     call tim%stop(4)
     call propquit(tim)
-    !>--- wrapper for the thermo routine
+!>--- wrapper for the thermo routine
   case (p_thermo)
     call tim%start(4,'')
     call thermo_mini(env)
     call tim%stop(4)
     call propquit(tim)
-    !>--- ensemble merging tool
+!>--- ensemble merging tool
   case (p_gesc1,p_gesc2)
     call tim%start(9,'')
     call biasmerge(env)
     call tim%stop(9)
     if (env%properties == -9224) call propquit(tim)
-    !>--- do nothing here
+!>--- do nothing here
   case default
     continue
   end select
@@ -237,7 +229,7 @@
 !>         PRE-OPTIMIZATION OF THE GEOMETRY
 !=========================================================================================!
   if (env%preopt) then
-    call xtbopt(env)
+    call trialOPT(env)
   else if (env%presp) then
     call xtbsp(env)
   end if
@@ -248,42 +240,58 @@
   select case (env%crestver)
   case (crest_mfmdgc)           !> MF-MD-GC algo (deprecated)
     call confscript1(env,tim)
+
   case (crest_imtd,crest_imtd2) !> MTD-GC algo
     call confscript2i(env,tim)
-  case (crest_mdopt)
+
+  case (crest_mdopt, crest_mdopt2)
     call mdopt(env,tim)        !> MDOPT
+
   case (crest_screen)
     call screen(env,tim)       !> SCREEN
+
   case (crest_nano)
     call reactor(env,tim)      !> NANO-REACTOR
+
   case (crest_compr)
     call compress(env,tim)     !> MTD COMPRESS mode
+
   case (crest_msreac)
     call msreact_handler(env,tim) !> MSREACT sub-program
+
   case (crest_pka)
     call pkaquick(env,tim)
+
   case (crest_solv)             !> microsolvation tools
     call crest_solvtool(env,tim)
+
   case (crest_sp)
     call crest_singlepoint(env,tim)
+
   case (crest_optimize)
     call crest_optimization(env,tim)
-  case (crest_mdopt2)
-    call crest_ensemble_optimization(env,tim)
+
   case (crest_moldyn)
     call crest_moleculardynamics(env,tim)
+
   case (crest_s1)
     call crest_search_1(env,tim)
+
   case (crest_mecp)
     call crest_search_mecp(env,tim)
+
   case (crest_numhessian)
     call crest_numhess(env,tim)
+
   case (crest_scanning)
     call crest_scan(env,tim)
+
   case (crest_rigcon) !> rule-based conformer generation
     call crest_rigidconf(env,tim)
+
   case (crest_test)
     call crest_playground(env,tim)
+
   case default
     continue
   end select
@@ -308,7 +316,7 @@
       case (1:8,10,20,100,998)
         call propcalc(conformerfile,j,env,tim)
       case (45)
-        call tim%start(15,'entropy eval.')
+        call tim%start(15,'Conf. entropy evaluation')
         call newentropyextrapol(env)
         call tim%stop(15)
       case (50:59)  !hybrid reoptimization (e.g. gfn2@gff)
@@ -331,6 +339,13 @@
     call scrend(env)
   end if
 
+!=========================================================================================!
+!> shout down hosted subprocesses
+  block
+  use ConfSolv_module
+  call cs_shutdown(io)
+  end block
+
 !=========================================================================================!
 !> Evaluate and print timings
   call eval_timer(tim)
Index: src/dynamics/dynamics_module.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2021 - 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!\n! Routines were adapted from the xtb code (github.com/grimme-lab/xtb)\n! under the Open-source software LGPL-3.0 Licencse.\n!================================================================================!\n\nmodule dynamics_module\n  use crest_parameters\n  use crest_calculator\n  use strucrd\n  use atmasses\n  use shake_module\n  use metadynamics_module\n!$ use omp_lib\n  implicit none\n\n  !======================================================================================!\n  !--- private module variables and parameters\n  private\n  integer :: i,j,k,l,ich,och,io\n  logical :: ex\n\n  !>--- some constants and name mappings\n  real(wp),parameter :: amutoau = amutokg*kgtome\n  real(wp),parameter :: fstoau = 41.3413733365614_wp\n\n  !>-- filetypes as integers\n  integer,parameter,public :: type_md = 1\n  integer,parameter,public :: type_mtd = 2\n\n  !>-- REEXPORTS from metadynamics_module\n  public :: mtdpot,mtd_ini,cv_dump,calc_mtd\n  public :: cv_std_mtd,cv_rmsd,cv_rmsd_static\n\n  !>-- REEXPORTS from shake_module\n  public :: shakedata,init_shake\n\n  public :: mddata\n  !======================================================================================!\n  !data object that contains settings for a molecular dynamics simulation.\n  type :: mddata\n\n    logical :: requested = .false.\n\n    integer :: md_index = 0      !> some index for parallelization\n    integer :: simtype = type_md !> type of the molecular dynamics simulation\n    logical :: restart = .false.\n    character(len=:),allocatable :: restartfile\n    character(len=:),allocatable :: trajectoryfile\n    !>--- data\n    real(wp) :: length_ps = 0.0_wp !20.0_wp  !> total simulation length in ps\n    integer :: length_steps = 0 !20000       !> total simulation length in steps\n    real(wp) :: tstep = 0.0_wp !1.0_wp       !> timestep in fs\n    real(wp) :: dumpstep = 0.0_wp !1000.0_wp !> snapshot dump step in fs\n    integer :: sdump = 0 !1000 !> snapshot dump to trajectory every x steps\n    integer :: dumped = 0      !> count how many structures have been written\n    integer :: printstep = 200 !> control how often (in steps) to print to stdout\n\n    real(wp) :: md_hmass = 0.0_wp !1.00794075_wp !> hydrogen mass\n\n    logical :: shake = .true. !> use SHAKE algorithm\n    integer :: nshake = 0  !> number of bonds considered in SHAKE\n    type(shakedata) :: shk !> SHAKE bond information\n\n    real(wp) :: tsoll = 0.0_wp !298.15_wp  !> wanted temperature\n    logical :: thermostat = .true. !> apply thermostat?\n    character(len=64) :: thermotype = 'berendsen'\n    real(wp) :: thermo_damp = 500.0_wp !> thermostat damping parameter\n    logical :: samerand = .false.\n\n    integer :: blockl        !> block length in MD steps\n    integer :: iblock = 0    !> block counter\n    integer :: nblock = 0    !> continuous block counter\n    integer :: blocknreg = 0 !> block regression points\n    integer :: maxblock\n    real(wp),allocatable :: blockrege(:)\n    real(wp),allocatable :: blocke(:)\n    real(wp),allocatable :: blockt(:)\n\n    !>--- the collection of MTD potentials\n    integer :: npot = 0\n    type(mtdpot),allocatable :: mtd(:)\n    integer,allocatable :: cvtype(:)\n\n  contains\n    generic,public :: add => md_add_mtd\n    procedure,private :: md_add_mtd\n    procedure :: defaults => md_defaults_fallback\n  end type mddata\n\n  public :: dynamics\n  public :: mdautoset\n\n!========================================================================================!\n!========================================================================================!\ncontains  !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\n  subroutine dynamics(mol,dat,calc,pr,term)\n!*************************************************************\n!* subroutine dynamics\n!* perform a molecular dynamics simulation\n!* the coordinate propagation is of the Velocity-Verlet type\n!*************************************************************\n    implicit none\n\n    type(coord) :: mol          !> molecule data (should be in Bohr)\n    type(mddata) :: dat         !> MD data\n    type(calcdata) :: calc      !> calculation control\n    logical,intent(in) :: pr    !> printout control\n    integer,intent(out) :: term !> termination status\n\n    integer :: t,nfreedom\n    real(wp) :: tstep_au\n    real(wp) :: epot,ekin,edum\n    real(wp) :: temp,thermoscal\n!>--- averages & errors\n    real(wp) :: Tav,Epav,Ekav,Eerror\n\n    real(wp),allocatable :: grd(:,:)\n    real(wp),allocatable :: velo(:,:)\n    real(wp),allocatable :: vel(:,:)\n    real(wp),allocatable :: veln(:,:)\n    real(wp),allocatable :: acc(:,:)\n    real(wp),allocatable :: mass(:)\n    real(wp),allocatable :: xyz_angstrom(:,:)\n\n    type(coord) :: molo\n    real(wp) :: f\n    real(wp) :: molmass,tmass\n    character(len=:),allocatable :: trajectory\n    integer :: trj\n    character(len=256) :: commentline\n    integer :: i,j,k,l,ich,och,io\n    integer :: dcount,printcount\n    logical :: ex\n\n    call initsignal()\n\n!>--- pre-settings and calculations\n    !$omp critical\n    call dat%defaults() !> check for unset parameters\n    term = 0\n    tstep_au = dat%tstep*fstoau\n    nfreedom = 3*mol%nat\n    if (dat%shake) then\n      call init_shake(mol%nat,mol%at,mol%xyz,dat%shk,pr)\n      dat%nshake = dat%shk%ncons\n      nfreedom = nfreedom-dat%nshake\n    end if\n!>--- averages\n    tav = 0.0_wp\n    eerror = 0.0_wp\n    ekav = 0.0_wp\n    epav = 0.0_wp\n    temp = 0.0_wp\n\n!>--- allocate data fields\n    allocate (xyz_angstrom(3,mol%nat))\n    allocate (molo%at(mol%nat),molo%xyz(3,mol%nat))\n    allocate (grd(3,mol%nat),vel(3,mol%nat),velo(3,mol%nat),source=0.0_wp)\n    allocate (veln(3,mol%nat),acc(3,mol%nat),mass(mol%nat),source=0.0_wp)\n    dat%blockl = min(5000,idint(5000.0_wp/dat%tstep))\n    dat%maxblock = nint(dat%length_steps/float(dat%blockl))\n    allocate (dat%blocke(dat%blockl),dat%blockt(dat%blockl))\n    allocate (dat%blockrege(dat%maxblock))\n    !$omp end critical\n\n!>--- settings printout\n    if (pr) then\n      write (*,*)\n      write (*,'(\"> \",a)') 'Molecular dynamics settings'\n      write (*,'('' MD time /ps        :'',f10.2)') dat%length_ps\n      write (*,'('' dt /fs             :'',f10.2)') dat%tstep\n      write (*,'('' temperature /K     :'',f10.2)') dat%tsoll\n      write (*,'('' max steps          :'',i10  )') dat%length_steps\n      !write (*,'('' block length (av.) :'',i6  )') blockl\n      write (*,'('' dumpstep(trj) /fs  :'',f10.2,i6)') dat%dumpstep,dat%sdump\n      !write (*,'('' dumpstep(coords)/fs:'',f8.2,i6)') dump_md,cdump0\n      write (*,'('' # deg. of freedom  :'',i10  )') nfreedom\n      call thermostatprint(dat,pr)\n      write (*,'('' SHAKE constraint   :'',8x,l)') dat%shake\n      if (dat%shake) then\n        if (dat%shk%shake_mode == 2) then\n          write (*,'('' # SHAKE bonds      :'',i10,a)') dat%nshake,' (all bonds)'\n        elseif (dat%shk%shake_mode == 1) then\n          write (*,'('' # SHAKE bonds      :'',i10,a)') dat%nshake,' (H only)'\n        end if\n      end if\n      write (*,'('' hydrogen mass /u   :'',f10.5 )') dat%md_hmass\n    end if\n\n!>--- set atom masses\n    !$omp critical\n    molmass = 0.0_wp\n    do i = 1,mol%nat\n      molmass = molmass+ams(mol%at(i))\n      mass(i) = ams(mol%at(i))*amutoau !>-- ams from module atmasses\n    end do\n    tmass = molmass*amutoau\n    do i = 1,mol%nat\n      if (mol%at(i) .eq. 1.and.dat%md_hmass .gt. 0.0_wp) then\n        mass(i) = dat%md_hmass*amutoau\n      end if\n    end do\n    molmass = molmass*amutokg\n    !$omp end critical\n\n!>--- initialize velocities (or read from restart file)\n    if (dat%thermostat) then\n      f = 1.0_wp\n    else\n      f = 2.0_wp\n    end if\n    edum = f*dat%tsoll*0.5_wp*kB*float(nfreedom)\n    call mdinitu(mol,dat,velo,mass,edum,pr)\n    call ekinet(mol%nat,velo,mass,ekin)\n\n!>--- initialize MTDs (if required)\n    !$omp critical\n    if (dat%simtype == type_mtd) then\n      call md_init_mtd(mol,dat,pr)\n    end if\n    !$omp end critical\n\n    !>--- initialize trajectory file\n    if (allocated(dat%trajectoryfile)) then\n      trajectory = dat%trajectoryfile\n    else\n      write (commentline,'(a,i0,a)') 'crest_',dat%md_index,'.trj'\n      trajectory = trim(commentline)\n    end if\n    !$omp critical\n    open (newunit=trj,file=trajectory)\n    !$omp end critical\n\n    !>--- begin printout\n    if (pr) then\n      write (*,'(/,\"> \",a)') 'Starting simulation'\n      if (.not.dat%thermostat) then\n        write (*,'(/,11x,\"time (ps)\",7x,\"<Epot>\",8x,\"Ekin\",5x,\"<T>\",7x,\"T\",12x, &\n           &         \"Etot\",7x,\"error\")')\n      else\n        write (*,'(/,11x,\"time (ps)\",7x,\"<Epot>\",8x,\"Ekin\",5x,\"<T>\",7x,\"T\",12x, &\n           &         \"Etot\")')\n      end if\n    end if\n\n    dcount = 0\n    printcount = 1\n!===============================================================!\n!===============================================================!\n!>--- begin MD loop\n    MD: do t = 1,dat%length_steps\n      call initsignal()\n\n      !>>-- STEP 1: calculate energy and forces\n      !>--- singlepoint calculation\n      epot = 0.0_wp\n      grd = 0.0_wp\n      call engrad(mol,calc,epot,grd,io)\n\n      if (io /= 0) then\n        if (dat%dumped > 0) then\n          term = 2  !> termination during MD\n        else\n          term = 1  !> termination upon first engrad call\n        end if\n        exit MD\n      end if\n      if (t == 1) then\n        edum = epot+ekin\n      end if\n\n      !>>-- STEP 1.5: calculate metadynamics bias\n      if (dat%simtype == type_mtd) then\n        !> MTD energy and gradient are added to epot and grd, respectively.\n        call md_calc_mtd(mol,dat,epot,grd,pr)\n        !$omp critical\n        call md_update_mtd(mol,dat,calc,pr)\n        !$omp end critical\n      end if\n\n      !>--- block data printouts\n      call u_block(mol,dat,epot,temp,pr)\n\n      !===========================================!\n      !>>-- write to trajectory and printout\n      if (dcount == dat%sdump) then\n        dcount = 0\n        dat%dumped = dat%dumped+1\n        !$omp critical\n        xyz_angstrom = mol%xyz*bohr\n        write (commentline,'(a,f22.12,1x,a)') 'Epot =',epot,''\n        call wrxyz(trj,mol%nat,mol%at,xyz_angstrom,commentline)\n        !$omp end critical\n      end if\n      if ((printcount == dat%printstep).or.(t == 1)) then\n        if (t > 1) printcount = 0\n        if (pr) then\n          if (.not.dat%thermostat) then\n            write (*,'(i7,f10.2,F16.5,F12.4,2F8.1,F16.5,4F10.4)') &\n               &   t,0.001_wp*float(t)*dat%tstep, (Epav+Epot)/float(t), &\n               &   Ekin,Tav/float(t),temp,Epot+Ekin, &\n               &   Edum/float(t)-Epot-Ekin\n          else\n            write (*,'(i7,f10.2,F16.5,F12.4,2F8.1,F16.5)') &\n               &   t,0.001_wp*float(t)*dat%tstep, (Epav+epot)/float(t), &\n               &   Ekin,Tav/float(t),temp,Epot+Ekin\n          end if\n        end if\n      end if\n\n      !>--- compute the acceleration at t\n      do i = 1,mol%nat\n        acc(:,i) = -grd(:,i)/mass(i)\n      end do\n\n      !>--- store positions (at t); velocities are at t-1/2dt\n      !$omp critical\n      molo%nat = mol%nat\n      molo%at = mol%at\n      molo%xyz = mol%xyz\n      !$omp end critical\n\n      !>>-- STEP 2: temperature and pressure/density control\n      !>--- estimate(!) velocities at t\n      veln = velo+0.5_wp*tstep_au*acc\n\n      !>--- compute kinetic energy and termperature\n      call ekinet(mol%nat,veln,mass,ekin)\n      temp = 2.0_wp*ekin/float(nfreedom)/kB\n\n      !>--- THERMOSTATING (determine factor thermoscal)\n      call thermostating(mol,dat,temp,thermoscal)\n\n      !>>-- STEP 3: velocity and position update\n      !>--- update velocities to t\n      ! I think the factor of 1/2 for the acc is missing in the xtb version\n      vel = thermoscal*(velo+0.5_wp*acc*tstep_au)\n      !>--- update positions to t+dt\n      mol%xyz = molo%xyz+vel*tstep_au\n\n      !>--- estimate new velocities at t\n      veln = 0.5_wp*(velo+vel)\n\n      !>--- compute kinetic energy and temperature for average tracking\n      call ekinet(mol%nat,veln,mass,ekin)\n      temp = 2.0_wp*ekin/float(nfreedom)/kB\n\n      !>--- apply SHAKE at t+dt?\n      if (dat%shake.and.dat%nshake > 0) then\n        call do_shake(mol%nat,molo%xyz,mol%xyz,vel,acc,mass,tstep_au,dat%shk,pr,io)\n        if (io /= 0) then\n          if (dat%dumped > 0) then\n            term = 2  !> termination during MD\n          else\n            term = 1  !> termination upon first engrad call\n          end if\n          exit MD\n        end if\n      end if\n\n      !>--- update velocities\n      velo = vel\n\n      !>--- remove translational and rotational componetnts of the velocity\n      call rmrottr(mol%nat,mass,velo,mol%xyz)\n\n      !>>-- Update averages and counter\n      edum = edum+epot+ekin\n      eerror = edum/float(t)-epot-ekin\n      tav = tav+temp\n      epav = epav+epot\n      ekav = ekav+ekin\n      dcount = dcount+1\n      printcount = printcount+1\n\n    end do MD\n!>--- finish MD loop\n!===============================================================!\n!===============================================================!\n!>--- close trajectory file\n    !$omp critical\n    close (trj)\n    !$omp end critical\n\n!>--- averages printout\n    if (pr) then\n      write (*,*)\n      write (*,*) 'average properties '\n      write (*,*) '----------------------'\n      write (*,*) '<Epot>               :',Epav/float(t)\n      write (*,*) '<Ekin>               :',Ekav/float(t)\n      write (*,*) '<Etot>               :', (Ekav+Epav)/float(t)\n      write (*,*) '<T>                  :',Tav/float(t)\n    end if\n\n!>--- write restart file\n    call wrmdrestart(mol,dat,velo)\n\n!>--- termination printout\n    if (pr) then\n      select case (term)\n      case (0)\n        write (*,*) 'normal MD termination'\n      case (1)\n        write (stderr,*) 'error in MD calculation'\n      case (2)\n        write (*,*) 'MD terminated, but still taking as converged.'\n      end select\n    end if\n\n!>--- deallocate data\n    deallocate (dat%blockrege,dat%blockt,dat%blocke)\n    deallocate (mass,acc,veln)\n    deallocate (vel,velo,grd)\n    deallocate (molo%xyz,molo%at)\n    deallocate (xyz_angstrom)\n\n    return\n  end subroutine dynamics\n\n!========================================================================================!\n  subroutine mdautoset(dat,iostatus)\n!************************************************\n!* subroutine mdautoset\n!* convert real-time settings (ps,fs) to steps\n!* Intended to restore settings once reset\n!************************************************\n    implicit none\n    type(mddata) :: dat\n    integer,intent(out) :: iostatus\n    real(wp) :: dum\n    integer :: idum\n\n    iostatus = 0\n\n    if (dat%length_ps .le. 0.0_wp.or. &\n    &  dat%tstep .le. 0.0_wp) then\n      write (stderr,*) 'need valid simulation length and time step!'\n      write (stderr,*) 'abort MD.'\n      iostatus = -1\n      return\n    end if\n\n    !>--- MD length to steps\n    dum = (dat%length_ps*1000.0_wp)/dat%tstep\n    dat%length_steps = nint(dum)\n\n    !>--- adjust structure dump to trajectory file\n    dum = max(1.0_wp, (dat%dumpstep/dat%tstep))\n    dat%sdump = nint(dum)\n\n    return\n  end subroutine mdautoset\n\n!========================================================================================!\n! subroutine ekinet\n! calculate kinetic energy from velocities and masses\n  subroutine ekinet(n,velo,mass,E)\n    implicit none\n    integer,intent(in) :: n\n    real(wp),intent(in) :: velo(3,n),mass(n)\n    real(wp),intent(out) :: e\n    e = 0.0_wp\n    do i = 1,n\n      e = e+mass(i)*(velo(1,i)**2+velo(2,i)**2+velo(3,i)**2)\n    end do\n    e = e*0.5_wp\n    return\n  end subroutine ekinet\n\n!========================================================================================!\n! subroutine u_block\n! update block data and printout\n  subroutine u_block(mol,dat,epot,temp,pr)\n    implicit none\n    type(coord) :: mol\n    type(mddata) :: dat\n    real(wp),intent(in) :: epot\n    real(wp),intent(in) :: temp\n    logical,intent(in) :: pr\n\n    integer :: nreg\n    real(wp) :: bave,bavt,slope\n\n    if (dat%iblock == dat%blockl) then\n      dat%nblock = dat%nblock+1\n      dat%iblock = 0\n      call blocksd(mol%nat,dat%blockl,dat%blocke,dat%blockt,bave,bavt)\n      dat%blocknreg = dat%blocknreg+1\n      nreg = dat%blocknreg\n      dat%blockrege(nreg) = bave\n      if (nreg .ge. 4) then\n        call regress(nreg-3,nreg,dat%blockrege,slope)\n      else\n        slope = 99.0_wp\n      end if\n      if (pr) then\n        write (*,'(''block <Epot> / <T> :'',f14.5,f7.1,4x, &\n           &             ''drift:'',d10.2,3x,''Tbath :'',f6.1)')  &\n           &             bave,bavt,slope,dat%tsoll\n      end if\n    else\n      dat%iblock = dat%iblock+1\n      dat%blocke(dat%iblock) = epot\n      dat%blockt(dat%iblock) = temp\n    end if\n\n    return\n\n  contains\n    subroutine regress(n1,n2,rege,slope)\n      implicit none\n      real(wp) :: rege(*),slope\n      integer :: n1,n2,n,i\n      real(wp) :: sx,sy,sxx,sxy,x\n\n      n = n2-n1+1\n      sx = 0.0_wp\n      sy = 0.0_wp\n      sxy = 0.0_wp\n      sxx = 0.0_wp\n      x = 0.0_wp\n      do i = n1,n2\n        x = x+1.0_wp\n        sx = sx+x\n        sy = sy+rege(i)\n        sxx = sxx+x**2\n        sxy = sxy+x*rege(i)\n      end do\n\n      slope = (dble(n)*sxy-sx*sy)/(dble(n)*sxx-sx*sx)\n      return\n    end subroutine regress\n\n    subroutine blocksd(n,nbl,ebl,tbl,esd,tsd)\n      implicit none\n      integer :: n,nbl\n      real(wp) :: ebl(nbl),tbl(nbl),dum,av,esd,tsd\n      integer :: i\n\n      dum = 0.0_wp\n      do i = 1,nbl\n        dum = dum+ebl(i)\n      end do\n      av = dum/dble(nbl)\n      esd = av\n\n      dum = 0.0_wp\n      do i = 1,nbl\n        dum = dum+tbl(i)\n      end do\n      av = dum/dble(nbl)\n      tsd = av\n\n      return\n    end subroutine blocksd\n  end subroutine u_block\n\n!========================================================================================!\n! subroutines wrmdrestart & rdmdrestart\n! write a file containing coordinates and velocities to restart the simulation\n  subroutine wrmdrestart(mol,dat,velo)\n    implicit none\n    type(coord) :: mol\n    type(mddata) :: dat\n    real(wp),intent(in) :: velo(3,mol%nat)\n    integer :: io,ich\n    character(len=256) :: atmp\n    if (.not.allocated(dat%restartfile)) then\n      write (atmp,'(a,i0,a)') 'crest_',dat%md_index,'.mdrestart'\n    else\n      atmp = dat%restartfile\n    end if\n    open (newunit=ich,file=trim(atmp)) !dat%restartfile)\n    write (ich,*) '-1.0'\n    do i = 1,mol%nat\n      write (ich,'(6D22.14)') mol%xyz(1:3,i),velo(1:3,i)\n    end do\n    close (ich)\n    return\n  end subroutine wrmdrestart\n\n  subroutine rdmdrestart(mol,dat,velo,fail)\n    implicit none\n    type(coord) :: mol\n    type(mddata) :: dat\n    real(wp),intent(inout) :: velo(3,mol%nat)\n    logical,intent(out) :: fail\n    real(wp) :: dum\n    character(len=256) :: atmp\n    integer :: io,ich\n\n    fail = .false.\n\n    if (allocated(dat%restartfile)) then\n      inquire (file=dat%restartfile,exist=ex)\n    end if\n    if (dat%restart.and.ex) then\n      open (newunit=ich,file=dat%restartfile)\n      do\n        read (ich,*,iostat=io) dum\n        if (io < 0) exit\n        do i = 1,mol%nat\n          read (ich,'(a)',iostat=io) atmp\n          if (io < 0) exit\n          read (atmp,'(6D22.14)',iostat=io) mol%xyz(1:3,i),velo(1:3,i)\n          if (io /= 0) exit\n        end do\n        exit\n      end do\n      if (io /= 0) then\n        write (0,*) 'failed to read MD restart file.'\n        fail = .true.\n      end if\n      close (ich)\n    else\n      fail = .true.\n    end if\n\n    return\n  end subroutine rdmdrestart\n\n!========================================================================================!\n! subroutine mdinitu\n! initialize MD velocities, either by reading a restart file\n! or by setting them randomly\n  subroutine mdinitu(mol,dat,velo,mass,Ekin,pr)\n    implicit none\n    type(coord) :: mol\n    type(mddata) :: dat\n    real(wp),intent(inout) :: velo(3,mol%nat)\n    real(wp),intent(in) :: mass(mol%nat)\n    real(wp),intent(in) :: Ekin\n    logical,intent(in) :: pr\n    real :: x(3),ranf\n    integer :: n\n    real(wp) :: eperat,v,f,t,edum,f2\n    integer,allocatable :: iseed(:)\n    logical :: newvelos\n    integer :: i\n\n    newvelos = .true.\n\n    !>--- from restart file\n    if (dat%restart) then\n      call rdmdrestart(mol,dat,velo,newvelos)\n      if (pr.and.(.not.newvelos)) then\n        write (*,'(1x,a,6x,l)') 'read restart file  :',.not.newvelos\n      end if\n    end if\n\n    !>--- newly initialized\n    if (newvelos) then\n      if (dat%samerand) then\n        call random_seed(size=n)\n        allocate (iseed(n),source=1)\n        call random_seed(put=iseed)\n      else\n        call random_seed()\n      end if\n      eperat = Ekin/(3.0_wp*float(mol%nat))\n      do i = 1,mol%nat\n        call random_number(x)\n        f2 = 1.0_wp\n        if (mol%at(i) .eq. 1) f2 = 2.0_wp\n        v = sqrt(2*eperat/mass(i))\n        f = 1.0_wp\n        if (x(1) .gt. 0.5_wp) f = -1.0_wp\n        velo(1,i) = v*f*f2\n        f = 1.0_wp\n        if (x(2) .gt. 0.5_wp) f = -1.0_wp\n        velo(2,i) = v*f*f2\n        f = 1.0d0\n        if (x(3) .gt. 0.5_wp) f = -1.0_wp\n        velo(3,i) = v*f*f2\n      end do\n    end if\n    call ekinet(mol%nat,velo,mass,edum)\n    t = edum/(0.5_wp*3.0_wp*float(mol%nat)*0.316681534524639E-05)\n    return\n  end subroutine mdinitu\n\n!========================================================================================!\n! subroutine thermostating\n! helper routine to re-scale velocities,\n! i.e., thermostating\n\n  subroutine thermostating(mol,dat,t,scal)\n    implicit none\n\n    type(coord) :: mol\n    type(mddata) :: dat\n    real(wp),intent(in) :: t\n    real(wp),intent(out) :: scal\n\n    scal = 1.0_wp\n\n    if (.not.dat%thermostat) return\n\n    select case (trim(dat%thermotype))\n    case ('berendsen')\n      scal = dsqrt(1.0d0+(dat%tstep/dat%thermo_damp) &\n                  &     *(dat%tsoll/t-1.0_wp))\n    case default !>-- (also berendsen thermostat)\n      scal = dsqrt(1.0d0+(dat%tstep/dat%thermo_damp) &\n                  &     *(dat%tsoll/t-1.0_wp))\n    end select\n\n    return\n  end subroutine thermostating\n\n  subroutine thermostatprint(dat,pr)\n    implicit none\n    type(mddata) :: dat\n    logical,intent(in) :: pr\n\n    if (.not.pr) return\n    if (dat%thermostat) then\n      select case (trim(dat%thermotype))\n      case ('berendsen')\n        write (*,'('' thermostat         :'',1x,a  )') trim(dat%thermotype)\n      case default !>-- (also berendsen thermostat)\n        write (*,'('' thermostat         :'',1x,a  )') 'berendsen'\n      end select\n    else\n      write (*,'('' thermostat         :'',1x,a  )') 'OFF'\n    end if\n\n    return\n  end subroutine thermostatprint\n\n!========================================================================================!\n! subroutine zeroz\n! remove z-directional acceleration of selected atoms\n  subroutine zeroz(nat,acc,apply)\n    implicit none\n    integer,intent(in) :: nat\n    real(wp),intent(inout) :: acc(3,nat)\n    logical,intent(in) :: apply(nat)\n    integer :: i\n    do i = 1,nat\n      if (apply(i)) acc(3,i) = 0.0_wp\n    end do\n    return\n  end subroutine zeroz\n\n!========================================================================================!\n! subroutine rmrottr\n! some MATHs to remove translational and rotational velocities\n  subroutine rmrottr(natoms,mass,vel_atom,c)\n    implicit none\n    integer :: natoms\n    real(wp) :: vel_atom(3,natoms),c(3,natoms),mass(natoms)\n    real(wp) :: rlm(3),ram(3),omega(3)\n    real(wp) :: ixx,iyy,izz,ixy,ixz,iyz,dummy\n    real(wp) :: fixx,fiyy,fizz,fixy,fixz,fiyz,COM(3)\n    real(wp) :: inertia(3,3),angmom(3)\n    real(wp) :: tmass\n    integer :: i\n\n    rlm = 0.0\n    ram = 0.0\n    call centerofmass(natoms,c,mass,tmass,COM)\n    angmom = 0.0\n    do i = 1,natoms\n      c(1,i) = c(1,i)-COM(1)\n      c(2,i) = c(2,i)-COM(2)\n      c(3,i) = c(3,i)-COM(3)\n      angmom(1) = angmom(1)+mass(i)*(c(2,i)*vel_atom(3,i)-&\n         &                                      c(3,i)*vel_atom(2,i))\n      angmom(2) = angmom(2)+mass(i)*(c(3,i)*vel_atom(1,i)-&\n         &                                      c(1,i)*vel_atom(3,i))\n      angmom(3) = angmom(3)+mass(i)*(c(1,i)*vel_atom(2,i)-&\n         &                                      c(2,i)*vel_atom(1,i))\n    end do\n    ixx = 0.0\n    iyy = 0.0\n    izz = 0.0\n    ixy = 0.0\n    ixz = 0.0\n    iyz = 0.0\n    do i = 1,natoms\n      ixx = ixx+mass(i)*(c(2,i)*c(2,i)+c(3,i)*c(3,i))\n      iyy = iyy+mass(i)*(c(3,i)*c(3,i)+c(1,i)*c(1,i))\n      izz = izz+mass(i)*(c(1,i)*c(1,i)+c(2,i)*c(2,i))\n      ixy = ixy-mass(i)*c(1,i)*c(2,i)\n      ixz = ixz-mass(i)*c(1,i)*c(3,i)\n      iyz = iyz-mass(i)*c(2,i)*c(3,i)\n    end do\n    inertia(1,1) = ixx\n    inertia(2,2) = iyy\n    inertia(3,3) = izz\n    inertia(1,2) = ixy\n    inertia(2,1) = ixy\n    inertia(1,3) = ixz\n    inertia(3,1) = ixz\n    inertia(2,3) = iyz\n    inertia(3,2) = iyz\n    call dmatinv(inertia,3,3,dummy)\n    omega = matmul(inertia,angmom)\n    do i = 1,natoms\n      rlm(1) = rlm(1)+mass(i)*vel_atom(1,i)\n      rlm(2) = rlm(2)+mass(i)*vel_atom(2,i)\n      rlm(3) = rlm(3)+mass(i)*vel_atom(3,i)\n    end do\n    do i = 1,natoms\n      ram(1) = (omega(2)*c(3,i)-omega(3)*c(2,i))\n      ram(2) = (omega(3)*c(1,i)-omega(1)*c(3,i))\n      ram(3) = (omega(1)*c(2,i)-omega(2)*c(1,i))\n\n      vel_atom(1,i) = vel_atom(1,i)-rlm(1)/tmass-ram(1)\n      vel_atom(2,i) = vel_atom(2,i)-rlm(2)/tmass-ram(2)\n      vel_atom(3,i) = vel_atom(3,i)-rlm(3)/tmass-ram(3)\n\n      c(1,i) = c(1,i)+COM(1)\n      c(2,i) = c(2,i)+COM(2)\n      c(3,i) = c(3,i)+COM(3)\n    end do\n\n  contains\n    subroutine centerofmass(natoms,c,mass,totmass,COM)\n      implicit none\n      integer natoms\n      real(wp) :: c(3,natoms),totmass,mass(natoms),COM(3)\n      integer :: i,j\n\n      COM(1) = 0.0\n      COM(2) = 0.0\n      COM(3) = 0.0\n\n      totmass = 0\n      do i = 1,natoms\n        totmass = totmass+mass(i)\n        COM(1) = COM(1)+mass(i)*c(1,i)\n        COM(2) = COM(2)+mass(i)*c(2,i)\n        COM(3) = COM(3)+mass(i)*c(3,i)\n      end do\n\n      COM(1) = COM(1)/totmass\n      COM(2) = COM(2)/totmass\n      COM(3) = COM(3)/totmass\n      return\n    end subroutine centerofmass\n\n    subroutine dmatinv(a,ldm,n,d)\n      implicit none\n      integer,intent(in) :: ldm,n\n      real(wp),intent(out) :: d\n      real(wp),intent(inout) :: a(ldm,*)\n      integer :: i,j,k,l(n),m(n)\n      real(wp) :: biga,temp\n      real(wp),parameter :: tol = 1.0d-12\n      !\n      d = 1.0_wp\n      !\n      do k = 1,n\n        l(k) = k\n        m(k) = k\n        biga = a(k,k)\n        do j = k,n\n          do i = k,n\n            if (abs(biga) .lt. abs(a(j,i))) then\n              biga = a(j,i)\n              l(k) = i\n              m(k) = j\n            end if\n          end do\n        end do\n        j = l(k)\n        if (j .gt. k) then\n          do i = 1,n\n            temp = -a(i,k)\n            a(i,k) = a(i,j)\n            a(i,j) = temp\n          end do\n        end if\n        i = m(k)\n        if (i .gt. k) then\n          do j = 1,n\n            temp = -a(k,j)\n            a(k,j) = a(i,j)\n            a(i,j) = temp\n          end do\n        end if\n        if (abs(biga) .lt. tol) then\n          d = 0.0_wp\n          return\n        end if\n        do i = 1,n\n          if (i .ne. k) a(k,i) = a(k,i)/(-biga)\n        end do\n        do i = 1,n\n          do j = 1,n\n            if (i .ne. k) then\n              if (j .ne. k) a(j,i) = a(k,i)*a(j,k)+a(j,i)\n            end if\n          end do\n        end do\n        do j = 1,n\n          if (j .ne. k) a(j,k) = a(j,k)/biga\n        end do\n        d = max(-1.0d25,min(1.0d25,d))\n        d = d*biga\n        a(k,k) = 1.0_wp/biga\n      end do\n      !\n      k = n\n      do\n        !\n        k = k-1\n        if (k .le. 0) exit\n        i = l(k)\n        if (i .gt. k) then\n          do j = 1,n\n            temp = a(k,j)\n            a(k,j) = -a(i,j)\n            a(i,j) = temp\n          end do\n        end if\n        j = m(k)\n        if (j .gt. k) then\n          do i = 1,n\n            temp = a(i,k)\n            a(i,k) = -a(i,j)\n            a(i,j) = temp\n          end do\n        end if\n      end do\n      !\n      return\n    end subroutine dmatinv\n  end subroutine rmrottr\n\n!========================================================================================!\n  subroutine md_init_mtd(mol,dat,pr)\n    implicit none\n    type(coord) :: mol\n    type(mddata) :: dat\n    logical :: pr\n    integer :: i\n\n    if (dat%simtype .ne. type_mtd) return\n    if (dat%npot < 1) return\n\n    do i = 1,dat%npot\n      call mtd_ini(mol,dat%mtd(i),dat%tstep,dat%length_ps,pr)\n    end do\n\n    return\n  end subroutine md_init_mtd\n\n!========================================================================================!\n  subroutine md_add_mtd(self,mtd)\n    implicit none\n    class(mddata) :: self\n    type(mtdpot) :: mtd\n    type(mtdpot),allocatable :: mtdtmp(:)\n    integer,allocatable :: cvtmp(:)\n    integer :: i,j,k\n\n    k = self%npot+1\n    allocate (mtdtmp(k))\n    allocate (cvtmp(k))\n    if (k > 1) then\n      do i = 1,k-1\n        mtdtmp(i) = self%mtd(i)\n        cvtmp(i) = self%cvtype(i)\n      end do\n    end if\n    mtdtmp(k) = mtd\n    cvtmp(k) = mtd%mtdtype\n    call move_alloc(mtdtmp,self%mtd)\n    call move_alloc(cvtmp,self%cvtype)\n    self%npot = k\n\n    !> if a metadynamics potential was added for the first time\n    !> change MD runtype to MTD accordingly\n    if (self%simtype == type_md) then\n      self%simtype = type_mtd\n    end if\n\n    return\n  end subroutine md_add_mtd\n\n!========================================================================================!\n  subroutine md_update_mtd(mol,dat,calc,pr)\n!*********************************************\n!* Update the collective variables for each\n!* metadynamics potential saved in mddata\n!*********************************************\n    implicit none\n    type(coord) :: mol\n    type(mddata) :: dat\n    type(calcdata) :: calc\n    logical :: pr\n    integer :: i\n\n    if (dat%simtype .ne. type_mtd) return\n    if (dat%npot < 1) return\n\n    do i = 1,dat%npot\n      select case (dat%cvtype(i))\n      case (cv_rmsd,cv_rmsd_static)\n        call cv_dump(mol,dat%mtd(i),0.0_wp,pr)\n      case default\n        cycle\n      end select\n    end do\n\n    return\n  end subroutine md_update_mtd\n\n!========================================================================================!\n  subroutine md_calc_mtd(mol,dat,epot,grd,pr)\n!***********************************************\n!* Calculate energy and gradient contributions\n!* from metadynamics potentials and add them to\n!* the current total energy and gradient\n!***********************************************\n!$  use omp_lib\n    implicit none\n    type(coord) :: mol\n    type(mddata) :: dat\n    real(wp),intent(inout) :: epot\n    real(wp),intent(inout) :: grd(3,mol%nat)\n    logical :: pr\n    integer :: i\n    real(wp) :: emtd\n    real(wp),allocatable :: grdmtd(:,:)\n\n    if (dat%simtype .ne. type_mtd) return\n    if (dat%npot < 1) return\n\n    !$omp critical\n    allocate (grdmtd(3,mol%nat),source=0.0_wp)\n    !$omp end critical\n    do i = 1,dat%npot\n      call calc_mtd(mol,dat%mtd(i),emtd,grdmtd)\n      epot = epot+emtd\n      grd = grd+grdmtd\n    end do\n    !$omp critical\n    deallocate (grdmtd)\n    !$omp end critical\n\n    return\n  end subroutine md_calc_mtd\n\n!========================================================================================!\n\n  subroutine md_defaults_fallback(self)\n!********************************************\n!* Check if selected parameters that are\n!* necessary to be able to run an MD\n!* have been set, and restore default\n!* values if not so\n!********************************************\n    implicit none\n    class(mddata) :: self\n    real(wp) :: dum\n\n    if (self%length_ps <= 0.0_wp) then\n      !> total runtime in ps\n      self%length_ps = 20.0_wp\n    end if\n    if (self%tstep <= 0.0_wp) then\n      !> time step in fs\n      self%tstep = 1.0_wp\n    end if\n    if (self%length_steps <= 0) then\n      !> simulation steps\n      self%length_steps = nint(self%length_ps*1000.0_wp/self%tstep)\n    end if\n    if (self%tsoll <= 0.0_wp) then\n      !> target temperature\n      self%tsoll = 298.15_wp\n    end if\n\n    if (self%dumpstep <= 0.0_wp) then\n      !> dump frequency in fs\n      self%dumpstep = 1000.0_wp\n    end if\n    if (self%sdump <= 0) then\n      !> trajectory structure dump every x steps\n      dum = max(1.0_wp, (self%dumpstep/self%tstep))\n      self%sdump = nint(dum)\n    end if\n\n    if (self%md_hmass <= 0.0_wp) then\n      !> hydrogen mass\n      self%md_hmass = 1.00794075_wp\n    end if\n\n    if (self%shake) then\n      !> SHAKE, if turned on but no mode selected\n      if (self%shk%shake_mode == 0) then\n        self%shk%shake_mode = 2 !> all bonds\n      end if\n    end if\n\n  end subroutine md_defaults_fallback\n!========================================================================================!\nend module dynamics_module\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/dynamics/dynamics_module.f90 b/src/dynamics/dynamics_module.f90
--- a/src/dynamics/dynamics_module.f90	
+++ b/src/dynamics/dynamics_module.f90	
@@ -98,6 +98,9 @@
     type(mtdpot),allocatable :: mtd(:)
     integer,allocatable :: cvtype(:)
 
+    !>--- on-the-fly multi-scale level choosing
+    integer,allocatable :: active_potentials(:)
+
   contains
     generic,public :: add => md_add_mtd
     procedure,private :: md_add_mtd
@@ -141,7 +144,7 @@
     real(wp),allocatable :: acc(:,:)
     real(wp),allocatable :: mass(:)
     real(wp),allocatable :: xyz_angstrom(:,:)
-
+    real(wp),allocatable :: backupweights(:)
     type(coord) :: molo
     real(wp) :: f
     real(wp) :: molmass,tmass
@@ -160,6 +163,7 @@
     term = 0
     tstep_au = dat%tstep*fstoau
     nfreedom = 3*mol%nat
+!> TODO fix frozen-atom degrees of freedom and SHAKE
     if (dat%shake) then
       call init_shake(mol%nat,mol%at,mol%xyz,dat%shk,pr)
       dat%nshake = dat%shk%ncons
@@ -172,6 +176,11 @@
     epav = 0.0_wp
     temp = 0.0_wp
 
+!>--- on-the-fly multiscale definition
+    if(allocated(dat%active_potentials))then
+      call calc%active(dat%active_potentials)
+    endif
+
 !>--- allocate data fields
     allocate (xyz_angstrom(3,mol%nat))
     allocate (molo%at(mol%nat),molo%xyz(3,mol%nat))
@@ -205,6 +214,9 @@
         end if
       end if
       write (*,'('' hydrogen mass /u   :'',f10.5 )') dat%md_hmass
+      if(allocated(dat%active_potentials))then
+       write (*,'('' active potentials  :'',i10)') size(dat%active_potentials,1)
+      endif
     end if
 
 !>--- set atom masses
@@ -232,6 +244,16 @@
     edum = f*dat%tsoll*0.5_wp*kB*float(nfreedom)
     call mdinitu(mol,dat,velo,mass,edum,pr)
     call ekinet(mol%nat,velo,mass,ekin)
+    if(calc%nfreeze > 0)then
+       do i = 1,mol%nat
+         if(calc%freezelist(i))then
+           acc(:,i) = 0.0_wp
+           grd(:,i) = 0.0_wp
+           velo(:,i) = 0.0_wp
+         endif
+       end do
+     endif
+
 
 !>--- initialize MTDs (if required)
     !$omp critical
@@ -332,6 +354,16 @@
       do i = 1,mol%nat
         acc(:,i) = -grd(:,i)/mass(i)
       end do
+
+      !>--- special setup for frozen atoms
+      if(calc%nfreeze > 0)then
+       do i = 1,mol%nat
+         if(calc%freezelist(i))then
+           acc(:,i) = 0.0_wp
+           grd(:,i) = 0.0_wp
+         endif
+       end do
+      endif
 
       !>--- store positions (at t); velocities are at t-1/2dt
       !$omp critical
@@ -355,8 +387,19 @@
       !>--- update velocities to t
       ! I think the factor of 1/2 for the acc is missing in the xtb version
       vel = thermoscal*(velo+0.5_wp*acc*tstep_au)
-      !>--- update positions to t+dt
-      mol%xyz = molo%xyz+vel*tstep_au
+
+      !>--- update positions to t+dt, except for frozen atoms
+      if(calc%nfreeze > 0)then
+       do i = 1,mol%nat
+         if(.not.calc%freezelist(i))then
+           mol%xyz(:,i) = molo%xyz(:,i)+vel(:,i)*tstep_au
+         else
+           vel(:,i) = 0.0_wp
+         endif
+       end do
+      else  
+        mol%xyz = molo%xyz+vel*tstep_au
+      endif
 
       !>--- estimate new velocities at t
       veln = 0.5_wp*(velo+vel)
@@ -435,6 +478,11 @@
     deallocate (molo%xyz,molo%at)
     deallocate (xyz_angstrom)
 
+!>--- restore weights if necessary
+    if(allocated(dat%active_potentials))then
+      call calc%active_restore()
+    endif
+
     return
   end subroutine dynamics
 
Index: src/parsing/confparse2.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022-2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!> NOTE: This is work in progress, not all input conventions have been set yet\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> INPUT FILE PARSER FOR CREST\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n!> A supplement to the parseflags routine\n!> in confparse.f90. This routine reads\n!> an input file (TOML format via the toml-f library)\n!>\n!> Input/Output:\n!>  env   -  crest's systemdata object, which\n!>           contains basically all information\n!>           for the calculation\n!>  fname -  name of the input file\n!>-----------------------------------------------\nsubroutine parseinputfile(env,fname)\n  use crest_parameters\n  !> modules for data storage in crest\n  use crest_data\n  use crest_calculator, only:calcdata\n  use dynamics_module,only:mddata\n\n  !> modules used for parsing the root_object\n  use parse_keyvalue,only:keyvalue\n  use parse_block,only:datablock\n  use parse_datastruct,only:root_object\n  use parse_maindata\n  use parse_inputfile,only:parse_input\n  use parse_calcdata,only:parse_calculation_data, &\n  &                         parse_dynamics_data\n  !> Declarations\n  implicit none\n  type(systemdata),intent(inout) :: env\n  character(len=*),intent(in) :: fname\n  type(root_object) :: dict\n  type(keyvalue)  :: kv\n  type(datablock) :: blk\n  type(calcdata) :: newcalc\n  type(mddata) :: mddat\n  logical :: ex,l1,l2\n  integer :: i,j,k,l\n\n!>--- check for the input files' existence\n  inquire (file=fname,exist=ex)\n  if (.not.ex) then\n    return\n  else\n    write (stdout,*) 'reading ',trim(fname)\n    env%legacy = .false.\n  end if\n\n!>--- read the file into the object 'dict'\n  call parse_input(fname,dict)\n  call dict%print()\n\n!>--- parse all root-level key-value pairs\n  do i = 1,dict%nkv\n    kv = dict%kv_list(i)\n    call parse_main_auto(env,kv)\n  end do\n\n!>--- parse all objects that write to env\n  do i = 1,dict%nblk\n    blk = dict%blk_list(i)\n    call parse_main_blk(env,blk)\n  end do\n\n!>--- check objects for a calculation setup\n!     i.e., all [calculation] and [[calculation.*]] blocks\n  call parse_calculation_data(newcalc,dict,l1)\n  if (l1) then\n    env%calc = newcalc\n    call env_calcdat_specialcases(env)\n  end if\n\n!>--- check for molecular dynamics setup\n!     i.e., all [dynamics] and [[dynamics.*]] blocks\n  call parse_dynamics_data(mddat,dict,l1)\n  if (l1) then\n    env%mddat = mddat\n  end if\n\n  call dict%deallocate()\n  return\nend subroutine parseinputfile\n\n!========================================================================================!\n!========================================================================================!\nsubroutine internal_constraint_repair(env)\n!*******************************************\n!* subroutine internal_constraint_setup\n!* 'repair' settings for constraints set up\n!* for the internal calculation engine\n!*******************************************\n  use crest_parameters\n  use crest_data\n  implicit none\n  type(systemdata) :: env\n  integer :: i,j,k,l,n\n  integer :: nat\n  logical,allocatable :: atms(:)\n\n  n = env%calc%nconstraints\n  if (n < 1) return\n\n  nat = env%nat\n\n  do i = 1,n\n    select case (env%calc%cons(i)%type)\n\n    case (4,5) !> wall, wall_fermi\n      if (env%calc%cons(i)%n == 0) then\n        !> if no #atoms have been specified, apply to all atoms\n        allocate (atms(nat))\n        atms = .true.\n        call env%calc%cons(i)%sphereupdate(nat,atms)\n        deallocate (atms)\n      end if\n\n    case default\n      continue\n    end select\n  end do\n\n  return\nend subroutine internal_constraint_repair\n\n!========================================================================================!\n!========================================================================================!\nsubroutine env_calcdat_specialcases(env)\n!****************************************************\n!* Some special treatments are sometimes necessary\n!* depending on a choosen calculation level,\n!* for example, a MD timestep adjustment for GFN-FF. \n!* This routine takes care of that, \n!* but some stuff (in particular MD settings) may be \n!* overwritten later in the respective block.\n!***************************************************\n  use crest_parameters\n  use crest_data\n  use crest_calculator\n  implicit none\n  type(systemdata) :: env\n\n  !> special case for GFN-FF calculations\n  if(any(env%calc%calcs(:)%id == jobtype%gfnff))then\n    env%mdstep = 1.5d0\n    env%hmass = 5.0d0\n    env%cts%cbonds_md = .true.\n    env%checkiso = .true.\n  endif\n\n\nend subroutine env_calcdat_specialcases\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/confparse2.f90 b/src/parsing/confparse2.f90
--- a/src/parsing/confparse2.f90	
+++ b/src/parsing/confparse2.f90	
@@ -24,17 +24,19 @@
 !> INPUT FILE PARSER FOR CREST
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!
 !========================================================================================!
-!> A supplement to the parseflags routine
-!> in confparse.f90. This routine reads
-!> an input file (TOML format via the toml-f library)
-!>
-!> Input/Output:
-!>  env   -  crest's systemdata object, which
-!>           contains basically all information
-!>           for the calculation
-!>  fname -  name of the input file
-!>-----------------------------------------------
+
 subroutine parseinputfile(env,fname)
+!****************************************************
+!* A supplement to the parseflags routine
+!* in confparse.f90. This routine reads
+!* an input file (TOML format via the toml-f library)
+!*
+!* Input/Output:
+!*  env   -  crest's systemdata object, which
+!*           contains basically all information
+!*           for the calculation
+!*  fname -  name of the input file
+!****************************************************
   use crest_parameters
   !> modules for data storage in crest
   use crest_data
@@ -80,7 +82,7 @@
     call parse_main_auto(env,kv)
   end do
 
-!>--- parse all objects that write to env
+!>--- parse all objects that write to env or global data
   do i = 1,dict%nblk
     blk = dict%blk_list(i)
     call parse_main_blk(env,blk)
@@ -100,6 +102,13 @@
   if (l1) then
     env%mddat = mddat
   end if
+
+!>--- check for lwONIOM setup (will be read at end of confparse)
+   do i = 1,dict%nblk
+      if(dict%blk_list(i)%header == 'lwoniom')then
+        env%ONIOM_toml = trim(fname)  
+      endif
+   enddo
 
   call dict%deallocate()
   return
@@ -132,10 +141,12 @@
     case (4,5) !> wall, wall_fermi
       if (env%calc%cons(i)%n == 0) then
         !> if no #atoms have been specified, apply to all atoms
+        write(*,*) 'restoring all atoms' 
         allocate (atms(nat))
         atms = .true.
         call env%calc%cons(i)%sphereupdate(nat,atms)
         deallocate (atms)
+        env%calc%cons(i)%ref = env%calc%cons(i)%ref * env%potscal
       end if
 
     case default
@@ -162,6 +173,8 @@
   use crest_calculator
   implicit none
   type(systemdata) :: env
+  integer :: i,j,k,l
+  integer :: refine_lvl
 
   !> special case for GFN-FF calculations
   if(any(env%calc%calcs(:)%id == jobtype%gfnff))then
@@ -172,4 +185,14 @@
   endif
 
 
+  !> check if any refinement is to be done between opt.
+  if(any(env%calc%calcs(:)%refine_lvl > 0))then
+    do i=1,env%calc%ncalculations 
+      refine_lvl = env%calc%calcs(i)%refine_lvl
+      if(refine_lvl <= 0 ) cycle
+      if(any(env%refine_queue(:) == refine_lvl)) cycle
+      call env%addrefine( refine_lvl )
+    enddo
+  endif
+
 end subroutine env_calcdat_specialcases
Index: src/parsing/parse_block.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nmodule parse_block\n  use crest_parameters\n  use filemod\n  use parse_keyvalue\n  implicit none\n\n  public :: datablock\n  type :: datablock\n    !> the data object's name\n    character(len=:),allocatable :: header\n    !> number & list of key value pairs\n    integer :: nkv = 0\n    type(keyvalue),allocatable :: kv_list(:)\n  contains\n    procedure :: addkv => blk_addkv\n    procedure :: print => blk_print\n    procedure :: fmt_header => blk_fmt_header\n    procedure :: deallocate => blk_deallocate\n  end type datablock\n\n  public :: parseblock\n  type :: parseblock\n    integer :: len = 0\n    character(len=:),allocatable :: header\n    character(len=:),allocatable :: content(:)\n  contains\n    procedure :: deallocate => deallocate_block\n    procedure :: print => print_block\n  end type parseblock\n\n  public :: parse_infile_block\n  public :: isheader\n\n!========================================================================================!\n!========================================================================================!\ncontains  !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\n!> the following routines are type-bound procedures\n\n!========================================================================================!\n  subroutine blk_addkv(self,kv)\n    implicit none\n    class(datablock) :: self\n    type(keyvalue) :: kv\n    type(keyvalue),allocatable :: newlist(:)\n    integer :: i,j\n    i = self%nkv\n    j = i+1\n    allocate (newlist(j))\n    newlist(1:i) = self%kv_list(1:i)\n    newlist(j) = kv\n    call move_alloc(newlist,self%kv_list)\n    self%nkv = j\n  end subroutine blk_addkv\n\n!========================================================================================!\n  subroutine blk_deallocate(self)\n    implicit none\n    class(datablock) :: self\n    self%header = ''\n    self%nkv = 0\n    if (allocated(self%kv_list)) deallocate (self%kv_list)\n  end subroutine blk_deallocate\n\n!========================================================================================!\n  subroutine blk_fmt_header(self)\n    implicit none\n    class(datablock) :: self\n    character(len=:),allocatable :: atmp\n    integer :: l\n    if (.not.allocated(self%header)) return\n\n    self%header = adjustl(self%header)\n    l = len_trim(self%header)\n    if (self%header(1:1) .eq. '['.and. &\n    &  self%header(l:l) .eq. ']') then\n      atmp = self%header(2:l-1)\n      call move_alloc(atmp,self%header)\n    end if\n  end subroutine blk_fmt_header\n\n!========================================================================================!\n  subroutine blk_print(self)\n    class(datablock) :: self\n    integer :: i\n    write (stdout,'(1x,\"object:\",1x,a)') self%header\n    do i = 1,self%nkv\n      if (i < self%nkv) then\n        write (stdout,'(1x,a,a)') '├──',trim(self%kv_list(i)%print())\n      else\n        write (stdout,'(1x,a,a)') '└──',trim(self%kv_list(i)%print())\n      end if\n    end do\n  end subroutine blk_print\n!========================================================================================!\n\n!> the following routines are only used in the fallback parsing routines\n!> the standard implementation uses the toml-f library instead (see parse_toml.F90)\n\n!========================================================================================!\n  subroutine read_datablock(file,i,blk)\n    implicit none\n    type(filetype),intent(inout)  :: file\n    type(datablock),intent(inout) :: blk\n    integer,intent(in) :: i\n\n    type(parseblock) :: rawblk\n    type(keyvalue) :: kvdum\n    integer :: j,k,io\n\n    call blk%deallocate()\n\n    call parse_infile_block(file,i,rawblk)\n    blk%header = rawblk%header\n    call clearheader(blk%header)\n\n    do j = 1,rawblk%len\n      call get_keyvalue(kvdum,rawblk%content(j),io)\n      if (io == 0) then\n        call blk%addkv(kvdum)\n      end if\n    end do\n\n  end subroutine read_datablock\n!========================================================================================!\n!> for given input file parse the next block\n  subroutine parse_infile_block(file,i,rawblk)\n    implicit none\n    type(filetype),intent(inout)      :: file\n    type(parseblock),intent(inout) :: rawblk\n    integer,intent(in) :: i\n    logical :: saveblock\n    integer :: j,k,l\n    character(len=:),allocatable :: src\n\n    call rawblk%deallocate()\n\n    src = repeat(' ',file%lwidth)\n\n    !saveblock = .false.\n    !iloop: do i = 1,file%nlines\n    !  if (i < file%current_line) cycle\n    !  if (.not. saveblock) then\n    if (isheader(file%line(i))) then\n      saveblock = .true.\n      rawblk%header = file%line(i)\n      !      cycle\n    end if\n    !  end if\n    !> get blocklength\n    k = i+1\n    l = 0\n    jloop: do j = k,file%nlines\n      if (isheader(file%line(j))) then\n        file%current_line = j\n        exit jloop\n      end if\n      if (len_trim(file%line(j)) > 0) then\n        l = l+1\n      end if\n      if (j == file%nlines) file%current_line = j\n    end do jloop\n    !if (l < 1) exit iloop\n    if (l < 1) return\n    !> get block\n    rawblk%len = l\n    allocate (rawblk%content(l),source=src)\n    l = 0\n    jloop2: do j = k,file%nlines\n      if (isheader(file%line(j))) then\n        saveblock = .false.\n        return\n      end if\n      if (len_trim(file%line(j)) > 0) then\n        l = l+1\n        rawblk%content(l) = file%line(j)\n      end if\n    end do jloop2\n    !end do iloop\n\n    return\n  end subroutine parse_infile_block\n\n!========================================================================================!\n!> deallocate block data\n  subroutine deallocate_block(self)\n    implicit none\n    class(parseblock) :: self\n\n    self%len = 0\n    if (allocated(self%header)) deallocate (self%header)\n    if (allocated(self%content)) deallocate (self%content)\n    return\n  end subroutine deallocate_block\n\n!========================================================================================!\n!> deallocate block data\n  subroutine print_block(self)\n    implicit none\n    class(parseblock) :: self\n    integer :: i\n\n    write (*,*)\n    if (allocated(self%header)) then\n      write (*,*) trim(self%header)\n      if (allocated(self%content)) then\n        do i = 1,self%len\n          write (*,*) self%content(i)\n        end do\n      end if\n    end if\n    return\n  end subroutine print_block\n\n!=======================================================================================!\n!> check if string is a block header\n  function isheader(str)\n    implicit none\n    logical :: isheader\n    character(len=*) :: str\n    character(len=:),allocatable :: atmp\n    integer :: l\n    isheader = .false.\n    atmp = adjustl(trim(str))\n    l = len_trim(atmp)\n    if (l < 1) return\n    if ((atmp(1:1) == '[').and.(atmp(l:l) == ']')) then\n      isheader = .true.\n    end if\n    return\n  end function isheader\n\n  subroutine clearheader(hdr)\n    implicit none\n    character(len=*) :: hdr\n    integer :: i,k,l\n    character(len=:),allocatable :: atmp,btmp\n    character(len=1) :: s\n    atmp = adjustl(hdr)\n    atmp = trim(atmp)\n    !>remove whitespaces\n    l = len_trim(atmp)\n    btmp = ''\n    do i = 1,l\n      s = atmp(i:i)\n      if (s == ' ') cycle\n      btmp = btmp//s\n    end do\n    atmp = btmp\n    !> cut off \"[\" and \"]\"\n    k = len_trim(atmp)-1\n    atmp = atmp(2:k)\n    hdr = trim(atmp)\n    return\n  end subroutine clearheader\n\n!========================================================================================!\nend module parse_block\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/parse_block.f90 b/src/parsing/parse_block.f90
--- a/src/parsing/parse_block.f90	
+++ b/src/parsing/parse_block.f90	
@@ -216,7 +216,7 @@
   end subroutine print_block
 
 !=======================================================================================!
-!> check if string is a block header
+!> check if string is a toml block header
   function isheader(str)
     implicit none
     logical :: isheader
Index: src/parsing/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nset(dir \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\nlist(APPEND srcs\n   \"${dir}/confparse2.f90\"\n   \"${dir}/parse_block.f90\"\n   \"${dir}/parse_calcdata.f90\"\n   \"${dir}/parse_maindata.f90\"\n   \"${dir}/parse_datastruct.f90\"\n   \"${dir}/parse_toml.F90\"\n   \"${dir}/parse_inputfile.F90\"\n   \"${dir}/parse_keyvalue.f90\"\n)\n\nset(srcs ${srcs} PARENT_SCOPE)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/CMakeLists.txt b/src/parsing/CMakeLists.txt
--- a/src/parsing/CMakeLists.txt	
+++ b/src/parsing/CMakeLists.txt	
@@ -18,10 +18,13 @@
 
 list(APPEND srcs
    "${dir}/confparse2.f90"
+   "${dir}/constraining.f90"
    "${dir}/parse_block.f90"
    "${dir}/parse_calcdata.f90"
    "${dir}/parse_maindata.f90"
    "${dir}/parse_datastruct.f90"
+   "${dir}/parse_xtbinput.f90"
+   "${dir}/parse_csv.f90"
    "${dir}/parse_toml.F90"
    "${dir}/parse_inputfile.F90"
    "${dir}/parse_keyvalue.f90"
Index: src/geo.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nmodule geo\n  use iso_fortran_env,wp => real64\n  implicit none\n  public\n\n  real(wp),parameter,private :: pi = acos(0.0_wp)*2.0_wp\n  real(wp),parameter,private :: pi2 = pi*2.0_wp\n \n!================================================================================!\n!================================================================================!\ncontains  !> MODULE PROCEDURES START HERE\n!================================================================================!\n!================================================================================!\n!> length of a vector\n    pure function vec_len(v) result(l)\n        implicit none\n        real(wp), intent(in) :: v(3)\n        real(wp) :: l\n        l = sqrt(dot_product(v,v))\n    end function\n!================================================================================!\n!> euclidean distance between two points\n    pure function distance(p,q) result(l)\n        implicit none\n        real(wp), intent(in) :: p(3),q(3)\n        real(wp) :: l,pq(3)\n        pq(:) = p(:) - q(:)\n        l = vec_len(pq)\n    end function distance\n!================================================================================!\n!> normalize the vector k\n  subroutine unitv(k)\n    implicit none\n    real(wp),intent(inout) :: k(3)\n    k = k / vec_len(k)\n    return\n  end subroutine unitv\n!================================================================================!\n!> calculate angle theta between vectors u and v\n  function tangle(u,v) result(angle)\n    implicit none\n    real(wp) :: angle\n    real(wp),intent(in) :: u(3)\n    real(wp),intent(in) :: v(3)\n    real(wp) :: ulen\n    real(wp) :: vlen\n    real(wp) :: uv\n\n    angle = 0.0_wp\n    ulen = vec_len(u)\n    vlen = vec_len(v)\n    !> uv = u(1)*v(1) + u(2)*v(2) + u(3)*v(3)\n    uv = dotp(u,v,3)\n    !> acos returns a value between 0 and pi\n    angle = acos(uv / (ulen * vlen))\n    return\n  end function tangle\n!================================================================================!\n!> calculate dot product between two vectors u and v\n  function dotp(u,v,n) result(dotproduct)\n    implicit none\n    real(wp) :: dotproduct\n    integer :: n     !dimension\n    real(wp),intent(in) :: u(n) !first vector\n    real(wp),intent(in) :: v(n) !second vector\n    integer :: i\n    dotproduct = 0.0_wp\n    do i = 1,n\n      dotproduct = dotproduct + u(i) * v(i)\n    end do\n    return\n  end function dotp\n!================================================================================!\n!> calculate the cross product between two vectors u and v\n  subroutine crosp(u,v,uv)\n    implicit none\n    real(wp),intent(in) :: u(3) !first vector\n    real(wp),intent(in) :: v(3) !second vector\n    real(wp),intent(out) :: uv(3)\n    uv = 0.0_wp\n    uv(1) = u(2) * v(3) - u(3) * v(2)\n    uv(2) = u(3) * v(1) - u(1) * v(3)\n    uv(3) = u(1) * v(2) - u(2) * v(1)\n    return\n  end subroutine crosp\n!================================================================================!\n!> calculate the normal between two vectors u and v spanning a plane\n!> a third point (the origin) can optionally be provided\n  function normal(u,v,o) result(nvec)\n    implicit none\n    real(wp) :: nvec(3)\n    real(wp),intent(in) :: u(3) !> first vector\n    real(wp),intent(in) :: v(3) !> second vector\n    real(wp),intent(in),optional :: o(3) !> optional, origin\n    real(wp) :: utmp(3), vtmp(3)\n    nvec = 0.0_wp\n    if(present(o))then\n      utmp(1:3) = u(1:3) - o(1:3)\n      vtmp(1:3) = v(1:3) - o(1:3)\n    else\n      utmp = u\n      vtmp = v\n    endif\n    call crosp(utmp,vtmp,nvec)\n    call unitv(nvec)\n    return\n  end function normal\n!================================================================================!\n!> calculate the dihedral angle between three vectors u, v, and w\n!> spanning two half planes. \n!> For four given points A-B-C-D defining the dihedral angle between the planes\n!> A-B-C and B-C-D, the vectors are u:A->B, v:B->C, and w:C->D\n!> The result will be in radians between −π (-180°) and π (180°).\n  function dihedral(u,v,w) result(dihed)\n    implicit none\n    real(wp) :: dihed\n    real(wp),intent(in) :: u(3) !> first vector\n    real(wp),intent(in) :: v(3) !> second vector\n    real(wp),intent(in) :: w(3) !> third vector\n    real(wp) :: uv(3), vw(3), uvw(3), tmp1, tmp2\n    dihed = 0.0_wp\n    call crosp(u, v, uv)\n    call crosp(v, w, vw)\n    call crosp(uv, vw, uvw) \n    tmp1 = dot_product(v, uvw) + 1.0d-10  !> small constant to avoid singularities\n    tmp2 = vec_len(v) * dot_product(uv,vw)\n    dihed = atan2(tmp1,tmp2) \n    return\n  end function dihedral\n\n!================================================================================!\n!> shift an angle x into the interval −π (-180°) <= x < π (180°)\n  function angleshift(x) result(xnew)\n     implicit none  \n      real(wp) :: x\n      real(wp) :: xnew\n      real(wp) :: f\n      f = floor(0.5_wp + ( x / pi2 ))\n      xnew = 2.0_wp*((x/pi2) - f)*pi\n  end function angleshift\n\n\n!================================================================================!\n!================================================================================!\n!> rotate around z axis\n  subroutine rotRz(u,theta)\n    implicit none\n    real(wp) :: u(3) !first vector\n    real(wp) :: v(3) !second vector\n    real(wp) :: theta\n    real(wp) :: Rz(3,3)\n\n    Rz = 0.0_wp\n    Rz = reshape(&\n      &  [  cos(theta),  sin(theta),   0.0_wp,   &\n      &    -sin(theta),  cos(theta),   0.0_wp,   &\n      &         0.0_wp,      0.0_wp,   1.0_wp ], &\n      &  [3,3])\n    \n    v = 0.0_wp\n    v = matmul(Rz,u)\n\n    u = v\n    return\n  end subroutine rotRz\n!================================================================================!\n  subroutine rotRz180(u)\n    implicit none\n    real(wp) :: u(3) !first vector\n    real(wp) :: v(3) !second vector\n    real(wp) :: Rz(3,3)\n\n    Rz = 0.0_wp\n    Rz(1,1) = -1.0_wp !cos(theta)\n    Rz(2,1) = 0.0_wp  !sin(theta)\n    Rz(1,2) = 0.0_wp  !-sin(theta)\n    Rz(2,2) = -1.0_wp !cos(theta)\n    Rz(3,3) = 1.0_wp\n\n    v = 0.0_wp\n    v = matmul(Rz,u)\n\n    u = v\n    return\n  end subroutine rotRz180\n!================================================================================!\n!> rotate around y axis\n  subroutine rotRy(u,theta)\n    implicit none\n    real(wp) :: u(3) !first vector\n    real(wp) :: v(3) !second vector\n    real(wp) :: theta\n    real(wp) :: Ry(3,3)\n\n    Ry = reshape(&\n      &  [  cos(theta), 0.0_wp, sin(theta),   &\n      &         0.0_wp, 1.0_wp,     0.0_wp,   &\n      &    -sin(theta), 0.0_wp, cos(theta) ], &\n      &  [3,3])\n\n    v = 0.0_wp\n    v = matmul(Ry,u)\n    u = v\n    return\n  end subroutine rotRy\n!================================================================================!\n  subroutine rotRy180(u)\n    implicit none\n    real(wp) :: u(3) !first vector\n    real(wp) :: v(3) !second vector\n    real(wp) :: Ry(3,3)\n\n    Ry = 0.0_wp\n    Ry(1,1) = -1.0_wp !cos(theta)\n    Ry(3,1) = 0.0_wp  !-sin(theta)\n    Ry(3,1) = 0.0_wp  !sin(theta)\n    Ry(3,3) = -1.0_wp !cos(theta)\n    Ry(2,2) = 1.0_wp\n\n    v = 0.0_wp\n    v = matmul(Ry,u)\n    u = v\n    return\n  end subroutine rotRy180\n!================================================================================!\n!> rotate around x axis\n  subroutine rotRx(u,theta)\n    implicit none\n    real(wp) :: u(3) !first vector\n    real(wp) :: v(3) !second vector\n    real(wp) :: theta\n    real(wp) :: Rx(3,3)\n\n    Rx = reshape(&\n      &  [ 1.0_wp,      0.0_wp,      0.0_wp,   &\n      &    0.0_wp,  cos(theta),  sin(theta),   &\n      &    0.0_wp, -sin(theta),  cos(theta) ], &\n      &  [3,3])\n\n    v = 0.0_wp\n    v = matmul(Rx,u)\n    u = v\n    return\n  end subroutine rotRx\n!================================================================================!\n!> rotate around x axis 180deg\n  subroutine rotRx180(u)\n    implicit none\n    real(wp) :: u(3) !first vector\n    real(wp) :: v(3) !second vector\n    real(wp) :: Rx(3,3)\n\n    Rx = 0.0_wp\n    Rx(2,2) = -1.0_wp !cos(theta)\n    Rx(2,3) = 0.0_wp  !-sin(theta)\n    Rx(2,3) = 0.0_wp  !sin(theta)\n    Rx(3,3) = -1.0_wp !cos(theta)\n    Rx(1,1) = 1.0_wp\n\n    v = 0.0_wp\n    v = matmul(Rx,u)\n    u = v\n    return\n  end subroutine rotRx180\n\n!================================================================================!\n!> rodriguez rotation of v, arount vector k  with angle theta\n  subroutine rodrot(v,k,theta)\n    implicit none\n    real(wp) :: v(3)    !> point to be rotated\n    real(wp) :: k(3)    !> the rotation axis !UNIT VECTOR!\n    real(wp) :: theta   !> angle of rotation around k\n    real(wp) :: vnew(3)\n    real(wp) :: kxv(3)\n    real(wp) :: kv\n    integer :: i\n\n    call unitv(k) !> make k into a unit vector (just in case)\n\n    !> v' = v*cos(theta) + (k x v)sin(theta) + k(k*v)(1-cos(theta)\n    vnew = 0\n    call crosp(k,v,kxv)\n    kv = dotp(k,v,3)\n    do i = 1,3\n      vnew(i) = v(i) * cos(theta)\n      vnew(i) = vnew(i) + kxv(i) * sin(theta)\n      vnew(i) = vnew(i) + k(i) * kv * (1 - cos(theta))\n    end do\n    v = vnew\n    return\n  end subroutine rodrot\n!================================================================================!\n!================================================================================!\nend module geo\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/geo.f90 b/src/geo.f90
--- a/src/geo.f90	
+++ b/src/geo.f90	
@@ -24,34 +24,34 @@
 
   real(wp),parameter,private :: pi = acos(0.0_wp)*2.0_wp
   real(wp),parameter,private :: pi2 = pi*2.0_wp
- 
+
 !================================================================================!
 !================================================================================!
 contains  !> MODULE PROCEDURES START HERE
 !================================================================================!
 !================================================================================!
 !> length of a vector
-    pure function vec_len(v) result(l)
-        implicit none
-        real(wp), intent(in) :: v(3)
-        real(wp) :: l
-        l = sqrt(dot_product(v,v))
-    end function
+  pure function vec_len(v) result(l)
+    implicit none
+    real(wp),intent(in) :: v(3)
+    real(wp) :: l
+    l = sqrt(dot_product(v,v))
+  end function
 !================================================================================!
 !> euclidean distance between two points
-    pure function distance(p,q) result(l)
-        implicit none
-        real(wp), intent(in) :: p(3),q(3)
-        real(wp) :: l,pq(3)
-        pq(:) = p(:) - q(:)
-        l = vec_len(pq)
-    end function distance
+  pure function distance(p,q) result(l)
+    implicit none
+    real(wp),intent(in) :: p(3),q(3)
+    real(wp) :: l,pq(3)
+    pq(:) = p(:)-q(:)
+    l = vec_len(pq)
+  end function distance
 !================================================================================!
 !> normalize the vector k
   subroutine unitv(k)
     implicit none
     real(wp),intent(inout) :: k(3)
-    k = k / vec_len(k)
+    k = k/vec_len(k)
     return
   end subroutine unitv
 !================================================================================!
@@ -71,7 +71,7 @@
     !> uv = u(1)*v(1) + u(2)*v(2) + u(3)*v(3)
     uv = dotp(u,v,3)
     !> acos returns a value between 0 and pi
-    angle = acos(uv / (ulen * vlen))
+    angle = acos(uv/(ulen*vlen))
     return
   end function tangle
 !================================================================================!
@@ -85,7 +85,7 @@
     integer :: i
     dotproduct = 0.0_wp
     do i = 1,n
-      dotproduct = dotproduct + u(i) * v(i)
+      dotproduct = dotproduct+u(i)*v(i)
     end do
     return
   end function dotp
@@ -97,9 +97,9 @@
     real(wp),intent(in) :: v(3) !second vector
     real(wp),intent(out) :: uv(3)
     uv = 0.0_wp
-    uv(1) = u(2) * v(3) - u(3) * v(2)
-    uv(2) = u(3) * v(1) - u(1) * v(3)
-    uv(3) = u(1) * v(2) - u(2) * v(1)
+    uv(1) = u(2)*v(3)-u(3)*v(2)
+    uv(2) = u(3)*v(1)-u(1)*v(3)
+    uv(3) = u(1)*v(2)-u(2)*v(1)
     return
   end subroutine crosp
 !================================================================================!
@@ -111,22 +111,22 @@
     real(wp),intent(in) :: u(3) !> first vector
     real(wp),intent(in) :: v(3) !> second vector
     real(wp),intent(in),optional :: o(3) !> optional, origin
-    real(wp) :: utmp(3), vtmp(3)
+    real(wp) :: utmp(3),vtmp(3)
     nvec = 0.0_wp
-    if(present(o))then
-      utmp(1:3) = u(1:3) - o(1:3)
-      vtmp(1:3) = v(1:3) - o(1:3)
+    if (present(o)) then
+      utmp(1:3) = u(1:3)-o(1:3)
+      vtmp(1:3) = v(1:3)-o(1:3)
     else
       utmp = u
       vtmp = v
-    endif
+    end if
     call crosp(utmp,vtmp,nvec)
     call unitv(nvec)
     return
   end function normal
 !================================================================================!
 !> calculate the dihedral angle between three vectors u, v, and w
-!> spanning two half planes. 
+!> spanning two half planes.
 !> For four given points A-B-C-D defining the dihedral angle between the planes
 !> A-B-C and B-C-D, the vectors are u:A->B, v:B->C, and w:C->D
 !> The result will be in radians between −π (-180°) and π (180°).
@@ -136,29 +136,28 @@
     real(wp),intent(in) :: u(3) !> first vector
     real(wp),intent(in) :: v(3) !> second vector
     real(wp),intent(in) :: w(3) !> third vector
-    real(wp) :: uv(3), vw(3), uvw(3), tmp1, tmp2
+    real(wp) :: uv(3),vw(3),uvw(3),tmp1,tmp2
     dihed = 0.0_wp
-    call crosp(u, v, uv)
-    call crosp(v, w, vw)
-    call crosp(uv, vw, uvw) 
-    tmp1 = dot_product(v, uvw) + 1.0d-10  !> small constant to avoid singularities
-    tmp2 = vec_len(v) * dot_product(uv,vw)
-    dihed = atan2(tmp1,tmp2) 
+    call crosp(u,v,uv)
+    call crosp(v,w,vw)
+    call crosp(uv,vw,uvw)
+    tmp1 = dot_product(v,uvw)+1.0d-10  !> small constant to avoid singularities
+    tmp2 = vec_len(v)*dot_product(uv,vw)
+    dihed = atan2(tmp1,tmp2)
     return
   end function dihedral
 
 !================================================================================!
 !> shift an angle x into the interval −π (-180°) <= x < π (180°)
   function angleshift(x) result(xnew)
-     implicit none  
-      real(wp) :: x
-      real(wp) :: xnew
-      real(wp) :: f
-      f = floor(0.5_wp + ( x / pi2 ))
-      xnew = 2.0_wp*((x/pi2) - f)*pi
+    implicit none
+    real(wp) :: x
+    real(wp) :: xnew
+    real(wp) :: f
+    f = floor(0.5_wp+(x/pi2))
+    xnew = 2.0_wp*((x/pi2)-f)*pi
   end function angleshift
 
-
 !================================================================================!
 !================================================================================!
 !> rotate around z axis
@@ -170,12 +169,13 @@
     real(wp) :: Rz(3,3)
 
     Rz = 0.0_wp
+!&<
     Rz = reshape(&
-      &  [  cos(theta),  sin(theta),   0.0_wp,   &
-      &    -sin(theta),  cos(theta),   0.0_wp,   &
-      &         0.0_wp,      0.0_wp,   1.0_wp ], &
-      &  [3,3])
-    
+    &  [ cos(theta), sin(theta), 0.0_wp,   &
+    &   -sin(theta), cos(theta), 0.0_wp,   &
+    &        0.0_wp,     0.0_wp, 1.0_wp], &
+    &  [3,3])
+!&>
     v = 0.0_wp
     v = matmul(Rz,u)
 
@@ -212,9 +212,9 @@
     real(wp) :: Ry(3,3)
 
     Ry = reshape(&
-      &  [  cos(theta), 0.0_wp, sin(theta),   &
-      &         0.0_wp, 1.0_wp,     0.0_wp,   &
-      &    -sin(theta), 0.0_wp, cos(theta) ], &
+      &  [cos(theta),0.0_wp,sin(theta),   &
+      &         0.0_wp,1.0_wp,0.0_wp,   &
+      &    -sin(theta),0.0_wp,cos(theta)], &
       &  [3,3])
 
     v = 0.0_wp
@@ -251,9 +251,9 @@
     real(wp) :: Rx(3,3)
 
     Rx = reshape(&
-      &  [ 1.0_wp,      0.0_wp,      0.0_wp,   &
-      &    0.0_wp,  cos(theta),  sin(theta),   &
-      &    0.0_wp, -sin(theta),  cos(theta) ], &
+      &  [1.0_wp,0.0_wp,0.0_wp,   &
+      &    0.0_wp,cos(theta),sin(theta),   &
+      &    0.0_wp,-sin(theta),cos(theta)], &
       &  [3,3])
 
     v = 0.0_wp
@@ -301,9 +301,9 @@
     call crosp(k,v,kxv)
     kv = dotp(k,v,3)
     do i = 1,3
-      vnew(i) = v(i) * cos(theta)
-      vnew(i) = vnew(i) + kxv(i) * sin(theta)
-      vnew(i) = vnew(i) + k(i) * kv * (1 - cos(theta))
+      vnew(i) = v(i)*cos(theta)
+      vnew(i) = vnew(i)+kxv(i)*sin(theta)
+      vnew(i) = vnew(i)+k(i)*kv*(1-cos(theta))
     end do
     v = vnew
     return
Index: src/parsing/parse_calcdata.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022-2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!> NOTE: This is work in progress, not all input conventions have been set yet\n!========================================================================================!\n!> Routines contained here are for parsing calculation and simulation settings that will \n!> enter separate setup objects.\n!> This concerns mainly [calculation]/[calculation. ...] and [dynamics] blocks\n\nmodule parse_calcdata\n  use crest_parameters\n  use crest_calculator,only:calcdata,calculation_settings,jobtype,constraint,scantype\n  use dynamics_module\n  use gradreader_module,only:gradtype,conv2gradfmt\n  use tblite_api,only:xtblvl\n\n  use parse_block,only:datablock\n  use parse_keyvalue,only:keyvalue\n  use parse_datastruct,only:root_object\n\n  implicit none\n  private\n\n!>-- routines for parsing a calculation_settings object\n  interface parse_setting  \n    module procedure :: parse_setting_auto\n    module procedure :: parse_setting_float\n    module procedure :: parse_setting_int\n    module procedure :: parse_setting_c\n    module procedure :: parse_setting_bool\n  end interface parse_setting\n\n!>-- routines for parsing a calcdata object\n  interface parse_calc\n    module procedure :: parse_calc_auto\n    module procedure :: parse_calc_float\n    module procedure :: parse_calc_int\n    module procedure :: parse_calc_c\n    module procedure :: parse_calc_bool\n  end interface parse_calc\n\n\n!>-- routines for parsing a mddata object\n  interface parse_md\n    module procedure :: parse_md_auto\n    module procedure :: parse_md_float\n    module procedure :: parse_md_int\n    module procedure :: parse_md_c\n    module procedure :: parse_md_bool\n  end interface parse_md\n\n!>-- routines for parsing a mtdpot object\n  interface parse_mtd\n    module procedure :: parse_metadyn_auto\n    module procedure :: parse_mtd_float\n    module procedure :: parse_mtd_int\n    module procedure :: parse_mtd_c\n    module procedure :: parse_mtd_bool\n  end interface parse_mtd\n\n  public :: parse_calculation_data\n  public :: parse_dynamics_data\n\n!========================================================================================!\n!========================================================================================!\ncontains !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\n  subroutine parse_calculation_data(calc,dict,included)\n    implicit none\n    type(calcdata) :: calc\n    type(root_object) :: dict\n    type(datablock) :: blk\n    type(calculation_settings) :: newjob,newjob2\n    type(constraint) :: newcstr\n    integer :: i,j,k,l\n    logical,intent(out) :: included\n\n    included = .false.\n    call calc%reset()\n\n    do i = 1,dict%nblk\n      call blk%deallocate()\n      blk = dict%blk_list(i)\n      if (blk%header == 'calculation') then\n        included = .true.\n        call parse_calcdat(blk,calc)\n\n      else if (blk%header == 'calculation.level') then\n        call parse_leveldata(blk,newjob)\n        call newjob%autocomplete(calc%ncalculations+1)\n        call calc%add(newjob)\n        included = .true.\n\n      else if (blk%header == 'calculation.mecp') then\n        !>-- setup\n        if (allocated(calc%calcs)) deallocate (calc%calcs)\n        calc%ncalculations = 0\n        calc%id = -1\n        call parse_leveldata(blk,newjob)\n        !>-- S0 setup\n        call parse_leveldata(blk,newjob)\n        newjob%uhf = 0\n        newjob%calcspace = 's0'\n        call calc%add(newjob)\n        !>-- S1 setup\n        newjob%uhf = 2\n        newjob%calcspace = 's1'\n        call calc%add(newjob)\n        included = .true.\n\n      else if (blk%header == 'calculation.constraints') then\n        call parse_constraintdat(blk,calc)\n        included = .true.\n\n      else if (blk%header == 'calculation.scans') then\n        call parse_scandat(blk,calc)\n        included = .true.\n\n      end if\n    end do\n    if (included) then\n      call calc%init()\n    end if\n    return\n  end subroutine parse_calculation_data\n\n!========================================================================================!\n!> The following routines are used to\n!> read information into the \"calculation_settings\" object\n!>---------------------------------------------------------\n  subroutine parse_leveldata(blk,job)\n    implicit none\n    type(datablock),intent(in) :: blk\n    type(calculation_settings),intent(out) :: job\n    integer :: i\n    call job%deallocate()\n    if ((blk%header .ne. 'calculation.level').and. &\n    & (blk%header .ne. 'calculation.mecp')) then\n      return\n    end if\n    do i = 1,blk%nkv\n      call parse_setting(job,blk%kv_list(i))\n    end do\n    return\n  end subroutine parse_leveldata\n  subroutine parse_setting_auto(job,kv)\n    implicit none\n    type(calculation_settings) :: job\n    type(keyvalue) :: kv\n    select case (kv%id)\n    case (1) !> float\n      call parse_setting(job,kv%key,kv%value_f)\n    case (2) !> int\n      call parse_setting(job,kv%key,kv%value_i)\n    case (3) !> bool\n      call parse_setting(job,kv%key,kv%value_b)\n    case (4) !> string\n      call parse_setting(job,kv%key,kv%value_c)\n    case (6,7) !> int/float array\n      call parse_setting_array(job,kv,kv%key)\n    end select\n  end subroutine parse_setting_auto\n  subroutine parse_setting_float(job,key,val)\n    implicit none\n    type(calculation_settings) :: job\n    character(len=*) :: key\n    real(wp) :: val\n    select case (key)\n    case ('uhf')\n      job%uhf = nint(val)\n    case ('chrg','charge')\n      job%chrg = nint(val)\n    case ('etemp')\n      job%etemp = val\n    case ('accuracy')\n      job%accuracy = val\n    case ('weight')\n      job%weight = val\n    case ('pressure')\n      job%extpressure = val\n    case ('proberad')\n      job%proberad = val\n    end select\n    return\n  end subroutine parse_setting_float\n  subroutine parse_setting_int(job,key,val)\n    implicit none\n    type(calculation_settings) :: job\n    character(len=*) :: key\n    integer :: val\n    select case (key)\n    case ('uhf')\n      job%uhf = val\n    case ('chrg','charge')\n      job%chrg = val\n    case ('id')\n      job%id = val\n    case ('maxscc')\n      job%maxscc = val\n    case ('tblite_level','tblite_hamiltonian')\n      job%tblitelvl = val\n    case ('lebedev')\n      job%ngrid = val\n    case('vdwSet')\n      job%vdwset = val\n    end select\n    return\n  end subroutine parse_setting_int\n  subroutine parse_setting_c(job,key,val)\n    implicit none\n    type(calculation_settings) :: job\n    character(len=*) :: key\n    character(len=*) :: val\n    select case (key)\n\n    case ('method')\n      select case (val)\n      case ('gfn-xtb','gfn','xtb')\n        job%id = jobtype%xtbsys\n      case ('generic')\n        job%id = jobtype%generic\n      case ('orca')\n        job%id = jobtype%orca\n      case ('turbomole','tm')\n        job%id = jobtype%turbomole\n      case ('terachem')\n        job%id = jobtype%terachem\n      case ('tblite')\n        job%id = jobtype%tblite\n      case ('gfn0','gfn0-xtb')\n        job%id = jobtype%gfn0\n      case ('gfn0*','gfn0*-xtb')\n        job%id = jobtype%gfn0occ\n      case ('gfnff','gff','gfn-ff')\n        job%id = jobtype%gfnff\n      case ('xhcff')\n        job%id = jobtype%xhcff\n      case ('none')\n        job%id = jobtype%unknown\n      case default\n        job%id = jobtype%unknown\n      end select\n\n    case ('bin','binary','script')\n      job%binary = val\n\n    case ('flags')\n      job%other = val\n\n      !> don't.\n      !case ('sys','syscall','systemcall')\n      !  job%systemcall = val\n\n    case ('calcspace','dir')\n      job%calcspace = val\n\n    case ('gradfile')\n      job%gradfile = val\n\n    case ('gradtype')\n      select case (val)\n      case ('engrad','xtb','orca')\n        job%gradtype = gradtype%engrad\n      case ('turbomole','tm')\n        job%gradtype = gradtype%turbomole\n      case ('generic')\n        job%gradtype = gradtype%unknown\n      case default\n        job%gradtype = gradtype%unknown\n      end select\n\n    case ('gradkey')\n      job%gradkey = val\n\n    case ('gradmt')\n      job%gradfmt = conv2gradfmt(val)\n\n    case ('efile')\n      job%efile = val\n\n    case ('tblite_level','tblite_hamiltonian')\n      select case (val)\n      case ('gfn2','gfn2-xtb')\n        job%tblitelvl = xtblvl%gfn2\n      case ('gfn1','gfn1-xtb')\n        job%tblitelvl = xtblvl%gfn1\n      case ('ipea1')\n        job%tblitelvl = xtblvl%ipea1\n      case default\n        job%tblitelvl = xtblvl%unknown\n      end select\n\n    case ('gbsa','alpb','cpcm')\n      job%solvmodel = key\n      job%solvent = val\n\n    end select\n    return\n  end subroutine parse_setting_c\n  subroutine parse_setting_bool(job,key,val)\n    implicit none\n    type(calculation_settings) :: job\n    character(len=*) :: key\n    logical :: val\n    select case (key)\n    case ('rdwbo')\n      job%rdwbo = val\n    case ('rddip','rddipole')\n      job%rddip = val\n    case ('dipgrad')\n      job%rddipgrad = val\n    case ('refresh')\n      job%apiclean = val\n      !TODO fix printout\n    case ('print')\n      if (val) job%prch = 999\n    end select\n    return\n  end subroutine parse_setting_bool\n  subroutine parse_setting_array(job,kv,key)\n    implicit none\n    type(calculation_settings) :: job\n    type(keyvalue) :: kv\n    character(len=*) :: key\n    select case (key)\n    case ('config')\n      call job%addconfig(kv%value_ia)\n    end select\n    return\n  end subroutine parse_setting_array\n!========================================================================================!\n!> The following routines are used to\n!> read information into the \"calcdata\" object\n!>---------------------------------------------------------\n  subroutine parse_calcdat(blk,calc)\n    implicit none\n    type(datablock),intent(in) :: blk\n    type(calcdata),intent(inout) :: calc\n    integer :: i\n    if (blk%header .ne. 'calculation') return\n    do i = 1,blk%nkv\n      call parse_calc(calc,blk%kv_list(i))\n    end do\n    return\n  end subroutine parse_calcdat\n  subroutine parse_calc_auto(calc,kv)\n    implicit none\n    type(calcdata) :: calc\n    type(keyvalue) :: kv\n    select case (kv%id)\n    case (1) !> float\n      call parse_calc(calc,kv%key,kv%value_f)\n    case (2) !> int\n      call parse_calc(calc,kv%key,kv%value_i)\n    case (3) !> bool\n      call parse_calc(calc,kv%key,kv%value_b)\n    case (4) !> string\n      call parse_calc(calc,kv%key,kv%value_c)\n    end select\n  end subroutine parse_calc_auto\n  subroutine parse_calc_float(calc,key,val)\n    implicit none\n    type(calcdata) :: calc\n    character(len=*) :: key\n    real(wp) :: val\n    select case (key)\n    case default\n      return\n    end select\n    return\n  end subroutine parse_calc_float\n  subroutine parse_calc_int(calc,key,val)\n    implicit none\n    type(calcdata) :: calc\n    character(len=*) :: key\n    integer :: val\n    select case (key)\n    case ('id','type')\n      calc%id = val\n    case ('maxcycle')\n      calc%maxcycle = val\n    case default\n      return\n    end select\n    return\n  end subroutine parse_calc_int\n  subroutine parse_calc_c(calc,key,val)\n    implicit none\n    type(calcdata) :: calc\n    character(len=*) :: key\n    character(len=*) :: val\n    select case (key)\n    case ('type')\n      select case (val)\n      case ('mecp')\n        calc%id = -1\n      case default\n        calc%id = 1\n      end select\n    case ('elog')\n      calc%elog = val\n      calc%pr_energies = .true.\n    case ('hess_update','hupdate')\n      select case (val)\n      case ('bfgs')\n        calc%iupdat = 0\n      case ('powell')\n        calc%iupdat = 1\n      case ('sr1')\n        calc%iupdat = 2\n      case ('bofill')\n        calc%iupdat = 3\n      case ('schlegel')\n        calc%iupdat = 4\n      case default\n        calc%iupdat = 0\n      end select\n    case default\n      return\n    end select\n    return\n  end subroutine parse_calc_c\n  subroutine parse_calc_bool(calc,key,val)\n    implicit none\n    type(calcdata) :: calc\n    character(len=*) :: key\n    logical :: val\n    select case (key)\n    case ('eprint')\n      calc%pr_energies = val\n    case default\n      return\n    end select\n    return\n  end subroutine parse_calc_bool\n\n!========================================================================================!\n!> The following routines are used to\n!> read information into the \"constraint\" object\n!> and add it to a calculation data object\n!>---------------------------------------------------------\n  subroutine parse_constraintdat(blk,calc)\n    implicit none\n    type(datablock),intent(in) :: blk\n    type(calcdata),intent(inout) :: calc\n    logical :: success\n    type(constraint) :: constr\n    integer :: i\n    if (blk%header .ne. 'calculation.constraints') return\n    do i = 1,blk%nkv\n      call parse_constraint_auto(constr,blk%kv_list(i),success)\n      if (success) then\n        call calc%add(constr)\n      end if\n    end do\n    return\n  end subroutine parse_constraintdat\n  subroutine parse_constraint_auto(constr,kv,success)\n    implicit none\n    type(keyvalue) :: kv\n    type(constraint) :: constr\n    logical,intent(out) :: success\n    real(wp) :: dum1,dum2,dum3\n    integer :: atm1,atm2,atm3,atm4\n    success = .false.\n    select case (kv%key)\n    case ('bond','bonds')\n      select case (kv%id)\n      case (4) !> string\n        select case (kv%value_c)\n        case ('all','allauto')\n          call constr%dummyconstraint(11)\n          success = .true.\n        end select\n      case(5)  !> regular array\n        call constr%rdbondconstraint(kv%na,kv%value_fa)\n        success = .true.\n      case (9) !> unspecified array\n        call constr%analyzedummy(11,kv%na,kv%value_rawa)\n        success = .true.\n      case default\n        success = .false.\n      end select\n    case ('dihedral')\n      read (kv%value_rawa(1),*) atm1\n      read (kv%value_rawa(2),*) atm2\n      read (kv%value_rawa(3),*) atm3\n      read (kv%value_rawa(4),*) atm4\n      read (kv%value_rawa(5),*) dum1\n      if (kv%na > 5) then\n        read (kv%value_rawa(6),*) dum2\n        call constr%dihedralconstraint(atm1,atm2,atm3,atm4,dum1,dum2)\n      else\n        call constr%dihedralconstraint(atm1,atm2,atm3,atm4,dum1)\n      end if\n      success = .true.\n    case ('sphere')\n      dum1 = kv%value_fa(3)  !> sphere radius\n      dum2 = kv%value_fa(1)  !> prefactor\n      dum3 = kv%value_fa(2)  !> exponent\n      call constr%sphereconstraint(0,dum1,dum2,dum3,.false.)\n      success = .true.\n    case ('sphere_logfermi')\n      dum1 = kv%value_fa(3)  !> sphere radius\n      dum2 = kv%value_fa(1)  !> fermi temperature\n      dum3 = kv%value_fa(2)  !> exponent factor\n      call constr%sphereconstraint(0,dum1,dum2,dum3,.true.)\n      success = .true.\n    case ('gapdiff')\n      dum1 = kv%value_fa(1)\n      dum2 = kv%value_fa(2)\n      call constr%gapdiffconstraint(dum1,dum2)\n      success = .true.\n    case ('gapdiff2','mecp')\n      success = .true.\n      if (kv%id == 3) then\n        if (kv%value_b) then\n          dum1 = 10.0_wp\n          dum2 = 0.005_wp\n          dum3 = 0.20_wp\n        else\n          success = .false.\n        end if\n      else\n        dum1 = kv%value_fa(1)\n        dum2 = kv%value_fa(2)\n        dum3 = kv%value_fa(3)\n      end if\n      call constr%gapdiffconstraint2(dum1,dum2,dum3)\n    case default\n      return\n    end select\n\n    return\n  end subroutine parse_constraint_auto\n\n!========================================================================================!\n!> The following routines are used to\n!> read information into the \"scan\" object\n!> and add it to a calculation data object\n!>---------------------------------------------------------\n  subroutine parse_scandat(blk,calc)\n    implicit none\n    type(datablock),intent(in) :: blk\n    type(calcdata),intent(inout) :: calc\n    logical :: success\n    type(scantype) :: scn\n    integer :: i\n    if (blk%header .ne. 'calculation.scans') return\n    do i = 1,blk%nkv\n      call parse_scan_auto(scn,blk%kv_list(i),success)\n      if (success) then\n        call calc%add(scn)\n      end if\n    end do\n    return\n  end subroutine parse_scandat\n  subroutine parse_scan_auto(scn,kv,success)\n    implicit none\n    type(keyvalue) :: kv\n    type(scantype) :: scn\n    logical,intent(out) :: success\n    real(wp) :: dum1,dum2,dum3\n    integer :: atm1,atm2,atm3,atm4\n    integer :: nsteps\n    success = .false.\n    call scn%deallocate()\n    select case (kv%key)\n    case ('bond','distance')\n      scn%type = 1\n      scn%n = 2\n      allocate (scn%atms(2))\n      read (kv%value_rawa(1),*) atm1\n      scn%atms(1) = atm1\n      read (kv%value_rawa(2),*) atm2\n      scn%atms(2) = atm2\n      read (kv%value_rawa(3),*) dum1\n      scn%minval = dum1\n      read (kv%value_rawa(4),*) dum2\n      scn%maxval = dum2\n      if (kv%na > 4) then\n        read (kv%value_rawa(5),*) nsteps\n        scn%steps = nsteps\n      end if\n      success = .true.\n    case ('dihedral')\n      scn%type = 3\n      scn%n = 2\n      allocate (scn%atms(4))\n      read (kv%value_rawa(1),*) atm1\n      scn%atms(1) = atm1\n      read (kv%value_rawa(2),*) atm2\n      scn%atms(2) = atm2\n      read (kv%value_rawa(3),*) atm3\n      scn%atms(3) = atm3\n      read (kv%value_rawa(4),*) atm4\n      scn%atms(4) = atm4\n      if (kv%na > 4) then\n        read (kv%value_rawa(5),*) nsteps\n        scn%steps = nsteps\n      end if\n      if (kv%na > 6) then\n        read (kv%value_rawa(6),*) dum1\n        scn%minval = dum1\n        read (kv%value_rawa(7),*) dum2\n        scn%maxval = dum2\n      end if\n      success = .true.\n    case default\n      return\n    end select\n\n    return\n  end subroutine parse_scan_auto\n\n!========================================================================================!\n!> The following routines are used to\n!> read information into the \"mddata\" object\n!>---------------------------------------------------------\n  subroutine parse_dynamics_data(mddat,dict,included)\n    implicit none\n    type(mddata) :: mddat\n    type(root_object) :: dict\n    type(datablock) :: blk\n    type(calculation_settings) :: newjob\n    type(constraint) :: newcstr\n    integer :: i,j,k,l\n    logical,intent(out) :: included\n\n    included = .false.\n\n    do i = 1,dict%nblk\n      call blk%deallocate()\n      blk = dict%blk_list(i)\n      if (blk%header == 'dynamics') then\n        included = .true.\n        call parse_mddat(blk,mddat)\n      else if (blk%header == 'dynamics.meta') then\n        call parse_metadyn(blk,mddat)\n        included = .true.\n      end if\n    end do\n    if (included) then\n      mddat%requested = .true.\n    end if\n    return\n  end subroutine parse_dynamics_data\n  subroutine parse_mddat(blk,mddat)\n    implicit none\n    type(datablock),intent(in) :: blk\n    type(mddata),intent(inout) :: mddat\n    integer :: i\n    if (blk%header .ne. 'dynamics') return\n    do i = 1,blk%nkv\n      call parse_md(mddat,blk%kv_list(i))\n    end do\n    return\n  end subroutine parse_mddat\n  subroutine parse_md_auto(mddat,kv)\n    implicit none\n    type(mddata) :: mddat\n    type(keyvalue) :: kv\n    select case (kv%id)\n    case (1) !> float\n      call parse_md(mddat,kv%key,kv%value_f)\n    case (2) !> int\n      call parse_md(mddat,kv%key,kv%value_i)\n    case (3) !> bool\n      call parse_md(mddat,kv%key,kv%value_b)\n    case (4) !> string\n      call parse_md(mddat,kv%key,kv%value_c)\n    end select\n  end subroutine parse_md_auto\n  subroutine parse_md_float(mddat,key,val)\n    implicit none\n    type(mddata) :: mddat\n    character(len=*) :: key\n    real(wp) :: val\n    select case (key)\n    case ('length','length_ps')\n      mddat%length_ps = val\n    case ('dump')\n      mddat%dumpstep = val\n    case ('hmass')\n      mddat%md_hmass = val\n    case ('tstep')\n      mddat%tstep = val\n    case ('t','temp','temperature' )\n      mddat%tsoll = val\n      mddat%thermostat =.true.\n    case default\n      return\n    end select\n    return\n  end subroutine parse_md_float\n  subroutine parse_md_int(mddat,key,val)\n    implicit none\n    type(mddata) :: mddat\n    character(len=*) :: key\n    integer :: val\n    real(wp) :: fval\n    select case (key)\n    case ('length','length_ps','dump','hmass','tstep')\n      fval = float(val)\n      call parse_md(mddat,key,fval)\n    case ('shake')\n      if( val <= 0 )then\n         mddat%shake = .false.\n      else\n         mddat%shake = .true.\n         mddat%shk%shake_mode = min(val,2)\n      endif\n    case ('printstep')\n       mddat%printstep = val\n    case ('t','temp','temperature' )\n      mddat%tsoll = float(val)\n      mddat%thermostat =.true.\n    case default\n      return\n    end select\n    return\n  end subroutine parse_md_int\n  subroutine parse_md_c(mddat,key,val)\n    implicit none\n    type(mddata) :: mddat\n    character(len=*) :: key\n    character(len=*) :: val\n    select case (key)\n    case default\n      return\n    end select\n    return\n  end subroutine parse_md_c\n  subroutine parse_md_bool(mddat,key,val)\n    implicit none\n    type(mddata) :: mddat\n    character(len=*) :: key\n    logical :: val\n    select case (key)\n    case ('shake')\n       mddat%shake = val\n       if(val) mddat%shk%shake_mode=1\n    case default\n      return\n    end select\n    return\n  end subroutine parse_md_bool\n\n!========================================================================================!\n!> The following routines are used to\n!> read information into the \"metadynamics\" object\n!> and add it to a mol.dynamics data object\n!>---------------------------------------------------------\n  subroutine parse_metadyn(blk,mddat)\n    implicit none\n    type(datablock),intent(in) :: blk\n    type(mddata),intent(inout) :: mddat\n    logical :: success\n    type(mtdpot) :: mtd\n    integer :: i,k\n    call mtd%deallocate()\n    if (blk%header .ne. 'dynamics.meta') return\n    do i = 1,blk%nkv\n      call parse_metadyn_auto(mtd,blk%kv_list(i),success)\n    end do\n    call mddat%add(mtd)\n    return\n  end subroutine parse_metadyn\n  subroutine parse_metadyn_auto(mtd,kv,success)\n    implicit none\n    type(keyvalue) :: kv\n    type(mtdpot) :: mtd\n    logical,intent(out) :: success\n    success = .false.\n    select case (kv%id)\n    case (1) !> float\n      call parse_mtd(mtd,kv%key,kv%value_f)\n      success = .true.\n    case (2) !> int\n      call parse_mtd(mtd,kv%key,kv%value_i)\n      success = .true.\n    case (3) !> bool\n      call parse_mtd(mtd,kv%key,kv%value_b)\n      success = .true.\n    case (4) !> string\n      call parse_mtd(mtd,kv%key,kv%value_c)\n      success = .true.\n    end select\n  end subroutine parse_metadyn_auto\n  subroutine parse_mtd_float(mtd,key,val)\n    implicit none\n    type(mtdpot) :: mtd\n    character(len=*) :: key\n    real(wp) :: val\n    select case (key)\n    case ('alpha')\n      mtd%alpha = val\n    case ('kpush')\n      mtd%kpush = val\n    case ('dump','dump_fs')\n      mtd%cvdump_fs = val\n    case ('dump_ps')\n      mtd%cvdump_fs = val*1000.0_wp\n    case ('ramp')\n      mtd%ramp = val\n    case default\n      return\n    end select\n    return\n  end subroutine parse_mtd_float\n  subroutine parse_mtd_int(mtd,key,val)\n    implicit none\n    type(mtdpot) :: mtd\n    character(len=*) :: key\n    integer :: val\n    real(wp) :: fval\n    select case (key)\n    case ('type')\n      mtd%mtdtype = val\n    case ('dump','dump_fs','dump_ps')\n      fval = float(val)\n      call parse_mtd(mtd,key,fval)\n    case default\n      return\n    end select\n    return\n  end subroutine parse_mtd_int\n  subroutine parse_mtd_c(mtd,key,val)\n    implicit none\n    type(mtdpot) :: mtd\n    character(len=*) :: key\n    character(len=*) :: val\n    select case (key)\n    case ('type')\n      select case (val)\n      case ('rmsd')\n        mtd%mtdtype = cv_rmsd\n      case default\n        mtd%mtdtype = 0\n      end select\n    case ('biasfile')\n       mtd%mtdtype = cv_rmsd_static\n       mtd%biasfile = val\n    case default\n      return\n    end select\n    return\n  end subroutine parse_mtd_c\n  subroutine parse_mtd_bool(mtd,key,val)\n    implicit none\n    type(mtdpot) :: mtd\n    character(len=*) :: key\n    logical :: val\n    select case (key)\n    case default\n      return\n    end select\n    return\n  end subroutine parse_mtd_bool\n\n!========================================================================================!\nend module parse_calcdata\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/parse_calcdata.f90 b/src/parsing/parse_calcdata.f90
--- a/src/parsing/parse_calcdata.f90	
+++ b/src/parsing/parse_calcdata.f90	
@@ -19,12 +19,13 @@
 
 !> NOTE: This is work in progress, not all input conventions have been set yet
 !========================================================================================!
-!> Routines contained here are for parsing calculation and simulation settings that will 
+!> Routines contained here are for parsing calculation and simulation settings that will
 !> enter separate setup objects.
 !> This concerns mainly [calculation]/[calculation. ...] and [dynamics] blocks
 
 module parse_calcdata
   use crest_parameters
+  use crest_data
   use crest_calculator,only:calcdata,calculation_settings,jobtype,constraint,scantype
   use dynamics_module
   use gradreader_module,only:gradtype,conv2gradfmt
@@ -38,7 +39,7 @@
   private
 
 !>-- routines for parsing a calculation_settings object
-  interface parse_setting  
+  interface parse_setting
     module procedure :: parse_setting_auto
     module procedure :: parse_setting_float
     module procedure :: parse_setting_int
@@ -55,7 +56,6 @@
     module procedure :: parse_calc_bool
   end interface parse_calc
 
-
 !>-- routines for parsing a mddata object
   interface parse_md
     module procedure :: parse_md_auto
@@ -207,7 +207,7 @@
     character(len=*) :: key
     integer :: val
     select case (key)
-    case ('uhf')
+    case ('uhf','multiplicity')
       job%uhf = val
     case ('chrg','charge')
       job%chrg = val
@@ -219,7 +219,7 @@
       job%tblitelvl = val
     case ('lebedev')
       job%ngrid = val
-    case('vdwSet')
+    case ('vdwset')
       job%vdwset = val
     end select
     return
@@ -245,6 +245,12 @@
         job%id = jobtype%terachem
       case ('tblite')
         job%id = jobtype%tblite
+      case ('gfn2','gfn2-xtb')
+        job%id = jobtype%tblite
+        job%tblitelvl = 2
+      case ('gfn1','gfn1-xtb')
+        job%id = jobtype%tblite
+        job%tblitelvl = 1
       case ('gfn0','gfn0-xtb')
         job%id = jobtype%gfn0
       case ('gfn0*','gfn0*-xtb')
@@ -255,6 +261,8 @@
         job%id = jobtype%xhcff
       case ('none')
         job%id = jobtype%unknown
+      case ('lj','lennard-jones')
+        job%id = jobtype%lj
       case default
         job%id = jobtype%unknown
       end select
@@ -308,10 +316,30 @@
         job%tblitelvl = xtblvl%unknown
       end select
 
+    case ('orca_cmd')
+      job%id = jobtype%orca
+      job%ORCA%cmd = val
+      job%binary = val
+    case ('orca_template')
+      job%id = jobtype%orca
+      call job%ORCA%read(val)
+
     case ('gbsa','alpb','cpcm')
       job%solvmodel = key
       job%solvent = val
 
+    case ('refine','refinement')
+      select case (val)
+      case ('sp','singlepoint')
+        job%refine_lvl = refine%singlepoint
+      case ('add','correction')
+        job%refine_lvl = refine%correction
+      case ('opt','optimization')
+        job%refine_lvl = refine%geoopt
+      case default
+        job%refine_lvl = refine%non
+      end select
+
     end select
     return
   end subroutine parse_setting_c
@@ -327,11 +355,13 @@
       job%rddip = val
     case ('dipgrad')
       job%rddipgrad = val
+    case ('rdgrad')
+      job%rdgrad = val
     case ('refresh')
       job%apiclean = val
-      !TODO fix printout
     case ('print')
-      if (val) job%prch = 999
+      job%pr = val
+      if (val) job%prch = 999  !> the actual ID will be generated automatically
     end select
     return
   end subroutine parse_setting_bool
@@ -478,8 +508,10 @@
     type(keyvalue) :: kv
     type(constraint) :: constr
     logical,intent(out) :: success
-    real(wp) :: dum1,dum2,dum3
+    real(wp) :: dum1,dum2,dum3,dum4
+    real(wp) :: rabc(3)
     integer :: atm1,atm2,atm3,atm4
+    logical,allocatable :: atlist(:)
     success = .false.
     select case (kv%key)
     case ('bond','bonds')
@@ -490,7 +522,7 @@
           call constr%dummyconstraint(11)
           success = .true.
         end select
-      case(5)  !> regular array
+      case (5)  !> regular array
         call constr%rdbondconstraint(kv%na,kv%value_fa)
         success = .true.
       case (9) !> unspecified array
@@ -524,6 +556,22 @@
       dum3 = kv%value_fa(2)  !> exponent factor
       call constr%sphereconstraint(0,dum1,dum2,dum3,.true.)
       success = .true.
+    case ('ellipsoid','ellipsoid_logfermi')
+      rabc(1:3) = kv%value_fa(1:3)
+      if (index(kv%key,'logfermi') .ne. 0) then
+        dum1 = 300.0_wp
+        dum2 = 6.0_wp
+        if (kv%na > 3) dum1 = kv%value_fa(4)
+        if (kv%na > 4) dum2 = kv%value_fa(5)
+        call constr%ellipsoid(0,atlist,rabc,dum1,dum2,.true.)
+      else
+        dum1 = 1.0_wp
+        dum2 = 30.0_wp
+        if (kv%na > 3) dum1 = kv%value_fa(4)
+        if (kv%na > 4) dum2 = kv%value_fa(5)
+        call constr%ellipsoid(0,atlist,rabc,dum1,dum2,.false.)
+      end if
+      success = .true.
     case ('gapdiff')
       dum1 = kv%value_fa(1)
       dum2 = kv%value_fa(2)
@@ -545,6 +593,28 @@
         dum3 = kv%value_fa(3)
       end if
       call constr%gapdiffconstraint2(dum1,dum2,dum3)
+    case ('bondrange')
+      atm1 = nint(kv%value_fa(1))
+      atm2 = nint(kv%value_fa(2))
+      dum1 = kv%value_fa(3)*aatoau
+      dum1 = max(0.0_wp,dum1) !> can't be negative
+      select case (kv%na)
+      case (3)
+        dum2 = huge(dum2)/3.0_wp !> some huge value
+        call constr%bondrangeconstraint(atm1,atm2,dum1,dum2)
+      case (4)
+        dum2 = kv%value_fa(4)*aatoau
+        call constr%bondrangeconstraint(atm1,atm2,dum1,dum2)
+      case (5)
+        dum3 = kv%value_fa(5)
+        call constr%bondrangeconstraint(atm1,atm2,dum1,dum2,beta=dum3)
+      case (6)
+        dum4 = kv%value_fa(6)
+        call constr%bondrangeconstraint(atm1,atm2,dum1,dum2,beta=dum3,T=dum4)
+      case default
+        error stop '**ERROR** wrong number of arguments in bondrange constraint'
+      end select
+      success = .true.
     case default
       return
     end select
@@ -687,6 +757,11 @@
       call parse_md(mddat,kv%key,kv%value_b)
     case (4) !> string
       call parse_md(mddat,kv%key,kv%value_c)
+    case default
+      select case (kv%key)
+      case ('active','active_levels')
+        mddat%active_potentials = kv%value_ia
+      end select
     end select
   end subroutine parse_md_auto
   subroutine parse_md_float(mddat,key,val)
@@ -703,9 +778,9 @@
       mddat%md_hmass = val
     case ('tstep')
       mddat%tstep = val
-    case ('t','temp','temperature' )
+    case ('t','temp','temperature')
       mddat%tsoll = val
-      mddat%thermostat =.true.
+      mddat%thermostat = .true.
     case default
       return
     end select
@@ -722,17 +797,17 @@
       fval = float(val)
       call parse_md(mddat,key,fval)
     case ('shake')
-      if( val <= 0 )then
-         mddat%shake = .false.
+      if (val <= 0) then
+        mddat%shake = .false.
       else
-         mddat%shake = .true.
-         mddat%shk%shake_mode = min(val,2)
-      endif
+        mddat%shake = .true.
+        mddat%shk%shake_mode = min(val,2)
+      end if
     case ('printstep')
-       mddat%printstep = val
-    case ('t','temp','temperature' )
+      mddat%printstep = val
+    case ('t','temp','temperature')
       mddat%tsoll = float(val)
-      mddat%thermostat =.true.
+      mddat%thermostat = .true.
     case default
       return
     end select
@@ -756,8 +831,8 @@
     logical :: val
     select case (key)
     case ('shake')
-       mddat%shake = val
-       if(val) mddat%shk%shake_mode=1
+      mddat%shake = val
+      if (val) mddat%shk%shake_mode = 1
     case default
       return
     end select
@@ -857,8 +932,8 @@
         mtd%mtdtype = 0
       end select
     case ('biasfile')
-       mtd%mtdtype = cv_rmsd_static
-       mtd%biasfile = val
+      mtd%mtdtype = cv_rmsd_static
+      mtd%biasfile = val
     case default
       return
     end select
Index: src/parsing/parse_maindata.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022-2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!> NOTE: This is work in progress, not all input conventions have been set yet\n!========================================================================================!\n!> Routines contained here are for parsing 'top level' settings that will \n!> enter the env systemdata object\n\nmodule parse_maindata\n  use crest_parameters\n  !> modules for data storage in crest\n  use crest_data\n  !> modules used for parsing the root_object\n  !>\n  use parse_keyvalue,only:keyvalue,valuetypes\n  use parse_block,only:datablock\n  use parse_datastruct,only:root_object\n  !> Declarations\n  implicit none\n  public\n\n!========================================================================================!\n!========================================================================================!\ncontains   !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n\n  subroutine parse_main_auto(env,kv)\n    implicit none\n    type(systemdata) :: env\n    type(keyvalue) :: kv\n    select case (kv%id)\n    case (valuetypes%float) !> float\n      call parse_main_float(env,kv%key,kv%value_f)\n    case (valuetypes%int) !> int\n      call parse_main_int(env,kv%key,kv%value_i)\n    case (valuetypes%bool) !> bool\n      call parse_main_bool(env,kv%key,kv%value_b)\n    case (valuetypes%string) !> string\n      call parse_main_c(env,kv%key,kv%value_c)\n    end select\n  end subroutine parse_main_auto\n  subroutine parse_main_float(env,key,val)\n    implicit none\n    type(systemdata) :: env\n    character(len=*) :: key\n    real(wp) :: val\n    select case (key)\n\n    end select\n    return\n  end subroutine parse_main_float\n  subroutine parse_main_int(env,key,val)\n    implicit none\n    type(systemdata) :: env\n    character(len=*) :: key\n    integer :: val\n    select case (key)\n    case ('threads','parallel')\n      env%Threads = val\n      env%autothreads = .true.\n      env%threadssetmanual = .true.\n    end select\n    return\n  end subroutine parse_main_int\n  subroutine parse_main_c(env,key,val)\n    implicit none\n    type(systemdata) :: env\n    character(len=*) :: key\n    character(len=*) :: val\n    select case (key)\n    case ('bin','binary')\n      env%ProgName = val\n    case ('runtype')\n      select case (val)\n      case ('none')\n        env%crestver = crest_none\n      case ('playground','test')\n        env%preopt = .false.\n        env%crestver = crest_test\n      case ('singlepoint','sp')\n        env%preopt = .false.\n        env%crestver = crest_sp\n      case ('ancopt','optimize')\n        env%preopt = .false.\n        env%crestver = crest_optimize\n      case ('ancopt_ensemble','optimize_ensemble')\n        env%preopt = .false.\n        env%crestver = crest_mdopt2\n      case ('md','mtd','metadynamics','dynamics')\n        env%preopt = .false.\n        env%crestver = crest_moldyn\n      case ('scan')\n        env%preopt = .false.\n        env%crestver = crest_scanning\n      case ('search_1')\n        env%preopt = .false.\n        env%crestver = crest_s1\n        env%runver = crest_s1\n      case ('mecp','mecp_search')\n        env%preopt = .false.\n        env%crestver = crest_mecp\n        env%runver = crest_mecp\n      case ('imtd-gc')\n        env%preopt = .false.\n        env%crestver = crest_imtd\n        env%runver = 1\n      case ('entropy','imtd-stmd')\n        env%crestver = crest_imtd  !> the entropy mode acts as subtype of the crest_imtd algo\n        env%properties = abs(p_CREentropy)\n        env%autozsort = .false.     !> turn off zsort (since we are not going to GC anyways)\n        env%performCross = .false.  !> turn off GC\n        env%entropic = .true.       !> indicator for this runtype\n        env%Maxrestart = 1          !> turn off MTD iterations (just do one)\n        env%rotamermds = .false.    !> turn off normMDs\n        env%entropymd = .true.      !> special static MTDs\n        env%runver = 111            !> version  for selection of MTD bias settings\n        env%doNMR = .true.          !> we need equivalencies\n        env%emtd%bhess = .false.    !> currently there is no BHESS version, TODO!\n        call env%addjob(env%properties)\n      case ('numhess','numerical hessian')\n        env%preopt = .false.\n        env%crestver = crest_numhessian\n        env%runver = crest_numhessian\n      case ('rigidconf')\n        env%preopt = .false.\n        env%crestver = crest_rigcon\n        env%runver = crest_rigcon\n      case default\n        env%crestver = crest_imtd\n      end select\n    case ('ensemble_input','ensemble')\n      env%ensemblename = val\n      env%inputcoords = val\n    case ('input')\n      env%inputcoords = val\n    end select\n    return\n  end subroutine parse_main_c\n  subroutine parse_main_bool(env,key,val)\n    implicit none\n    type(systemdata) :: env\n    character(len=*) :: key\n    logical :: val\n    select case (key)\n    case ('preopt')\n      env%preopt = val\n    case ('noopt')\n      env%preopt = .not.val\n    case ('topo')\n      env%checktopo = val\n    case ('notopo')\n      env%checktopo = .not.val\n    end select\n    return\n  end subroutine parse_main_bool\n!========================================================================================!\n  subroutine parse_main_blk(env,blk)\n    implicit none\n    type(systemdata) :: env\n    type(datablock) :: blk\n    select case (blk%header)\n    case ('cregen')\n\n    end select\n  end subroutine parse_main_blk\n!========================================================================================!\nend module parse_maindata\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/parse_maindata.f90 b/src/parsing/parse_maindata.f90
--- a/src/parsing/parse_maindata.f90	
+++ b/src/parsing/parse_maindata.f90	
@@ -26,6 +26,7 @@
   use crest_parameters
   !> modules for data storage in crest
   use crest_data
+  use crest_restartlog
   !> modules used for parsing the root_object
   !>
   use parse_keyvalue,only:keyvalue,valuetypes
@@ -97,12 +98,19 @@
       case ('singlepoint','sp')
         env%preopt = .false.
         env%crestver = crest_sp
+      case ('numgrad')
+        env%preopt = .false.
+        env%crestver = crest_sp
+        env%testnumgrad = .true.
       case ('ancopt','optimize')
         env%preopt = .false.
         env%crestver = crest_optimize
-      case ('ancopt_ensemble','optimize_ensemble')
+      case ('ancopt_ensemble','optimize_ensemble','mdopt')
         env%preopt = .false.
         env%crestver = crest_mdopt2
+      case ('screen_ensemble','screen')
+        env%preopt = .false.
+        env%crestver = crest_screen
       case ('md','mtd','metadynamics','dynamics')
         env%preopt = .false.
         env%crestver = crest_moldyn
@@ -145,11 +153,15 @@
       case default
         env%crestver = crest_imtd
       end select
-    case ('ensemble_input','ensemble')
+    case ('ensemble_input','ensemble','input_ensemble')
       env%ensemblename = val
       env%inputcoords = val
     case ('input')
       env%inputcoords = val
+    case ('constraints','xtbconstraints','xtbinput') !> equivalent to --cinp
+      env%constraints = val
+    case ('rigidconf_file')
+      env%rigidconf_userfile = val
     end select
     return
   end subroutine parse_main_c
@@ -167,6 +179,10 @@
       env%checktopo = val
     case ('notopo')
       env%checktopo = .not.val
+    case ('restart')
+      if(val)then
+        call read_restart(env)
+      endif
     end select
     return
   end subroutine parse_main_bool
@@ -177,8 +193,78 @@
     type(datablock) :: blk
     select case (blk%header)
     case ('cregen')
-
+      call parse_cregen(env,blk)
+    case('confsolv')
+      call parse_confsolv(env,blk)
     end select
   end subroutine parse_main_blk
+!========================================================================================!
+ subroutine parse_cregen(env,blk)
+!****************************************
+!* parse settings for the CREGEN routine
+!****************************************  
+    implicit none
+    type(systemdata) :: env
+    type(datablock) :: blk
+    type(keyvalue) :: kv
+    integer :: i
+!>--- parse the arguments
+    do i = 1,blk%nkv
+      kv = blk%kv_list(i)
+    select case (kv%key)
+    case ('ewin') 
+      env%ewin = kv%value_f
+    case ('ethr')
+      env%ethr = kv%value_f
+    case ('rthr')
+      env%rthr = kv%value_f
+    case ( 'bthr')
+      env%bthr2 = kv%value_f
+    case ('eqv','nmr') 
+      env%doNMR = kv%value_b 
+    end select
+    enddo
+  end subroutine parse_cregen
+
+!========================================================================================!
+  subroutine parse_confsolv(env,blk)
+    use ConfSolv_module
+    implicit none
+    type(systemdata) :: env
+    type(datablock) :: blk
+    type(keyvalue) :: kv
+    integer :: i    
+!>--- add ConfSolv as refinement level to give a ΔΔGsoln
+    call env%addrefine(refine%ConfSolv)
+
+!>--- parse the arguments
+    do i = 1,blk%nkv
+      kv = blk%kv_list(i)
+    select case (kv%key)
+    case ('pid')
+      if(.not.allocated(cs_pid)) allocate(cs_pid)
+      cs_pid = kv%value_i
+    case ('bin')
+       cs_bin = trim(kv%value_c)
+    case ( 'port')
+       if(.not.allocated(cs_port)) allocate(cs_port)
+       cs_port = kv%value_i
+    case ('solvent') 
+    !> to define a single solvent like: solvent = ['water','O']
+       if(kv%na == 2)then
+         cs_solvent = trim(kv%value_rawa(1))
+         cs_smiles = trim(kv%value_rawa(2)) 
+       else
+         cs_solvent = kv%value_c
+       endif
+    case ('solvent_name')
+       cs_solvent = kv%value_c
+    case ('solvent_smiles')
+       cs_smiles = kv%value_c
+    case ('model_path','param','checkpoint')
+       cs_param = kv%value_c
+    end select
+    enddo
+  end subroutine parse_confsolv
 !========================================================================================!
 end module parse_maindata
Index: src/parsing/meson.build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nsrcs += files(\n  'confparse2.f90',\n  'parse_block.f90',\n  'parse_calcdata.f90',\n  'parse_datastruct.f90',\n  'parse_maindata.f90',\n  'parse_toml.F90',\n  'parse_inputfile.F90',\n  'parse_keyvalue.f90',\n)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/meson.build b/src/parsing/meson.build
--- a/src/parsing/meson.build	
+++ b/src/parsing/meson.build	
@@ -16,10 +16,13 @@
 
 srcs += files(
   'confparse2.f90',
+  'constraining.f90',
   'parse_block.f90',
   'parse_calcdata.f90',
   'parse_datastruct.f90',
   'parse_maindata.f90',
+  'parse_xtbinput.f90',
+  'parse_csv.f90',
   'parse_toml.F90',
   'parse_inputfile.F90',
   'parse_keyvalue.f90',
Index: src/algos/singlepoint.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> Implementation of a singlepoint calculation\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\nsubroutine crest_singlepoint(env,tim)\n!********************************************************************\n!* Standalone runtype for a singlepoint calculation\n!*\n!* Input/Output:\n!*  env  -  crest's systemdata object\n!*  tim  -  timer object\n!********************************************************************\n  use crest_parameters\n  use crest_data\n  use crest_calculator\n  use strucrd\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(timer),intent(inout)      :: tim\n  type(coord) :: mol,molnew\n  integer :: i,j,k,l,io,ich\n  logical :: pr,wr\n  character(len=80) :: atmp\n!========================================================================================!\n  type(calcdata) :: calc\n  real(wp) :: accuracy,etemp\n\n  real(wp) :: energy\n  real(wp),allocatable :: grad(:,:)\n\n  character(len=*),parameter :: partial = '∂E/∂'\n!========================================================================================!\n  call tim%start(14,'Singlepoint calculation')\n!========================================================================================!\n  write (stdout,*)\n  !call system('figlet singlepoint')\n  write (stdout,*) \"     _             _                  _       _   \"\n  write (stdout,*) \" ___(_)_ __   __ _| | ___ _ __   ___ (_)_ __ | |_ \"\n  write (stdout,*) \"/ __| | '_ \\ / _` | |/ _ \\ '_ \\ / _ \\| | '_ \\| __|\"\n  write (stdout,*) \"\\__ \\ | | | | (_| | |  __/ |_) | (_) | | | | | |_ \"\n  write (stdout,*) \"|___/_|_| |_|\\__, |_|\\___| .__/ \\___/|_|_| |_|\\__|\"\n  write (stdout,*) \"             |___/       |_|                      \"\n  write (stdout,*)\n!========================================================================================!\n  call env%ref%to(mol)\n  write (stdout,*)\n  write (stdout,*) 'Input structure:'\n  call mol%append(stdout)\n  write (stdout,*)\n!========================================================================================!\n\n  write (stdout,'(a)') repeat('-',80)\n  write (stdout,'(a)')\n\n  allocate (grad(3,mol%nat),source=0.0_wp)\n  calc = env%calc\n\n!>--- print some info about the calculation\n  call calc%info(stdout)\n\n!>--- and then start it\n  write (stdout,'(a)') repeat('-',80)\n  write (stdout,'(a)',advance='no') '> Performing singlepoint calculations ... '\n  flush (stdout)\n  call engrad(mol,calc,energy,grad,io)\n  call tim%stop(14)\n  write (stdout,*) 'done.'\n  write (atmp,'(a)') '> Total wall time for calculations'\n  call tim%write_timing(stdout,14,trim(atmp),.true.)\n  write (stdout,'(a)') repeat('-',80)\n  if (io /= 0) then\n    write (stdout,*)\n    write (stdout,*) 'WARNING: Calculation exited with error!'\n    return\n  end if\n\n!>--- print out the results\n  if (any(calc%calcs(:)%rdwbo)) then\n    write (stdout,*)\n    write (stdout,*) 'Connectivity information (bond order):'\n    do k = 1,calc%ncalculations\n      if (calc%calcs(k)%rdwbo) then\n        write (stdout,'(\"> \",a,i0)') 'Calculation level ',k\n        write (stdout,'(a12,a12,a10)') 'Atom A','Atom B','BO(A-B)'\n        do i = 1,mol%nat\n          do j = 1,i-1\n            if (calc%calcs(k)%wbo(i,j) > 0.0002_wp) then\n              write (stdout,*) i,j,calc%calcs(k)%wbo(i,j)\n            end if\n          end do\n        end do\n      end if\n    end do\n    write (stdout,*)\n    write (stdout,'(a)') repeat('-',80)\n  else\n    write (stdout,*)\n  end if\n\n  write (stdout,'(a)') '> Final molecular gradient ( Eh/a0 ):'\n  write (stdout,'(13x,a,13x,a,13x,a)') partial//'x',partial//'y',partial//'z'\n  do i = 1,mol%nat\n    write (stdout,'(3f18.8)') grad(1:3,i)\n  end do\n  write (stdout,'(a,f18.8,a)') '> Gradient norm:',norm2(grad),' Eh/α'\n\n  if (calc%ncalculations > 1) then\n    write (stdout,*)\n    write (stdout,'(a)') '> Individual energies and gradient norms:'\n    do k = 1,calc%ncalculations\n      write (stdout,'(1x,a,i0,2f18.8)') 'calculation ',k,calc%etmp(k),norm2(calc%grdtmp(:,:,k))\n    end do\n    if (calc%nconstraints > 0) then\n      write (stdout,'(1x,a)') '(+ constraints contribution)'\n    end if\n  end if\n\n  write (stdout,*)\n  write (stdout,'(a)') repeat('=',40)\n  write (stdout,'(1x,a,f20.10,a)') 'TOTAL ENERGY ',energy,' Eh'\n  write (stdout,'(1x,a,f20.10,a)') 'GRADIENT NORM',norm2(grad),' Eh/α'\n  write (stdout,'(a)') repeat('=',40)\n\n  deallocate (grad)\n!========================================================================================!\n  return\nend subroutine crest_singlepoint\n\n!========================================================================================!\n!========================================================================================!\n\nsubroutine crest_xtbsp(env,xtblevel,molin)\n!********************************************************************\n!* Replacement for the legacy xtbsp routine, makes use of gfn0 or tblite.\n!* The purpose of this routine is usually to generate WBOs\n!*\n!* Input/Output:\n!*  env      - crest's systemdata object\n!*  xtblevel - quick selection of calc. level\n!*  molin    - molecule data\n!********************************************************************\n  use crest_parameters \n  use crest_data\n  use crest_calculator\n  use strucrd\n  use wiberg_mayer,only:write_wbo\n  implicit none\n  !> INPUT\n  type(systemdata) :: env\n  integer,intent(in),optional :: xtblevel\n  type(coord),intent(in),optional :: molin\n  !> LOCAL\n  integer :: lv,io\n  type(calcdata) :: tmpcalc\n  type(calculation_settings) :: cal\n  type(coord) :: mol\n  real(wp) :: energy\n  real(wp),allocatable :: grad(:,:)\n\n  !>--- transfer settings from env to tmpcalc\n  call env2calc(env,tmpcalc,molin)\n\n  tmpcalc%calcs(1)%rdwbo = .true. !> obtain WBOs\n  if (present(xtblevel)) then\n    select case (xtblevel) !> no default\n    case (0)\n      tmpcalc%calcs(1)%id = jobtype%gfn0\n    case (1)\n      tmpcalc%calcs(1)%id = jobtype%tblite\n      tmpcalc%calcs(1)%tblitelvl = 1\n    case (2)\n      tmpcalc%calcs(1)%id = jobtype%tblite\n      tmpcalc%calcs(1)%tblitelvl = 2\n    end select\n  end if\n  if (present(molin)) then\n    mol = molin\n  else\n    call mol%open('coord')\n  end if\n  allocate (grad(3,mol%nat),source=0.0_wp)\n\n  call engrad(mol,tmpcalc,energy,grad,io)\n  if (io .ne. 0) then\n    error stop 'crest_xtbsp failed'\n  end if\n\n  !>--- write wbo file\n  if (tmpcalc%calcs(1)%rdwbo) then\n    call write_wbo(tmpcalc%calcs(1)%wbo,0.002_wp)\n\n  end if\n\n  deallocate (grad)\n  call tmpcalc%reset()\n  call mol%deallocate()\nend subroutine crest_xtbsp\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/singlepoint.f90 b/src/algos/singlepoint.f90
--- a/src/algos/singlepoint.f90	
+++ b/src/algos/singlepoint.f90	
@@ -34,6 +34,7 @@
   use crest_data
   use crest_calculator
   use strucrd
+  use gradreader_module, only: write_engrad
   implicit none
   type(systemdata),intent(inout) :: env
   type(timer),intent(inout)      :: tim
@@ -49,8 +50,6 @@
   real(wp),allocatable :: grad(:,:)
 
   character(len=*),parameter :: partial = '∂E/∂'
-!========================================================================================!
-  call tim%start(14,'Singlepoint calculation')
 !========================================================================================!
   write (stdout,*)
   !call system('figlet singlepoint')
@@ -61,6 +60,10 @@
   write (stdout,*) "|___/_|_| |_|\__, |_|\___| .__/ \___/|_|_| |_|\__|"
   write (stdout,*) "             |___/       |_|                      "
   write (stdout,*)
+!========================================================================================!
+  call ompset_max(env%threads)
+  call ompprint_intern()
+  call tim%start(14,'Singlepoint calculation')
 !========================================================================================!
   call env%ref%to(mol)
   write (stdout,*)
@@ -117,18 +120,22 @@
     write (stdout,*)
   end if
 
+  if(all(calc%calcs(:)%rdgrad == .false.))then
+    write (stdout,'(a)') '> No gradients calculated'
+  else 
   write (stdout,'(a)') '> Final molecular gradient ( Eh/a0 ):'
   write (stdout,'(13x,a,13x,a,13x,a)') partial//'x',partial//'y',partial//'z'
   do i = 1,mol%nat
     write (stdout,'(3f18.8)') grad(1:3,i)
   end do
-  write (stdout,'(a,f18.8,a)') '> Gradient norm:',norm2(grad),' Eh/α'
+  write (stdout,'(a,f18.8,a)') '> Gradient norm:',norm2(grad),' Eh/a0'
+  endif
 
   if (calc%ncalculations > 1) then
     write (stdout,*)
     write (stdout,'(a)') '> Individual energies and gradient norms:'
     do k = 1,calc%ncalculations
-      write (stdout,'(1x,a,i0,2f18.8)') 'calculation ',k,calc%etmp(k),norm2(calc%grdtmp(:,:,k))
+      write (stdout,'(1x,a,i3,2f18.8)') 'calculation ',k,calc%etmp(k),norm2(calc%grdtmp(:,:,k))
     end do
     if (calc%nconstraints > 0) then
       write (stdout,'(1x,a)') '(+ constraints contribution)'
@@ -138,9 +145,16 @@
   write (stdout,*)
   write (stdout,'(a)') repeat('=',40)
   write (stdout,'(1x,a,f20.10,a)') 'TOTAL ENERGY ',energy,' Eh'
-  write (stdout,'(1x,a,f20.10,a)') 'GRADIENT NORM',norm2(grad),' Eh/α'
+  write (stdout,'(1x,a,f20.10,a)') 'GRADIENT NORM',norm2(grad),' Eh/a0'
   write (stdout,'(a)') repeat('=',40)
 
+  write(stdout,'(1x,a)') 'Writing crest.engrad ...' 
+  call write_engrad('crest.engrad',energy,grad)
+
+  if(env%testnumgrad)then
+    call numgrad(mol,calc,grad)
+  endif 
+
   deallocate (grad)
 !========================================================================================!
   return
Index: src/ompmklset.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c OMP and MKL parallelization settings \n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!xTB uses OMP parallelization. This can be controlled by setting\n!the MKL_NUM_THREADS and OMP_NUM_THREADS enviornment variables.\n\nsubroutine ompmklset(omp,maxrun,maximum)\n      use omp_lib\n      use iomod\n      implicit none\n      integer :: omp,maxrun\n      real*8 :: omp1,omp2\n      integer :: dummy5 ,io\n      logical :: maximum\n\n      if(omp.gt.OMP_GET_NUM_PROCS())then\n         omp=OMP_GET_NUM_PROCS()\n      endif\n\n      if(maximum)then\n         dummy5=omp*MAXRUN\n         io = setenv('OMP_NUM_THREADS',dummy5)\n         io = setenv('MKL_NUM_THREADS',dummy5)\n      else\n         io = setenv('OMP_NUM_THREADS',omp)\n         io = setenv('MKL_NUM_THREADS',omp)\n\n      write(*,*)\n      write(*,*) '==================================='\n      write(*,'(''  # threads ='',9x,i3)')omp\n      dummy5=omp * MAXRUN\n      if(dummy5.gt.OMP_GET_NUM_PROCS())then\n         write(*,*) '! Warning: unreasonable combination of         !'\n         write(*,*) '! # of threads and # of parallel xTB calls.    !'\n         write(*,*) '! Adjusted to:                                 !'\n         omp1 = real(OMP_GET_NUM_PROCS())\n         omp2 = real(omp)\n         MAXRUN=floor((omp1/omp2))\n      endif\n      write(*,'(''  parallel xTB calls:''1x,i3)')MAXRUN\n      write(*,*) '==================================='\n      write(*,*)\n      endif\nend subroutine ompmklset\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c OMP and MKL parallelization settings (short routine)\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n\nsubroutine ompquickset(omp)\n      use iomod\n      implicit none\n      integer,intent(in) :: omp\n      integer :: io\n\n      io = setenv('OMP_NUM_THREADS',omp)\n      io = setenv('MKL_NUM_THREADS',omp)\n\nend subroutine ompquickset\n\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c OMP and MKL parallelization settings, getting the settings with maximum number of OMP threads\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine ompset_max(omp,maxrun)\n      use iomod\n      implicit none\n      integer,intent(inout) :: omp,maxrun\n      integer :: io\n\n      omp=omp*maxrun\n      maxrun=1\n\n      io = setenv('OMP_NUM_THREADS',omp)\n      io = setenv('MKL_NUM_THREADS',omp)\n\nend subroutine ompset_max\n\n\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c OMP and MKL parallelization settings, getting the settings with minimum number of OMP threads\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine ompset_min(omp,maxrun)\n      use iomod\n      implicit none\n      integer,intent(inout) :: omp,maxrun\n      integer :: io\n\n      maxrun=omp*maxrun\n      omp=1\n\n      io = setenv('OMP_NUM_THREADS',omp)\n      io = setenv('MKL_NUM_THREADS',omp)\n\nend subroutine ompset_min\n\n\n\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c OMP and MKL autoset switchcase routine\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine ompautoset(threads,mode,omp,maxrun,factor)\n      use omp_lib\n      implicit none\n      integer,intent(in) :: mode,factor\n      integer,intent(inout) :: threads,omp,maxrun\n      real*8 :: dum1\n\n      if(threads.eq.0)then                    !special case\n         threads=OMP_GET_NUM_PROCS()\n      endif\n\n      if(threads.gt.OMP_GET_NUM_PROCS())then  !limitation critirium 1: don't try to use more threads than available\n         threads=OMP_GET_NUM_PROCS()\n      endif\n\n      if((maxrun.gt.threads).or.(omp.gt.threads))then   !limitation critirium 2: don't use stupid maxrun or omp settings\n         maxrun=threads\n         omp=1\n      endif\n\n      dum1=float(omp)*float(maxrun)\n      if(dum1.lt.float(threads))then !limitation critirium 3: use the maximum number of threads\n         maxrun=threads\n         omp=1\n      endif\n\n      select case( mode )\n        case( 1 )   !maximum number of OMP threads\n          call ompset_max(omp,maxrun)\n        case( 2 )   !maximum number of parallel jobs\n          call ompset_min(omp,maxrun)\n        case( 3 )   !run multiple jobs each on multiple threads\n          dum1=float(threads)/float(factor)\n          if(dum1.ge.2)then\n             maxrun=factor\n             omp=floor(dum1)\n             call ompquickset(omp)\n          else\n             call ompset_min(omp,maxrun)\n          endif\n        case( 4 ) !max number of threads for confscript internal routines (does not apply to the system calls)\n          call OMP_Set_Num_Threads(threads)\n#ifdef WITH_MKL\n          call MKL_Set_Num_Threads(threads)\n#endif\n        case( 5 ) !max number of threads for confscript to 1 (so that confscript itself doesn't block to many cores)\n          call OMP_Set_Num_Threads(1)\n#ifdef WITH_MKL\n          call MKL_Set_Num_Threads(1)\n#endif\n        case( 6 ) !case 2 combined with case 4, for OMP parallel task loop ---> each individual xTB job has only 1 thread, confscript has maximum number of threads to manage task list\n          call ompset_min(omp,maxrun)\n          call OMP_Set_Num_Threads(maxrun)\n#ifdef WITH_MKL\n          call MKL_Set_Num_Threads(maxrun)\n#endif\n        case( 7 ) !case 3, but for OMP parallelization\n          dum1=float(threads)/float(factor)\n          if(dum1.ge.2)then\n             maxrun=factor\n             omp=floor(dum1)\n             call ompquickset(omp)\n          else\n             call ompset_min(omp,maxrun)\n          endif\n          call OMP_Set_Num_Threads(maxrun)\n#ifdef WITH_MKL\n          call MKL_Set_Num_Threads(maxrun)\n#endif\n        case( 8 ) !--- set OMP threads to max. or a given maximum, i.e. use an upper limit for the threads\n          omp=min(threads,factor)\n          maxrun=1\n          call ompquickset(omp)\n          call OMP_Set_Num_Threads(maxrun)\n#ifdef WITH_MKL\n          call MKL_Set_Num_Threads(maxrun)\n#endif\n        case default  !done if omp and MAXRUN are valid and \n          call ompquickset(omp)\n      end select     \n\n\nend subroutine ompautoset\n\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c get omp/mkl automatically from the global variables\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine ompgetauto(threads,omp,maxrun)\n      use omp_lib\n      use iomod\n      implicit none\n      integer,intent(inout) :: threads,omp,maxrun\n      integer :: nproc\n      integer :: r\n      character(len=256) :: val\n\n      call getenv('OMP_NUM_THREADS',val)\n      read(val,*,iostat=r) nproc\n      if(r.ne.0)then\n         nproc=1\n      endif\n      threads=nproc\n      maxrun=1\n      omp=nproc\n\nend subroutine ompgetauto\n\n\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c print omp/mkl automatically from the global variables\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine ompprint()\n      use omp_lib\n      implicit none\n      integer :: nproc\n      integer :: r\n      character(len=256) :: val\n\n      call getenv('OMP_NUM_THREADS',val)\n      read(val,*,iostat=r) nproc\n      if(r.ne.0)then\n         nproc=1\n      endif\n      write(*,*) '============================='\n      write(*,*) ' # threads =', nproc\n      write(*,*) '============================='\nend subroutine ompprint\n\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c print omp/mkl threads that are used at the moment\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine ompprint_intern()\n      use omp_lib\n      implicit none\n      integer :: nproc,TID\n\n!$OMP PARALLEL PRIVATE(TID)\n      TID = OMP_GET_THREAD_NUM()\n      IF (TID .EQ. 0) THEN\n         nproc = OMP_GET_NUM_THREADS()\n         write(*,*) '============================='\n         write(*,*) ' # threads =', nproc\n         write(*,*) '============================='\n      END IF\n!$OMP END PARALLEL \nend subroutine ompprint_intern\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ompmklset.F90 b/src/ompmklset.F90
--- a/src/ompmklset.F90	
+++ b/src/ompmklset.F90	
@@ -81,18 +81,18 @@
 !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 !c OMP and MKL parallelization settings, getting the settings with maximum number of OMP threads
 !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-subroutine ompset_max(omp,maxrun)
+subroutine ompset_max(threads)
       use iomod
       implicit none
-      integer,intent(inout) :: omp,maxrun
+      integer,intent(in) :: threads
       integer :: io
 
-      omp=omp*maxrun
-      maxrun=1
-
-      io = setenv('OMP_NUM_THREADS',omp)
-      io = setenv('MKL_NUM_THREADS',omp)
-
+      io = setenv('OMP_NUM_THREADS',threads)
+      io = setenv('MKL_NUM_THREADS',threads)
+      call OMP_Set_Num_Threads(threads)
+#ifdef WITH_MKL
+      call MKL_Set_Num_Threads(threads)
+#endif
 end subroutine ompset_max
 
 
@@ -148,7 +148,7 @@
 
       select case( mode )
         case( 1 )   !maximum number of OMP threads
-          call ompset_max(omp,maxrun)
+          call ompset_max(threads)
         case( 2 )   !maximum number of parallel jobs
           call ompset_min(omp,maxrun)
         case( 3 )   !run multiple jobs each on multiple threads
Index: src/algos/playground.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!> Implementation of whatever, for testing implementations\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>!\n!========================================================================================!\n!> Input/Output:\n!>  env  -  crest's systemdata object\n!>  tim  -  timer object\n!>-----------------------------------------------\nsubroutine crest_playground(env,tim)\n  use crest_parameters\n  use crest_data\n  use crest_calculator\n  use strucrd \n  use optimize_module\n  use tblite_api\n  use wiberg_mayer, only: write_wbo \n  use adjacency\n  use zdata\n  use probabilities_module\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(timer),intent(inout)      :: tim\n  type(coord) :: mol,molnew\n  integer :: i,j,k,l,io,ich \n  logical :: pr,wr\n!========================================================================================!\n  type(calcdata) :: calc\n  real(wp) :: accuracy,etemp\n   \n  integer :: V,maxgen\n  integer,allocatable :: A(:,:)\n  logical,allocatable :: rings(:,:)\n  integer,allocatable :: tmp(:)\n  logical :: connected,fail\n  type(zmolecule) :: zmol\n\n  real(wp) :: energy\n  real(wp),allocatable :: grad(:,:),geo(:,:)\n  integer,allocatable :: na(:),nb(:),nc(:),at2(:)\n  integer :: nat2\n  real(wp),allocatable :: mu(:)\n  real(wp) :: kappa,rrad\n!========================================================================================!\n  call tim%start(14,'Test implementation') \n!========================================================================================!\n  !call system('figlet welcome')\n  write(*,*) \"              _                          \"\n  write(*,*) \"__      _____| | ___ ___  _ __ ___   ___ \"\n  write(*,*) \"\\ \\ /\\ / / _ \\ |/ __/ _ \\| '_ ` _ \\ / _ \\\"\n  write(*,*) \" \\ V  V /  __/ | (_| (_) | | | | | |  __/\"\n  write(*,*) \"  \\_/\\_/ \\___|_|\\___\\___/|_| |_| |_|\\___|\"\n  write(*,*) \n!========================================================================================!\n  call env%ref%to(mol)\n  write(*,*)\n  write(*,*) 'Input structure:'\n  call mol%append(stdout)\n  write(*,*) \n!========================================================================================!\n\n call calcSrrhoav(env,env%ensemblename)  \n\n\n\n!========================================================================================!\n  call tim%stop(14)\n  return\nend subroutine crest_playground\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/playground.f90 b/src/algos/playground.f90
--- a/src/algos/playground.f90	
+++ b/src/algos/playground.f90	
@@ -78,9 +78,6 @@
   write(*,*) 
 !========================================================================================!
 
- call calcSrrhoav(env,env%ensemblename)  
-
-
 
 !========================================================================================!
   call tim%stop(14)
Index: src/algos/search_entropy.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nsubroutine crest_search_entropy(env,tim)\n!*******************************************************************\n!* This is the re-implementation of CREST's sMTD-iMTD workflow\n!* from https://doi.org/10.1039/d1sc00621e\n!* with calculation of conformational entropy\n!* This is a TODO\n!*******************************************************************\n  use crest_parameters,only:wp,stdout\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use dynamics_module\n  use shake_module\n  use iomod\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(timer),intent(inout)      :: tim\n  type(coord) :: mol,molnew\n  integer :: i,j,k,l,io,ich,m\n  logical :: pr,wr\n!===========================================================!\n  type(calcdata) :: calc\n  type(mddata) :: mddat\n  type(shakedata) :: shk\n\n  type(mddata),allocatable :: mddats(:)\n  integer :: nsim,nallout\n\n  real(wp) :: energy,gnorm\n  real(wp),allocatable :: grad(:,:)\n  character(len=:),allocatable :: ensnam\n  integer :: nat,nall\n  real(wp),allocatable :: eread(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  integer,allocatable  :: at(:)\n  logical :: dump,ex\n  character(len=80) :: atmp,btmp,str\n  logical :: multilevel(6)\n  logical :: start,lower\n!===========================================================!\n!> Entropy algo variables\n  logical :: stopiter,fail\n  integer :: bref,dum,eit,eit2\n!===========================================================!\n!>--- printout header\n  write (stdout,*)\n  write (stdout,'(10x,\"┍\",49(\"━\"),\"┑\")')\n  write (stdout,'(10x,\"│\",14x,a,13x,\"│\")') \"CREST ENTROPY SAMPLING\"\n  write (stdout,'(10x,\"┕\",49(\"━\"),\"┙\")')\n  write (stdout,*)\n  write (stdout,'(1x,a)') 'please cite:'\n  write (stdout,'(1x,a)') '• P.Pracht, S.Grimme, Chem. Sci., 2021, 12, 6551-6568.'\n  write (stdout,'(1x,a)') '• J.Gorges, S.Grimme, A.Hansen, P.Pracht, PCCP, 2022,24, 12249-12259.'\n  write (stdout,*)\n\n!===========================================================!\n!>--- setup\n  call env%ref%to(mol)\n  write (stdout,*) 'Input structure:'\n  call mol%append(stdout)\n  write (stdout,*)\n\n!>--- sets the MD length according to a flexibility measure\n  call md_length_setup(env)\n!>--- create the MD calculator saved to env\n  call env_to_mddat(env)\n\n  if (env%performMTD) then\n!>--- (optional) calculate a short 1ps test MTD to check settings\n   call tim%start(1,'trial metadynamics (MTD)')\n   call trialmd(env)    \n   call tim%stop(1)\n  end if\n\n!===========================================================!\n!>--- Start mainloop\n  env%nreset = 0\n  start = .true.\n  MAINLOOP: do\n    call printiter\n    if (.not.start) then\n!>--- clean Dir for new iterations, but leave iteration backup files\n      call clean_V2i\n      env%nreset = env%nreset+1\n    else\n!>--- at the beginning, wipe directory clean\n      call V2cleanup(.false.)\n    end if\n!===========================================================!\n!>--- Meta-dynamics loop\n    mtdloop: do i = 1,env%Maxrestart\n\n      write (stdout,*)\n      write (stdout,'(1x,a)') '------------------------------'\n      write (stdout,'(1x,a,i0)') 'Meta-Dynamics Iteration ',i\n      write (stdout,'(1x,a)') '------------------------------'\n\n      nsim = -1 !>--- enambles automatic MTD setup in init routines\n      call crest_search_multimd_init(env,mol,mddat,nsim)\n      allocate (mddats(nsim),source=mddat)\n      call crest_search_multimd_init2(env,mddats,nsim)\n\n      call tim%start(2,'Metadynamics (MTD)')\n      call crest_search_multimd(env,mol,mddats,nsim)\n      call tim%stop(2)\n!>--- a file called crest_dynamics.trj should have been written\n      ensnam = 'crest_dynamics.trj'\n!>--- deallocate for next iteration\n      if (allocated(mddats)) deallocate (mddats)\n\n!==========================================================!\n!>--- Reoptimization of trajectories\n      call tim%start(3,'Geometry optimization')\n      multilevel = (/.true.,.false.,.false.,.false.,.true.,.false./)\n      call crest_multilevel_oloop(env,ensnam,multilevel)\n      call tim%stop(3)\n\n!>--- save the CRE under a backup name\n      call checkname_xyz(crefile,atmp,str)\n      call checkname_xyz('.cre',str,btmp)\n      call rename(atmp,btmp)\n!>--- save cregen output\n      call checkname_tmp('cregen',atmp,btmp)\n      call rename('cregen.out.tmp',btmp)\n\n!=========================================================!\n!>--- cleanup after first iteration and prepare next\n      if (i .eq. 1.and.start) then\n        start = .false.\n!>-- obtain a first lowest energy as reference\n        env%eprivious = env%elowest\n!>-- remove the two extreme-value MTDs\n        if (.not.env%readbias.and.env%runver .ne. 33.and. &\n        &   env%runver .ne. 787878) then\n          env%nmetadyn = env%nmetadyn-2\n        end if\n!>-- the cleanup\n        call clean_V2i\n!>-- and always do two cycles of MTDs\n        cycle mtdloop\n      end if\n!=========================================================!\n!>--- Check for lowest energy\n      call elowcheck(lower,env)\n      if (.not.lower) then\n        exit mtdloop\n      end if\n    end do mtdloop\n!=========================================================!\n!>--- collect all ensembles from mtdloop and merge\n    write (stdout,*)\n    write (stdout,'(''========================================'')')\n    write (stdout,'(''           MTD Simulations done         '')')\n    write (stdout,'(''========================================'')')\n    write (stdout,'(1x,''Collecting ensmbles.'')')\n!>-- collecting all ensembles saved as \".cre_*.xyz\"\n    call collectcre(env)\n    call newcregen(env,0)\n    call checkname_xyz(crefile,atmp,btmp)\n!>--- remaining number of structures\n    call remaining_in(atmp,env%ewin,nallout)\n\n!=========================================================!\n!>--- (optional) Perform additional MDs on the lowest conformers\n    if (env%rotamermds) then\n      call tim%start(4,'Molecular dynamics (MD)')\n      call crest_rotamermds(env,conformerfile)\n      call tim%stop(4)\n\n!>--- Reoptimization of trajectories\n      call checkname_xyz(crefile,atmp,btmp)\n      write (stdout,'('' Appending file '',a,'' with new structures'')') trim(atmp)\n      ensnam = 'crest_dynamics.trj'\n      call appendto(ensnam,trim(atmp))\n      call tim%start(3,'Geometry optimization')\n      call crest_multilevel_wrap(env,trim(atmp),5)\n      call tim%stop(3)\n\n      call elowcheck(lower,env)\n      if (lower) then\n        call checkname_xyz(crefile,atmp,str)\n        call checkname_xyz('.cre',str,btmp)\n        call rename(atmp,btmp)\n        cycle MAINLOOP\n      end if\n    end if\n\n!=========================================================!\n!>---- Entropy mode iterative statically biased MDs\n    if (env%entropymd) then\n!>--- determine how many MDs need to be run and setup\n!>--- and other entropy mode parameters\n      call adjustnormmd(env)\n      call mtdatoms(env)\n      call emtdcopy(env,0,stopiter,fail)\n      bref = env%emtd%nbias\n\n!>--- sMTD iterations, done until max iterations or convergence\n      ENTROPYITER: do eit = 1,env%emtd%iter\n        !> Modify bias\n        dum = nint(float(env%emtd%nbias)*env%emtd%nbiasgrow)\n        env%emtd%nbias = max(env%emtd%nbias+1,dum)\n        fail = .false.\n\n!>--- Loop handling fallbacks\n        EFALLBACK: do k = 1,env%emtd%maxfallback\n          call printiter2(eit)\n          call tim%start(6,'Static metadynamics (sMTD)')\n          !>-- start from the current crest_conformers.xyz\n          call crest_smtd_mds(env,conformerfile)\n          call tim%stop(6)\n          call emtdcheckempty(env,fail,env%emtd%nbias)\n\n          if (fail) then\n            if (k == env%emtd%maxfallback) then\n              stopiter = .true.\n            else\n              cycle EFALLBACK\n            end if\n          else\n\n!!>--- Reoptimization of trajectories\n            call checkname_xyz(crefile,atmp,btmp)\n            call tim%start(3,'Geometry optimization')\n            multilevel = (/.true.,.false.,.false.,.false.,.false.,.true./)\n            call crest_multilevel_oloop(env,trim(atmp),multilevel)\n            call tim%stop(3)\n\n!>--- if in the entropy mode a lower structure was found -> cycle (required for extrapolation)\n            call elowcheck(lower,env)\n            if (lower.and.env%entropic) then\n              env%emtd%nbias = bref  !> IMPORTANT, reset for restart\n              cycle MAINLOOP\n            end if\n\n!>--- otherwise, handle files andfile handling\n            eit2 = eit\n            call emtdcopy(env,eit2,stopiter,fail)\n            env%emtd%iterlast = eit2\n          end if\n\n          if (.not.lower.and.fail.and..not.stopiter) then\n            cycle EFALLBACK\n          end if\n\n          exit EFALLBACK  !> fallback loop is exited on first opportuinity\n        end do EFALLBACK\n\n        if (stopiter) then\n          exit ENTROPYITER\n        end if\n\n      end do ENTROPYITER\n    end if\n\n!==========================================================!\n!>--- exit mainloop\n    exit MAINLOOP\n  end do MAINLOOP\n\n!==========================================================!\n!>--- print CREGEN results and clean up Directory a bit\n  write (stdout,'(/)')\n  call smallhead('Final Ensemble Information')\n  call V2terminating()\n\n!==========================================================!\n  return\nend subroutine crest_search_entropy\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n!========================================================================================!\n\nsubroutine crest_smtd_mds(env,ensnam)\n!***********************************************************\n!* set up and perform several sMTD's on a number of\n!* conformers obtained from clustering.\n!* The input ensemble (read from ensnam) is typically the\n!* conformer file.\n!***********************************************************\n  use crest_parameters,only:wp,stdout,bohr\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use iomod\n  use dynamics_module\n  implicit none\n  type(systemdata),intent(inout) :: env\n  character(len=*),intent(in) :: ensnam\n\n  integer :: nsim\n  type(mddata) :: mddat\n  type(mddata),allocatable :: mddats(:)\n  type(coord) :: mol\n  type(coord),allocatable :: mols(:)\n  integer :: nat,nall\n  real(wp),allocatable :: eread(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  integer,allocatable  :: at(:)\n  integer :: nstrucs,i,j,k,io\n  real(wp) :: temp,newtemp\n  character(len=128) :: atmp,btmp\n!============================================================!\n  integer :: nclustbackup\n  integer :: TOTAL\n!============================================================!\n!>--- coord setup\n  call env%ref%to(mol)\n  call rdensembleparam(ensnam,nat,nall)\n  if (nall .lt. 1) then\n    write (stdout,*) 'empty ensemble file',trim(ensnam)\n    return\n  end if\n\n!============================================================!\n!>--- PCA/k-Means Cluster setup\n!============================================================!\n  nclustbackup = env%maxcluster\n\n  !>--- first, generate the structures will be used as bias\n  env%nclust = env%emtd%nbias  !> this determines how many clusters will be build\n  call create_anmr_dummy(nat)\n  call smallhead('determining bias structures via PCA/k-Means')\n  call CCEGEN(env,.false.,ensnam)  !> this routine does PCA/k-Means\n  call rdensembleparam(clusterfile,nat,TOTAL)\n  if (TOTAL < 1) then\n    call copy('crest_best.xyz',clusterfile)\n    TOTAL = 1\n  end if\n  write (*,'(1x,i0,a)') TOTAL,' structures were selected'\n  write (*,'(1x,a,/)') 'done.'\n  env%mtdstaticfile = \"crest_bias.xyz\"\n  env%nstatic = TOTAL\n  call rename(clusterfile,env%mtdstaticfile)\n\n  !>--- then, get the input structures\n  env%nclust = env%emtd%nMDs  !> this determines how many clusters will be build\n  call smallhead('determining MTD seed structures via PCA/k-Means')\n  call CCEGEN(env,.false.,ensnam)  !> this routine does PCA/k-Means\n  call rdensembleparam(clusterfile,nat,TOTAL)\n  write (stdout,'(1x,i0,a)') TOTAL,' structures were selected'\n  write (stdout,'(1x,a,/)') 'done.'\n\n  !>--- and cleanup\n  call remove('anmr_nucinfo')\n  env%nclust = nclustbackup\n!============================================================!\n!============================================================!\n\n!>--- Generate the required number of static MD calculators\n  nsim = TOTAL !> from the generated cluster\n  call crest_search_multimd_init(env,mol,mddat,nsim) !> general mddat setup\n  allocate (mddats(nsim),source=mddat)\n!>--- adjust T's and runtimes, and load the bias\n  call crest_init_multimd_smtd(env,mddats,nsim,env%mtdstaticfile)\n\n!>--- read cluster ensemble and prepare mols to start MTDs from\n  call rdensemble(clusterfile,nall,mols)\n\n!>--- print what we are doing\n  write (atmp,'(''Static MTDs (umbrella sampling) on '',i0,'' selected conformer(s)'')') nall\n  call smallheadline(trim(atmp))\n  write (stdout,'(\"> Using \",i0,\" constant RMSD bias potentials per MTD\")') env%nstatic\n\n!===================================================================!\n!>--- and finally, run the sMTDs on the different starting structures\n  call crest_search_multimd2(env,mols,mddats,nsim)\n!>--- output will be collected in crest_dynamics.trj\n!>--- but the entropy routines look for the crest_rotamers_ files\n  call checkname_xyz(crefile,atmp,btmp)\n  call rename('crest_dynamics.trj',atmp)\n!===================================================================!\n!>--- by default, clean up the directory\n  if (.not.env%keepModef) call cleanMTD\n\n!>--- deallocate molecule and MD containers\n  if (allocated(mols)) deallocate (mols)\n  if (allocated(mddats)) deallocate (mddats)\n  return\nend subroutine crest_smtd_mds\n\n!=========================================================================================!\nsubroutine crest_init_multimd_smtd(env,mddats,nsim,biasfile)\n!**************************************************************\n!* Append a list of MD calculators (mddats),\n!* change them to static metadynamics and\n!* adujst otherwise needed parameter such as the temperature.\n!* Bias structures will be read from biasfile\n!*\n!* The routines adjustnormmd() and mtdatoms() must have been\n!* called before calling this routine so all the required data\n!* is initialized!\n!**************************************************************\n  use crest_parameters,only:wp,stdout,bohr,sep\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use dynamics_module\n  use iomod,only:makedir,directory_exist,remove\n!$ use omp_lib\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(mddata),intent(inout) :: mddats(nsim)\n  integer,intent(in) :: nsim\n  character(len=*),intent(in) :: biasfile\n  integer :: i,io\n  integer :: nat,nall\n  integer,allocatable :: at(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  real(wp),allocatable :: eread(:)\n  logical :: ex\n  integer :: idum1\n  real(wp) :: dum1\n  type(mtdpot),allocatable :: mtds(:)\n  type(mtdpot) :: mtdtmp\n  character(len=80) :: atmp\n  character(len=*),parameter :: mdir = 'STATICMTD'\n\n!>--- parallel MD setup, prepare files\n  ex = directory_exist(mdir)\n  if (ex) then\n    call rmrf(mdir)\n  end if\n  io = makedir(mdir)\n  do i = 1,nsim\n    mddats(i)%md_index = i\n    write (atmp,'(a,i0,a)') 'crest_',i,'.trj'\n    mddats(i)%trajectoryfile = mdir//sep//trim(atmp)\n    write (atmp,'(a,i0,a)') 'crest_',i,'.mdrestart'\n    mddats(i)%restartfile = mdir//sep//trim(atmp)\n!>--- append settings\n    mddats(i)%simtype = type_mtd  !> set to MTD runtype (includes the static version)\n    mddats(i)%tsoll = env%emtd%temperature !> temperature\n    mddats(i)%length_ps = env%mdtime*env%emtd%lenfac  !> simulation length\n!>--- complete real-time settings to steps again\n    call mdautoset(mddats(i),io)\n  end do\n\n!>--- kpush & alpha, and parameters that will be the same for all\n  mtdtmp%kpush = env%emtd%katoms*env%emtd%kpush\n  mtdtmp%alpha = env%emtd%alpha\n  mtdtmp%cvdump_fs = huge(dum1)   !> set to large to avoid new structure dumps\n  mtdtmp%cvdumpstep = huge(idum1) !> same\n  mtdtmp%mtdtype = cv_rmsd_static  !> set the correct bias type\n\n!>--- load static bias stuctures\n  inquire (file=biasfile,exist=ex)\n  if (.not.ex) error stop 'Could not initialize static metadynamics'\n  call rdensembleparam(biasfile,nat,nall)\n  allocate (xyz(3,nat,nall),at(nat),eread(nall))\n  call rdensemble(biasfile,nat,nall,at,xyz,eread)\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n!>--- Important: bias structures must be in Bohrs\n  xyz = xyz/bohr\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n\n!>--- transfer a copy of mtdtmp to each MD container\n  do i = 1,nsim\n    if (allocated(mddats(i)%mtd)) deallocate (mddats(i)%mtd)\n    if (allocated(mddats(i)%cvtype)) deallocate (mddats(i)%cvtype)\n    mddats(i)%npot = 1\n    allocate (mddats(i)%mtd(1),source=mtdtmp)\n    allocate (mddats(i)%cvtype(1),source=cv_rmsd_static)\n\n    !>--- a ramp parameter depending on timestep (relative to old GFN2-xTB default)\n    mddats(i)%mtd(1)%ramp = (mddats(i)%tstep/5.0_wp)*env%emtd%mtdramp\n\n    !>--- the bias structures are transferred here\n    allocate (mddats(i)%mtd(1)%cvxyz(3,nat,nall))\n    mddats(i)%mtd(1)%cvxyz(:,:,:) = xyz(:,:,:)\n    mddats(i)%mtd(1)%ncur = nall    !> will not change\n    mddats(i)%mtd(1)%maxsave = nall !> won't change either\n\n    !>--- transfer the atomlist (ther sMTD pot is only acting on the heavy atoms)\n    allocate (mddats(i)%mtd(1)%atinclude(nat),source=.false.)\n    mddats(i)%mtd(1)%atinclude(:) = env%emtd%atomlist2(:)\n  end do\n\n  deallocate (eread,at,xyz)\n  return\nend subroutine crest_init_multimd_smtd\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/search_entropy.f90 b/src/algos/search_entropy.f90
--- a/src/algos/search_entropy.f90	
+++ b/src/algos/search_entropy.f90	
@@ -31,6 +31,7 @@
   use dynamics_module
   use shake_module
   use iomod
+  use utilities
   implicit none
   type(systemdata),intent(inout) :: env
   type(timer),intent(inout)      :: tim
@@ -86,7 +87,7 @@
 
   if (env%performMTD) then
 !>--- (optional) calculate a short 1ps test MTD to check settings
-   call tim%start(1,'trial metadynamics (MTD)')
+   call tim%start(1,'Trial metadynamics (MTD)')
    call trialmd(env)    
    call tim%stop(1)
   end if
@@ -130,7 +131,7 @@
 !==========================================================!
 !>--- Reoptimization of trajectories
       call tim%start(3,'Geometry optimization')
-      multilevel = (/.true.,.false.,.false.,.false.,.true.,.false./)
+      call optlev_to_multilev(env%optlev,multilevel)
       call crest_multilevel_oloop(env,ensnam,multilevel)
       call tim%stop(3)
 
@@ -179,31 +180,6 @@
 !>--- remaining number of structures
     call remaining_in(atmp,env%ewin,nallout)
 
-!=========================================================!
-!>--- (optional) Perform additional MDs on the lowest conformers
-    if (env%rotamermds) then
-      call tim%start(4,'Molecular dynamics (MD)')
-      call crest_rotamermds(env,conformerfile)
-      call tim%stop(4)
-
-!>--- Reoptimization of trajectories
-      call checkname_xyz(crefile,atmp,btmp)
-      write (stdout,'('' Appending file '',a,'' with new structures'')') trim(atmp)
-      ensnam = 'crest_dynamics.trj'
-      call appendto(ensnam,trim(atmp))
-      call tim%start(3,'Geometry optimization')
-      call crest_multilevel_wrap(env,trim(atmp),5)
-      call tim%stop(3)
-
-      call elowcheck(lower,env)
-      if (lower) then
-        call checkname_xyz(crefile,atmp,str)
-        call checkname_xyz('.cre',str,btmp)
-        call rename(atmp,btmp)
-        cycle MAINLOOP
-      end if
-    end if
-
 !=========================================================!
 !>---- Entropy mode iterative statically biased MDs
     if (env%entropymd) then
@@ -303,6 +279,7 @@
   use crest_calculator
   use strucrd
   use iomod
+  use utilities
   use dynamics_module
   implicit none
   type(systemdata),intent(inout) :: env
@@ -368,7 +345,7 @@
 !============================================================!
 
 !>--- Generate the required number of static MD calculators
-  nsim = TOTAL !> from the generated cluster
+  nsim = min(TOTAL,env%emtd%nMDs) !> from the generated cluster, but limited to env%emtd%nMDs
   call crest_search_multimd_init(env,mol,mddat,nsim) !> general mddat setup
   allocate (mddats(nsim),source=mddat)
 !>--- adjust T's and runtimes, and load the bias
@@ -378,7 +355,7 @@
   call rdensemble(clusterfile,nall,mols)
 
 !>--- print what we are doing
-  write (atmp,'(''Static MTDs (umbrella sampling) on '',i0,'' selected conformer(s)'')') nall
+  write (atmp,'(''Static MTDs (umbrella sampling) on '',i0,'' selected conformer(s)'')') nsim
   call smallheadline(trim(atmp))
   write (stdout,'("> Using ",i0," constant RMSD bias potentials per MTD")') env%nstatic
 
@@ -417,6 +394,7 @@
   use strucrd
   use dynamics_module
   use iomod,only:makedir,directory_exist,remove
+  use utilities 
 !$ use omp_lib
   implicit none
   type(systemdata),intent(inout) :: env
Index: src/algos/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nset(dir \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\nlist(APPEND srcs\n  \"${dir}/singlepoint.f90\"\n  \"${dir}/dynamics.f90\"\n  \"${dir}/numhess.f90\"\n  \"${dir}/optimization.f90\"\n  \"${dir}/playground.f90\"\n  \"${dir}/crossing.f90\"\n  \"${dir}/scan.f90\" \n  \"${dir}/search_1.f90\"\n  \"${dir}/search_mecp.f90\"\n  \"${dir}/setuptest.f90\"\n  \"${dir}/hessian_tools.f90\"\n  \"${dir}/search_imtdgc.f90\"\n  \"${dir}/search_entropy.f90\"\n  \"${dir}/parallel.f90\"\n)\n\nset(srcs ${srcs} PARENT_SCOPE)\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/CMakeLists.txt b/src/algos/CMakeLists.txt
--- a/src/algos/CMakeLists.txt	
+++ b/src/algos/CMakeLists.txt	
@@ -23,12 +23,14 @@
   "${dir}/optimization.f90"
   "${dir}/playground.f90"
   "${dir}/crossing.f90"
+  "${dir}/refine.f90"
   "${dir}/scan.f90" 
   "${dir}/search_1.f90"
   "${dir}/search_mecp.f90"
   "${dir}/setuptest.f90"
   "${dir}/hessian_tools.f90"
-  "${dir}/search_imtdgc.f90"
+  "${dir}/ConfSolv.F90"
+  "${dir}/search_conformers.f90"
   "${dir}/search_entropy.f90"
   "${dir}/parallel.f90"
 )
Index: src/ztopology.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!================================================================================!\n!  This file contains many subroutines related to topology setup of a molecule.\n!  It requires the polymorphic datatype \"zmolecule\", which can be found in the\n!  \"zdata.f90\" module.\n!\n!  Most routines are based on a representation where the molecule is seen as a\n!  \"graph\" and the topology is analyzed by navigating through the different\n!  paths of the graph.\n!\n!  P. Pracht, 2019/20\n!================================================================================!\n!================================================================================!\n!  SIMPLETOPO: set up topology.\n!  All the information is stored in the complex datatype object \"zmol\"\n!  Although the name implies it, there is nothing much \"simple\" for some\n!  of the routines ...\n!\n!  simpeltopo_file version is a file wrapper\n!  simpeltopo_mol version is a wrapper for a coord object\n!================================================================================!\nsubroutine simpletopo_file(fname,zmol,verbose,getrings,wbofile)\n  use iso_fortran_env,wp => real64\n  use zdata\n  use strucrd,only:rdnat,rdcoord\n  implicit none\n  character(len=*) :: fname\n  type(zmolecule)  :: zmol\n  logical          :: verbose\n  logical          :: getrings\n  character(len=*),optional :: wbofile\n  integer :: n\n  integer,allocatable :: at(:)\n  real(wp),allocatable :: xyz(:,:)\n  logical :: ex\n  interface\n    subroutine simpletopo(n,at,xyz,zmol,verbose,getrings,wbofile)\n      import :: zmolecule,wp\n      implicit none\n      type(zmolecule)  :: zmol\n      logical          :: verbose\n      logical          :: getrings\n      integer,intent(in)  :: n\n      integer,intent(in)  :: at(n)\n      real(wp),intent(in) :: xyz(3,n) !in Bohrs\n      character(len=*),intent(in),optional :: wbofile\n    end subroutine simpletopo\n  end interface\n\n  call rdnat(fname,n)\n  allocate (at(n),xyz(3,n))\n  call rdcoord(fname,n,at,xyz)\n\n  ex = .false.\n  if (present(wbofile)) then\n    inquire (file=wbofile,exist=ex)\n  end if\n  if (.not.ex) then\n    call simpletopo(n,at,xyz,zmol,verbose,getrings,'')\n  else\n    call simpletopo(n,at,xyz,zmol,verbose,getrings,wbofile)\n  end if\n\n  deallocate (xyz,at)\n  return\nend subroutine simpletopo_file\n\nsubroutine simpletopo_mol(mol,zmol,verbose,getrings)\n  use iso_fortran_env,wp => real64\n  use zdata\n  use strucrd\n  implicit none\n  type(coord)      :: mol    !in\n  type(zmolecule)  :: zmol   !out\n  logical          :: verbose\n  logical          :: getrings\n  interface\n    subroutine simpletopo(n,at,xyz,zmol,verbose,getrings,wbofile)\n      import :: zmolecule,wp\n      implicit none\n      type(zmolecule)  :: zmol\n      logical          :: verbose\n      logical          :: getrings\n      integer,intent(in)  :: n\n      integer,intent(in)  :: at(n)\n      real(wp),intent(in) :: xyz(3,n) !in Bohrs\n      character(len=*),intent(in),optional :: wbofile\n    end subroutine simpletopo\n  end interface\n  call simpletopo(mol%nat,mol%at,mol%xyz,zmol,verbose,getrings,'')\n  return\nend subroutine simpletopo_mol\n\n!================================================================================!\n!  SIMPLETOPO: set up topology.\n!  n   - number of atoms\n!  at  - atom types (as atom number)\n!  xyz - cartesian coordinates (in Bohrs)\n!  zmol - polymorphic datatype containing the molecule data\n!  verbose - boolean to activate printouts\n!  wbofile - (optional) name of the file containing WBOs\n!================================================================================!\nsubroutine simpletopo(n,at,xyz,zmol,verbose,getrings,wbofile)\n  use crest_parameters\n  use zdata\n  implicit none\n  type(zmolecule)  :: zmol\n  type(zmolecule)  :: zfrag\n  type(zring)      :: newring\n  logical          :: verbose\n  logical          :: getrings\n  integer,intent(in)  :: n\n  integer,intent(in)  :: at(n)\n  real(wp),intent(in) :: xyz(3,n) !in Bohrs\n  character(len=*),intent(in),optional :: wbofile\n  type(zatom),allocatable :: zat(:)\n  real(wp),allocatable :: cn(:)\n  real(wp),allocatable :: bond(:,:)\n  real(wp),allocatable :: wbo(:,:)\n  real(wp),allocatable :: rcov(:)\n  integer :: i,j,k\n  integer :: ntopo\n  logical,allocatable :: neighmat(:,:)\n  integer,allocatable :: topovec(:)\n  integer :: nrings\n\n  logical :: ex,useWBO\n\n!--- header\n  if (verbose) then\n    write (*,*)\n    call smallhead('TOPOLOGY ANALYSIS')\n  end if\n\n!--- set covalent radii and calculate coordination numbers\n  allocate (rcov(94))\n  call setrcov(rcov)\n  allocate (cn(n),bond(n,n))\n  call xcoord2(n,at,xyz,rcov,cn,900.0_wp,bond)\n!--- read in WBOs if required\n  ex = .false.\n  if (present(wbofile)) then\n    inquire (file=wbofile,exist=ex)\n  end if\n  if (ex) then\n    allocate (wbo(n,n))\n    call readwbo(\"wbo\",n,wbo)\n    !write(*,*) wbo\n    !stop\n    useWBO = .true.\n  else\n    useWBO = .false.\n  end if\n\n  allocate (zat(n))\n  if (.not.useWBO) then\n!--- get individual neighbour lists and set up molecule object \"zat\"\n    ntopo = n*(n+1)/2\n    allocate (neighmat(n,n),source=.false.)\n    allocate (topovec(ntopo))\n    call bondtotopo(n,at,bond,cn,ntopo,topovec,neighmat)\n    call neighbourset(zmol,n,at,xyz,cn,ntopo,topovec)\n    deallocate (topovec,neighmat)\n  else\n!--- neighbour list could also be set up from WBOs, which is not necessarily better\n    do i = 1,n\n      zat(i)%cn = cn(i)\n      call wboneighbours(i,n,at,xyz,wbo,0.7d0,zat(i))\n      call wborepaireta(i,n,at,xyz,cn,wbo,zat(i))  !handle eta-coordinated atoms\n    end do\n\n    !--- transfer information to zmol class\n    zmol%nat = n      !number of atoms\n    zmol%zat = zat    !list of atoms, including data\n    zmol%at = at      !list of atom types (integer)\n  end if\n  do i = 1,n\n    call zat(i)%deallocate()\n  end do\n  !if(allocated(zat))deallocate(zat)\n\n!--- analyze system for fragments\n  call zmol%mrec()\n\n  allocate (zmol%distmat(n,n))\n  do i = 1,n\n    do j = 1,n\n      zmol%distmat(i,j) = (xyz(1,i)-xyz(1,j))**2+ &\n    &                   (xyz(2,i)-xyz(2,j))**2+ &\n    &                   (xyz(3,i)-xyz(3,j))**2\n      zmol%distmat(i,j) = sqrt(zmol%distmat(i,j))\n    end do\n  end do\n\n!--- printouts?\n  if (verbose) then\n    write (*,'(1x,a)') 'Coordinates (Bohr):'\n    do i = 1,n\n      call zmol%zat(i)%wrtmline(6)\n    end do\n    write (*,*)\n    call zmol%wrtable(6)\n    write (*,*)\n\n    if (allocated(zmol%molvec)) then\n      write (*,'(1x,a,i0)') 'Number of fragments in the system:  ',zmol%nfrag\n      write (*,*)\n    end if\n  end if\n\n!--- identify rings\n  if (getrings) then\n    do i = 1,zmol%nfrag\n      call zmol%fragment(i,zfrag)\n      !zfrag%maxring = maxringident !maxringident is a global variable from zdata.f90\n      !call countrings(zfrag,nrings)\n      !if (verbose.and.nrings > 0) then\n      !  if (zmol%nfrag > 1) then\n      !    write (*,'(1x,a,i0)') 'Fragment ',i\n      !    write (*,'(1x,a,i0,/)') 'Total number of rings in the fragment: ',nrings\n      !  else\n      !    write (*,'(1x,a,i0,/)') 'Total number of rings in the system: ',nrings\n      !  end if\n      !end if\n      !if (nrings .ge. 1) then\n      !  allocate (zfrag%zri(nrings))\n      call newgetrings(zfrag,.false.)\n      nrings = zfrag%nri\n      do j = 1,nrings\n        newring = zfrag%zri(j)\n        do k = 1,newring%rs\n          newring%rlist(k) = zfrag%revmap(newring%rlist(k))\n        end do\n        call zmol%addring(newring)\n        call newring%deallocate()\n      end do\n      !end if\n      if (verbose.and.nrings > 0) then\n        if (zmol%nfrag > 1) then\n          write (stdout,'(1x,a,i0)') 'Fragment ',i\n          write (stdout,'(1x,a,i0,/)') 'Total number of rings in the fragment: ',nrings\n        else\n          write (stdout,'(1x,a,i0,/)') 'Total number of rings in the system: ',nrings\n        end if\n      end if\n      call zfrag%deallocate()\n    end do\n    if (verbose) then\n      call zmol%prrings(stdout)\n      if (zmol%nri > 0) then\n        write (stdout,'(/,1x,a,i0,/)') 'Total number of rings in the system: ',zmol%nri\n      end if\n    end if\n  end if\n\n!--- deallocation of memory\n  if (allocated(wbo)) deallocate (wbo)\n  deallocate (bond,cn)\n  deallocate (rcov)\n  return\nend subroutine simpletopo\n\n!=======================================================================!\n!C compute coordination numbers by adding an inverse damping function\n!=======================================================================!\nsubroutine xcoord2(nat,iz,xyz,rcov,cn,cn_thr,bond)\n  use iso_fortran_env,wp => real64\n  implicit none\n  integer,intent(in) :: nat\n  integer,intent(in) :: iz(nat)\n  real(wp),intent(in) :: xyz(3,nat)\n  real(wp),intent(out) :: cn(nat)\n  real(wp),intent(in)  :: cn_thr\n  real(wp),intent(in)  :: rcov(94)\n  real(wp),intent(out) :: bond(nat,nat)\n  integer :: i,k1\n  integer :: iat\n  real(wp) :: dx,dy,dz,r,damp,xn,rr,rco,r2,rcovi,rcovj\n  k1 = 16\n  bond = 0.0d0\n  cn = 0.0d0\n  do i = 1,nat\n    xn = 0.0d0\n    rcovi = rcov(iz(i))\n    do iat = 1,nat\n      if (iat .ne. i) then\n        dx = xyz(1,iat)-xyz(1,i)\n        dy = xyz(2,iat)-xyz(2,i)\n        dz = xyz(3,iat)-xyz(3,i)\n        r2 = dx*dx+dy*dy+dz*dz\n        r = sqrt(r2)\n        if (r2 .gt. cn_thr) cycle\n        rcovj = rcov(iz(iat))\n! covalent distance in Bohr\n        rco = (rcovi+rcovj)*1.0  ! this scaling reduces the size of the clusters\n        rr = rco/r\n! counting function exponential has a better long-range behavior than MHGs inverse damping\n        damp = 1.d0/(1.d0+exp(-k1*(rr-1.0d0)))\n        bond(iat,i) = damp\n        xn = xn+damp\n      end if\n    end do\n    cn(i) = xn\n  end do\n  return\nend subroutine xcoord2\n\n!===================================================!\n! generate the topo array for a given structure\n!===================================================!\nsubroutine bondtotopo(nat,at,bond,cn,ntopo,topo,neighbourmat)\n  use iso_fortran_env,only:wp => real64\n  integer,intent(in)  :: nat\n  integer,intent(in) :: at(nat)\n  real(wp),intent(inout) :: bond(nat,nat)\n  real(wp),intent(in) :: cn(nat)\n  integer,intent(in)  :: ntopo\n  integer,intent(out) :: topo(ntopo)\n  real(wp),allocatable :: cn2(:)\n  logical,intent(inout) :: neighbourmat(nat,nat)\n  integer :: i,j,k,l\n  integer :: icn,rcn\n  integer :: lin\n  allocate (cn2(nat),source=0.0_wp)\n  topo = 0\n  neighbourmat = .false.\n  !--- some heuristic rules and CN array setup\n  do i = 1,nat\n    cn2(i) = cn(i)\n    rcn = floor(cn(i))\n    select case (at(i)) !additional empirical topology rules\n      ! case( 5 ) !B\n      !   if( nint(cn(i)) > 4) cn2(i)=4.0_wp\n      ! case( 9,17,35,53 ) !F,Cl,Br,I\n      !   cn2(i) = min(cn(i),1.0_wp)\n    case (6) !C\n      if ((cn(i)-rcn) < 0.7_wp) then\n        cn2(i) = rcn\n      end if\n    end select\n    !-- extreme CN cases\n    if (nint(cn(i)) > 8) cn2(i) = 8.0_wp\n    !empirical: rounding down up to .6 is better for topo setup\n    if ((cn(i)-rcn) < 0.6_wp) then\n      cn2(i) = rcn\n    end if\n  end do\n  !--- build the topology\n  do i = 1,nat\n    icn = nint(cn2(i))\n    do k = 1,icn\n      j = maxloc(bond(:,i),1)\n      bond(j,i) = 0.0d0\n      if (i .eq. j) cycle\n      neighbourmat(i,j) = .true. !--important: not automatically (i,j)=(j,i)\n    end do\n  end do\n  do i = 1,nat\n    do j = 1,nat\n      if (i == j) cycle\n      l = lin(i,j)\n      !-- only save matching topology --> prevent high CN failures\n      if (neighbourmat(i,j).and.neighbourmat(j,i)) then\n        topo(l) = 1\n      else\n        ! special case for carbon (because the carbon CN is typically correct)\n        ! this helps, e.g. with eta-coordination in ferrocene\n        ! (used, except if both are carbon)\n        if (.not. (at(i) == 6.and.at(j) == 6)) then\n          if (at(i) == 6.and.neighbourmat(i,j)) topo(l) = 1\n          if (at(j) == 6.and.neighbourmat(j,i)) topo(l) = 1\n        end if\n      end if\n    end do\n  end do\n  deallocate (cn2)\n  return\nend subroutine bondtotopo\n\nsubroutine bondtotopo_excl(nat,at,bond,cn,ntopo,topo,neighbourmat,excl)\n  use iso_fortran_env,only:wp => real64\n  integer,intent(in)  :: nat\n  integer,intent(in) :: at(nat)\n  real(wp),intent(inout) :: bond(nat,nat)\n  real(wp),intent(in) :: cn(nat)\n  integer,intent(in)  :: ntopo\n  integer,intent(out) :: topo(ntopo)\n  real(wp),allocatable :: cn2(:)\n  logical,intent(inout) :: neighbourmat(nat,nat)\n  logical,intent(in) :: excl(nat)\n  integer :: i,j,k,l\n  integer :: icn,rcn\n  integer :: lin\n  allocate (cn2(nat),source=0.0_wp)\n  topo = 0\n  neighbourmat = .false.\n  !--- some heuristic rules and CN array setup\n  do i = 1,nat\n    cn2(i) = cn(i)\n    rcn = floor(cn(i))\n    select case (at(i)) !additional empirical topology rules\n      ! case( 5 ) !B\n      !   if( nint(cn(i)) > 4) cn2(i)=4.0_wp\n      ! case( 9,17,35,53 ) !F,Cl,Br,I\n      !   cn2(i) = min(cn(i),1.0_wp)\n    case (6) !C\n      if ((cn(i)-rcn) < 0.7_wp) then\n        cn2(i) = rcn\n      end if\n    end select\n    !-- extreme CN cases\n    if (nint(cn(i)) > 8) cn2(i) = 8.0_wp\n    !empirical: rounding down up to .6 is better for topo setup\n    if ((cn(i)-rcn) < 0.6_wp) then\n      cn2(i) = rcn\n    end if\n  end do\n  !--- build the topology\n  do i = 1,nat\n    icn = nint(cn2(i))\n    do k = 1,icn\n      j = maxloc(bond(:,i),1)\n      bond(j,i) = 0.0d0\n      if (i .eq. j) cycle\n      neighbourmat(i,j) = .true. !--important: not automatically (i,j)=(j,i)\n      if (excl(i).or.excl(j)) neighbourmat(i,j) = .false.\n    end do\n  end do\n  do i = 1,nat\n    do j = 1,nat\n      if (i == j) cycle\n      l = lin(i,j)\n      !-- only save matching topology --> prevent high CN failures\n      if (neighbourmat(i,j).and.neighbourmat(j,i)) then\n        topo(l) = 1\n      else\n        ! special case for carbon (because the carbon CN is typically correct)\n        ! this helps, e.g. with eta-coordination in ferrocene\n        ! (used, except if both are carbon)\n        if (.not. (at(i) == 6.and.at(j) == 6)) then\n          if (at(i) == 6.and.neighbourmat(i,j)) topo(l) = 1\n          if (at(j) == 6.and.neighbourmat(j,i)) topo(l) = 1\n        end if\n      end if\n    end do\n  end do\n  deallocate (cn2)\n  return\nend subroutine bondtotopo_excl\nsubroutine quicktopo(nat,at,xyz,ntopo,topovec)\n  use iso_fortran_env,only:wp => real64\n  implicit none\n  integer :: nat\n  integer :: at(nat)\n  real(wp) :: xyz(3,nat) !must be in Bohrs\n  integer :: ntopo\n  integer :: topovec(ntopo)\n  real(wp),allocatable :: rcov(:),cn(:),bond(:,:)\n  logical,allocatable :: neighmat(:,:)\n  allocate (rcov(94))\n  call setrcov(rcov)\n  allocate (bond(nat,nat),cn(nat),source=0.0_wp)\n  allocate (neighmat(nat,nat),source=.false.)\n  cn = 0.0d0\n  bond = 0.0d0\n  call xcoord2(nat,at,xyz,rcov,cn,900.0_wp,bond)\n  call bondtotopo(nat,at,bond,cn,ntopo,topovec,neighmat)\n  deallocate (neighmat,cn,bond,rcov)\n  return\nend subroutine quicktopo\n\n!-- transfer topology data to the zmol object\nsubroutine neighbourset(zmol,nat,at,xyz,cn,ntopo,topovec)\n  use iso_fortran_env,only:wp => real64\n  use zdata\n  use strucrd,only:i2e\n  implicit none\n  type(zmolecule) :: zmol\n  integer,intent(in)  :: nat\n  real(wp),intent(in) :: xyz(3,nat)\n  integer,intent(in)  :: at(nat)\n  real(wp),intent(in) :: cn(nat)\n  integer,intent(in)     :: ntopo\n  integer,intent(in) :: topovec(ntopo)\n  integer :: lin\n  integer :: i,j,k,l\n  integer :: inei\n\n  allocate (zmol%zat(nat))\n  zmol%nat = nat    !number of atoms\n  zmol%at = at      !list of atom types (integer)\n  do i = 1,nat\n    zmol%zat(i)%atype = at(i)\n    zmol%zat(i)%cart(:) = xyz(:,i)\n    zmol%zat(i)%el = i2e(at(i),'nc')\n    zmol%zat(i)%cn = cn(i)\n    zmol%zat(i)%pos = i\n    inei = 0\n    do j = 1,nat\n      if (i == j) cycle\n      l = lin(i,j)\n      if (topovec(l) == 1) inei = inei+1\n    end do\n    allocate (zmol%zat(i)%ngh(inei))\n    allocate (zmol%zat(i)%ngt(inei))\n    k = 0\n    do j = 1,nat\n      if (i == j) cycle\n      l = lin(i,j)\n      if (topovec(l) == 1) then\n        k = k+1\n        zmol%zat(i)%ngh(k) = j      ! the k-th neighbour of atom i is atom j\n        zmol%zat(i)%ngt(k) = at(j)  ! atom j has this atom type\n      end if\n    end do\n    zmol%zat(i)%nei = inei\n    call quicksort(inei,zmol%zat(i)%ngh)\n    !call quicksort(inei,zmol%zat(i)%ngt)\n    do j = 1,inei\n      zmol%zat(i)%ngt(j) = at(zmol%zat(i)%ngh(j))\n    end do\n  end do\n\n  return\nend subroutine neighbourset\n\n!=======================================================================!\n!  compute Zmat (internal coordinates) for the zmol struct\n!=======================================================================!\nsubroutine ztopozmat(zmol,pr)\n  use iso_fortran_env,wp => real64\n  use zdata\n  implicit none\n  type(zmolecule)  :: zmol\n  logical          :: pr\n\n  integer :: nat\n  real(wp),allocatable :: xyz(:,:)\n  real(wp),allocatable :: geo(:,:)\n  integer,allocatable :: na(:),nb(:),nc(:)\n  integer :: i\n  real(wp),parameter :: pi = 3.14159265358979D0\n  real(wp),parameter :: rad = 180.0d0/pi\n\n  nat = zmol%nat\n  allocate (geo(3,nat),xyz(3,nat),source=0.0d0)\n  allocate (na(nat),nb(nat),nc(nat),source=0)\n\n  do i = 1,nat\n    xyz(1:3,i) = zmol%zat(i)%cart(1:3)\n  end do\n\n  !call xyzint(xyz,nat,na,nb,nc,rad,geo)\n  call xyzint(xyz,nat,na,nb,nc,1.0d0,geo)\n  !call xyzgeo(xyz,nat,na,nb,nc,rad,geo)\n\n  if (pr) then\n    call smallhead('INTERNAL COORDINATES (ZMATRIX)')\n    do i = 1,nat\n      write (*,'(2x,a,4x,3f10.4,1x,3i5)') zmol%zat(i)%el,geo(1:3,i),na(i),nb(i),nc(i)\n    end do\n  end if\n\n  call move_alloc(geo,zmol%zmat)\n  call move_alloc(na,zmol%zna)\n  call move_alloc(nb,zmol%znb)\n  call move_alloc(nc,zmol%znc)\n\n  deallocate (xyz)\n  return\nend subroutine ztopozmat\n\n!=======================================================================!\n! With the CN-based neighbourlist it can happen that two atoms\n! are shared as a neighbour only in the list of one of the atoms.\n! This needs correction and is one of the reasons why WBO-based\n! neighbourlists are better.\n!=======================================================================!\nsubroutine crosscheckCNnei(zmol)\n  use iso_fortran_env,wp => real64\n  use zdata\n  implicit none\n  type(zmolecule) :: zmol\n  integer :: i,j,k,l\n  integer :: nei,newnei\n  integer,allocatable :: newngh(:)\n  integer,allocatable :: newngt(:)\n  do i = 1,zmol%nat\n    nei = zmol%zat(i)%nei\n    newnei = nei\n    allocate (newngh(nei),source=0)\n    allocate (newngt(nei),source=0)\n    do j = 1,nei\n      k = zmol%zat(i)%ngh(j)\n      if (any(zmol%zat(k)%ngh(:) .eq. i)) then\n        newngh(j) = k\n        newngt(j) = zmol%at(k)\n        cycle !atom i is also the neighbour of its own neighbour\n      else\n        !else, the atoms seem to be \"artificial\" neighbours and\n        !has to be removed from the neighbourlist\n        newngh(j) = 0\n        newnei = newnei-1\n      end if\n    end do\n    !--- if the neighbour list was changed we update it\n    if (newnei .lt. nei) then\n      deallocate (zmol%zat(i)%ngh,zmol%zat(i)%ngt)\n      allocate (zmol%zat(i)%ngh(newnei),zmol%zat(i)%ngt(newnei))\n      l = 0\n      do j = 1,nei\n        if (newngh(j) .ne. 0) then\n          l = l+1\n          zmol%zat(i)%ngh(l) = newngh(j)\n          zmol%zat(i)%ngt(l) = newngt(j)\n        end if\n      end do\n      zmol%zat(i)%nei = newnei\n    end if\n    deallocate (newngt,newngh)\n  end do\n\n  return\nend subroutine crosscheckCNnei\n\n!=======================================================================!\n!  get the neighbours of an atom based on the WBOs\n!=======================================================================!\nsubroutine wboneighbours(i,nat,at,xyz,wbo,wbothr,zat)\n  use iso_fortran_env,only:wp => real64\n  use zdata\n  use strucrd,only:i2e\n  implicit none\n  integer,intent(in)  :: i\n  real(wp),intent(in) :: xyz(3,nat)\n  real(wp),intent(in) :: wbo(nat,nat)\n  real(wp),intent(in) :: wbothr\n  integer,intent(in)  :: at(nat)\n  integer,intent(in)  :: nat\n  type(zatom)         :: zat    !--- \"zat\" is the complex datatype object for atom i\n  integer :: icn\n  integer :: k,l,j\n\n  zat%atype = at(i)\n  zat%cart(:) = xyz(:,i)\n  zat%el = i2e(at(i),'nc')\n  zat%pos = i\n\n  icn = 0\n  do k = 1,nat\n    if (wbo(i,k) .ge. wbothr) then\n      icn = icn+1\n    end if\n  end do\n  zat%nei = icn\n  allocate (zat%ngh(icn),zat%ngt(icn))\n  l = 0\n  do j = 1,nat\n    if (wbo(i,j) .ge. wbothr) then\n      l = l+1\n      zat%ngh(l) = j      ! the l-th neighbour of atom i is atom j\n      zat%ngt(l) = at(j)  ! atom j has this atom type\n    end if\n  end do\n  call quicksort(icn,zat%ngh)\n  !call quicksort(icn,zat%ngt)\n  do j = 1,icn\n    zat%ngt(j) = at(zat%ngh(j))\n  end do\n\n  return\nend subroutine wboneighbours\nsubroutine wborepaireta(i,nat,at,xyz,cn,wbo,zat)\n  use iso_fortran_env,only:wp => real64\n  use zdata\n  implicit none\n  integer,intent(in)  :: i\n  real(wp),intent(in) :: xyz(3,nat)\n  real(wp),intent(in) :: cn(nat)\n  real(wp),intent(in) :: wbo(nat,nat)\n  integer,intent(in)  :: at(nat)\n  integer,intent(in)  :: nat\n  type(zatom)         :: zat\n\n  if (cn(i) .gt. 1.and.zat%nei .lt. 1) then\n    if (allocated(zat%ngt)) deallocate (zat%ngt)\n    if (allocated(zat%ngh)) deallocate (zat%ngh)\n    write (*,*) i,at(i),cn(i)\n    call wboneighbours(i,nat,at,xyz,wbo,0.1d0,zat)\n  end if\n  return\nend subroutine wborepaireta\n\n!=================================================================!\n! subroutine wbomrec\n! molcount: number of total fragments (increased during search)\n! nat: overall number of atoms\n! wbo: bond orders\n! wbothr: threshold for when a bond is present\n! molvec: assignment vector of atom to fragment\n!=================================================================!\nsubroutine wbomrec(molcount,nat,wbo,wbothr,molvec)\n  use iso_fortran_env,wp => real64\n  implicit none\n  real(wp) :: wbo(nat,nat)\n  real(wp) :: wbothr\n  integer :: nat,molvec(nat),i,molcount\n  logical :: taken(nat)\n  molvec = 0\n  molcount = 1\n  taken = .false.\n  do i = 1,nat\n    if (.not.taken(i)) then\n      molvec(i) = molcount\n      taken(i) = .true.\n      call wbofrags(i,nat,wbo,wbothr,taken,molvec,molcount)\n      molcount = molcount+1\n    end if\n  end do\n  molcount = molcount-1\n  return\nend subroutine wbomrec\n!- depth-first search through the WBO list to determine all connected atoms\nrecursive subroutine wbofrags(i,nat,wbo,wbothr,taken,molvec,molcnt)\n  use iso_fortran_env,wp => real64\n  implicit none\n  integer :: i,nat\n  real(wp) :: wbo(nat,nat)\n  real(wp) :: wbothr\n  integer :: molcnt,molvec(nat),j\n  logical taken(nat)\n  do j = 1,nat\n    if (i .eq. j) cycle\n    if (wbo(i,j) .ge. wbothr) then\n      if (.not.taken(j)) then\n        molvec(j) = molcnt\n        taken(j) = .true.\n        call wbofrags(j,nat,wbo,wbothr,taken,molvec,molcnt)\n      end if\n    end if\n  end do\n  return\nend subroutine wbofrags\n\n!=======================================================================!\n!  compare two arrays and check if their content is identical\n!=======================================================================!\nsubroutine arrcomp(n,narr,m,marr,equi)\n  implicit none\n  integer :: n\n  integer :: narr(*)\n  integer :: m\n  integer :: marr(*)\n  logical :: equi\n  logical,allocatable :: mask(:)\n  if (n .ne. m) then\n    equi = .false.\n    return\n  end if\n  allocate (mask(n))\n  mask(:) = narr(1:n) .eq. marr(1:n)\n  if (any(.not.mask(:))) then\n    equi = .false.\n  else\n    equi = .true.\n  end if\n  deallocate (mask)\n  return\nend subroutine arrcomp\n\n!=======================================================================!\n! compare two arrays and check if they have exactly one element in common\n!=======================================================================!\nfunction arruniqel(n,narr,m,marr,el)\n  implicit none\n  logical :: arruniqel\n  integer :: n\n  integer :: narr(n)\n  integer :: m\n  integer :: marr(m)\n  integer :: el\n  integer :: incr\n  integer :: i\n  arruniqel = .false.\n  el = 0\n  incr = 0\n  do i = 1,n\n    if (any(marr(:) .eq. narr(i))) then\n      incr = incr+1\n      el = narr(i)\n    end if\n  end do\n  if (incr .eq. 1) then\n    arruniqel = .true.\n    !el = el\n  else\n    arruniqel = .false.\n    el = 0\n  end if\n  return\nend function arruniqel\n\n!=========================================================================!\n! check if all atoms contained in narr are in the neighbour list of atom i\n!=========================================================================!\nlogical function allneigh(zmol,i,n,narr)\n  use zdata\n  implicit none\n  type(zmolecule) :: zmol\n  integer :: i\n  integer :: n\n  integer :: narr(n)\n  integer :: j\n  logical :: dum\n  dum = .true.\n  do j = 1,n\n    dum = dum.and.any(zmol%zat(i)%ngh(:) == narr(j))\n  end do\n  allneigh = dum\n  return\nend function allneigh\n\n!=======================================================================!\n! get information about the side chain\n!=======================================================================!\nsubroutine getsideweight(zmol,i,j,mside)\n  use iso_fortran_env,only:wp => real64\n  use zdata\n  use atmasses\n  implicit none\n  integer,intent(in) :: i  !central atom\n  integer,intent(in) :: j  !first atom of the side chain\n  type(zmolecule) :: zmol\n  real(wp),intent(out) :: mside\n\n  integer :: k,l\n  integer :: atm\n\n  integer,allocatable :: path(:)\n\n  mside = 0.0_wp\n\n  allocate (path(zmol%nat),source=0)\n  l = 0\n  call recside(zmol,i,j,path,l)\n\n  do k = 1,zmol%nat\n    if (path(k) .eq. 0) cycle\n    l = path(k)\n    atm = zmol%zat(l)%atype\n    mside = mside+ams(atm)\n  end do\n\n  deallocate (path)\n  return\nend subroutine getsideweight\n\n!=======================================================================!\n!  count the number of rings in the system\n!  (just a call on the same \"newgetrings\" routine,\n!   but some of the data has to be reset)\n!=======================================================================!\nsubroutine countrings(zmol,nrings)\n  use iso_fortran_env,only:wp => real64\n  use zdata\n  implicit none\n  type(zmolecule) :: zmol\n  integer,intent(out) :: nrings\n  integer :: i\n  nrings = 0\n  call newgetrings(zmol,.false.)\n  nrings = zmol%nri\n  do i = 1,zmol%nat\n    zmol%zat(i)%ring = .false.\n  end do\n  return\nend subroutine countrings\n\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!\n!================================================================================================!\n! new \"getring\" routine.\n! requires a FULLY SET UP TOPOLOGY in the \"zmol\" datatype\n! Utilizes graph theory to detect rings via Dijkstra's algorithm.\n!\n!   DO. NOT. TOUCH.\n!\n!================================================================================================!\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!\nsubroutine newgetrings(zmol,verbose)\n!> newest implementation of the getrings routine\n!> that employs clean rewrites of graph and shortest-path routines\n  use crest_parameters\n  use zdata\n  use adjacency\n  implicit none\n  !> INPUT/OUTPUT\n  type(zmolecule),intent(inout) :: zmol\n  logical,intent(in) :: verbose\n  !> LOCAL\n  type(zring) :: zri\n  integer :: V,nrings,nmem\n  integer,allocatable :: A(:,:) !> adjacency matrix    \n  logical,allocatable :: rings(:,:)\n  logical,allocatable :: ringtracker(:,:)\n  integer,allocatable :: tmppath(:)\n  logical,allocatable :: tmpmem(:)\n  logical :: duplicate\n  integer :: i,j,k\n\n  !>-- some printout\n  if (verbose) then\n    write (stdout,'(1x,a,1x,i0,1x,a)') 'ring analysis on',zmol%nat,'atoms:'\n  end if\n\n  !>-- reset number of rings\n  nrings = 0\n\n  !>-- atoms as vertices\n  V = zmol%nat\n  allocate (A(V,V),source=0)\n  allocate (rings(V,V),ringtracker(V,V),source=.false.)\n\n  !>-- get the adjacency matrix\n  call zmol%adjacency(A)\n\n  !>-- check possible rings\n  call check_rings_min(V,A,rings)\n\n  allocate (tmppath(V),source=0)\n  allocate (tmpmem(V),source=.false.)\n  !>-- sweeps\n  do i = 1,V\n    do j = 1,i-1\n      nmem = 0\n      !>-- if a possible ring was detected, get it\n      if (rings(j,i)) then\n        call get_ring_min(V,A,i,j,tmppath,nmem)\n      end if\n      !>-- if we were successful and now the number or ring members\n      if (nmem > 0) then\n        tmpmem(:) = .false.\n        do k = 1,V\n          if (tmppath(k) > 0) tmpmem(tmppath(k)) = .true.\n        end do\n        !>-- add the first ring\n        if (nrings == 0) then\n          nrings = nrings+1\n          ringtracker(:,nrings) = tmpmem(:)\n          !>-- or check duplicates\n        else\n          duplicate = .false.\n          do k = 1,nrings\n            if (all(ringtracker(:,k) .eqv. tmpmem(:))) then\n              duplicate = .true.\n              exit\n            end if\n          end do\n          if (.not.duplicate) then\n            nrings = nrings+1\n            ringtracker(:,nrings) = tmpmem(:)\n          end if\n        end if\n      end if\n    end do !> j loop\n  end do !> i loop\n  deallocate (tmpmem,tmppath)\n\n  if (verbose) then\n    if (nrings > 0) then\n      write (stdout,'(3x,i0,1x,a)') nrings,'unique rings detected'\n    else\n      write (stdout,'(3x,a)') 'system contains no rings'\n    end if\n  end if\n\n  !>--- put rings into zmol\n  if (allocated(zmol%zri)) deallocate (zmol%zri)\n  zmol%nri = 0\n  zmol%zat(:)%ring = .false.\n  do i = 1,nrings\n    call zri%deallocate !> clear space (if allocated)\n    nmem = count(ringtracker(:,i))\n    allocate (tmppath(nmem),source=0)\n    k = 0\n    do j = 1,V\n      if (ringtracker(j,i)) then\n        k = k+1\n        tmppath(k) = j\n        zmol%zat(i)%ring = .true.\n      end if\n    end do\n    zri%rs = nmem\n    call move_alloc(tmppath,zri%rlist)\n    call zmol%addring(zri)\n    if (allocated(tmppath)) deallocate (tmppath)\n  end do\n\n  if (verbose) then\n    call zmol%prrings(stdout)\n  end if\n\n  deallocate (ringtracker,rings,A)\n  return\nend subroutine newgetrings\n\n!===============================================================!\n!  get all atoms of the side chain l of k and write them to path\n!===============================================================!\nrecursive subroutine recside(zmol,k,l,path,j)\n  use iso_fortran_env,only:wp => real64\n  use zdata\n  implicit none\n  type(zmolecule) :: zmol\n  integer,intent(in) :: k          !the starting atom\n  integer,intent(in) :: l          !current atom\n  integer,intent(inout) :: j       !postion counter\n  integer,intent(inout) :: path(zmol%nat)  !entire path\n  integer :: i,p\n\n  if (k .eq. l) return\n  if (any(path(:) == l)) return\n  if (j+1 .gt. zmol%nat) return\n\n  j = j+1\n  path(j) = l\n\n  if (zmol%zat(l)%nei .gt. 1) then\n    do i = 1,zmol%zat(l)%nei\n      p = zmol%zat(l)%ngh(i)\n      call recside(zmol,k,p,path,j)\n    end do\n  end if\n\n  return\nend subroutine recside\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!\n!================================================================================================!\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc!\n\n!==========================================================!\n! \"commonring\" is a function (return value .true./.false.)\n! that is used to check is a given list of atoms is part\n! of the same ring.\n!\n! On Input:  zmol - molecule and topology\n!            n    - # of atoms to be checked\n!            atms - array containing the atoms\n!\n! On Output: function value\n!            r - the common ring (if function value = .true.)\n!==========================================================!\nlogical function commonring(zmol,n,atms,r)\n  use zdata\n  implicit none\n  type(zmolecule) :: zmol\n  integer,intent(in) :: n\n  integer,intent(in) :: atms(n)\n  integer,intent(out) :: r\n  integer :: i,j\n  logical :: l1,l2\n  commonring = .false.\n  r = 0\n  !--- first check if the atoms are in a ring at all.\n  !    if not, we can return immediatly.\n  l1 = .true.\n  do i = 1,n\n    l1 = l1.and.zmol%zat(atms(i))%ring\n  end do\n  if (.not.l1) return\n  !--- loop over all rings in the molecule and check if\n  !    the atoms are part of it\n  OUTER: do i = 1,zmol%nri\n    l2 = .true.\n    INNER: do j = 1,n\n      l2 = l2.and.(any(zmol%zri(i)%rlist(:) .eq. atms(j)))\n      if (.not.l2) cycle OUTER\n    end do INNER\n    if (l2) then\n      commonring = .true.\n      r = i\n    end if\n  end do OUTER\n  return\nend function commonring\n\n!==========================================================!\n! \"ringside\" is a subroutine that is used to check\n! in which direction of which atom a ring extends,\n! starting from atom i.\n!\n! On Input:  zmol - molecule and topology\n!            n    - starting atom\n!            ring - which ring to look at\n!\n! On Output: atms - array containing the atoms\n!\n!==========================================================!\nsubroutine ringside(zmol,i,ring,atms)\n  use zdata\n  implicit none\n  type(zmolecule) :: zmol\n  integer,intent(in) :: i\n  integer,intent(in) :: ring\n  integer,intent(inout) :: atms(zmol%nat)\n  integer :: j,k,n,l\n  integer,allocatable :: path(:)\n  n = zmol%nat\n  allocate (path(n),source=0)\n  !--- loop over neighbour list of i\n  do j = 1,zmol%zat(i)%nei\n    k = zmol%zat(i)%ngh(j)\n    !--- if the neighbour and i are in the selected ring, do nothing\n    if (any(zmol%zri(ring)%rlist .eq. k)) cycle\n    !--- else, get everything attached to  the neighbour\n    path = 0\n    l = 0\n    call recside(zmol,i,k,path,l)\n    call mergearr(n,atms,n,path)  !merge path into atms\n  end do\n  deallocate (path)\n\n  return\nend subroutine ringside\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ztopology.f90 b/src/ztopology.f90
--- a/src/ztopology.f90	
+++ b/src/ztopology.f90	
@@ -121,6 +121,7 @@
 subroutine simpletopo(n,at,xyz,zmol,verbose,getrings,wbofile)
   use crest_parameters
   use zdata
+  use miscdata, only: rcov
   implicit none
   type(zmolecule)  :: zmol
   type(zmolecule)  :: zfrag
@@ -135,7 +136,6 @@
   real(wp),allocatable :: cn(:)
   real(wp),allocatable :: bond(:,:)
   real(wp),allocatable :: wbo(:,:)
-  real(wp),allocatable :: rcov(:)
   integer :: i,j,k
   integer :: ntopo
   logical,allocatable :: neighmat(:,:)
@@ -144,18 +144,16 @@
 
   logical :: ex,useWBO
 
-!--- header
+!>--- header
   if (verbose) then
     write (*,*)
     call smallhead('TOPOLOGY ANALYSIS')
   end if
 
-!--- set covalent radii and calculate coordination numbers
-  allocate (rcov(94))
-  call setrcov(rcov)
+!>--- set covalent radii and calculate coordination numbers
   allocate (cn(n),bond(n,n))
   call xcoord2(n,at,xyz,rcov,cn,900.0_wp,bond)
-!--- read in WBOs if required
+!>--- read in WBOs if required
   ex = .false.
   if (present(wbofile)) then
     inquire (file=wbofile,exist=ex)
@@ -274,7 +272,6 @@
 !--- deallocation of memory
   if (allocated(wbo)) deallocate (wbo)
   deallocate (bond,cn)
-  deallocate (rcov)
   return
 end subroutine simpletopo
 
@@ -289,7 +286,7 @@
   real(wp),intent(in) :: xyz(3,nat)
   real(wp),intent(out) :: cn(nat)
   real(wp),intent(in)  :: cn_thr
-  real(wp),intent(in)  :: rcov(94)
+  real(wp),intent(in)  :: rcov(*)
   real(wp),intent(out) :: bond(nat,nat)
   integer :: i,k1
   integer :: iat
@@ -328,6 +325,7 @@
 !===================================================!
 subroutine bondtotopo(nat,at,bond,cn,ntopo,topo,neighbourmat)
   use iso_fortran_env,only:wp => real64
+  use utilities
   integer,intent(in)  :: nat
   integer,intent(in) :: at(nat)
   real(wp),intent(inout) :: bond(nat,nat)
@@ -338,7 +336,6 @@
   logical,intent(inout) :: neighbourmat(nat,nat)
   integer :: i,j,k,l
   integer :: icn,rcn
-  integer :: lin
   allocate (cn2(nat),source=0.0_wp)
   topo = 0
   neighbourmat = .false.
@@ -397,6 +394,7 @@
 
 subroutine bondtotopo_excl(nat,at,bond,cn,ntopo,topo,neighbourmat,excl)
   use iso_fortran_env,only:wp => real64
+  use utilities
   integer,intent(in)  :: nat
   integer,intent(in) :: at(nat)
   real(wp),intent(inout) :: bond(nat,nat)
@@ -408,7 +406,6 @@
   logical,intent(in) :: excl(nat)
   integer :: i,j,k,l
   integer :: icn,rcn
-  integer :: lin
   allocate (cn2(nat),source=0.0_wp)
   topo = 0
   neighbourmat = .false.
@@ -467,23 +464,22 @@
 end subroutine bondtotopo_excl
 subroutine quicktopo(nat,at,xyz,ntopo,topovec)
   use iso_fortran_env,only:wp => real64
+  use miscdata, only: rcov
   implicit none
   integer :: nat
   integer :: at(nat)
   real(wp) :: xyz(3,nat) !must be in Bohrs
   integer :: ntopo
   integer :: topovec(ntopo)
-  real(wp),allocatable :: rcov(:),cn(:),bond(:,:)
+  real(wp),allocatable :: cn(:),bond(:,:)
   logical,allocatable :: neighmat(:,:)
-  allocate (rcov(94))
-  call setrcov(rcov)
   allocate (bond(nat,nat),cn(nat),source=0.0_wp)
   allocate (neighmat(nat,nat),source=.false.)
   cn = 0.0d0
   bond = 0.0d0
   call xcoord2(nat,at,xyz,rcov,cn,900.0_wp,bond)
   call bondtotopo(nat,at,bond,cn,ntopo,topovec,neighmat)
-  deallocate (neighmat,cn,bond,rcov)
+  deallocate (neighmat,cn,bond)
   return
 end subroutine quicktopo
 
@@ -492,6 +488,7 @@
   use iso_fortran_env,only:wp => real64
   use zdata
   use strucrd,only:i2e
+  use utilities
   implicit none
   type(zmolecule) :: zmol
   integer,intent(in)  :: nat
@@ -500,7 +497,6 @@
   real(wp),intent(in) :: cn(nat)
   integer,intent(in)     :: ntopo
   integer,intent(in) :: topovec(ntopo)
-  integer :: lin
   integer :: i,j,k,l
   integer :: inei
 
Index: src/algos/optimization.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\nsubroutine crest_optimization(env,tim)\n!***********************************************\n!* subroutine crest_optimization\n!* This routine implements a standalone runtype\n!* to perform geometry optimization for the \n!* specified input file (read from env%ref)\n!***********************************************\n  use crest_parameters,only:wp,stdout,bohr\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use optimize_module\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(timer),intent(inout)      :: tim\n  type(coord) :: mol,molnew\n  integer :: i,j,k,l,io,ich\n  logical :: pr,wr\n!========================================================================================!\n  type(calcdata) :: calc\n\n  real(wp) :: energy,gnorm\n  real(wp),allocatable :: grad(:,:)\n\n  character(len=80) :: atmp\n  character(len=*),parameter :: partial = '∂E/∂'\n!========================================================================================!\n  call tim%start(14,'Geometry optimization')\n  call env%ref%to(mol)\n  write (stdout,*)\n  call smallhead('Input structure:')\n  call mol%append(stdout)\n  write (stdout,*)\n\n!========================================================================================!\n\n  allocate (grad(3,mol%nat),source=0.0_wp)\n  calc = env%calc\n  !>--- check if we have any calculation settings allocated\n  if (calc%ncalculations < 1) then\n    write (stdout,*) 'no calculations allocated'\n    return\n  else\n    call calc%info( stdout )\n  end if\n  write(stdout,'(a)') repeat('-',80)\n\n  !>--- first energy&gradient calculation\n  call engrad(mol,calc,energy,grad,io)\n\n  !>-- geopetry optimization\n  pr = .true. !> stdout printout\n  wr = .true. !> write crestopt.log\n  call optimize_geometry(mol,molnew,calc,energy,grad,pr,wr,io)\n\n  if (io == 0) then\n    write (stdout,*) 'geometry successfully optimized!'\n    write (stdout,*)\n    write(stdout,'(a)') repeat('-',80)\n    write (stdout,*)\n    call smallhead( 'Output structure:') \n    call molnew%append(stdout)\n    write (stdout,*)\n    write (stdout,*) 'optimized geometry written to crestopt.xyz'\n    gnorm = norm2(grad)\n    write (atmp,'(1x,\"Etot=\",f16.10,1x,\"g norm=\",f12.8)') energy,gnorm\n    molnew%comment = trim(atmp)\n    open (newunit=ich,file='crestopt.xyz')\n    call molnew%append(ich)\n    close (ich)\n  else\n    write (stdout,*) 'geometry optimization FAILED!'\n  end if\n\n!========================================================================================!\n!>--- print out the results\n   if(any(calc%calcs(:)%rdwbo))then\n   write(stdout,*)\n   write(stdout,*) 'Connectivity information (bond order):'\n   do k=1,calc%ncalculations\n     if(calc%calcs(k)%rdwbo)then\n       write(stdout,'(\"> \",a,i0)') 'Calculation level ',k\n       write(stdout,'(a12,a12,a10)') 'Atom A','Atom B','BO(A-B)'\n       do i=1,mol%nat\n         do j=1,i-1\n           if(calc%calcs(k)%wbo(i,j) > 0.0002_wp)then\n            write(stdout,*) i,j,calc%calcs(k)%wbo(i,j)\n           endif\n         enddo\n       enddo\n     endif\n   enddo\n   endif\n   write(stdout,*)\n\n   write(stdout,'(a)') repeat('-',80)\n   write(stdout,'(a)') '> Final molecular gradient ( Eh/a0 ):'\n   write(stdout,'(13x,a,13x,a,13x,a)')partial//'x',partial//'y',partial//'z'\n   do i = 1,mol%nat\n      write (stdout,'(3f18.8)') grad(1:3,i)\n   end do\n   write(stdout,'(a,f18.8,a)') '> Gradient norm:',norm2(grad),' Eh/α'\n\n   if(calc%ncalculations > 1)then\n   write(stdout,*)\n   write(stdout,'(a)') '> Individual energies and gradient norms:'\n     do k=1,calc%ncalculations\n       write(stdout,'(1x,a,i0,2f18.8)') 'calculation ',k,calc%etmp(k),norm2(calc%grdtmp(:,:,k))\n     enddo\n     if(calc%nconstraints > 0)then\n       write(stdout,'(1x,a)') '(+ constraints contribution)'\n     endif\n   endif\n\n   write(stdout,*)\n   write(stdout,'(a)') repeat('=',40)\n   write(stdout,'(1x,a,f20.10,a)') 'TOTAL ENERGY ',energy,' Eh'\n   write(stdout,'(1x,a,f20.10,a)') 'GRADIENT NORM',norm2(grad),' Eh/α'\n   write(stdout,'(a)') repeat('=',40)\n   \n   if(io /= 0)then\n    write (stdout,*) 'WARNING: geometry optimization FAILED!'\n   endif\n\n  deallocate (grad)\n!========================================================================================!\n  call tim%stop(14)\n  return\nend subroutine crest_optimization\n\n!========================================================================================!\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n!========================================================================================!\nsubroutine crest_ensemble_optimization(env,tim)\n!***********************************************\n!* subroutine crest_ensemble_optimization\n!* This routine implements a standalone runtype\n!* to perform geometry optimizations along an\n!* ensemble or trajectory file.\n!***********************************************\n  use crest_parameters,only:wp,stdout,bohr\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use optimize_module\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(timer),intent(inout)      :: tim\n  type(coord) :: mol,molnew\n  integer :: i,j,k,l,io,ich,c\n  logical :: pr,wr,ex\n!========================================================================================!\n  type(calcdata) :: calc\n\n  real(wp) :: energy,gnorm\n  real(wp),allocatable :: grad(:,:)\n\n  character(len=:),allocatable :: ensnam\n  integer :: nat,nall\n  real(wp),allocatable :: eread(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  integer,allocatable  :: at(:)\n  character(len=80) :: atmp\n  real(wp) :: percent\n  character(len=52) :: bar\n!========================================================================================!\n  write (*,*)\n!>--- check for the ensemble file\n  inquire (file=env%ensemblename,exist=ex)\n  if (ex) then\n    ensnam = env%ensemblename\n  else\n    write (stdout,*) 'no ensemble file provided.'\n    return\n  end if\n\n!>--- start the timer\n  call tim%start(14,'Ensemble optimization')\n\n!>---- read the input ensemble\n  call rdensembleparam(ensnam,nat,nall)\n  if (nall .lt. 1) return\n  allocate (xyz(3,nat,nall),at(nat),eread(nall))\n  call rdensemble(ensnam,nat,nall,at,xyz,eread)\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n!>--- Important: crest_oloop requires coordinates in Bohrs\n  xyz = xyz / bohr\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n\n!>--- set OMP parallelization\n  if (env%autothreads) then\n    !>--- usually, one thread per xtb job\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,nall)\n  end if\n\n!========================================================================================!\n  !>--- printout header\n  write (stdout,*)\n  write (stdout,'(10x,\"┍\",49(\"━\"),\"┑\")')\n  write (stdout,'(10x,\"│\",14x,a,14x,\"│\")') \"ENSEMBLE OPTIMIZATION\"\n  write (stdout,'(10x,\"┕\",49(\"━\"),\"┙\")')\n  write (stdout,*)\n  write (stdout,'(1x,a,i0,a,1x,a)') 'Optimizing all ',nall,' structures of file',trim(ensnam)\n  !>--- call the loop\n  call crest_oloop(env,nat,nall,at,xyz,eread,.true.)\n\n  deallocate (eread,at,xyz)\n!========================================================================================!\n  call tim%stop(14)\n  return\nend subroutine crest_ensemble_optimization\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/optimization.f90 b/src/algos/optimization.f90
--- a/src/algos/optimization.f90	
+++ b/src/algos/optimization.f90	
@@ -44,7 +44,10 @@
   character(len=80) :: atmp
   character(len=*),parameter :: partial = '∂E/∂'
 !========================================================================================!
+  call ompset_max(env%threads)
+  call ompprint_intern()
   call tim%start(14,'Geometry optimization')
+!========================================================================================!
   call env%ref%to(mol)
   write (stdout,*)
   call smallhead('Input structure:')
@@ -55,7 +58,7 @@
 
   allocate (grad(3,mol%nat),source=0.0_wp)
   calc = env%calc
-  !>--- check if we have any calculation settings allocated
+!>--- check if we have any calculation settings allocated
   if (calc%ncalculations < 1) then
     write (stdout,*) 'no calculations allocated'
     return
@@ -64,10 +67,7 @@
   end if
   write(stdout,'(a)') repeat('-',80)
 
-  !>--- first energy&gradient calculation
-  call engrad(mol,calc,energy,grad,io)
-
-  !>-- geopetry optimization
+!>-- geometry optimization
   pr = .true. !> stdout printout
   wr = .true. !> write crestopt.log
   call optimize_geometry(mol,molnew,calc,energy,grad,pr,wr,io)
@@ -76,19 +76,24 @@
     write (stdout,*) 'geometry successfully optimized!'
     write (stdout,*)
     write(stdout,'(a)') repeat('-',80)
+
     write (stdout,*)
     call smallhead( 'Output structure:') 
     call molnew%append(stdout)
     write (stdout,*)
+
     write (stdout,*) 'optimized geometry written to crestopt.xyz'
     gnorm = norm2(grad)
     write (atmp,'(1x,"Etot=",f16.10,1x,"g norm=",f12.8)') energy,gnorm
     molnew%comment = trim(atmp)
+
     open (newunit=ich,file='crestopt.xyz')
     call molnew%append(ich)
     close (ich)
+
   else
     write (stdout,*) 'geometry optimization FAILED!'
+
   end if
 
 !========================================================================================!
@@ -118,13 +123,13 @@
    do i = 1,mol%nat
       write (stdout,'(3f18.8)') grad(1:3,i)
    end do
-   write(stdout,'(a,f18.8,a)') '> Gradient norm:',norm2(grad),' Eh/α'
+   write(stdout,'(a,f18.8,a)') '> Gradient norm:',norm2(grad),' Eh/a0'
 
    if(calc%ncalculations > 1)then
    write(stdout,*)
    write(stdout,'(a)') '> Individual energies and gradient norms:'
      do k=1,calc%ncalculations
-       write(stdout,'(1x,a,i0,2f18.8)') 'calculation ',k,calc%etmp(k),norm2(calc%grdtmp(:,:,k))
+       write(stdout,'(1x,a,i3,2f18.8)') 'calculation ',k,calc%etmp(k),norm2(calc%grdtmp(:,:,k))
      enddo
      if(calc%nconstraints > 0)then
        write(stdout,'(1x,a)') '(+ constraints contribution)'
@@ -134,7 +139,7 @@
    write(stdout,*)
    write(stdout,'(a)') repeat('=',40)
    write(stdout,'(1x,a,f20.10,a)') 'TOTAL ENERGY ',energy,' Eh'
-   write(stdout,'(1x,a,f20.10,a)') 'GRADIENT NORM',norm2(grad),' Eh/α'
+   write(stdout,'(1x,a,f20.10,a)') 'GRADIENT NORM',norm2(grad),' Eh/a0'
    write(stdout,'(a)') repeat('=',40)
    
    if(io /= 0)then
@@ -224,8 +229,111 @@
   call crest_oloop(env,nat,nall,at,xyz,eread,.true.)
 
   deallocate (eread,at,xyz)
+  write(stdout,'(/,a,a,a)') 'Optimized ensemble written to <',ensemblefile,'>'
+
+!========================================================================================!
+  !>--- (optional) refinement step
+  if (allocated(env%refine_queue)) then
+    write(stdout,*)
+    call crest_refine(env,ensemblefile,ensemblefile//'.refine')
+    write(stdout,'(/,a,a,a)') 'Refined ensemble written to <',ensemblefile,'.refine>'
+  endif 
+
 !========================================================================================!
   call tim%stop(14)
   return
 end subroutine crest_ensemble_optimization
 
+!========================================================================================!
+!>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<!
+!========================================================================================!
+subroutine crest_ensemble_screening(env,tim)
+!****************************************************
+!* subroutine crest_ensemble_screening
+!* This routine implements a standalone runtype
+!* to perform geometry optimizations along an
+!* ensemble in a multilevel step and sort in between
+!****************************************************
+  use crest_parameters,only:wp,stdout,bohr
+  use crest_data
+  use crest_calculator
+  use strucrd
+  use optimize_module
+  use iomod 
+  implicit none
+  type(systemdata),intent(inout) :: env
+  type(timer),intent(inout)      :: tim
+  type(coord) :: mol,molnew
+  integer :: i,j,k,l,io,ich,c
+  logical :: pr,wr,ex
+!========================================================================================!
+  type(calcdata) :: calc
+
+  real(wp) :: energy,gnorm
+  real(wp),allocatable :: grad(:,:)
+
+  character(len=:),allocatable :: ensnam
+  integer :: nat,nall
+  real(wp),allocatable :: eread(:)
+  real(wp),allocatable :: xyz(:,:,:)
+  integer,allocatable  :: at(:)
+  character(len=80) :: atmp
+  real(wp) :: percent
+  character(len=52) :: bar
+  logical :: multilevel(6)
+!========================================================================================!
+  write (*,*)
+!>--- check for the ensemble file
+  inquire (file=env%ensemblename,exist=ex)
+  if (ex) then
+    ensnam = env%ensemblename
+  else
+    write (stdout,*) 'no ensemble file provided.'
+    return
+  end if
+
+!>--- start the timer
+  call tim%start(14,'Ensemble screening')
+
+!>---- read the input ensemble
+  call rdensembleparam(ensnam,nat,nall)
+  if (nall .lt. 1) return
+
+!>--- set OMP parallelization
+  if (env%autothreads) then
+    !>--- usually, one thread per xtb job
+    call ompautoset(env%threads,7,env%omp,env%MAXRUN,nall)
+  end if
+
+!========================================================================================!
+  !>--- printout header
+  write (stdout,*)
+  write (stdout,'(10x,"┍",48("━"),"┑")')
+  write (stdout,'(10x,"│",15x,a,15x,"│")') "ENSEMBLE SCREENING"
+  write (stdout,'(10x,"┕",48("━"),"┙")')
+  write (stdout,*)
+  write (stdout,'(1x,''Multilevel optimization and structure screening.'')')
+  write (stdout,*)
+  write (stdout,'(1x,a,a)') 'Input file: ','<'//trim(ensnam)//'>'
+  write (stdout,'(1x,a,i0,a)') 'Containing ',nall,' structures.'
+
+  !>--- call the loop
+  call rmrfw('crest_rotamers_')
+  call optlev_to_multilev(3.0d0,multilevel)
+  call crest_multilevel_oloop(env,ensnam,multilevel)
+ 
+!---- printout
+  call catdel('cregen.out.tmp')
+  write (stdout,'(/,1x,a,1x,a)') 'Final ensemble on file','<'//trim(ensemblefile)//'>'
+
+  call rename(conformerfile,trim(ensemblefile))
+
+!---- clean up
+  call screen_cleanup
+
+
+!========================================================================================!
+  call tim%stop(14)
+  return
+end subroutine crest_ensemble_screening
+
Index: src/algos/crossing.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!========================================================================================!\n!> subroutine crest_crossing\n!> Read in an ensemble file and optimize all structures\n!> perform a crossing of z-matrices to generate new structures\n!> The procedure is loosely inspired by genetic algorithms\n!>------------------------------------------------------\nsubroutine crest_crossing(env,maxgen,fname,maxpairs)\n  use crest_parameters,only:wp,stdout,bohr,autokcal\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use optimize_module\n  implicit none\n  !> INPUT\n  type(systemdata),intent(inout) :: env\n  integer,intent(in)             :: maxgen\n  character(len=*),intent(in),optional   :: fname\n  real(wp),intent(in),optional :: maxpairs\n  !> LOCAL\n  integer :: i,j,k,l,io,ich,c\n  logical :: pr,wr,ex\n!========================================================================================!\n  real(wp) :: rthr,ewin,cthr\n\n  character(len=:),allocatable :: ensnam\n  integer :: nat,nall,nalltmp,maxgen2\n  real(wp),allocatable :: eread(:),erel(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  integer,allocatable  :: at(:)\n  real(wp) :: percent,maxtmp\n!========================================================================================!\n!>--- check for the ensemble file\n  if (present(fname)) then\n    ensnam = trim(fname)\n  else\n    ensnam = env%ensemblename\n  end if\n  inquire (file=ensnam,exist=ex)\n  if (.not.ex) then\n    write (stdout,*) 'no ensemble file found by crest_crossing()'\n    return\n  end if\n\n!>---- read the input ensemble\n  call rdensembleparam(ensnam,nat,nall)\n  if (nall .lt. 1) return\n  allocate (xyz(3,nat,nall),at(nat),eread(nall))\n  call rdensemble(ensnam,nat,nall,at,xyz,eread)\n  if (nall .lt. 2) then\n    write (stdout,*) 'Not enough structures to perform GC!'\n    return\n  end if\n\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n!>--- Important: crest_crossing requires coordinates in Bohrs\n  xyz = xyz/bohr\n!>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<!\n\n!>--- set OMP parallelization, use max number of threads\n  call ompautoset(env%threads,4,env%omp,env%MAXRUN,0) \n\n!========================================================================================!\n!>--- thresholds\n  ewin = env%ewin           !> energy window\n  rthr = env%rthr*2.0d0     !> standard RMSD threshold\n  cthr = 0.3d0              !> CN clash threshold\n  if(present(maxpairs))then !> dynamically adjust ewin in order to fit maxpairs\n    allocate(erel(nall))\n    call etoerel(nall,eread,erel,autokcal)\n    nalltmp = count( erel(:) < ewin)\n    maxtmp = (float(nalltmp)*(float(nalltmp)-1.0_wp))/2.0_wp\n    if( maxtmp > maxpairs)then\n      do while (maxtmp > maxpairs)\n        ewin = ewin - 0.01_wp\n        nalltmp = count( erel(:) < ewin)\n        maxtmp = (float(nalltmp)*(float(nalltmp)-1.0_wp))/2.0_wp\n      enddo\n    endif\n    deallocate(erel)\n  endif\n!========================================================================================!\n  !>--- printout header\n  write (stdout,*)\n  write (stdout,'(5x,''========================================'')')\n  write (stdout,'(5x,''|        Structure Crossing (GC)       |'')')\n  write (stdout,'(5x,''========================================'')')\n  write (stdout,*)\n  call ompprint_intern\n  write (stdout,'(a,a)')  'input  file name : ',trim(ensnam)\n  write (stdout,'(a,i8)') 'number of atoms                :',nat\n  write (stdout,'(a,i8)') 'number of points on xyz files  :',nall\n  if(present(maxpairs).and.(ewin.ne.env%ewin))then\n  write (stdout,'(a,es8.1)') 'max. # of parent structures    :',maxpairs\n  write (stdout,'(a,f8.2)') 'adjusted energy window  /kcal  :',ewin\n  else\n  write (stdout,'(a,f8.2)') 'conformer energy window  /kcal :',ewin\n  endif\n  write (stdout,'(a,f8.4)') 'CN per atom difference cut-off :',cthr\n  write (stdout,'(a,2f8.4)') 'RMSD threshold (Ang, Bohr)     :',rthr,rthr/bohr\n  write (stdout,'(a,1x,i8)') 'max. # of generated structures :',maxgen\n\n  maxgen2 = maxgen\n  call crossing(nat,nall,at,xyz,eread,ewin,rthr,cthr,maxgen2)\n\n\n  deallocate (eread,at,xyz)\n!========================================================================================!\n  return\nend subroutine crest_crossing\n\n!========================================================================================!\n!========================================================================================!\nsubroutine crossing(nat,nall,at,xyz,er,ewin,rthr,cthr,maxgen)\n  use crest_parameters\n  use ls_rmsd\n  use strucrd\n  implicit none\n  !> INPUT\n  integer,intent(in)  :: nat,nall           !> number of atoms, number of structures\n  integer,intent(in)  :: at(nat)            !> atomic numbers\n  real(wp),intent(inout) :: xyz(3,nat,nall) !> cartesian coordinates in Bohr(!!!) for ensemble\n  real(wp),intent(in) :: er(nall)           !> energies in Eh for each structure\n  integer,intent(inout) :: maxgen           !> max. number of generated structures\n  real(wp),intent(in) :: ewin               !> energy window\n  real(wp),intent(in) :: rthr               !> rmsd threshold in Ang\n  real(wp),intent(in) :: cthr               !> CN clash threshold\n  !> LOCAL\n  logical :: pr\n  real(sp),allocatable :: zmat(:,:,:),zref(:,:) !> zmat in single precision\n  integer,allocatable  :: na(:),nb(:),nc(:)\n  real(wp),allocatable :: rcov(:)\n  real(wp),allocatable :: cdum(:,:),zdum(:,:),xyzref(:,:)\n  real(wp),allocatable :: xyzgen(:,:,:),rms(:)\n  real(wp),allocatable :: erel(:)\n  real(wp),allocatable :: cnref(:)\n  real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:),ydum(:)  !> rmsd dummy stuff\n  integer,allocatable  :: ind(:)\n  real(wp) :: rthrbohr,rthrbohr100,rthrzmat,emin,rmsdavg,rval,rval2\n  real(wp) :: nmaxref,ncount,ncheck,ncheckstep\n  integer :: ierr,ntaken,ident,rcount,maxgen2\n  integer :: i,j,m,k,nwin,minpos\n  character(len=80) :: atmp\n  integer :: dumpio\n  logical :: fail,rmsdcheck,stop_crossing,huge_number\n  integer :: sdselect !> this is a function\n\n  pr = .true.\n  rmsdcheck = .true.\n\n  !>--- molecule storage\n  allocate (cdum(3,nat),zdum(3,nat),source=0.0_wp)\n  allocate (xyzref(3,nat),source=0.0_wp)\n  allocate (zmat(3,nat,nall),zref(3,nat),source=0.0_sp) !> zmat in single precision\n  allocate (na(nat),nb(nat),nc(nat),source=0)\n  allocate (gdum(3,3),Udum(3,3),xdum(3),ydum(3))\n\n  !>--- parameter setup\n  rthrbohr = rthr/bohr  !> Ang to Bohr\n  rthrbohr100 = rthrbohr/100.0_wp\n  allocate (rcov(94),erel(nall),cnref(nat),source=0.0_wp)\n  call setrcov(rcov)\n  call etoerel(nall,er,erel,autokcal)\n  nwin = count((erel(:) < ewin),1)\n  minpos = minloc(erel,1)\n  if (pr) write (stdout,*) '# in E window',nwin\n  nmaxref = (float(nwin)*(float(nwin)-1.0_wp))/2.0_wp\n\n  !>--- lowest conformer to provide reference values\n  xyzref(1:3,1:nat) = xyz(1:3,1:nat,minpos)  !> reference Cartesians\n  call ycoord(nat,rcov,at,xyzref,cnref,100.0d0) !> refernce CNs\n  call XYZINT(xyzref,nat,na,nb,nc,1.0d0,zdum)   !> z-mat connectivity\n  zref(:,:) = real(zdum,sp)                    !> reference z-mat\n\n  !>--- convert to internal coordinates\n  !$OMP PARALLEL PRIVATE(i,zdum) &\n  !$OMP SHARED(nall,nat,na,nb,nc,xyz,zmat)\n  !$OMP DO\n  do i = 1,nall\n    call XYZGEO(xyz(:,:,i),nat,na,nb,nc,1.0d0,zdum)\n    zmat(:,:,i) = real(zdum(:,:),sp) !> zmat in single precision\n  end do\n  !$OMP END DO\n  !$OMP END PARALLEL\n\n  !>--- generation loop setup\n  ierr = 0          !> discarded\n  rmsdavg = 0.0_wp     !> avg. rmsd of generated structures\n  rcount = 0          !> counting for avg\n  ident = 0          !> counting of discarded identical\n  ntaken = 0          !> counting of selected structures\n  maxgen2 = maxgen*2   !> check double the amount of structures needed\n  ncount = 0.0_wp      !> continous counter\n  ncheck = 0.1_wp     !> checkpoint for printout\n  ncheckstep = 0.25_wp !> steps for checkpoint printout\n  stop_crossing = .false. !> parameter for early termination\n  huge_number = .false.\n  if(nmaxref > 10*maxgen2)then\n    huge_number = .true.\n    maxgen2 = maxgen*5\n  endif\n  allocate (xyzgen(3,nat,maxgen2),rms(maxgen2),source=0.0_wp)\n  \n\n!$OMP PARALLEL PRIVATE(i,j,k,m, zdum,cdum, rval,rval2, fail) &\n!$OMP PRIVATE(Udum,xdum,ydum,gdum) &\n!$OMP SHARED(erel,ewin,nat,at,zref,zmat,na,nb,nc,rcov,cnref ) &\n!$OMP SHARED(cthr,rthrbohr,rthrbohr100,rms,xyzgen,maxgen,maxgen2) &\n!$OMP SHARED(ncount,nmaxref,ncheck,ncheckstep) &\n!$OMP SHARED(ierr,rcount,ident,rmsdavg,ntaken,rmsdcheck,stop_crossing,huge_number )\n!$OMP DO\n  do i = 1,nall\n    if (erel(i) > ewin) cycle\n    do j = 1,i-1\n      if(stop_crossing) cycle !> since we must not jump out of an OMP loop, use this workaround\n      if (erel(j) > ewin) cycle\n      ncount = ncount+1.0_wp\n      !>-- new structure generation\n      do m = 1,nat\n        !>-- new internal coords\n        do k = 1,3\n          zdum(k,m) = real(zref(k,m)+zmat(k,m,j)-zmat(k,m,i),wp)\n        end do\n        !>-- prevent linear bends\n        if (pi-zdum(2,m) .lt. 0.001_wp) zdum(2,m) = pi-0.005_wp\n        if (zdum(2,m) .lt. 0.001_wp) zdum(2,m) = 0.005_wp\n      end do\n      call GMETRY(nat,zdum,cdum,na,nb,nc,fail)\n      !>--- checks\n      if (fail) then\n        !$omp atomic\n        ierr = ierr+1\n        cycle\n      end if\n      call ycoord2(nat,rcov,at,cdum,cnref,100.d0,cthr,fail) !> CN clashes\n      if (fail) then\n        !$omp atomic\n        ierr = ierr+1\n        cycle\n      end if\n      call rmsd(nat,cdum,xyzref,0,Udum,xdum,ydum,rval,.false.,gdum)\n      !call poor_mans_rmsd(nat,xyzref,cdum,rval)\n      if (rval <= rthrbohr) then\n        !$omp atomic\n        ierr = ierr+1\n        cycle\n      else\n        !$omp atomic\n        rcount = rcount+1\n        !$omp atomic\n        rmsdavg = rmsdavg+rval\n      end if\n      !$omp critical\n      if (ntaken < 1) then\n        ntaken = ntaken+1\n        xyzgen(:,:,ntaken) = cdum\n        rms(ntaken) = rval\n      else\n        !> check if we have the generated structure already\n        fail = .false.\n        do m = 1,ntaken\n          !> check only those with a similar rmsd to the reference\n          if (abs(rms(m)-rval) < rthrbohr100 ) then\n            if (rmsdcheck) then !> variant 1: Cartesian RMSDs\n              call rmsd(nat,cdum,xyzgen(:,:,m),0,Udum,xdum,ydum,rval2,.false.,gdum)\n              if (rval2 < rthrbohr) then\n                ident = ident+1\n                fail = .true.\n                exit\n              end if\n            else !> variant 2: crude approximation, discard it\n              ident = ident+1\n              fail = .true.\n              exit\n            end if\n          end if\n        end do\n        if (fail) then\n          continue\n        else\n          if (ntaken < maxgen2) then\n            ntaken = ntaken+1\n            xyzgen(:,:,ntaken) = cdum\n            rms(ntaken) = rval\n          elseif(huge_number) then\n            stop_crossing = .true.\n          else\n            k = sdselect(ntaken,rms,rval)\n            if (k > 0) then\n              xyzgen(:,:,k) = cdum\n              rms(k) = rval\n            end if\n          end if\n        end if\n      end if\n      !$omp end critical\n    end do\n    !>-- checkpoint printout\n    !$omp critical\n    if(huge_number)then\n    if (pr .and.((float(ntaken)/float(maxgen2)) >= ncheck).and. .not.stop_crossing) then\n      ncheck = ncheck+ncheckstep\n      if (ncheck > 1.0_wp) ncheck = 1.0_wp\n      write (stdout,'(f6.1,\" % done\")') (float(ntaken)/float(maxgen2))*100.0_wp\n    end if\n    else\n    if (pr .and.((ncount/nmaxref) >= ncheck)) then\n      ncheck = ncheck+ncheckstep\n      if (ncheck > 1.0_wp) ncheck = 1.0_wp\n      write (stdout,'(f6.1,\" % done\")') (ncount/nmaxref)*100.0_wp\n    end if\n    endif\n    !$omp end critical\n  end do\n!$OMP END DO\n!$OMP END PARALLEL\n  if(pr.and.(ntaken > 0)) write (stdout,'(\" finished.\")')\n  rmsdavg = rmsdavg/float(rcount)\n\n  if (pr) then\n    if (ntaken > 0) then\n      write (stdout,'(1x,a,f12.5)') 'average rmsd w.r.t input     :',rmsdavg\n      write (stdout,'(1x,a,i12)') 'number of clash discarded    :',ierr\n      write (stdout,'(1x,a,i12)') 'removed identical structures :',ident\n    else\n      write (stdout,'(1x,a)') 'no new structures generated'\n    end if\n  end if\n\n  if (ntaken > 0) then\n    !>--- determin order for dumping\n    rmsdavg = sum(rms(1:ntaken))/float(ntaken)\n    allocate (ind(ntaken),source=0)\n    do i = 1,ntaken\n      ind(i) = i\n      rms(i) = -(rms(i)-rmsdavg)**2\n    end do\n    call qsort(rms(1:ntaken),1,ntaken,ind)\n    maxgen = min(maxgen,ntaken)\n    !>--- dump the new structures to file\n    !xyzgen = xyzgen*bohr !> to Angström\n    open (newunit=dumpio,file='confcross.xyz')\n    do i = 1,maxgen\n      k = ind(i)\n      xyzgen(:,:,k) = xyzgen(:,:,k)*bohr !> to Angström\n      write (atmp,'(1x,f12.6,1x,a)') rms(i),'!GC'\n      call wrxyz(dumpio,nat,at,xyzgen(:,:,k),trim(atmp))\n    end do\n    close (dumpio)\n    if (pr) then\n      write (stdout,'(/,1x,i0,1x,a,/)') maxgen,'structures written to confcross.xyz'\n    end if\n  end if\n\n  !>--- cleanup\n  if (allocated(ind)) deallocate (ind)\n  if (allocated(ydum)) deallocate (ydum)\n  if (allocated(xdum)) deallocate (xdum)\n  if (allocated(Udum)) deallocate (Udum)\n  if (allocated(gdum)) deallocate (gdum)\n  if (allocated(zmat)) deallocate (zmat)\n  if (allocated(zdum)) deallocate (zdum)\n  if (allocated(zref)) deallocate (zref)\n  if (allocated(xyzref)) deallocate (xyzref)\n  if (allocated(na)) deallocate (na)\n  if (allocated(nb)) deallocate (nb)\n  if (allocated(nc)) deallocate (nc)\n  if (allocated(cnref)) deallocate (cnref)\n  if (allocated(erel)) deallocate (erel)\n  if (allocated(rcov)) deallocate (rcov)\n  if (allocated(cdum)) deallocate (cdum)\n  if (allocated(xyzgen)) deallocate (xyzgen)\n\nend subroutine crossing\n\n!========================================================================================!\n  function sdselect(n,rms,rval) result(pos)\n    use crest_parameters\n!> calculates SD of rms()\n!> and checks which entry to replace by rval in order to\n!> maximise the SD. returns this entry's number (or zero)\n    implicit none\n    integer :: pos\n    integer,intent(in)  :: n\n    real(wp),intent(in) :: rms(n)\n    real(wp),intent(in) :: rval\n    real(wp) :: avg,sdref,sdtmp\n    integer :: i,j\n\n    pos = 0\n    avg = sum(rms)\n    avg = avg/float(n)\n    sdref = sum((rms(:)-avg)**2)\n    sdref = sqrt(sdref/float(n))\n\n    do i = 1,n\n      avg = sum(rms)-rms(i)+rval\n      avg = avg/float(n)\n      sdtmp = sum((rms(:)-avg)**2)\n      sdtmp = sdtmp-(rms(i)-avg)**2\n      sdtmp = sdtmp+(rval-avg)**2\n      sdtmp = sqrt(sdtmp/float(n))\n      if (sdtmp > sdref) then\n        sdref = sdtmp\n        pos = i\n      end if\n    end do\n  end function sdselect\n!========================================================================================!\n\nsubroutine poor_mans_rmsd(nat,xyz_A,xyz_B,rmsd)\n  use crest_parameters\n  implicit none\n  integer,intent(in) :: nat\n  real(wp),intent(in) :: xyz_A(3,nat)\n  real(wp),intent(in) :: xyz_B(3,nat)\n  real(wp),intent(out) :: rmsd\n  integer :: i,j,k,l\n  real(wp) :: dum\n  rmsd = 0.0_wp\n  do i=1,nat\n     dum = sum((xyz_A(1:3,i)-xyz_B(1:3,i))**2.0_wp)\n     dum = dum/float(nat)  \n     rmsd = rmsd + dum\n  enddo\n  rmsd = sqrt(rmsd) \n\nend subroutine poor_mans_rmsd\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/crossing.f90 b/src/algos/crossing.f90
--- a/src/algos/crossing.f90	
+++ b/src/algos/crossing.f90	
@@ -133,6 +133,7 @@
   use crest_parameters
   use ls_rmsd
   use strucrd
+  use miscdata, only: rcov
   implicit none
   !> INPUT
   integer,intent(in)  :: nat,nall           !> number of atoms, number of structures
@@ -147,7 +148,6 @@
   logical :: pr
   real(sp),allocatable :: zmat(:,:,:),zref(:,:) !> zmat in single precision
   integer,allocatable  :: na(:),nb(:),nc(:)
-  real(wp),allocatable :: rcov(:)
   real(wp),allocatable :: cdum(:,:),zdum(:,:),xyzref(:,:)
   real(wp),allocatable :: xyzgen(:,:,:),rms(:)
   real(wp),allocatable :: erel(:)
@@ -176,8 +176,8 @@
   !>--- parameter setup
   rthrbohr = rthr/bohr  !> Ang to Bohr
   rthrbohr100 = rthrbohr/100.0_wp
-  allocate (rcov(94),erel(nall),cnref(nat),source=0.0_wp)
-  call setrcov(rcov)
+  allocate (erel(nall),cnref(nat),source=0.0_wp)
+  ! call setrcov(rcov)
   call etoerel(nall,er,erel,autokcal)
   nwin = count((erel(:) < ewin),1)
   minpos = minloc(erel,1)
@@ -385,7 +385,7 @@
   if (allocated(nc)) deallocate (nc)
   if (allocated(cnref)) deallocate (cnref)
   if (allocated(erel)) deallocate (erel)
-  if (allocated(rcov)) deallocate (rcov)
+  !if (allocated(rcov)) deallocate (rcov)
   if (allocated(cdum)) deallocate (cdum)
   if (allocated(xyzgen)) deallocate (xyzgen)
 
Index: src/algos/meson.build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nsrcs += files(\n  'singlepoint.f90',\n  'dynamics.f90',\n  'numhess.f90',\n  'optimization.f90',\n  'playground.f90',\n  'crossing.f90',\n  'scan.f90',\n  'search_1.f90',\n  'search_mecp.f90',\n  'setuptest.f90',\n  'hessian_tools.f90',\n  'search_imtdgc.f90',\n  'search_entropy.f90',\n  'parallel.f90', \n)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/meson.build b/src/algos/meson.build
--- a/src/algos/meson.build	
+++ b/src/algos/meson.build	
@@ -21,12 +21,14 @@
   'optimization.f90',
   'playground.f90',
   'crossing.f90',
+  'refine.f90',
   'scan.f90',
   'search_1.f90',
   'search_mecp.f90',
   'setuptest.f90',
   'hessian_tools.f90',
-  'search_imtdgc.f90',
+  'ConfSolv.F90',
+  'search_conformers.f90',
   'search_entropy.f90',
   'parallel.f90', 
 )
Index: src/propcalc.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c  Routines related to additonal property calculations\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n\nsubroutine protreffrag(env)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use strucrd,only:rdnat,rdcoord\n  implicit none\n  type(systemdata) :: env\n  integer,allocatable  :: molvec(:)\n  integer,allocatable  :: at(:)\n  real(wp),allocatable :: xyz(:,:)\n\n  associate (nat => env%nat)\n!------ get number of fragments for original structure\n    allocate (xyz(3,nat),at(nat),molvec(nat))\n    call rdcoord('coord',nat,at,xyz)\n    call mrec(env%ptb%nfrag,xyz,nat,at,molvec) !requires xyz in bohr\n    deallocate (molvec,at,xyz)\n  end associate\nend subroutine protreffrag\n\n!---------------------------------------------------------------------------------------\n! perform a property calculation for a given ensemble file\n!---------------------------------------------------------------------------------------\nsubroutine propcalc(iname,imode,env,tim)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  use strucrd,only:rdensembleparam,rdensemble,wrxyz\n  implicit none\n\n  type(systemdata) :: env\n  type(timer)      :: tim\n  integer :: imode\n\n  character(len=*),intent(in)  :: iname   !file name\n\n  integer :: i,k,r,ii\n  integer :: TMPCONF\n  integer :: P\n  integer :: ich,ich2\n\n  interface\n    subroutine prop_OMP_loop(env,TMPCONF,jobcall,pop)\n      import :: systemdata,wp\n      implicit none\n\n      type(systemdata) :: env\n      integer :: TMPCONF\n      character(len=1024) :: jobcall\n      real(wp),intent(in),optional :: pop(TMPCONF)\n    end subroutine\n  end interface\n\n  character(len=20) :: xname\n  character(len=20) :: pipe\n  character(len=80) :: solv\n  character(len=256) :: ctmp\n  character(len=512) :: str,thispath,tmppath,optpath\n  character(len=1024):: jobcall\n  character(len=:),allocatable :: largejobcall\n\n  real(wp) :: pthr,sumpop\n  integer :: maxpop\n  integer :: nat,nall,ng\n  logical :: ex,update\n  logical :: niceprint\n\n  character(len=40),allocatable :: origin(:)\n  real(wp),allocatable :: eread(:),popul(:),dumm(:)\n  real(wp),allocatable :: xyz(:,:,:)\n  integer,allocatable  :: at(:)\n  logical,allocatable :: mask(:)\n  integer,allocatable :: degen(:,:)\n\n!---\n  call largehead('P R O P E R T Y   C A L C U L A T I O N')\n\n!--- some settings\n  solv = ''\n  pipe = '2>/dev/null'\n  xname = 'struc.xyz'\n  call getcwd(thispath)\n  update = .true.\n  maxpop = 1\n\n  if (env%properties == -666) then\n    imode = env%properties2\n  end if\n\n  niceprint = env%niceprint\n\n  pthr = env%pthr\n\n!---- read the input ensemble\n  call rdensembleparam(iname,nat,nall)\n  env%nat = nat\n  if (nall .lt. 1) return\n  allocate (xyz(3,nat,nall),at(nat),eread(nall),mask(nall))\n  mask = .true.\n  if (.not.env%trackorigin) then\n    call rdensemble(iname,nat,nall,at,xyz,eread)\n  else\n    allocate (origin(nall))\n    call rdensemble_origin(iname,nat,nall,at,xyz,eread,origin)\n  end if\n  TMPCONF = nall\n\n!---- Use only populated conformers for special applications\n  if (any((/2,111/) == imode)) then\n\n    allocate (popul(nall))\n    call boltz2(nall,eread,popul)\n    !write(*,*) eread\n    !write(*,*) popul\n    k = 0\n    maxpop = maxloc(popul(:),1) !locate max. populated structure (this one is always taken)\n    sumpop = 0.0_wp\n    do i = 1,nall\n      if (popul(i) .ge. pthr.or.i .eq. maxpop) then\n        k = k+1\n      else\n        exit\n      end if\n    end do\n    write (*,'(1x,a,i0,a)') 'Population threshold (-pthr) : ',nint(pthr*100.0_wp),' %'\n\n    write (*,'(1x,i0,a,i0,a)') k,' populated structure(s) (out of a total ', &\n    & nall,') will be considered.'\n\n    mask(:) = popul(:) .ge. pthr\n    mask(maxpop) = .true.\n  end if\n\n!---- for multilevel reoptimization don't use all rotamers\n  if (imode .ge. 50.and.imode .lt. 60) then\n    inquire (file='cre_members',exist=ex)\n    if (ex) then\n      open (newunit=ich,file='cre_members')\n      read (ich,*) ng\n      allocate (degen(3,ng))\n      do i = 1,ng\n        read (ich,*) degen(1:3,i)\n      end do\n      close (ich)\n      !-- always include lowest rotamer for all conf.\n      do i = 1,ng\n        mask(degen(2,i)) = .true.\n      end do\n    end if\n  end if\n\n!---- create the PROP directory\n  !---- create directory for the optimizations\n  optpath = 'PROP'\n  call rmrf(optpath)\n  r = makedir(trim(optpath))\n\n  call copysub('coord',trim(optpath))\n\n  call env%wrtCHRG(trim(optpath))\n  call copysub(env%fixfile,trim(optpath))\n  !call copysub(env%constraints,trim(optpath))\n  if (env%useqmdff) then\n    call copysub('solvent',trim(optpath))\n  end if\n  if (env%gfnver == '--gff') then\n    r = sylnk(trim(thispath)//'/'//'gfnff_topo',trim(optpath)//'/'//'gfnff_topo')\n  end if\n\n  call chdir(trim(optpath))\n  call getcwd(optpath)\n!---- set up sub-directories\n  write (*,'(1x,a,a,a)',advance='no') 'writing TMPCONF* Dirs from file \"',trim(iname),'\" ...'\n  ii = 1\n  do i = 1,nall\n    if ((imode .eq. 2).and.(allocated(popul))) then\n      if ((popul(i) .lt. pthr).and.i .ne. maxpop) cycle !skip unpopulated for '-prop autoir'\n    end if\n    if (.not.mask(i)) cycle\n\n    write (ctmp,'(''TMPCONF'',i0)') ii\n    r = makedir(trim(ctmp))\n    call chdir(ctmp)\n    open (newunit=ich,file=xname)\n    call wrxyz(ich,nat,at,xyz(:,:,i))\n\n    call write_cts(ich,env%cts)\n    close (ich)\n\n    if (imode .eq. 2.and.trim(env%gfnver) .eq. '--gfn2') then\n      call add_mass_xtb(xname)\n    end if\n\n    call chdir(optpath)\n\n    call env%wrtCHRG(trim(ctmp))\n    call copysub(env%fixfile,trim(ctmp))\n    if (env%useqmdff) then\n      call copysub('solvent',trim(ctmp))\n    end if\n    if (env%gfnver == '--gff') then\n      r = sylnk(trim(optpath)//'/'//'gfnff_topo',trim(ctmp)//'/'//'gfnff_topo')\n    end if\n\n    ii = ii+1\n  end do\n  write (*,'(1x,a)') 'done.'\n\n  if (any(mask.eqv..false.)) then\n    TMPCONF = ii-1\n    nall = ii-1\n    if (allocated(popul)) deallocate (popul)\n  end if\n\n!--- setting the threads for correct parallelization\n  if (env%autothreads) then\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,TMPCONF) !set global OMP/MKL variable for xtb jobs\n  end if\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n  call chdir(thispath)\n!--- select what to do\n  P = imode\n  select case (P)\n  case (1)\n    call smallhead('Hessian calculations for all conformers')\n    write (jobcall,'(a,1x,a,1x,a,'' --hess '',a,1x,a,'' >xtb.out'')') &\n    &    trim(env%ProgName),trim(xname),trim(env%gfnver),trim(env%solv),trim(pipe)\n  case (10)\n    call smallhead('Optimization + Hessian calculations for all conformers')\n    write (jobcall,'(a,1x,a,1x,a,'' --ohess '',a,1x,a,'' >xtb.out'')') &\n    &    trim(env%ProgName),trim(xname),trim(env%gfnver),trim(env%solv),trim(pipe)\n  case (13)\n    call smallhead('Free energy calculation in solvation')\n    write (jobcall,'(a,1x,a,1x,a,'' --sp '',a,'' >sp.out'')') &\n    &    trim(env%ProgName),trim(xname),trim(env%gfnver),trim(pipe) !E_gas(Solv_geom) singlepoint\n    largejobcall = trim(jobcall)//' ; '\n    write (jobcall,'(a,1x,a,1x,a,'' --ohess '',a,1x,a,'' >xtb.out'')') &\n    &    trim(env%ProgName),trim(xname),trim(env%gfnver),trim(env%solv),trim(pipe)\n    jobcall = largejobcall//trim(jobcall)\n  case (2)\n    call smallhead('IR calculation for populated conformers')\n    write (jobcall,'(a,1x,a,1x,a,'' --ohess '',a,1x,a,'' >xtb.out'')') &\n    &    trim(env%ProgName),trim(xname),trim(env%gfnver),trim(env%solv),trim(pipe)\n!       case( 3:6,7,8,100 ) ! unspecific case DFT\n!         call smallhead('DFT calculation using xtb as driver')\n!         if( any((/3,4/)==P) )then\n!           call dftrc_reader(env,.true.)  !B97-3c OPT default\n!           call dftTMwarning\n!         else\n!           call dftrc_reader(env,.false.) !read DFT settings\n!         endif\n!         call chdir(optpath)\n!         call cefine_setup(env,TMPCONF)\n!         call xtbDFTdriver(env,xname,jobcall) !create jobcall\n  case (20)\n    call smallhead('Reoptimization for all conformers')\n    write (jobcall,'(a,1x,a,1x,a,'' --opt vtight '',a,1x,a,'' >xtb.out'')') &\n    &    trim(env%ProgName),trim(xname),trim(env%gfnver),trim(env%solv),trim(pipe)\n  case (50:59)\n    call smallhead('Reoptimization of entire CRE')\n    write (jobcall,'(a,1x,a,1x,a,'' --opt vtight '',a,1x,a,'' >xtb.out'')') &\n    &    trim(env%ProgName),trim(xname),trim(env%gfnver2),trim(env%solv),trim(pipe)\n  case default\n    write (jobcall,'(a,1x,a,1x,a,'' --sp '',a,1x,a,'' >xtb.out'')') &\n    &    trim(env%ProgName),trim(xname),trim(env%gfnver),trim(env%solv),trim(pipe)\n  end select\n  call chdir(optpath)\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n\n  write (*,'(1x,a,i0,a)') 'Performing calculations for ', &\n  & TMPCONF,' structures ...'\n  call sleep(1)\n  call tim%start(10,'PROPERTY calc.')\n  allocate (dumm(TMPCONF),source=1.0_wp)\n  call prop_OMP_loop(env,TMPCONF,jobcall,dumm)  !<------- this is where the \"magic\" happens\n  deallocate (dumm)\n  write (*,*)\n  call tim%stop(10)\n  write (*,*) 'done.'\n\n  call tim%start(10,'PROPERTY calc.')\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n\n!--- select what to do with the output\n  select case (imode)\n\n!------ generate an ensemble with free energies from hessian calculations\n  case (1,10)\n    call rdpropens(TMPCONF,nat,xyz) !get updated geometries\n    open (newunit=ich,file='crest_property.xyz')\n    do i = 1,TMPCONF\n      write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtb.out'\n      call grepval(tmppath,'TOTAL FREE ENERGY',ex,eread(i))\n      if (.not.env%trackorigin) then\n        write (str,'(3x,f16.10)') eread(i)\n      else\n        write (str,'(3x,f16.10,2x,a,a)') eread(i),'!',trim(origin(i))\n      end if\n      call wrxyz(ich,nat,at,xyz(:,:,i),trim(str))\n    end do\n    close (ich)\n    env%ensemblename = 'crest_property.xyz'\n    env%confgo = .true.\n\n    call newcregen(env,0)\n\n    call rename('crest_property.xyz.sorted', &\n    & trim(thispath)//'/crest_property.xyz')\n    call remove(env%ensemblename)\n!------ IR averaging\n  case (2)\n    call autoir(TMPCONF,imode,env)\n    call rdpropens(TMPCONF,nat,xyz) !get updated geometries\n    call wrpropens(TMPCONF,nat,xyz,at,eread)\n!!----- DFT handling\n!       case( 3:8,100 )\n!         call DFTprocessing(env,TMPCONF,nat,at)\n!------ vtight reoptimization only for conformers!\n  case (20)\n    call rdpropens(TMPCONF,nat,xyz) !get updated geometries\n    call wrpropens(TMPCONF,nat,xyz,at,eread)\n    env%ensemblename = 'crest_property.xyz'\n    env%confgo = .true.\n\n    call newcregen(env,0)\n\n    call rename('crest_ensemble.xyz', &\n    & trim(thispath)//'/crest_conformers.xyz')\n  case (50:59)\n    call rdpropens(TMPCONF,nat,xyz) !get updated geometries\n    env%ensemblename = 'crest_reopt.xyz'\n    open (newunit=ich,file=env%ensemblename)\n    do i = 1,TMPCONF\n      write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtb.out'\n      call grepval(tmppath,'total energy',ex,eread(i))\n      if (.not.env%trackorigin) then\n        write (str,'(3x,f16.10)') eread(i)\n      else\n        write (str,'(3x,f16.10,2x,a,a)') eread(i),'!',trim(origin(i))\n      end if\n      call wrxyz(ich,nat,at,xyz(:,:,i),trim(str))\n    end do\n    close (ich)\n    call rename(env%ensemblename, trim(thispath)//'/'//env%ensemblename)\n    call chdir(thispath)\n    if (imode .lt. 59) then !TODO temporary skip for some testing\n      env%confgo = .true.\n\n      call newcregen(env,0)\n\n      env%confgo = .false.\n      call rename(trim(env%ensemblename)//'.sorted', &\n      & env%ensemblename)\n    end if\n\n  case (998) !singlpoint (no reranking) + dipoles\n    open (newunit=ich,file='crest_property.xyz')\n    open (newunit=ich2,file='crest.dipoles')\n    do i = 1,TMPCONF\n      write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtb.out'\n      call grepval(tmppath,'| TOTAL ENERGY',ex,eread(i))\n      write (str,'(3x,f16.10)') eread(i)\n      call wrxyz(ich,nat,at,xyz(:,:,i),trim(str))\n\n      call grepcntxt(tmppath,'molecular dipole:',ex,ctmp, 3) \n      if(ex)then\n        write(ich2,'(a)') trim(ctmp(10:))\n      else\n        write(ich2,'(a)') ''\n      endif\n    end do\n    close (ich)\n    close(ich2)\n\n    call rename('crest.dipoles', &\n    & trim(thispath)//'/'//'crest.dipoles')  \n\n    write(*,*)\n    write(*,*) 'Dipole moments for each conformer (x,y,z,total) written to crest.dipoles'\n\n  case (999) !singlpoint reranking\n    open (newunit=ich,file='crest_property.xyz')\n    do i = 1,TMPCONF\n      write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtb.out'\n      call grepval(tmppath,'| TOTAL ENERGY',ex,eread(i))\n      write (str,'(3x,f16.10)') eread(i)\n      call wrxyz(ich,nat,at,xyz(:,:,i),trim(str))\n    end do\n    close (ich)\n    env%ensemblename = 'crest_property.xyz'\n    env%confgo = .true.\n\n    call newcregen(env,0)\n\n    call rename('crest_property.xyz.sorted', &\n    & trim(thispath)//'/crest_property.xyz')\n    call remove(env%ensemblename)\n    call rename('crest_ensemble.xyz', &\n    & trim(thispath)//'/crest_ensemble.xyz')\n\n  case default\n    continue\n  end select\n\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!>--- move around some files\n\n  inquire (file='cregen.out.tmp',exist=ex)\n  if (ex) then\n    call cat('cregen.out.tmp')\n  end if\n\n  inquire (file='crest.vibspectrum',exist=ex)\n  if (ex) then\n    call rename('crest.vibspectrum', &\n    & trim(thispath)//'/'//'crest.vibspectrum')\n  end if\n\n  inquire (file='crest_property.xyz',exist=ex)\n  if (ex) then\n    call rename('crest_property.xyz', &\n    & trim(thispath)//'/'//'crest_property.xyz')\n  end if\n\n  inquire (file='crest_populated.xyz',exist=ex)\n  if (ex) then\n    call rename('crest_populated.xyz', &\n    & trim(thispath)//'/'//'crest_populated.xyz')\n  end if\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!>--- stop timer\n\n  call tim%stop(10)\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!>--- change back to original directory (just to be sure)\n\n  call chdir(thispath)\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!>--- decide if something has to be cleaned up here\n\n  if (env%pclean) then\n    select case (imode)\n    case (20,50:59,998,999)\n      call rmrf('PROP')\n    case default\n      continue\n    end select\n  end if\n\n  if (allocated(xyz)) deallocate (xyz)\n  if (allocated(at)) deallocate (at)\n  if (allocated(eread)) deallocate (eread)\n  if (allocated(origin)) deallocate (origin)\n  if (allocated(mask)) deallocate (mask)\n  if (allocated(popul)) deallocate (popul)\n\nend subroutine propcalc\n\n!----------------------------------------------------------------------------------------------------\n! THE OMP-PARALLEL LOOP\n!----------------------------------------------------------------------------------------------------\nsubroutine prop_OMP_loop(env,TMPCONF,jobcall,pop)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  implicit none\n\n  type(systemdata) :: env\n  integer :: TMPCONF\n  character(len=1024) :: jobcall\n  real(wp),intent(in),optional :: pop(TMPCONF)\n\n  real(wp) :: pthr\n  logical :: niceprint\n  character(len=52) :: bar\n  real(wp) :: percent\n  integer :: vz,k,i,maxpop,io\n  character(len=512) :: tmppath\n\n!----- quick settings\n  niceprint = env%niceprint\n  pthr = env%pthr\n  maxpop = maxloc(pop(:),1)\n  if (niceprint) then\n    call printemptybar()\n  end if\n  k = 0        ! count finished jobs\n\n!$omp parallel &\n!$omp shared( vz,jobcall,TMPCONF,pop,pthr,percent,k,niceprint,bar,maxpop )\n!$omp single\n  do i = 1,TMPCONF\n    vz = i\n    !$omp task firstprivate( vz ) private( tmppath,io )\n    call initsignal()\n    !$omp critical\n    write (tmppath,'(a,i0)') 'TMPCONF',vz\n    !$omp end critical\n    if (pop(vz) .ge. pthr.or.vz .eq. maxpop) then\n      call command('cd '//trim(tmppath)//' && '//trim(jobcall), io)\n    end if\n    !$omp critical\n    k = k+1\n    if (niceprint) then\n      percent = float(k)/float(TMPCONF)*100\n      call progbar(percent,bar)\n      call printprogbar(percent,bar)\n    else\n      write (6,'(1x,i0)',advance='no') k\n      flush (6)\n    end if\n    !$omp end critical\n    !$omp end task\n  end do\n!$omp taskwait\n!$omp end single\n!$omp end parallel\n\n  return\nend subroutine prop_OMP_loop\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n! grep total energies and printout energy list\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine etotprop(TMPCONF,pop,pr)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  implicit none\n  integer,intent(in) :: TMPCONF\n  real(wp),intent(inout) :: pop(TMPCONF)\n  logical :: pr\n  character(len=512) :: tmppath\n  logical :: ex\n  integer :: i\n  real(wp) :: dE\n  real(wp),allocatable :: eread(:)\n\n  real(wp),parameter :: kcal = 627.5095_wp\n\n  write (*,'(1x,a)') \"Calculating populations from total energies ...\"\n  allocate (eread(TMPCONF))\n  do i = 1,TMPCONF\n    write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtb.out'\n    call grepval(tmppath,'total energy',ex,eread(i))\n  end do\n\n!--- convert to populations\n  call boltz2(TMPCONF,eread,pop)\n  if (pr) then\n    write (*,'(a)') '========================================================='\n    write (*,'(a)') '============= total energies & populations  ============='\n    write (*,'(a)') '========================================================='\n    write (*,'('' structure    ΔE(kcal/mol)    Etot(Eh)        weight'')')\n    do i = 1,TMPCONF\n      dE = (eread(i)-eread(1))*kcal\n      write (*,'(i5,6x,F10.2,4x,F14.6,F13.4)') i,dE,eread(i),pop(i)\n    end do\n    write (*,*)\n  end if\n  deallocate (eread)\n  return\nend subroutine etotprop\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n! grep optimized geometries (ONLY that, no energies)\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine rdpropens(TMPCONF,n,xyz)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  implicit none\n\n  integer,intent(in)  :: TMPCONF\n  integer,intent(in)  :: n\n  real(wp),intent(inout) :: xyz(3,n,TMPCONF)\n\n  integer :: ich\n  character(len=512) :: tmppath,atmp\n  character(len=64)  :: dum\n  logical :: ex\n  integer :: i,j\n\n  real(wp),parameter :: kcal = 627.5095_wp\n\n  do i = 1,TMPCONF\n    write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtbopt.xyz'\n    inquire (file=tmppath,exist=ex)\n    if (.not.ex) then\n      write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','struc.xyz'\n    end if\n    open (newunit=ich,file=tmppath)\n    read (ich,'(a)') atmp\n    read (ich,'(a)') atmp\n    do j = 1,n\n      read (ich,*) dum,xyz(1:3,j,i)\n    end do\n    close (ich)\n  end do\n\n  return\nend subroutine rdpropens\nsubroutine wrpropens(TMPCONF,n,xyz,at,eread)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  use strucrd,only:wrxyz\n  implicit none\n\n  integer,intent(in)    :: TMPCONF\n  integer,intent(in)    :: n\n  real(wp),intent(in)   :: xyz(3,n,TMPCONF)\n  real(wp),intent(inout):: eread(TMPCONF)\n  integer,intent(in)    :: at(n)\n  integer :: ich\n  character(len=512) :: tmppath\n  logical :: ex\n  integer :: i\n\n  open (newunit=ich,file='crest_property.xyz')\n  do i = 1,TMPCONF\n    write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtb.out'\n    call grepval(tmppath,'total energy',ex,eread(i))\n    call wrxyz(ich,n,at,xyz(:,:,i),eread(i))\n  end do\n  return\nend subroutine wrpropens\nsubroutine wrpropens_pop(env,TMPCONF,n,xyz,at,eread,pthr)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  use strucrd,only:wrxyz\n  implicit none\n\n  type(systemdata) :: env\n  integer,intent(in)    :: TMPCONF\n  integer,intent(in)    :: n\n  real(wp),intent(in)   :: xyz(3,n,TMPCONF)\n  real(wp),intent(in)   :: eread(TMPCONF)\n  integer,intent(in)    :: at(n)\n  real(wp),intent(in)   :: pthr\n  integer :: ich,ich5\n  integer :: i\n  integer :: pmax\n  real(wp),allocatable :: pop(:),dpop(:),edum(:)\n\n  allocate (pop(TMPCONF),dpop(TMPCONF))\n  call boltz2(TMPCONF,eread,pop)\n  pmax = maxloc(pop,1)\n\n  dpop = pop\n\n!      if(env%hardcutDFT)then\n!         call cutDFTpop(env,dpop,TMPCONF)\n!         allocate(edum(TMPCONF))\n!         edum=eread\n!         do i=1,TMPCONF\n!            if(dpop(i).le.0.00001_wp)then\n!              edum(i)=0.0_wp\n!            endif\n!         enddo\n!         call boltz2(TMPCONF,edum,pop)\n!         deallocate(edum)\n!      endif\n\n  open (newunit=ich5,file='autoir.pop')\n  open (newunit=ich,file='crest_populated.xyz')\n  do i = 1,TMPCONF\n    if (dpop(i) .lt. pthr.and.i .ne. pmax) cycle\n    write (ich5,'(1x,i0,1x,f6.4)') i,pop(i)\n    call wrxyz(ich,n,at,xyz(:,:,i),eread(i))\n  end do\n  close (ich)\n  close (ich5)\n  deallocate (dpop,pop)\n  return\nend subroutine wrpropens_pop\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n! obtain an averaged IR spectrum for the ensemble\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine autoir(TMPCONF,imode,env)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  implicit none\n\n  type(systemdata) :: env\n\n  integer,intent(in) :: TMPCONF\n  integer :: imode\n\n  integer :: i,j,k,l\n  integer :: nall,nmodes,mnew,npop\n  integer :: ich,ich5\n  character(len=512) :: tmppath\n  real(wp) :: dE\n  real(wp) :: pthr\n  logical :: ex\n  integer  :: minl,minll(1),maxl\n\n  real(wp),allocatable :: eread(:),pop(:),pop2(:),edum(:)\n  real(wp),allocatable :: vibspec(:,:,:)\n\n  real(wp),allocatable :: freq(:),tmpfreq(:),dum(:)\n  real(wp),allocatable :: inten(:),tmpint(:)\n\n  real(wp),parameter :: kcal = 627.5095_wp\n\n  nall = TMPCONF\n  pthr = env%pthr\n\n  write (*,*)\n  write (*,'(1x,a)') \"Obtaining calculated vibspectra ...\"\n\n  select case (imode)\n  case (2)\n!--- get the free energies for better weights\n    write (*,'(1x,a)') \"Calculating populations from free energies ...\"\n    allocate (eread(TMPCONF),pop(TMPCONF))\n    do i = 1,TMPCONF\n      write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtb.out'\n      call grepval(tmppath,'TOTAL FREE ENERGY',ex,eread(i))\n    end do\n  case default\n!--- just energies\n    write (*,'(1x,a)') \"Calculating populations from total energies ...\"\n    allocate (eread(TMPCONF),pop(TMPCONF))\n    do i = 1,TMPCONF\n      write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','xtb.out'\n      call grepval(tmppath,'total energy',ex,eread(i))\n    end do\n  end select\n!--- convert to populations\n  call boltz2(nall,eread,pop)\n!      if(env%hardcutDFT .and. imode.ne.2)then !special sort mode\n!         call cutDFTpop(env,pop,nall)\n!         allocate(edum(nall))\n!         edum(1:nall)=eread(1:nall)*pop(1:nall) !set energies of removed structures to 0\n!         call boltz2(nall,edum,pop) !convert to new populations, only with used structures\n!      endif\n  maxl = maxloc(pop(:),1)\n\n!--- short energy printout\n  write (*,*)\n  select case (imode)\n  case (2)\n    write (*,'(a)') '========================================================='\n    write (*,'(a)') '============= free energies & populations  =============='\n    write (*,'(a)') '========================================================='\n    write (*,'('' structure    ΔG(kcal/mol)    Gtot(Eh)        weight'')')\n  case default\n    write (*,'(a)') '========================================================='\n    write (*,'(a)') '============= total energies & populations  ============='\n    write (*,'(a)') '========================================================='\n    write (*,'('' structure    ΔE(kcal/mol)    Etot(Eh)        weight'')')\n  end select\n  do i = 1,nall\n    dE = (eread(i)-eread(1))*kcal\n    write (*,'(i5,6x,F10.2,4x,F14.6,F13.4)') i,dE,eread(i),pop(i)\n  end do\n  write (*,*)\n\n  !--- if only populated structures are required.\n  npop = 0\n  do i = 1,TMPCONF\n    if (pop(i) .ge. pthr.or.i .eq. maxl) npop = npop+1\n  end do\n  nall = npop\n  write (*,'(1x,i0,a,i0,a)') nall, &\n  & ' structures are above the population threshold of ',nint(pthr*100.0_wp),'%.'\n\n!--- read-in spectra\n  nmodes = env%nat*3\n  allocate (vibspec(2,nmodes,nall),pop2(nall))  !vibspec(1,:,i)=frequencies of mol i\n  !vibspec(2,:,i)=intensities of mol i\n\n  open (newunit=ich5,file='autoir.pop')\n  npop = 1\n  do i = 1,TMPCONF\n    if (pop(i) .ge. pthr.or.i .eq. maxl) then\n      write (ich5,'(1x,i0,1x,f6.4)') i,pop(i)\n      write (tmppath,'(a,i0,a,a)') 'TMPCONF',i,'/','vibspectrum'\n      call rdvibs(tmppath,nmodes,vibspec(1,:,npop),vibspec(2,:,npop))\n      pop2(npop) = pop(i)\n      npop = npop+1\n    end if\n  end do\n  close (ich5)\n\n  write (*,'(1x,a,i0,a)',advance='no') 'Weighting ',nall,' vibspectra ...'\n!--- weight spectra and sort frequencies\n  mnew = (nmodes-6)*nall+6\n  allocate (freq(mnew),inten(mnew))\n!--- write to new arrays\n  !--- translation first\n  do i = 1,6\n    freq(i) = 0.0_wp\n    inten(i) = 0.0_wp\n  end do\n  !--- then the vibspectra\n  l = 7\n  do k = 1,nall\n    do j = 7,nmodes\n      freq(l) = vibspec(1,j,k)\n      inten(l) = vibspec(2,j,k)*pop2(k) !scaled intensity\n      l = l+1\n    end do\n  end do\n\n!--- sort in ascending order\n  allocate (tmpfreq(mnew),tmpint(mnew),dum(mnew-6))\n  tmpfreq = 0.0_wp\n  tmpint = 0.0_wp\n  dum(:) = freq(7:mnew)\n  do i = 7,mnew\n    minll = minloc(dum)\n    minl = minll(1)\n    tmpfreq(i) = dum(minl)\n    tmpint(i) = inten(minl+6)\n    dum(minl) = 100000.0_wp\n  end do\n  freq = tmpfreq\n  inten = tmpint\n  deallocate (dum,tmpint,tmpfreq)\n\n  write (*,'(1x,a)') \"done.\"\n  write (*,*)\n\n!--- write new file\n  open (file='crest.vibspectrum',newunit=ich)\n  call write_tm_vibspectrum(ich,mnew,freq,inten)\n  write (*,'(1x,a)') 'Written to file <crest.vibspectrum>'\n\n  deallocate (inten,freq,pop2,vibspec,pop,eread)\n\n  return\nend subroutine autoir\n\n!--- read vibspectrum file in TM format\nsubroutine rdvibs(fname,nmodes,freq,inten)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  implicit none\n\n  character(len=*),intent(in) :: fname\n  integer,intent(in)   :: nmodes\n  real(wp),intent(out) :: freq(nmodes)    !frequencies\n  real(wp),intent(out) :: inten(nmodes)   !intensities\n\n  integer :: k\n  integer :: ich,io,n\n  character(len=256) :: atmp\n  real(wp) :: floats(10)\n  logical :: ex\n\n  freq = 0.0_wp\n  inten = 0.0_wp\n\n  inquire (file=fname,exist=ex)\n  if (.not.ex) return\n\n  k = 1 !modes\n  open (file=fname,newunit=ich)\n  rdfile: do\n    read (ich,'(a)',iostat=io) atmp\n    if (io < 0) exit\n    if (index(atmp,'$vibrational spectrum') .ne. 0) then\n      rdblock: do\n        read (ich,'(a)',iostat=io) atmp\n        if (io < 0) exit rdfile\n        if (index(atmp,'$end') .ne. 0) exit rdfile\n        if (index(atmp,'#') .ne. 0) cycle rdblock !skip comment lines\n        call readl(atmp,floats,n)\n        freq(k) = floats(2)\n        inten(k) = floats(3)\n        k = k+1\n      end do rdblock\n    end if\n  end do rdfile\n\n  return\nend subroutine rdvibs\n\nsubroutine write_tm_vibspectrum(ich,n3,freq,ir_int)\n  use iso_fortran_env,wp => real64\n  integer,intent(in)  :: ich ! file handle\n  integer,intent(in)  :: n3\n  real(wp),intent(in)  :: freq(n3)\n  real(wp),intent(in)  :: ir_int(n3)\n  integer  :: i\n  real(wp) :: thr = 0.01_wp\n  write (ich,'(\"$vibrational spectrum\")')\n  write (ich,'(\"#  mode     symmetry     wave number   IR intensity    selection rules\")')\n  write (ich,'(\"#                         cm**(-1)        (amu)          IR     RAMAN\")')\n  do i = 1,n3\n    if (abs(freq(i)) .lt. thr) then\n      write (ich,'(i6,9x,    f18.2,f16.5,7x,\" - \",5x,\" - \")') &\n        i,freq(i),0.0_wp\n    else\n      write (ich,'(i6,8x,\"a\",f18.2,f16.5,7x,\"YES\",5x,\"YES\")') &\n        i,freq(i),ir_int(i)\n    end if\n  end do\n  write (ich,'(\"$end\")')\nend subroutine\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/propcalc.f90 b/src/propcalc.f90
--- a/src/propcalc.f90	
+++ b/src/propcalc.f90	
@@ -50,6 +50,7 @@
   use crest_data
   use iomod
   use strucrd,only:rdensembleparam,rdensemble,wrxyz
+  use utilities, only: boltz2
   implicit none
 
   type(systemdata) :: env
@@ -558,6 +559,7 @@
   use iso_fortran_env,wp => real64
   use crest_data
   use iomod
+  use utilities, only: boltz2
   implicit none
   integer,intent(in) :: TMPCONF
   real(wp),intent(inout) :: pop(TMPCONF)
@@ -662,6 +664,7 @@
   use crest_data
   use iomod
   use strucrd,only:wrxyz
+  use utilities, only: boltz2
   implicit none
 
   type(systemdata) :: env
@@ -715,6 +718,7 @@
   use iso_fortran_env,wp => real64
   use crest_data
   use iomod
+  use utilities, only: boltz2
   implicit none
 
   type(systemdata) :: env
Index: src/meson.build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nsubdir('qcg')\nsubdir('dynamics')\nsubdir('calculator')\nsubdir('optimize')\nsubdir('algos')\nsubdir('parsing')\nsubdir('qmhelpers')\nsubdir('graphs') \nsubdir('rigidconf')\nsubdir('discretize')\nsubdir('entropy')\nsubdir('legacy_algos')\n\n\nsrcs += files(\n  'atmasses.f90',\n  'axis_module.f90',\n  'biasmerge.f90',\n  'bondconstraint.f90',\n  'ccegen.f90',\n  'choose_settings.f90',\n  'classes.f90',\n  'cleanup.f90',\n  'compress.f90',\n  'confparse.f90',\n  'constraining.f90',\n  'cregen.f90',\n  'crest_pars.f90',\n  'data.f90',\n  'ensemblecomp.f90',\n  'eval_timer.f90',\n  'filemod.f90',\n  'flexi.F90',\n  'freqmasses.f90',\n  'geo.f90',\n  'identifiers.f90',\n  'internals.f90', \n  'internals2.f90',\n  'io.f',\n  'iomod.F90',\n  'legacy_wrappers.f90',\n  'ls_rmsd.f90',\n  'marqfit.f90',\n  'minitools.f90',\n  'msmod.f90',\n  'msreact.f90',\n  'ncigeo.f90',\n  'neighbor.f',\n  'ompmklset.F90',\n  'printouts.f90',\n  'prmat.f90',\n  'progressbar.f90',\n  'propcalc.f90',\n  'quicksort.f90',\n  'readl.f90',\n  'rotcompare.f90',\n  'scratch.f90',\n  'sdfio.f90',\n  'select.f90',\n  'signal.c',\n  'sigterm.f90',\n  'sortens.f90',\n  'spline.f90',\n  'strucreader.f90',\n  'symmetry2.f90',\n  'symmetry_i.c',\n  'testmol.f90',\n  'timer.f90',\n  'trackorigin.f90',\n  'utilities.f',\n  'zdata.f90',\n  'zsort.f90',\n  'ztopology.f90',\n)\n\nprog += files(\n  'crest_main.f90',\n)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/meson.build b/src/meson.build
--- a/src/meson.build	
+++ b/src/meson.build	
@@ -39,10 +39,8 @@
   'cleanup.f90',
   'compress.f90',
   'confparse.f90',
-  'constraining.f90',
   'cregen.f90',
   'crest_pars.f90',
-  'data.f90',
   'ensemblecomp.f90',
   'eval_timer.f90',
   'filemod.f90',
@@ -52,16 +50,15 @@
   'identifiers.f90',
   'internals.f90', 
   'internals2.f90',
-  'io.f',
   'iomod.F90',
   'legacy_wrappers.f90',
   'ls_rmsd.f90',
   'marqfit.f90',
   'minitools.f90',
+  'miscdata.f90',
   'msmod.f90',
   'msreact.f90',
   'ncigeo.f90',
-  'neighbor.f',
   'ompmklset.F90',
   'printouts.f90',
   'prmat.f90',
@@ -69,6 +66,7 @@
   'propcalc.f90',
   'quicksort.f90',
   'readl.f90',
+  'restartlog.f90',
   'rotcompare.f90',
   'scratch.f90',
   'sdfio.f90',
@@ -83,9 +81,9 @@
   'testmol.f90',
   'timer.f90',
   'trackorigin.f90',
-  'utilities.f',
+  'utilmod.f90',
+  'wallsetup.f90',
   'zdata.f90',
-  'zsort.f90',
   'ztopology.f90',
 )
 
Index: src/iomod.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!> This is a collection of various IO subroutines\n\nmodule iomod\n  use iso_fortran_env,wp => real64,stdout=>output_unit\n  use iso_c_binding\n  implicit none\n  public\n\n  interface\n    function mkdir(path,mode) bind(c,name=\"mkdir\")\n      use iso_c_binding\n      integer(c_int) :: mkdir\n      character(kind=c_char,len=1) :: path(*)\n      integer(c_int16_t),value :: mode\n    end function mkdir\n  end interface\n\n  interface\n    integer(kind=c_int) function c_setenv(c_name,c_VALUE) bind(c,name=\"setenv\")\n      use iso_c_binding\n      character(kind=c_char)   :: c_name(*)\n      character(kind=c_char)   :: c_VALUE(*)\n    end function\n  end interface\n  interface setenv\n    module procedure setenv_string\n    module procedure setenv_int\n    module procedure setenv_float\n  end interface setenv\n\n  interface\n    integer(kind=c_int) function c_symlink(c_from,c_to) bind(c,name=\"symlink\")\n      use iso_c_binding\n      character(kind=c_char)   :: c_from(*)\n      character(kind=c_char)   :: c_to(*)\n    end function\n  end interface\n\n  interface wrshort\n    module procedure wrshort_real\n    module procedure wrshort_int\n    module procedure wrshort_string\n  end interface wrshort\n\n  interface rdshort\n    module procedure rdshort_real\n    module procedure rdshort_int\n    module procedure rdshort_string\n  end interface rdshort\n\n  interface uppercase\n!    module procedure to_upper\n    module procedure to_upper_func\n  end interface uppercase\n\n  interface lowercase\n!    module procedure to_lower\n    module procedure to_lower_func\n  end interface lowercase\n\n  interface convert_to_string\n    module procedure i8_to_string\n    module procedure i16_to_string\n    module procedure i32_to_string\n    module procedure i64_to_string\n    module procedure r32_to_string\n    module procedure r64_to_string\n    module procedure bool_to_string\n  end interface convert_to_string\n  interface to_str\n    module procedure to_str_i8\n    module procedure to_str_i16\n    module procedure to_str_i32\n    module procedure to_str_i64\n    module procedure to_str_r32\n    module procedure to_str_r64\n    module procedure to_str_bool\n  end interface to_str\n\n  public :: checkprog\n  public :: checkprog_silent\n  private :: getpath\n\n!========================================================================================!\n!========================================================================================!\ncontains !> MODULE PROCEDURES START HERE\n!========================================================================================!\n!========================================================================================!\n!-------------------------------------------------------------\n! remove file 'fname'\n! if 'fname' contains the wildcard '*', the remove is ignored\n!--------------------------------------------------------------\n  subroutine remove(fname)\n    implicit none\n    character(len=*) :: fname\n    integer :: ich,och\n    logical :: ex\n    if (index(fname,'*') .eq. 0) then\n      open (newunit=ich,file=fname)\n      close (ich,status='delete')\n    end if\n  end subroutine remove\n\n!-------------------------------------------------------------\n! creates an empty file \"fname\", similar to the shell command \"touch\"\n!--------------------------------------------------------------\n  subroutine touch(fname)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    open (newunit=ich,file=fname)\n    close (ich)\n  end subroutine touch\n\n!-------------------------------------------------------------\n! prints the file \"fname\", similar to the shell command \"cat\"\n!--------------------------------------------------------------\n  subroutine cat(fname)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    character(len=512) :: str\n    integer :: io\n    open (newunit=ich,file=fname)\n    do\n      read (ich,'(a)',iostat=io) str\n      if (io < 0) exit\n      write (stdout,'(a)') trim(str)\n    end do\n    close (ich)\n  end subroutine cat\n\n!--------------------------------------------------------------------------------------\n! prints the file \"fname\", similar to the shell command \"cat\" but deletes it at the end\n!--------------------------------------------------------------------------------------\n  subroutine catdel(fname)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    character(len=512) :: str\n    integer :: io\n    open (newunit=ich,file=fname)\n    do\n      read (ich,'(a)',iostat=io) str\n      if (io < 0) exit\n      write (stdout,'(a)') trim(str)\n    end do\n    close (unit=ich,status='delete')\n  end subroutine catdel\n\n!-------------------------------------------------------------------------\n! copy a file from path \"from\" to path \"to\"\n!-------------------------------------------------------------------------\n  subroutine copy(from,to)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: from\n    character(len=*) :: to\n    character(len=512) :: line\n    integer :: io\n    inquire (file=from,exist=ex)\n    if (ex) then\n      open (newunit=ich,file=from)\n      open (newunit=och,file=to)\n      do\n        read (ich,'(a)',iostat=io) line\n        if (io < 0) exit\n        write (och,'(a)') trim(line)\n      end do\n      close (och)\n      close (ich)\n    end if\n  end subroutine copy\n\n!-------------------------------------------------------------------------\n! copy a file from path \"from\" to a specified sub-directory \"to\"\n!-------------------------------------------------------------------------\n  subroutine copysub(from,to)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: from\n    character(len=*) :: to\n    character(len=512) :: line,dir1\n    integer :: io\n    inquire (file=from,exist=ex)\n    if (ex) then\n      call getcwd(dir1)\n      inquire (file=from,exist=ex)\n      if (ex) then\n        open (newunit=ich,file=from)\n        call chdir(to)\n        open (newunit=och,file=from)\n        do\n          read (ich,'(a)',iostat=io) line\n          if (io < 0) exit\n          write (och,'(a)') trim(line)\n        end do\n        close (och)\n        close (ich)\n      end if\n      call chdir(dir1)\n    end if\n  end subroutine copysub\n\n!-------------------------------------------------------------------------\n! move a file from path \"from\" to path \"to\". \"from\" file is deleted.\n!-------------------------------------------------------------------------\n  subroutine move(from,to)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: from\n    character(len=*) :: to\n    inquire (file=from,exist=ex)\n    if (ex) then\n      call remove(to)\n      call rename(from,to)\n    else\n      write (stdout,'(''file '',a,'' does not exist!'')') trim(from)\n    end if\n  end subroutine move\n\n!-------------------------------------------------------------------------\n! converts a path relative to the current directory (i.e. containing \"../\"\n! and such) into the absolute Path\n!-------------------------------------------------------------------------\n  subroutine getAbsPath(Path)\n    implicit none\n    character(len=*),intent(inout) :: Path\n    character(len=512) :: thispath\n    call getcwd(thispath)  !get current working directory\n    call chdir(Path)\n    call getcwd(Path)  !get the absolute path which was given as a relative path\n    call chdir(thispath) !switch back to original directory\n  end subroutine getAbsPath\n\n!-------------------------------------------------------------------------\n! the \"inquire\" command, but in a sub-directory\n!-------------------------------------------------------------------------\n  subroutine inquiresub(f,sub,bool)\n    implicit none\n    character(len=*),intent(in) :: f\n    character(len=*),intent(in) :: sub\n    character(len=512) :: thispath\n    logical,intent(out) :: bool\n    call getcwd(thispath)  !get current working directory\n    call chdir(sub) !go to the subdirectory\n    inquire (file=f,exist=bool) !do the \"inquire\"\n    call chdir(thispath) !switch back to original directory\n  end subroutine inquiresub\n\n!-------------------------------------------------------------------------\n! append content of text file \"from\" into text file \"to\", similar to \"cat A >> B\"\n!-------------------------------------------------------------------------\n  subroutine appendto(from,to)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    integer :: io\n    character(len=*) :: from\n    character(len=*) :: to\n    character(len=1024) :: str\n    open (newunit=ich,file=to)\n    open (newunit=och,file=from)\n    do\n      read (ich,*,iostat=io)\n      if (io < 0) then\n        backspace (ich)\n        exit\n      end if\n    end do\n    do\n      read (och,'(a)',iostat=io) str\n      if (io < 0) then\n        exit\n      else\n        write (ich,'(a)') trim(str)\n      end if\n    end do\n    close (och)\n    close (ich)\n  end subroutine appendto\n\n!-------------------------------------------------------------------------\n! make a directory via iso_c_binding\n!-------------------------------------------------------------------------\n  function makedir(str)\n    implicit none\n    integer :: makedir\n    character(len=*) :: str\n    makedir = mkdir(str//char(0),int(o'770',c_int16_t)) !create new directory\n    return\n  end function makedir\n\n!-------------------------------------------------------------------------\n! put a environment variable via iso_c_binding\n!-------------------------------------------------------------------------\n  function setenv_string(env,str)\n    implicit none\n    integer :: setenv_string\n    character(len=*) :: env\n    character(len=*) :: str\n    setenv_string = c_setenv(env//c_null_char,str//c_null_char) !create new directory\n    return\n  end function setenv_string\n  function setenv_int(env,intval)\n    implicit none\n    integer :: setenv_int\n    character(len=*) :: env\n    integer :: intval\n    character(len=20) :: str\n    write (str,'(i0)') intval\n    setenv_int = c_setenv(env//c_null_char,trim(str)//c_null_char) !create new directory\n    return\n  end function setenv_int\n  function setenv_float(env,floatval)\n    implicit none\n    integer :: setenv_float\n    character(len=*) :: env\n    real(wp) :: floatval\n    character(len=30) :: str\n    write (str,'(f14.6)') floatval\n    setenv_float = c_setenv(env//c_null_char,trim(str)//c_null_char) !create new directory\n    return\n  end function setenv_float\n\n!-------------------------------------------------------------------------\n! set a symlink from path1 to path2  via iso_c_binding\n!-------------------------------------------------------------------------\n  function sylnk(path1,path2)\n    implicit none\n    integer :: sylnk\n    character(len=*) :: path1\n    character(len=*) :: path2\n    sylnk = c_symlink(trim(path1)//c_null_char,trim(path2)//c_null_char) !create new directory\n    return\n  end function sylnk\n\n!-------------------------------------------------------------------------\n! minigrep: a grep subroutine that returns true or false, depending on\n! if the substring \"str\" is present in the file \"fil\"\n!-------------------------------------------------------------------------\n  subroutine minigrep(fil,str,bool)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    logical :: bool\n    character(len=*) :: fil\n    character(len=*) :: str\n    character(len=512) :: tmp\n    integer :: io\n    bool = .false.\n    open (newunit=ich,file=fil)\n    do\n      read (ich,'(a)',iostat=io) tmp\n      if (io < 0) exit\n      if (index(tmp,str) .ne. 0) then\n        bool = .true.\n        close (ich)\n        exit\n      end if\n    end do\n    close (ich)\n    !minigrep = bool\n    return\n  end subroutine minigrep\n\n!-------------------------------------------------------------------------\n! grepval: a grep subroutine that returns the float that follows immeadeatly\n! after the substring \"str\". Works only for the first occurence of \"str\".\n! If str is not present, \"bool\" returns .false.\n!-------------------------------------------------------------------------\n  subroutine grepval(fil,str,bool,val)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    logical :: bool\n    character(len=*) :: fil\n    character(len=*) :: str\n    character(len=512) :: tmp\n    real(wp) :: val\n    integer :: io\n    bool = .false.\n    val = 0.0d0\n    open (newunit=ich,file=fil)\n    do\n      read (ich,'(a)',iostat=io) tmp\n      if (io < 0) exit\n      io = index(tmp,str,.true.)\n      if (io .ne. 0) then\n        io = io+len(str)\n        tmp = adjustl(tmp(io+1:))\n        read (tmp,*) val\n        bool = .true.\n        close (ich)\n        exit\n      end if\n    end do\n    close (ich)\n    !minigrep = bool\n    return\n  end subroutine grepval\n\n!---------------------------------------------------------------------------\n! grepcntx: a grep subroutine that returns the entire line containing \"str\"\n! or the specified line after the occurence of \"str\", given\n! If str is not present, \"bool\" returns .false.\n!---------------------------------------------------------------------------\n  subroutine grepcntxt(fil,str,bool,line,context)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    logical,intent(out) :: bool\n    logical :: track\n    character(len=*),intent(in) :: fil\n    character(len=*),intent(in) :: str\n    character(len=*),intent(out) :: line\n    integer,intent(in),optional :: context\n    integer :: cntxt\n    character(len=512) :: tmp\n    real(wp) :: val\n    integer :: io,itrack,reftrack\n    bool = .false.\n    track = .false.\n    val = 0.0d0\n    line = ''\n    itrack = 0\n    if (present(context)) then\n      reftrack = max(0,context)\n    else\n      reftrack = 0\n    end if\n    open (newunit=ich,file=fil)\n    do\n      read (ich,'(a)',iostat=io) tmp\n      if (io < 0) exit\n      io = index(tmp,str,.true.)\n      if (io .ne. 0) then\n        bool = .true.\n        track = .true.\n      end if\n      if (track) then\n        if (itrack == reftrack) then\n          line = trim(tmp)\n          exit\n        else\n          itrack = itrack+1\n        end if\n      end if\n    end do\n    close (ich)\n    return\n  end subroutine grepcntxt\n\n!--------------------------------------------------------------------------------------\n! Write a file with a single line (INT)\n!--------------------------------------------------------------------------------------\n  subroutine wrshort_int(fname,var)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    integer :: var\n    open (newunit=ich,file=fname)\n    write (ich,*) var\n    close (ich)\n  end subroutine wrshort_int\n\n!--------------------------------------------------------------------------------------\n! Write a file with a single line (REAL)\n!--------------------------------------------------------------------------------------\n  subroutine wrshort_real(fname,var)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    real(wp) :: var\n    open (newunit=ich,file=fname)\n    write (ich,*) var\n    close (ich)\n  end subroutine wrshort_real\n\n!--------------------------------------------------------------------------------------\n! Write a file with a single line (STRING)\n!--------------------------------------------------------------------------------------\n  subroutine wrshort_string(fname,var)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    character(len=*) :: var\n    open (newunit=ich,file=fname)\n    write (ich,'(a)') var\n    close (ich)\n  end subroutine wrshort_string\n\n!--------------------------------------------------------------------------------------\n! reads the first line of a file (INT)\n!--------------------------------------------------------------------------------------\n  subroutine rdshort_int(fname,var)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    integer :: var\n    integer :: io\n    open (newunit=ich,file=fname)\n    read (ich,*,iostat=io) var\n    if (io .ne. 0) var = 0\n    close (ich)\n  end subroutine rdshort_int\n\n!--------------------------------------------------------------------------------------\n! reads the first line of a file (REAL)\n!--------------------------------------------------------------------------------------\n  subroutine rdshort_real(fname,var)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    real(wp) :: var\n    integer :: io\n    open (newunit=ich,file=fname)\n    read (ich,*,iostat=io) var\n    if (io .ne. 0) var = 0.0d0\n    close (ich)\n  end subroutine rdshort_real\n\n!--------------------------------------------------------------------------------------\n! reads the first line of a file (STRING)\n!--------------------------------------------------------------------------------------\n  subroutine rdshort_string(fname,var)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    character(len=*) :: fname\n    character(len=*) :: var\n    integer :: io\n    open (newunit=ich,file=fname)\n    read (ich,'(a)',iostat=io) var\n    if (io .ne. 0) var = ''\n    close (ich)\n  end subroutine rdshort_string\n\n!----------------------------------------------------------------------------\n! returns entry x of line as string, or as empty if end-of-line is reached\n\n  subroutine glinex(line,x,string)\n    implicit none\n    integer :: ich,och\n    logical :: ex\n    integer,intent(in) :: x\n    character(len=*),intent(in)  :: line\n    character(len=*),intent(out) :: string\n    character(len=80) :: stmp\n    character(len=1)  :: digit\n    integer :: i,k,cs\n    logical :: track\n\n    string = ''\n    stmp = ''\n    cs = 0\n    track = .false.\n    k = len(trim(line))\n    do i = 1,k\n      digit = line(i:i)\n      if (digit .eq. ' '.or.digit .eq. char(9)) then  !should exclude tabstops and blanks, 9 is ascii code for tab\n        if (track) then\n          if (cs == x) then\n            string = trim(stmp)\n            exit\n          end if\n        end if\n        track = .false.\n        stmp = ''\n        cycle\n      else\n        if (.not.track) cs = cs+1\n        track = .true.\n        stmp = trim(stmp)//trim(digit)\n        if (i .eq. k.and.x .lt. 0) then  !if x is lt. 0, the last element of the line is returned\n          string = trim(stmp)\n          exit\n        end if\n      end if\n    end do\n    return\n  end subroutine glinex\n\n!----------------------------------------------------------------------------\n! cut the leading x words (seperated by blanks) of a string, and overwrite it\n\n  subroutine clinex(line,x)\n    implicit none\n    integer,intent(in) :: x\n    character(len=*),intent(inout)  :: line\n    character(len=1)  :: digit\n    integer :: i,j,k,cs\n    logical :: track\n\n    cs = 0\n    track = .false.\n    k = len(trim(line))\n    do i = 1,k\n      digit = line(i:i)\n      if (digit .eq. ' '.or.digit .eq. char(9)) then  !should exclude tabstops and blanks, 9 is ascii code for tab\n        track = .false.\n        cycle\n      else\n        if (.not.track) cs = cs+1\n        if (cs .gt. x) then\n          j = i-1\n          line = line(j:k)\n          exit\n        end if\n        track = .true.\n      end if\n    end do\n    return\n  end subroutine clinex\n\n!-------------------------------------------------------------\n! convert a string to upper or lower case\n!--------------------------------------------------------------\n  subroutine to_upper(str)\n    character(*),intent(in out) :: str\n    integer :: i\n    do i = 1,len(str)\n      select case (str(i:i))\n      case (\"a\":\"z\")\n        str(i:i) = achar(iachar(str(i:i))-32)\n      end select\n    end do\n  end subroutine to_upper\n  function to_upper_func(str) result(out)\n    character(*),intent(in) :: str\n    character(len=:),allocatable :: out\n    out = str\n    call to_upper(out)\n  end function to_upper_func\n  subroutine to_lower(str)\n    character(*),intent(in out) :: str\n    integer :: i\n    do i = 1,len(str)\n      select case (str(i:i))\n      case (\"A\":\"Z\")\n        str(i:i) = achar(iachar(str(i:i))+32)\n      end select\n    end do\n  end subroutine to_lower\n  function to_lower_func(str) result(out)\n    character(*),intent(in) :: str\n    character(len=:),allocatable :: out\n    out = str\n    call to_lower(out)\n  end function to_lower_func\n\n!-----------------------------------------------------------------\n! a simple routine to lock a feature of the code behind a password\n!-----------------------------------------------------------------\n  subroutine pwdlock(pwdref)\n    implicit none\n    character(len=*) :: pwdref    ! check for this password\n    character(len=:),allocatable :: pwd\n    pwd = pwdref !allocate max length of pwd\n    write (stdout,'(/,1x,a)',advance='no') 'Locked feature. Enter password: '\n    read (*,*) pwd\n    if (pwd == pwdref) then\n      write (stdout,'(1x,a,/)') 'Valid. Continue.'\n    else\n      error stop 'Invalid. Stop.'\n    end if\n    return\n  end subroutine pwdlock\n\n!-----------------------------------------------------------------------------------\n! copy a coord file until an $set-block is encountered\n!-----------------------------------------------------------------------------------\n  subroutine clear_setblock(fname)\n    implicit none\n    character(len=*) :: fname\n    character(len=512) :: atmp\n    integer :: iost\n    integer :: ich,ich2\n\n    open (newunit=ich,file=fname)\n    open (newunit=ich2,file='.setdgtmp')\n\n    do\n      read (ich,'(a)',iostat=iost) atmp\n      if (iost < 0) exit\n      if ((index(atmp,'$set') .ne. 0).or.  &\n      &  (index(atmp,'$end') .ne. 0)) then\n        write (ich2,'(a)') '$end'\n        exit\n      else\n        write (ich2,'(a)') trim(atmp)\n      end if\n    end do\n    close (ich,status='delete')\n    close (ich2)\n    call rename('.setdgtmp',fname)\n  end subroutine clear_setblock\n\n!====================================================================!\n  function filechecker(fin,fout) result(have)\n    implicit none\n    logical :: have\n    character(len=*),intent(in) :: fin\n    character(len=*),intent(out) :: fout\n    have = .false.\n    inquire (file=fin,exist=have)\n    if (have) then\n      fout = fin\n    else\n      fout = ''\n    end if\n    return\n  end function filechecker\n\n!=========================================================================================!\n!=========================================================================================!\n!=========================================================================================!\n\n!> Checking directories with Fortran's inquire is not handled by the standard.\n!> The interpretation whether or not to report a directory as file is compiler\n!> specific and therefore always an extension to the Fortran standard.\n  function directory_exist(file) result(exist)\n    character(len=*),intent(in) :: file\n    logical :: exist\n#ifdef __INTEL_COMPILER\n    !> Intel provides the directory extension to inquire to handle this case\n    inquire (directory=file,exist=exist)\n#else\n    !> GCC handles directories as files, to make sure we get a directory and\n    !> not a file append a path separator and the current dir\n    inquire (file=trim(file)//\"/.\",exist=exist)\n#endif\n  end function directory_exist\n\n!=========================================================================================!\n!=========================================================================================!\n!=========================================================================================!\n!> type conversion routines\n!> 8 bit integers\n  subroutine i8_to_string(i_in,str_out)\n    implicit none\n    integer(kind=int8) :: i_in\n    character(len=:),allocatable :: str_out\n    character(len=4) :: stmp\n    write (stmp,*) i_in\n    str_out = trim(adjustl(stmp))\n  end subroutine i8_to_string\n\n!> 16 bit integers\n  subroutine i16_to_string(i_in,str_out)\n    implicit none\n    integer(kind=int16) :: i_in\n    character(len=:),allocatable :: str_out\n    character(len=6) :: stmp\n    write (stmp,*) i_in\n    str_out = trim(adjustl(stmp))\n  end subroutine i16_to_string\n\n!> 32 bit integer\n  subroutine i32_to_string(i_in,str_out)\n    implicit none\n    integer(kind=int32) :: i_in\n    character(len=:),allocatable :: str_out\n    character(len=12) :: stmp\n    write (stmp,*) i_in\n    str_out = trim(adjustl(stmp))\n  end subroutine i32_to_string\n\n!> 64 bit integer\n  subroutine i64_to_string(i_in,str_out)\n    implicit none\n    integer(kind=int64) :: i_in\n    character(len=:),allocatable :: str_out\n    character(len=60) :: stmp\n    write (stmp,*) i_in\n    str_out = trim(adjustl(stmp))\n  end subroutine i64_to_string\n\n!> 32 bit float\n  subroutine r32_to_string(r_in,str_out)\n    implicit none\n    real(kind=real32) :: r_in\n    character(len=:),allocatable :: str_out\n    character(len=80) :: stmp\n    write (stmp,*) r_in\n    str_out = trim(adjustl(stmp))\n  end subroutine r32_to_string\n\n!> 64 bit float\n  subroutine r64_to_string(r_in,str_out)\n    implicit none\n    real(kind=wp) :: r_in\n    character(len=:),allocatable :: str_out\n    character(len=80) :: stmp\n    write (stmp,*) r_in\n    str_out = trim(adjustl(stmp))\n  end subroutine r64_to_string\n\n!> boolean\n  subroutine bool_to_string(bool,str_out)\n    implicit none\n    logical :: bool\n    character(len=:),allocatable :: str_out\n    if (bool) then\n      str_out = 'true'\n    else\n      str_out = 'false'\n    end if\n  end subroutine bool_to_string\n\n!> function variants\n  function to_str_i8(i8) result(str_out)\n    implicit none\n    integer(kind=int8) :: i8\n    character(len=:),allocatable :: str_out\n    call convert_to_string(i8,str_out)\n  end function to_str_i8\n  function to_str_i16(i16) result(str_out)\n    implicit none\n    integer(kind=int16) :: i16\n    character(len=:),allocatable :: str_out\n    call convert_to_string(i16,str_out)\n  end function to_str_i16\n  function to_str_i32(i32) result(str_out)\n    implicit none\n    integer(kind=int32) :: i32\n    character(len=:),allocatable :: str_out\n    call convert_to_string(i32,str_out)\n  end function to_str_i32\n  function to_str_i64(i64) result(str_out)\n    implicit none\n    integer(kind=int64) :: i64\n    character(len=:),allocatable :: str_out\n    call convert_to_string(i64,str_out)\n  end function to_str_i64\n  function to_str_r32(r32) result(str_out)\n    implicit none\n    real(kind=real32) :: r32\n    character(len=:),allocatable :: str_out\n    call convert_to_string(r32,str_out)\n  end function to_str_r32\n  function to_str_r64(r64) result(str_out)\n    implicit none\n    real(kind=wp) :: r64\n    character(len=:),allocatable :: str_out\n    call convert_to_string(r64,str_out)\n    str_out = truncate_zeros(str_out)\n  end function to_str_r64\n  function to_str_bool(bool) result(str_out)\n    implicit none\n    logical :: bool\n    character(len=:),allocatable :: str_out\n    call convert_to_string(bool,str_out)\n  end function to_str_bool\n\n!> truncate zeros of a float string\n  function truncate_zeros(str_in) result(str_out)\n    character(len=:),allocatable :: str_in\n    character(len=:),allocatable :: str_out\n    integer :: i,j,k,l\n    str_out = ''\n    if (allocated(str_in)) then\n      if (index(lowercase(str_in),'e') .ne. 0) then\n        str_out = trim(adjustl(str_in))\n        return\n      end if\n      l = len_trim(str_in)\n      k = l\n      do i = l,1,-1\n        k = i\n        if (str_in(i:i) .ne. '0') then\n          exit\n        end if\n      end do\n      if (str_in(k:k) .eq. '.') k = k+1\n      str_out = str_in(1:k)\n      str_out = trim(adjustl(str_out))\n    end if\n  end function truncate_zeros\n\n!========================================================================================!\n!========================================================================================!\n!========================================================================================!\n\n  subroutine getpath(fname,path)\n    implicit none\n    character(len=*) :: fname\n    character(len=*) :: path\n    character(len=:),allocatable :: checkcall\n    character(len=:),allocatable :: pipe\n    integer :: rcode,ich,io\n\n    pipe = ' >/dev/null 2>/dev/null'\n\n    checkcall = 'command -v '//trim(fname)//pipe\n    call command(checkcall,rcode)\n\n    if (rcode .eq. 0) then\n      checkcall = 'command -v '//trim(fname)//' > pathout.tmp 2>/dev/null'\n      call command(checkcall,io)\n      open (newunit=ich,file='pathout.tmp')\n      read (ich,'(a)') path\n      close (ich,status='delete')\n    end if\n    return\n  end subroutine getpath\n!=========================================================================================!\n  subroutine checkprog(fname,r)\n    implicit none\n    character(len=*) :: fname\n    character(len=:),allocatable :: checkcall\n    character(len=:),allocatable :: pipe\n    integer :: rcode,r\n    character(len=512) :: path\n\n    pipe = ' >/dev/null 2>/dev/null'\n\n    checkcall = 'command -v '//trim(fname)//pipe\n    call command(checkcall,rcode)\n\n    write (stdout,'(4x,a,a,a)') 'binary: \"',trim(fname),'\"'\n    if (rcode .ne. 0) then\n      write (stdout,'(4x,a)') 'status: not found'\n      r = r+1\n    else\n      write (stdout,'(4x,a)') 'status: present'\n      call getpath(fname,path)\n      write (stdout,'(4x,a,a)') 'path  : ',trim(path)\n    end if\n\n    return\n  end subroutine checkprog\n!=========================================================================================!\n! the same as above but only provide a printout (at all) if the program is not present!\n  subroutine checkprog_silent(fname,verbose,iostat)\n    implicit none\n    character(len=*) :: fname\n    logical,intent(in),optional :: verbose\n    integer,intent(out),optional :: iostat\n    character(len=:),allocatable :: checkcall\n    character(len=:),allocatable :: pipe\n    integer :: io\n\n    pipe = ' >/dev/null 2>/dev/null'\n    checkcall = 'command -v '//trim(fname)//pipe\n    call command(trim(checkcall), exitstat=io)\n\n    if(present(verbose))then\n    if (io .ne. 0 .and. verbose) then\n      write (stdout,'(4x,a,a,a)') 'binary: \"',trim(fname),'\"'\n      write (stdout,'(4x,a)') 'status: not found'\n    end if\n    endif\n\n    if(present(iostat))then\n       iostat = io\n    endif\n\n    return\n  end subroutine checkprog_silent\n\n!========================================================================================!\n!========================================================================================!\n!========================================================================================!\n\n!> For some reason the behaviour of \"call system\"  and \"call execute_command_line\"\n!> differs slightly beteen Intel and GNU versions of the program that I have build.\n!> I don't understand why this is the case.\n!> To circumvent issues for now, I will simpy include two different wrappers with\n!> precompiler statements.\n!> It doesn't matter too much as these are mostly relevant for legacy routines.\n  subroutine command(cmd,exitstat)\n    implicit none\n    character(len=*),intent(in) :: cmd\n    integer,intent(out),optional :: exitstat\n    integer :: io\n#ifdef __INTEL_COMPILER\n    call execute_command_line(trim(cmd),exitstat=io)\n#else\n    call system(trim(cmd),io)\n#endif\n    if (present(exitstat)) exitstat = io\n  end subroutine command\n\n!========================================================================================!\n!========================================================================================!\n!========================================================================================!\nend module iomod\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/iomod.F90 b/src/iomod.F90
--- a/src/iomod.F90	
+++ b/src/iomod.F90	
@@ -20,7 +20,7 @@
 !> This is a collection of various IO subroutines
 
 module iomod
-  use iso_fortran_env,wp => real64,stdout=>output_unit
+  use iso_fortran_env,wp => real64,stdout => output_unit
   use iso_c_binding
   implicit none
   public
@@ -476,6 +476,28 @@
     return
   end subroutine grepcntxt
 
+!=====================================================================================!
+  function getlines(fname,maxwidth) result(n)
+    character(len=*) :: fname
+    logical :: ex
+    integer,intent(out),optional :: maxwidth
+    integer :: n,io,w,ich
+    character(len=1056) :: atmp
+    n = 0
+    w = 0
+    inquire (file=fname,exist=ex)
+    if (.not.ex) return
+    open (newunit=ich,file=fname)
+    do
+      read (ich,'(a)',iostat=io) atmp
+      if (io /= 0) exit
+      n = n+1
+      if (len_trim(atmp) > w) w = len_trim(atmp)
+    end do
+    if (present(maxwidth)) maxwidth = w
+    close (ich)
+  end function getlines
+
 !--------------------------------------------------------------------------------------
 ! Write a file with a single line (INT)
 !--------------------------------------------------------------------------------------
@@ -697,35 +719,6 @@
     return
   end subroutine pwdlock
 
-!-----------------------------------------------------------------------------------
-! copy a coord file until an $set-block is encountered
-!-----------------------------------------------------------------------------------
-  subroutine clear_setblock(fname)
-    implicit none
-    character(len=*) :: fname
-    character(len=512) :: atmp
-    integer :: iost
-    integer :: ich,ich2
-
-    open (newunit=ich,file=fname)
-    open (newunit=ich2,file='.setdgtmp')
-
-    do
-      read (ich,'(a)',iostat=iost) atmp
-      if (iost < 0) exit
-      if ((index(atmp,'$set') .ne. 0).or.  &
-      &  (index(atmp,'$end') .ne. 0)) then
-        write (ich2,'(a)') '$end'
-        exit
-      else
-        write (ich2,'(a)') trim(atmp)
-      end if
-    end do
-    close (ich,status='delete')
-    close (ich2)
-    call rename('.setdgtmp',fname)
-  end subroutine clear_setblock
-
 !====================================================================!
   function filechecker(fin,fout) result(have)
     implicit none
@@ -973,18 +966,18 @@
 
     pipe = ' >/dev/null 2>/dev/null'
     checkcall = 'command -v '//trim(fname)//pipe
-    call command(trim(checkcall), exitstat=io)
+    call command(trim(checkcall),exitstat=io)
 
-    if(present(verbose))then
-    if (io .ne. 0 .and. verbose) then
-      write (stdout,'(4x,a,a,a)') 'binary: "',trim(fname),'"'
-      write (stdout,'(4x,a)') 'status: not found'
-    end if
-    endif
+    if (present(verbose)) then
+      if (io .ne. 0.and.verbose) then
+        write (stdout,'(4x,a,a,a)') 'binary: "',trim(fname),'"'
+        write (stdout,'(4x,a)') 'status: not found!'
+      end if
+    end if
 
-    if(present(iostat))then
-       iostat = io
-    endif
+    if (present(iostat)) then
+      iostat = io
+    end if
 
     return
   end subroutine checkprog_silent
@@ -996,7 +989,7 @@
 !> For some reason the behaviour of "call system"  and "call execute_command_line"
 !> differs slightly beteen Intel and GNU versions of the program that I have build.
 !> I don't understand why this is the case.
-!> To circumvent issues for now, I will simpy include two different wrappers with
+!> To circumvent issues for now, I will simply include two different wrappers with
 !> precompiler statements.
 !> It doesn't matter too much as these are mostly relevant for legacy routines.
   subroutine command(cmd,exitstat)
Index: src/algos/parallel.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2022 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!> a collection of routines to set up parallel runs of\n!> MDs and optimizations.\n\n!========================================================================================!\n\nsubroutine crest_oloop(env,nat,nall,at,xyz,eread,dump)\n  use crest_parameters,only:wp,stdout,sep\n  use crest_calculator\n  use omp_lib\n  use crest_data\n  use strucrd\n  use optimize_module\n  use iomod,only:makedir,directory_exist,remove\n  implicit none\n  type(systemdata),intent(inout) :: env\n  real(wp),intent(inout) :: xyz(3,nat,nall)\n  integer,intent(in)  :: at(nat)\n  real(wp),intent(inout) :: eread(nall)\n  integer,intent(in) :: nat,nall\n  logical,intent(in) :: dump\n\n  type(coord),allocatable :: mols(:)\n  type(coord),allocatable :: molsnew(:)\n  integer :: i,j,k,l,io,ich,ich2,c,z,job_id\n  logical :: pr,wr,ex\n  type(calcdata),allocatable :: calculations(:)\n  type(calcdata) :: calc\n  integer :: T  !> number of parallel running instances\n  real(wp) :: energy,gnorm\n  real(wp),allocatable :: grad(:,:)\n  integer :: thread_id,vz,job\n  character(len=80) :: atmp\n  real(wp) :: percent\n  character(len=52) :: bar\n\n  !>--- check if we have any calculation settings allocated\n  calc = env%calc\n  if (calc%ncalculations < 1) then\n    write (stdout,*) 'no calculations allocated'\n    return\n  end if\n\n  !>--- prepare objects for parallelization\n  T = env%threads\n  allocate (calculations(T),source=env%calc)\n  allocate (mols(T),molsnew(T))\n  do i = 1,T\n    do j = 1,calc%ncalculations\n      calculations(i)%calcs(j) = env%calc%calcs(j)\n      !>--- directories\n      ex = directory_exist(env%calc%calcs(j)%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(env%calc%calcs(j)%calcspace))\n      end if\n      write (atmp,'(a,\"_\",i0)') sep,i\n      calculations(i)%calcs(j)%calcspace = env%calc%calcs(j)%calcspace//trim(atmp)\n    end do\n    calculations(i)%pr_energies = .false.\n    allocate (mols(i)%at(nat),mols(i)%xyz(3,nat))\n    allocate (molsnew(i)%at(nat),molsnew(i)%xyz(3,nat))\n  end do\n\n  !>--- printout directions\n  pr = .false. !> stdout printout\n  wr = .false. !> write crestopt.log\n  if (dump) then\n    open (newunit=ich,file=ensemblefile)\n    open (newunit=ich2,file=ensembleelog)\n  end if\n  if (env%niceprint) then\n    percent = 0.0_wp\n    call progbar(percent,bar)\n    call printprogbar(percent,bar)\n  end if\n  !>--- shared variables\n  allocate (grad(3,nat),source=0.0_wp)\n\n  c = 0\n  k = 0\n  z = 0\n  eread(:) = 0.0_wp\n  !>--- loop over ensemble\n  !$omp parallel &\n  !$omp shared(env,calculations,nat,nall,at,xyz,c,k,z,pr,wr,dump,percent,bar,ich,ich2,mols,molsnew)\n  !$omp single\n  do i = 1,nall\n\n    call initsignal()\n    vz = i\n    !$omp task firstprivate( vz ) private(j,job,calc,energy,grad,io,atmp,gnorm,thread_id)\n    call initsignal()\n\n    thread_id = OMP_GET_THREAD_NUM()\n    job = thread_id+1\n    !>--- modify calculation spaces\n    !$omp critical\n    z = z+1\n    mols(job)%nat = nat\n    mols(job)%at(:) = at(:)\n    mols(job)%xyz(:,:) = xyz(:,:,z)\n\n    molsnew(job)%nat = nat\n    molsnew(job)%at(:) = at(:)\n    molsnew(job)%xyz(:,:) = xyz(:,:,z)\n    !$omp end critical\n\n    !>--- first energy&gradient calculation\n    call engrad(mols(job),calculations(job),energy,grad,io)\n\n    !>-- geopetry optimization\n    call optimize_geometry(mols(job),molsnew(job),calculations(job),energy,grad,pr,wr,io)\n\n    !$omp critical\n    if (io == 0) then\n      !>--- successful optimization (io==0)\n      c = c+1\n      if (dump) then\n        gnorm = norm2(grad)\n        write (atmp,'(1x,\"Etot=\",f16.10,1x,\"g norm=\",f12.8)') energy,gnorm\n        molsnew(job)%comment = trim(atmp)\n        call molsnew(job)%append(ich)\n        call calc_eprint(calculations(job),energy,calculations(job)%etmp,ich2)\n      end if\n    end if\n    k = k+1\n    if (env%niceprint) then\n      percent = float(k)/float(nall)*100.0_wp\n      call progbar(percent,bar)\n      call printprogbar(percent,bar)\n    else\n      write (stdout,'(1x,i0)',advance='no') k\n      flush (stdout)\n    end if\n\n    !$omp end critical\n    !$omp end task\n  end do\n  !$omp taskwait\n  !$omp end single\n  !$omp end parallel\n\n  if (.not.env%niceprint) then\n    write (stdout,'(/,1x,a)') 'done.'\n  else\n    write (stdout,*)\n  end if\n\n  write (stdout,'(1x,i0,a,i0,a)') c,' of ',nall,' structures successfully optimized.'\n\n  if (dump) then\n    close (ich)\n    close (ich2)\n  end if\n\n  deallocate (grad)\n  deallocate (calculations)\n  if (allocated(mols)) deallocate (mols)\n  if (allocated(molsnew)) deallocate (molsnew)\n  return\nend subroutine crest_oloop\n\n!========================================================================================!\n!========================================================================================!\n\nsubroutine crest_search_multimd(env,mol,mddats,nsim)\n!*****************************************************\n!* this runs nsim MDs on the same structure (mol)\n!*****************************************************\n  use crest_parameters,only:wp,stdout,sep\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use dynamics_module\n  use iomod,only:makedir,directory_exist,remove\n  use omp_lib\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(mddata) :: mddats(nsim)\n  integer :: nsim\n  type(coord) :: mol\n  type(coord),allocatable :: moltmps(:)\n  integer :: i,j,io,ich\n  logical :: pr,ex\n  type(calcdata) :: calc\n  type(mddata) :: mddat\n  integer :: T\n  real(wp) :: percent\n  character(len=52) :: bar\n  character(len=80) :: atmp\n  character(len=*),parameter :: mdir = 'MDFILES'\n\n  type(calcdata),allocatable :: calculations(:)\n  integer :: vz,job,thread_id\n  real(wp) :: etmp\n  real(wp),allocatable :: grdtmp(:,:)\n!===========================================================!\n\n!>--- set threads\n  if (env%autothreads) then\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,nsim)\n  end if\n\n  !>--- check if we have any MD & calculation settings allocated\n  mddat = env%mddat\n  calc = env%calc\n  if (.not.mddat%requested) then\n    write (stdout,*) 'MD requested, but no MD settings present.'\n    return\n  else if (calc%ncalculations < 1) then\n    write (stdout,*) 'MD requested, but no calculation settings present.'\n    return\n  end if\n\n!>--- prepare calculation containers for parallelization (one per thread)\n  T = env%threads\n  allocate (calculations(T),source=env%calc)\n  allocate (moltmps(T),source=mol)\n  allocate (grdtmp(3,mol%nat),source=0.0_wp)\n  do i = 1,T\n    moltmps(i)%nat = mol%nat\n    moltmps(i)%at = mol%at\n    moltmps(i)%xyz = mol%xyz\n    do j = 1,calc%ncalculations\n      calculations(i)%calcs(j) = env%calc%calcs(j)\n      !>--- directories\n      ex = directory_exist(env%calc%calcs(j)%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(env%calc%calcs(j)%calcspace))\n      end if\n      write (atmp,'(a,\"_\",i0)') sep,i\n      calculations(i)%calcs(j)%calcspace = env%calc%calcs(j)%calcspace//trim(atmp)\n    end do\n    calculations(i)%pr_energies = .false.\n    !>--- initialize the calculations\n    call engrad(moltmps(i),calculations(i),etmp,grdtmp,io)\n  end do\n\n  !>--- other settings\n  pr = .false.\n\n  !>--- run the MDs\n  !$omp parallel &\n  !$omp shared(env,calculations,mddats,mol,pr,percent,bar,ich, moltmps)\n  !$omp single\n  do i = 1,nsim\n\n    call initsignal()\n    vz = i\n    !$omp task firstprivate( vz ) private( job,thread_id,io,ex )\n    call initsignal()\n\n    thread_id = OMP_GET_THREAD_NUM()\n    job = thread_id+1\n    !$omp critical\n    moltmps(job)%nat = mol%nat\n    moltmps(job)%at = mol%at\n    moltmps(job)%xyz = mol%xyz\n\n    if (mddats(vz)%simtype == type_md) then\n      write (stdout,'(a,i4,a)') 'Starting MD',vz,' with the settings:'\n    else if (mddats(vz)%simtype == type_mtd) then\n      if (mddats(vz)%cvtype(1) == cv_rmsd_static)then\n       write (stdout,'(a)',advance='no') 'Starting static MTD'\n      else\n        write (stdout,'(a)',advance='no') 'Starting MTD'\n      endif\n      write (stdout,'(i4,a)') vz,' with the settings:'\n    end if\n    write (stdout,'(''     MD time /ps        :'',f8.1)') mddats(vz)%length_ps\n    write (stdout,'(''     dt /fs             :'',f8.1)') mddats(vz)%tstep\n    write (stdout,'(''     dumpstep(trj) /fs  :'',f8.1)') mddats(vz)%dumpstep\n    if (mddats(vz)%simtype == type_mtd) then\n      if (mddats(vz)%cvtype(1) == cv_rmsd) then\n        write (stdout,'(''     dumpstep(Vbias) /ps:'',f8.2)') &\n        & mddats(vz)%mtd(1)%cvdump_fs/1000.0_wp\n      endif\n      write (stdout,'(''     Vbias factor k /Eh :'',f8.4)') &\n      &  mddats(vz)%mtd(1)%kpush\n      write (stdout,'(''     Vbias exp α /bohr⁻²:'',f8.4)') &\n      &  mddats(vz)%mtd(1)%alpha\n    end if\n    !$omp end critical\n\n    !>--- the acutal MD call\n    call dynamics(moltmps(job),mddats(vz),calculations(job),pr,io)\n\n    !$omp critical\n    if (mddats(vz)%simtype == type_mtd) then\n      write (stdout,'(a)',advance='no') '*MTD '\n    else\n      write (stdout,'(a)',advance='no') '*MD '\n    endif\n    if (io == 0) then\n      write (stdout,'(i0,a)') vz,' completed successfully'\n    else\n      write (stdout,'(i0,a)') vz,' terminated with early'\n    end if\n    !$omp end critical\n    !$omp end task\n  end do\n  !$omp taskwait\n  !$omp end single\n  !$omp end parallel\n\n  !>--- collect trajectories into one\n  call collect(nsim,mddats)\n\n  deallocate (calculations)\n  if (allocated(moltmps)) deallocate (moltmps)\n  return\ncontains\n  subroutine collect(n,mddats)\n    implicit none\n    integer :: n\n    type(mddata) :: mddats(n)\n    logical :: ex\n    integer :: i,io,ich,ich2\n    character(len=:),allocatable :: atmp\n    character(len=256) :: btmp\n    open (newunit=ich,file='crest_dynamics.trj')\n    do i = 1,n\n      atmp = mddats(i)%trajectoryfile\n      inquire (file=atmp,exist=ex)\n      if (ex) then\n        open (newunit=ich2,file=atmp)\n        io = 0\n        do while (io == 0)\n          read (ich2,'(a)',iostat=io) btmp\n          if (io == 0) then\n            write (ich,'(a)') trim(btmp)\n          end if\n        end do\n        close (ich2)\n      end if\n    end do\n    close (ich)\n    return\n  end subroutine collect\nend subroutine crest_search_multimd\n!========================================================================================!\nsubroutine crest_search_multimd_init(env,mol,mddat,nsim)\n  use crest_parameters,only:wp,stdout\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use dynamics_module\n  use iomod,only:makedir,directory_exist,remove\n  use omp_lib\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(mddata) :: mddat\n  type(coord) :: mol\n  integer,intent(inout) :: nsim\n  integer :: i,io\n  logical :: pr\n!========================================================================================!\n  type(calcdata) :: calc\n  type(shakedata) :: shk\n\n  real(wp) :: energy\n  real(wp),allocatable :: grad(:,:)\n  character(len=*),parameter :: mdir = 'MDFILES'\n\n!========================================================================================!\n\n  !>--- check if we have any MD & calculation settings allocated\n  mddat = env%mddat\n  calc = env%calc\n  if (.not.mddat%requested) then\n    write (stdout,*) 'MD requested, but no MD settings present.'\n    return\n  else if (calc%ncalculations < 1) then\n    write (stdout,*) 'MD requested, but no calculation settings present.'\n    return\n  end if\n\n  !>--- init SHAKE?\n  if (mddat%shake) then\n    calc%calcs(1)%rdwbo = .true.\n    allocate (grad(3,mol%nat),source=0.0_wp)\n    call engrad(mol,calc,energy,grad,io)\n    deallocate (grad)\n    calc%calcs(1)%rdwbo = .false.\n\n    shk%shake_mode = env%mddat%shk%shake_mode\n    call move_alloc(calc%calcs(1)%wbo,shk%wbo)\n\n    mddat%shk = shk\n    call init_shake(mol%nat,mol%at,mol%xyz,mddat%shk,pr)\n    mddat%nshake = mddat%shk%ncons\n  end if\n  !>--- complete real-time settings to steps\n  call mdautoset(mddat,io)\n\n  !>--- (optional)  MTD initialization\n  if (nsim < 0) then\n    mddat%simtype = type_mtd  !>-- set runtype to MTD\n\n    call defaultGF(env)\n    write (stdout,*) 'list of applied metadynamics Vbias parameters:'\n    do i = 1,env%nmetadyn\n      write (stdout,'(''$metadyn '',f10.5,f8.3,i5)') env%metadfac(i)/env%rednat,env%metadexp(i)\n    end do\n    write (stdout,*)\n\n    !>--- how many simulations\n    nsim = env%nmetadyn\n  end if\n\n  return\nend subroutine crest_search_multimd_init\nsubroutine crest_search_multimd_init2(env,mddats,nsim)\n  use crest_parameters,only:wp,stdout,sep\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use dynamics_module\n  use iomod,only:makedir,directory_exist,remove\n  use omp_lib\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(mddata) :: mddats(nsim)\n  integer :: nsim\n  integer :: i,io\n  logical :: ex\n!========================================================================================!\n  type(mtdpot),allocatable :: mtds(:)\n\n  character(len=80) :: atmp\n  character(len=*),parameter :: mdir = 'MDFILES'\n\n  !>--- parallel MD setup\n  ex = directory_exist(mdir)\n  if (ex) then\n    call rmrf(mdir)\n  end if\n  io = makedir(mdir)\n  do i = 1,nsim\n    mddats(i)%md_index = i\n    write (atmp,'(a,i0,a)') 'crest_',i,'.trj'\n    mddats(i)%trajectoryfile = mdir//sep//trim(atmp)\n    write (atmp,'(a,i0,a)') 'crest_',i,'.mdrestart'\n    mddats(i)%restartfile = mdir//sep//trim(atmp)\n  end do\n\n  allocate (mtds(nsim))\n  do i = 1,nsim\n    if (mddats(i)%simtype == type_mtd) then\n      mtds(i)%kpush = env%metadfac(i)/env%rednat\n      mtds(i)%alpha = env%metadexp(i)\n      mtds(i)%cvdump_fs = float(env%mddump)\n      mtds(i)%mtdtype = cv_rmsd\n\n      mddats(i)%npot = 1\n      allocate (mddats(i)%mtd(1),source=mtds(i))\n      allocate (mddats(i)%cvtype(1),source=cv_rmsd)\n    end if\n  end do\n  if (allocated(mtds)) deallocate (mtds)\n\n  return\nend subroutine crest_search_multimd_init2\n!========================================================================================!\nsubroutine crest_search_multimd2(env,mols,mddats,nsim)\n!*******************************************************************\n!* this runs nsim MDs on nsim selected different structures (mols)\n!*******************************************************************\n  use crest_parameters,only:wp,stdout,sep\n  use crest_data\n  use crest_calculator\n  use strucrd\n  use dynamics_module\n  use shake_module\n  use iomod,only:makedir,directory_exist,remove\n  use omp_lib\n  implicit none\n  type(systemdata),intent(inout) :: env\n  type(mddata) :: mddats(nsim)\n  integer :: nsim\n  type(coord) :: mols(nsim)\n  type(coord),allocatable :: moltmps(:)\n  integer :: i,j,io,ich\n  logical :: pr,ex\n  type(calcdata) :: calc\n  type(mddata) :: mddat\n  integer :: T\n  real(wp) :: percent\n  character(len=52) :: bar\n  character(len=80) :: atmp\n  character(len=*),parameter :: mdir = 'MDFILES'\n\n  type(calcdata),allocatable :: calculations(:)\n  integer :: vz,job,thread_id\n!===========================================================!\n  !>--- set threads\n  if (env%autothreads) then\n    call ompautoset(env%threads,7,env%omp,env%MAXRUN,nsim)\n  end if\n\n  !>--- check if we have any MD & calculation settings allocated\n  mddat = env%mddat\n  calc = env%calc\n  if (.not.mddat%requested) then\n    write (stdout,*) 'MD requested, but no MD settings present.'\n    return\n  else if (calc%ncalculations < 1) then\n    write (stdout,*) 'MD requested, but no calculation settings present.'\n    return\n  end if\n\n  !>--- prepare calculation objects for parallelization (one per thread)\n  T = env%threads\n  allocate (calculations(T),source=env%calc)\n  allocate (moltmps(T),source=mols(1))\n  do i = 1,T\n    do j = 1,calc%ncalculations\n      calculations(i)%calcs(j) = env%calc%calcs(j)\n      !>--- directories\n      ex = directory_exist(env%calc%calcs(j)%calcspace)\n      if (.not.ex) then\n        io = makedir(trim(env%calc%calcs(j)%calcspace))\n      end if\n      write (atmp,'(a,\"_\",i0)') sep,i\n      calculations(i)%calcs(j)%calcspace = env%calc%calcs(j)%calcspace//trim(atmp)\n    end do\n    calculations(i)%pr_energies = .false.\n  end do\n\n  !>--- other settings\n  pr = .false.\n\n  !>--- run the MDs\n  !$omp parallel &\n  !$omp shared(env,calculations,mddats,mols,pr,percent,bar,ich, moltmps)\n  !$omp single\n  do i = 1,nsim\n\n    call initsignal()\n    vz = i\n    !$omp task firstprivate( vz ) private( job,thread_id,io,ex )\n    call initsignal()\n\n    thread_id = OMP_GET_THREAD_NUM()\n    job = thread_id+1\n    !$omp critical\n    moltmps(job)%nat = mols(vz)%nat\n    moltmps(job)%at = mols(vz)%at\n    moltmps(job)%xyz = mols(vz)%xyz\n\n    if (mddats(vz)%simtype == type_md) then\n      write (stdout,'(a,i4,a)') 'Starting MD',vz,' with the settings:'\n    else if (mddats(vz)%simtype == type_mtd) then\n      if (mddats(vz)%cvtype(1) == cv_rmsd_static)then\n       write (stdout,'(a)',advance='no') 'Starting static MTD'\n      else\n        write (stdout,'(a)',advance='no') 'Starting MTD'\n      endif\n      write (stdout,'(i4,a)') vz,' with the settings:'\n    end if\n    write (stdout,'(''     MD time /ps        :'',f8.1)') mddats(vz)%length_ps\n    write (stdout,'(''     target T /K        :'',f8.1)') mddats(vz)%tsoll\n    write (stdout,'(''     dt /fs             :'',f8.1)') mddats(vz)%tstep\n    write (stdout,'(''     dumpstep(trj) /fs  :'',f8.1)') mddats(vz)%dumpstep\n    if (mddats(vz)%simtype == type_mtd) then\n      if (mddats(vz)%cvtype(1) == cv_rmsd) then\n        write (stdout,'(''     dumpstep(Vbias) /ps:'',f8.2)') &\n        & mddats(vz)%mtd(1)%cvdump_fs/1000.0_wp\n      endif\n      write (stdout,'(''     Vbias factor k /Eh :'',f8.4)') &\n      &  mddats(vz)%mtd(1)%kpush\n      write (stdout,'(''     Vbias exp α /bohr⁻²:'',f8.4)') &\n      &  mddats(vz)%mtd(1)%alpha\n    end if\n    !$omp end critical\n\n    !>--- the acutal MD call\n    call dynamics(moltmps(job),mddats(vz),calculations(job),pr,io)\n\n    !$omp critical\n    if (mddats(vz)%simtype == type_mtd) then\n      write (stdout,'(a)',advance='no') '*MTD '\n    else\n      write (stdout,'(a)',advance='no') '*MD '\n    endif\n    if (io == 0) then\n      write (stdout,'(i0,a)') vz,' completed successfully'\n    else\n      write (stdout,'(i0,a)') vz,' terminated with early'\n    end if\n    !deallocate(moltmp%at,moltmp%xyz)\n    !$omp end critical\n    !$omp end task\n  end do\n  !$omp taskwait\n  !$omp end single\n  !$omp end parallel\n\n  !>--- collect trajectories into one\n  call collect(nsim,mddats)\n\n  deallocate (calculations)\n  if (allocated(moltmps)) deallocate (moltmps)\n  return\ncontains\n  subroutine collect(n,mddats)\n    implicit none\n    integer :: n\n    type(mddata) :: mddats(n)\n    logical :: ex\n    integer :: i,io,ich,ich2\n    character(len=:),allocatable :: atmp\n    character(len=256) :: btmp\n    open (newunit=ich,file='crest_dynamics.trj')\n    do i = 1,n\n      atmp = mddats(i)%trajectoryfile\n      inquire (file=atmp,exist=ex)\n      if (ex) then\n        open (newunit=ich2,file=atmp)\n        io = 0\n        do while (io == 0)\n          read (ich2,'(a)',iostat=io) btmp\n          if (io == 0) then\n            write (ich,'(a)') trim(btmp)\n          end if\n        end do\n        close (ich2)\n      end if\n    end do\n    close (ich)\n    return\n  end subroutine collect\nend subroutine crest_search_multimd2\n!========================================================================================!\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/algos/parallel.f90 b/src/algos/parallel.f90
--- a/src/algos/parallel.f90	
+++ b/src/algos/parallel.f90	
@@ -1,7 +1,7 @@
 !================================================================================!
 ! This file is part of crest.
 !
-! Copyright (C) 2022 Philipp Pracht
+! Copyright (C) 2022-2023  Philipp Pracht
 !
 ! crest is free software: you can redistribute it and/or modify it under
 ! the terms of the GNU Lesser General Public License as published by
@@ -17,19 +17,176 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-!> a collection of routines to set up parallel runs of
-!> MDs and optimizations.
+!> A collection of routines to set up OMP-parallel runs of MDs and optimizations.
+
+!========================================================================================!
+!========================================================================================!
+!> Routines for concurrent singlepoint evaluations
+!========================================================================================!
+!========================================================================================!
+subroutine crest_sploop(env,nat,nall,at,xyz,eread)
+!***************************************************************
+!* subroutine crest_sploop
+!* This subroutine performs concurrent singlpoint evaluations
+!* for the given ensemble. Input eread is overwritten
+!***************************************************************
+  use crest_parameters,only:wp,stdout,sep
+  use crest_calculator
+  use omp_lib
+  use crest_data
+  use strucrd
+  use optimize_module
+  use iomod,only:makedir,directory_exist,remove
+  implicit none
+  type(systemdata),intent(inout) :: env
+  real(wp),intent(inout) :: xyz(3,nat,nall)
+  integer,intent(in)  :: at(nat)
+  real(wp),intent(inout) :: eread(nall)
+  integer,intent(in) :: nat,nall
+
+  type(coord),allocatable :: mols(:)
+  integer :: i,j,k,l,io,ich,ich2,c,z,job_id,zcopy
+  logical :: pr,wr,ex
+  type(calcdata),allocatable :: calculations(:)
+  integer :: T  !> number of parallel running instances
+  real(wp) :: energy,gnorm
+  real(wp),allocatable :: grad(:,:),grads(:,:,:)
+  integer :: thread_id,vz,job
+  character(len=80) :: atmp
+  real(wp) :: percent,runtime
+
+  type(timer) :: profiler
+
+!>--- check if we have any calculation settings allocated
+  if (env%calc%ncalculations < 1) then
+    write (stdout,*) 'no calculations allocated'
+    return
+  end if
+
+!>--- prepare objects for parallelization
+  T = env%threads
+  allocate (calculations(T),source=env%calc)
+  allocate (mols(T))
+  do i = 1,T
+    do j = 1,env%calc%ncalculations
+      calculations(i)%calcs(j) = env%calc%calcs(j)
+      !>--- directories
+      ex = directory_exist(env%calc%calcs(j)%calcspace)
+      if (.not.ex) then
+        io = makedir(trim(env%calc%calcs(j)%calcspace))
+      end if
+      write (atmp,'(a,"_",i0)') sep,i
+      calculations(i)%calcs(j)%calcspace = env%calc%calcs(j)%calcspace//trim(atmp)
+      call calculations(i)%calcs(j)%printid(i,j)
+    end do
+    calculations(i)%pr_energies = .false.
+    allocate (mols(i)%at(nat),mols(i)%xyz(3,nat))
+  end do
+
+!>--- printout directions and timer initialization
+  pr = .false. !> stdout printout
+  wr = .false. !> write crestopt.log
+  call profiler%init(1)
+  call profiler%start(1)
+
+!>--- first progress printout (initializes progress variables)
+  call crest_oloop_pr_progress(env,nall,0)
+
+!>--- shared variables
+  allocate (grads(3,nat,T), source=0.0_wp)
+  c = 0  !> counter of successfull optimizations
+  k = 0  !> counter of total optimization (fail+success)
+  z = 0  !> counter to perform optimization in right order (1...nall)
+  eread(:) = 0.0_wp
+  grads(:,:,:) = 0.0_wp
+!>--- loop over ensemble
+  !$omp parallel &
+  !$omp shared(env,calculations,nat,nall,at,xyz,eread,grads,c,k,z,pr,wr) &
+  !$omp shared(ich,ich2,mols)
+  !$omp single
+  do i = 1,nall
+
+    call initsignal()
+    vz = i
+    !$omp task firstprivate( vz ) private(i,j,job,energy,io,thread_id,zcopy)
+    call initsignal()
+
+    thread_id = OMP_GET_THREAD_NUM()
+    job = thread_id+1
+    !>--- modify calculation spaces
+    !$omp critical
+    z = z+1
+    zcopy = z
+    mols(job)%nat = nat
+    mols(job)%at(:) = at(:)
+    mols(job)%xyz(:,:) = xyz(:,:,z)
+    !$omp end critical
+
+    !>-- engery+gradient call
+    call engrad(mols(job),calculations(job),energy,grads(:,:,job),io)
+
+    !$omp critical
+    if (io == 0) then
+      !>--- successful optimization (io==0)
+      c = c+1
+      eread(zcopy) = energy
+    else
+      eread(zcopy) = 0.0_wp
+    end if
+    k = k+1
+    !>--- print progress
+    call crest_oloop_pr_progress(env,nall,k)
+    !$omp end critical
+    !$omp end task
+  end do
+  !$omp taskwait
+  !$omp end single
+  !$omp end parallel
+
+!>--- finalize progress printout
+  call crest_oloop_pr_progress(env,nall,-1)
+
+!>--- stop timer
+  call profiler%stop(1)
+
+!>--- prepare some summary printout
+  percent = float(c)/float(nall)*100.0_wp
+  write(atmp,'(f5.1,a)') percent,'% success)'
+  write (stdout,'(">",1x,i0,a,i0,a,a)') c,' of ',nall,' structures successfully evaluated (', &
+  &     trim(adjustl(atmp))
+  write (atmp,'(">",1x,a,i0,a)') 'Total runtime for ',nall,' singlepoint calculations:'
+  call profiler%write_timing(stdout,1,trim(atmp),.true.)
+  runtime = profiler%get(1)
+  write(atmp,'(f16.3,a)') runtime/real(nall,wp),' sec'
+  write(stdout,'(a,a,a)') '> Corresponding to approximately ',trim(adjustl(atmp)), &
+  &                       ' per processed structure' 
+
+  deallocate (grads)
+  call profiler%clear()
+  deallocate (calculations)
+  if (allocated(mols)) deallocate (mols)
+  return
+end subroutine crest_sploop
 
 !========================================================================================!
-
+!========================================================================================!
+!> Routines for concurrent geometry optimization
+!========================================================================================!
+!========================================================================================!
 subroutine crest_oloop(env,nat,nall,at,xyz,eread,dump)
-  use crest_parameters,only:wp,stdout,sep
+!***************************************************************
+!* subroutine crest_oloop
+!* This subroutine performs concurrent geometry optimizations
+!* for the given ensemble. Inputs xyz and eread are overwritten
+!***************************************************************
+  use crest_parameters,only:wp,stdout,sep 
   use crest_calculator
   use omp_lib
   use crest_data
   use strucrd
   use optimize_module
   use iomod,only:makedir,directory_exist,remove
+  use crest_restartlog, only: trackrestart,restart_write_dummy
   implicit none
   type(systemdata),intent(inout) :: env
   real(wp),intent(inout) :: xyz(3,nat,nall)
@@ -40,31 +197,36 @@
 
   type(coord),allocatable :: mols(:)
   type(coord),allocatable :: molsnew(:)
-  integer :: i,j,k,l,io,ich,ich2,c,z,job_id
+  integer :: i,j,k,l,io,ich,ich2,c,z,job_id,zcopy
   logical :: pr,wr,ex
   type(calcdata),allocatable :: calculations(:)
-  type(calcdata) :: calc
   integer :: T  !> number of parallel running instances
   real(wp) :: energy,gnorm
-  real(wp),allocatable :: grad(:,:)
+  real(wp),allocatable :: grads(:,:,:)
   integer :: thread_id,vz,job
   character(len=80) :: atmp
-  real(wp) :: percent
-  character(len=52) :: bar
+  real(wp) :: percent,runtime
+
+  type(timer) :: profiler
+
+!>--- decide wether to skip this call
+   if(trackrestart(env))then 
+     call restart_write_dummy(ensemblefile)
+     return 
+   endif
 
-  !>--- check if we have any calculation settings allocated
-  calc = env%calc
-  if (calc%ncalculations < 1) then
+!>--- check if we have any calculation settings allocated
+  if (env%calc%ncalculations < 1) then
     write (stdout,*) 'no calculations allocated'
     return
   end if
 
-  !>--- prepare objects for parallelization
+!>--- prepare objects for parallelization
   T = env%threads
   allocate (calculations(T),source=env%calc)
   allocate (mols(T),molsnew(T))
   do i = 1,T
-    do j = 1,calc%ncalculations
+    do j = 1,env%calc%ncalculations
       calculations(i)%calcs(j) = env%calc%calcs(j)
       !>--- directories
       ex = directory_exist(env%calc%calcs(j)%calcspace)
@@ -73,40 +235,43 @@
       end if
       write (atmp,'(a,"_",i0)') sep,i
       calculations(i)%calcs(j)%calcspace = env%calc%calcs(j)%calcspace//trim(atmp)
+      call calculations(i)%calcs(j)%printid(i,j)
     end do
     calculations(i)%pr_energies = .false.
     allocate (mols(i)%at(nat),mols(i)%xyz(3,nat))
     allocate (molsnew(i)%at(nat),molsnew(i)%xyz(3,nat))
   end do
 
-  !>--- printout directions
+!>--- printout directions and timer initialization
   pr = .false. !> stdout printout
   wr = .false. !> write crestopt.log
   if (dump) then
     open (newunit=ich,file=ensemblefile)
     open (newunit=ich2,file=ensembleelog)
   end if
-  if (env%niceprint) then
-    percent = 0.0_wp
-    call progbar(percent,bar)
-    call printprogbar(percent,bar)
-  end if
-  !>--- shared variables
-  allocate (grad(3,nat),source=0.0_wp)
-
-  c = 0
-  k = 0
-  z = 0
+  call profiler%init(1)
+  call profiler%start(1)
+
+!>--- first progress printout (initializes progress variables)
+  call crest_oloop_pr_progress(env,nall,0)
+
+!>--- shared variables
+  allocate (grads(3,nat,T),source=0.0_wp)
+  c = 0  !> counter of successfull optimizations
+  k = 0  !> counter of total optimization (fail+success)
+  z = 0  !> counter to perform optimization in right order (1...nall)
   eread(:) = 0.0_wp
-  !>--- loop over ensemble
+  grads(:,:,:) = 0.0_wp
+!>--- loop over ensemble
   !$omp parallel &
-  !$omp shared(env,calculations,nat,nall,at,xyz,c,k,z,pr,wr,dump,percent,bar,ich,ich2,mols,molsnew)
+  !$omp shared(env,calculations,nat,nall,at,xyz,eread,grads,c,k,z,pr,wr,dump) &
+  !$omp shared(ich,ich2,mols,molsnew)
   !$omp single
   do i = 1,nall
 
     call initsignal()
     vz = i
-    !$omp task firstprivate( vz ) private(j,job,calc,energy,grad,io,atmp,gnorm,thread_id)
+    !$omp task firstprivate( vz ) private(j,job,energy,io,atmp,gnorm,thread_id,zcopy)
     call initsignal()
 
     thread_id = OMP_GET_THREAD_NUM()
@@ -114,6 +279,7 @@
     !>--- modify calculation spaces
     !$omp critical
     z = z+1
+    zcopy = z
     mols(job)%nat = nat
     mols(job)%at(:) = at(:)
     mols(job)%xyz(:,:) = xyz(:,:,z)
@@ -123,34 +289,28 @@
     molsnew(job)%xyz(:,:) = xyz(:,:,z)
     !$omp end critical
 
-    !>--- first energy&gradient calculation
-    call engrad(mols(job),calculations(job),energy,grad,io)
-
-    !>-- geopetry optimization
-    call optimize_geometry(mols(job),molsnew(job),calculations(job),energy,grad,pr,wr,io)
-
+    !>-- geometry optimization
+    call optimize_geometry(mols(job),molsnew(job),calculations(job),energy,grads(:,:,job),pr,wr,io)
+   
     !$omp critical
     if (io == 0) then
       !>--- successful optimization (io==0)
       c = c+1
       if (dump) then
-        gnorm = norm2(grad)
+        gnorm = norm2(grads(:,:,job))
         write (atmp,'(1x,"Etot=",f16.10,1x,"g norm=",f12.8)') energy,gnorm
         molsnew(job)%comment = trim(atmp)
         call molsnew(job)%append(ich)
         call calc_eprint(calculations(job),energy,calculations(job)%etmp,ich2)
       end if
+      eread(zcopy) = energy
+      xyz(:,:,zcopy) = molsnew(job)%xyz(:,:)
+    else
+      eread(zcopy) = 0.0_wp
     end if
     k = k+1
-    if (env%niceprint) then
-      percent = float(k)/float(nall)*100.0_wp
-      call progbar(percent,bar)
-      call printprogbar(percent,bar)
-    else
-      write (stdout,'(1x,i0)',advance='no') k
-      flush (stdout)
-    end if
-
+    !>--- print progress
+    call crest_oloop_pr_progress(env,nall,k)
     !$omp end critical
     !$omp end task
   end do
@@ -158,32 +318,110 @@
   !$omp end single
   !$omp end parallel
 
-  if (.not.env%niceprint) then
-    write (stdout,'(/,1x,a)') 'done.'
-  else
-    write (stdout,*)
-  end if
+!>--- finalize progress printout
+  call crest_oloop_pr_progress(env,nall,-1)
 
-  write (stdout,'(1x,i0,a,i0,a)') c,' of ',nall,' structures successfully optimized.'
+!>--- stop timer
+  call profiler%stop(1)
 
+!>--- prepare some summary printout
+  percent = float(c)/float(nall)*100.0_wp
+  write(atmp,'(f5.1,a)') percent,'% success)'
+  write (stdout,'(">",1x,i0,a,i0,a,a)') c,' of ',nall,' structures successfully optimized (', &
+  &     trim(adjustl(atmp))
+  write (atmp,'(">",1x,a,i0,a)') 'Total runtime for ',nall,' optimizations:'
+  call profiler%write_timing(stdout,1,trim(atmp),.true.)
+  runtime = profiler%get(1)
+  write(atmp,'(f16.3,a)') runtime/real(nall,wp),' sec'
+  write(stdout,'(a,a,a)') '> Corresponding to approximately ',trim(adjustl(atmp)), &
+  &                       ' per processed structure' 
+
+!>--- close files (if they are open)
   if (dump) then
     close (ich)
     close (ich2)
   end if
 
-  deallocate (grad)
+  deallocate (grads)
+  call profiler%clear()
   deallocate (calculations)
   if (allocated(mols)) deallocate (mols)
   if (allocated(molsnew)) deallocate (molsnew)
   return
 end subroutine crest_oloop
 
+!========================================================================================!
+subroutine crest_oloop_pr_progress(env,total,current)
+!*********************************************
+!* subroutine crest_oloop_pr_progress
+!* A subroutine to print and track progress of
+!* concurrent geometry optimizations
+!*********************************************
+  use crest_parameters, only:wp,stdout
+  use crest_data
+  use iomod, only: to_str
+  implicit none
+  type(systemdata),intent(inout) :: env
+  integer,intent(in) :: total,current
+  real(wp) :: percent
+  character(len=52) :: bar
+  character(len=5) :: atmp
+  real(wp),save :: increment
+  real(wp),save :: progressbarrier
+
+  percent = float(current)/float(total)*100.0_wp
+  if (current == 0) then !> as a wrapper to start the printout
+    progressbarrier = 0.0_wp
+    if (env%niceprint) then
+      percent = 0.0_wp
+      call progbar(percent,bar)
+      call printprogbar(percent,bar)
+    end if
+    increment = 10.0_wp
+    if(total > 1000) increment = 7.5_wp
+    if(total > 5000) increment = 5.0_wp
+    if(total >10000) increment = 2.5_wp
+    if(total >20000) increment = 1.0_wp
+
+
+  else if (current <= total .and. current > 0) then !> the regular printout case
+    if (env%niceprint) then
+      call progbar(percent,bar)
+      call printprogbar(percent,bar)
+
+    else if (.not.env%legacy) then
+      if(percent >= progressbarrier)then
+       write(atmp,'(f5.1)') percent
+       write (stdout,'(1x,a)',advance='no') '|>'//trim(adjustl(atmp))//'%'
+       progressbarrier = progressbarrier + increment
+       progressbarrier = min(progressbarrier, 100.0_wp)
+       flush(stdout)
+      endif
+    else
+      write (stdout,'(1x,i0)',advance='no') current
+      flush (stdout)
+    end if
+
+  else !> as a wrapper to finalize the printout
+    if (.not.env%niceprint) then
+      write (stdout,'(/,1x,a)') 'done.'
+    else
+      write (stdout,*)
+    end if
+  end if
+
+end subroutine crest_oloop_pr_progress
+
+!========================================================================================!
+!========================================================================================!
+!> Routines for parallel MDs
 !========================================================================================!
 !========================================================================================!
 
 subroutine crest_search_multimd(env,mol,mddats,nsim)
 !*****************************************************
-!* this runs nsim MDs on the same structure (mol)
+!* subroutine crest_search_multimd
+!* this runs #nsim MDs on the same structure (mol)
 !*****************************************************
   use crest_parameters,only:wp,stdout,sep
   use crest_data
@@ -192,6 +430,7 @@
   use dynamics_module
   use iomod,only:makedir,directory_exist,remove
   use omp_lib
+  use crest_restartlog, only: trackrestart,restart_write_dummy
   implicit none
   type(systemdata),intent(inout) :: env
   type(mddata) :: mddats(nsim)
@@ -200,8 +439,6 @@
   type(coord),allocatable :: moltmps(:)
   integer :: i,j,io,ich
   logical :: pr,ex
-  type(calcdata) :: calc
-  type(mddata) :: mddat
   integer :: T
   real(wp) :: percent
   character(len=52) :: bar
@@ -212,7 +449,13 @@
   integer :: vz,job,thread_id
   real(wp) :: etmp
   real(wp),allocatable :: grdtmp(:,:)
+  type(timer) :: profiler
 !===========================================================!
+!>--- decide wether to skip this call
+   if(trackrestart(env))then
+     call restart_write_dummy('crest_dynamics.trj')
+     return
+   endif
 
 !>--- set threads
   if (env%autothreads) then
@@ -220,12 +463,10 @@
   end if
 
   !>--- check if we have any MD & calculation settings allocated
-  mddat = env%mddat
-  calc = env%calc
-  if (.not.mddat%requested) then
+  if (.not.env%mddat%requested) then
     write (stdout,*) 'MD requested, but no MD settings present.'
     return
-  else if (calc%ncalculations < 1) then
+  else if (env%calc%ncalculations < 1) then
     write (stdout,*) 'MD requested, but no calculation settings present.'
     return
   end if
@@ -239,7 +480,7 @@
     moltmps(i)%nat = mol%nat
     moltmps(i)%at = mol%at
     moltmps(i)%xyz = mol%xyz
-    do j = 1,calc%ncalculations
+    do j = 1,env%calc%ncalculations
       calculations(i)%calcs(j) = env%calc%calcs(j)
       !>--- directories
       ex = directory_exist(env%calc%calcs(j)%calcspace)
@@ -248,6 +489,7 @@
       end if
       write (atmp,'(a,"_",i0)') sep,i
       calculations(i)%calcs(j)%calcspace = env%calc%calcs(j)%calcspace//trim(atmp)
+      call calculations(i)%calcs(j)%printid(i,j)
     end do
     calculations(i)%pr_energies = .false.
     !>--- initialize the calculations
@@ -256,6 +498,7 @@
 
   !>--- other settings
   pr = .false.
+  call profiler%init(nsim)
 
   !>--- run the MDs
   !$omp parallel &
@@ -274,47 +517,17 @@
     moltmps(job)%nat = mol%nat
     moltmps(job)%at = mol%at
     moltmps(job)%xyz = mol%xyz
-
-    if (mddats(vz)%simtype == type_md) then
-      write (stdout,'(a,i4,a)') 'Starting MD',vz,' with the settings:'
-    else if (mddats(vz)%simtype == type_mtd) then
-      if (mddats(vz)%cvtype(1) == cv_rmsd_static)then
-       write (stdout,'(a)',advance='no') 'Starting static MTD'
-      else
-        write (stdout,'(a)',advance='no') 'Starting MTD'
-      endif
-      write (stdout,'(i4,a)') vz,' with the settings:'
-    end if
-    write (stdout,'(''     MD time /ps        :'',f8.1)') mddats(vz)%length_ps
-    write (stdout,'(''     dt /fs             :'',f8.1)') mddats(vz)%tstep
-    write (stdout,'(''     dumpstep(trj) /fs  :'',f8.1)') mddats(vz)%dumpstep
-    if (mddats(vz)%simtype == type_mtd) then
-      if (mddats(vz)%cvtype(1) == cv_rmsd) then
-        write (stdout,'(''     dumpstep(Vbias) /ps:'',f8.2)') &
-        & mddats(vz)%mtd(1)%cvdump_fs/1000.0_wp
-      endif
-      write (stdout,'(''     Vbias factor k /Eh :'',f8.4)') &
-      &  mddats(vz)%mtd(1)%kpush
-      write (stdout,'(''     Vbias exp α /bohr⁻²:'',f8.4)') &
-      &  mddats(vz)%mtd(1)%alpha
-    end if
     !$omp end critical
+    !>--- startup printout (thread safe)
+    call parallel_md_block_printout(mddats(vz),vz)
 
-    !>--- the acutal MD call
+    !>--- the acutal MD call with timing
+    call profiler%start(vz)
     call dynamics(moltmps(job),mddats(vz),calculations(job),pr,io)
+    call profiler%stop(vz)
 
-    !$omp critical
-    if (mddats(vz)%simtype == type_mtd) then
-      write (stdout,'(a)',advance='no') '*MTD '
-    else
-      write (stdout,'(a)',advance='no') '*MD '
-    endif
-    if (io == 0) then
-      write (stdout,'(i0,a)') vz,' completed successfully'
-    else
-      write (stdout,'(i0,a)') vz,' terminated with early'
-    end if
-    !$omp end critical
+    !>--- finish printout (thread safe)
+    call parallel_md_finish_printout(mddats(vz),vz,io,profiler)
     !$omp end task
   end do
   !$omp taskwait
@@ -324,6 +537,7 @@
   !>--- collect trajectories into one
   call collect(nsim,mddats)
 
+  call profiler%clear()
   deallocate (calculations)
   if (allocated(moltmps)) deallocate (moltmps)
   return
@@ -356,8 +570,16 @@
     return
   end subroutine collect
 end subroutine crest_search_multimd
+
 !========================================================================================!
 subroutine crest_search_multimd_init(env,mol,mddat,nsim)
+!*******************************************************
+!* subroutine crest_search_multimd_init
+!* This routine will initialize a copy of env%mddat
+!* and save it to the local mddat. If we are about to
+!* run RMSD metadynamics, the required number of
+!* simulations (#nsim) is returned
+!*******************************************************
   use crest_parameters,only:wp,stdout
   use crest_data
   use crest_calculator
@@ -372,38 +594,42 @@
   integer,intent(inout) :: nsim
   integer :: i,io
   logical :: pr
-!========================================================================================!
+!=======================================================!
   type(calcdata) :: calc
   type(shakedata) :: shk
 
   real(wp) :: energy
   real(wp),allocatable :: grad(:,:)
   character(len=*),parameter :: mdir = 'MDFILES'
-
-!========================================================================================!
+!======================================================!
 
   !>--- check if we have any MD & calculation settings allocated
   mddat = env%mddat
-  calc = env%calc
   if (.not.mddat%requested) then
     write (stdout,*) 'MD requested, but no MD settings present.'
     return
-  else if (calc%ncalculations < 1) then
+  else if (env%calc%ncalculations < 1) then
     write (stdout,*) 'MD requested, but no calculation settings present.'
     return
   end if
 
   !>--- init SHAKE?
   if (mddat%shake) then
-    calc%calcs(1)%rdwbo = .true.
-    allocate (grad(3,mol%nat),source=0.0_wp)
-    call engrad(mol,calc,energy,grad,io)
-    deallocate (grad)
-    calc%calcs(1)%rdwbo = .false.
+    if (allocated(env%ref%wbo)) then
+      shk%wbo = env%ref%wbo
+    else
+      calc = env%calc
+      calc%calcs(1)%rdwbo = .true.
+      allocate (grad(3,mol%nat),source=0.0_wp)
+      call engrad(mol,calc,energy,grad,io)
+      deallocate (grad)
+      calc%calcs(1)%rdwbo = .false.
 
-    shk%shake_mode = env%mddat%shk%shake_mode
-    call move_alloc(calc%calcs(1)%wbo,shk%wbo)
+      shk%shake_mode = env%mddat%shk%shake_mode
+      call move_alloc(calc%calcs(1)%wbo,shk%wbo)
+    end if
 
+    shk%shake_mode = env%shake
     mddat%shk = shk
     call init_shake(mol%nat,mol%at,mol%xyz,mddat%shk,pr)
     mddat%nshake = mddat%shk%ncons
@@ -428,6 +654,8 @@
 
   return
 end subroutine crest_search_multimd_init
+
+!========================================================================================!
 subroutine crest_search_multimd_init2(env,mddats,nsim)
   use crest_parameters,only:wp,stdout,sep
   use crest_data
@@ -442,7 +670,7 @@
   integer :: nsim
   integer :: i,io
   logical :: ex
-!========================================================================================!
+!========================================================!
   type(mtdpot),allocatable :: mtds(:)
 
   character(len=80) :: atmp
@@ -479,10 +707,12 @@
 
   return
 end subroutine crest_search_multimd_init2
+
 !========================================================================================!
 subroutine crest_search_multimd2(env,mols,mddats,nsim)
 !*******************************************************************
-!* this runs nsim MDs on nsim selected different structures (mols)
+!* subroutine crest_search_multimd2
+!* this runs #nsim MDs on #nsim selected different structures (mols)
 !*******************************************************************
   use crest_parameters,only:wp,stdout,sep
   use crest_data
@@ -492,7 +722,9 @@
   use shake_module
   use iomod,only:makedir,directory_exist,remove
   use omp_lib
+  use crest_restartlog, only: trackrestart,restart_write_dummy
   implicit none
+  !> INPUT
   type(systemdata),intent(inout) :: env
   type(mddata) :: mddats(nsim)
   integer :: nsim
@@ -500,8 +732,6 @@
   type(coord),allocatable :: moltmps(:)
   integer :: i,j,io,ich
   logical :: pr,ex
-  type(calcdata) :: calc
-  type(mddata) :: mddat
   integer :: T
   real(wp) :: percent
   character(len=52) :: bar
@@ -510,29 +740,34 @@
 
   type(calcdata),allocatable :: calculations(:)
   integer :: vz,job,thread_id
+  type(timer) :: profiler
 !===========================================================!
-  !>--- set threads
+!>--- decide wether to skip this call
+   if(trackrestart(env))then
+     call restart_write_dummy('crest_dynamics.trj')
+     return
+   endif
+
+!>--- set threads
   if (env%autothreads) then
     call ompautoset(env%threads,7,env%omp,env%MAXRUN,nsim)
   end if
 
-  !>--- check if we have any MD & calculation settings allocated
-  mddat = env%mddat
-  calc = env%calc
-  if (.not.mddat%requested) then
+!>--- check if we have any MD & calculation settings allocated
+  if (.not.env%mddat%requested) then
     write (stdout,*) 'MD requested, but no MD settings present.'
     return
-  else if (calc%ncalculations < 1) then
+  else if (env%calc%ncalculations < 1) then
     write (stdout,*) 'MD requested, but no calculation settings present.'
     return
   end if
 
-  !>--- prepare calculation objects for parallelization (one per thread)
+!>--- prepare calculation objects for parallelization (one per thread)
   T = env%threads
   allocate (calculations(T),source=env%calc)
   allocate (moltmps(T),source=mols(1))
   do i = 1,T
-    do j = 1,calc%ncalculations
+    do j = 1,env%calc%ncalculations
       calculations(i)%calcs(j) = env%calc%calcs(j)
       !>--- directories
       ex = directory_exist(env%calc%calcs(j)%calcspace)
@@ -541,16 +776,18 @@
       end if
       write (atmp,'(a,"_",i0)') sep,i
       calculations(i)%calcs(j)%calcspace = env%calc%calcs(j)%calcspace//trim(atmp)
+      call calculations(i)%calcs(j)%printid(i,j)
     end do
     calculations(i)%pr_energies = .false.
   end do
 
-  !>--- other settings
+!>--- other settings
   pr = .false.
+  call profiler%init(nsim)
 
-  !>--- run the MDs
+!>--- run the MDs
   !$omp parallel &
-  !$omp shared(env,calculations,mddats,mols,pr,percent,bar,ich, moltmps)
+  !$omp shared(env,calculations,mddats,mols,pr,percent,bar,ich, moltmps,profiler)
   !$omp single
   do i = 1,nsim
 
@@ -565,58 +802,27 @@
     moltmps(job)%nat = mols(vz)%nat
     moltmps(job)%at = mols(vz)%at
     moltmps(job)%xyz = mols(vz)%xyz
-
-    if (mddats(vz)%simtype == type_md) then
-      write (stdout,'(a,i4,a)') 'Starting MD',vz,' with the settings:'
-    else if (mddats(vz)%simtype == type_mtd) then
-      if (mddats(vz)%cvtype(1) == cv_rmsd_static)then
-       write (stdout,'(a)',advance='no') 'Starting static MTD'
-      else
-        write (stdout,'(a)',advance='no') 'Starting MTD'
-      endif
-      write (stdout,'(i4,a)') vz,' with the settings:'
-    end if
-    write (stdout,'(''     MD time /ps        :'',f8.1)') mddats(vz)%length_ps
-    write (stdout,'(''     target T /K        :'',f8.1)') mddats(vz)%tsoll
-    write (stdout,'(''     dt /fs             :'',f8.1)') mddats(vz)%tstep
-    write (stdout,'(''     dumpstep(trj) /fs  :'',f8.1)') mddats(vz)%dumpstep
-    if (mddats(vz)%simtype == type_mtd) then
-      if (mddats(vz)%cvtype(1) == cv_rmsd) then
-        write (stdout,'(''     dumpstep(Vbias) /ps:'',f8.2)') &
-        & mddats(vz)%mtd(1)%cvdump_fs/1000.0_wp
-      endif
-      write (stdout,'(''     Vbias factor k /Eh :'',f8.4)') &
-      &  mddats(vz)%mtd(1)%kpush
-      write (stdout,'(''     Vbias exp α /bohr⁻²:'',f8.4)') &
-      &  mddats(vz)%mtd(1)%alpha
-    end if
     !$omp end critical
+    !>--- startup printout (thread safe)
+    call parallel_md_block_printout(mddats(vz),vz)
 
-    !>--- the acutal MD call
+    !>--- the acutal MD call with timing
+    call profiler%start(vz)
     call dynamics(moltmps(job),mddats(vz),calculations(job),pr,io)
+    call profiler%stop(vz)
 
-    !$omp critical
-    if (mddats(vz)%simtype == type_mtd) then
-      write (stdout,'(a)',advance='no') '*MTD '
-    else
-      write (stdout,'(a)',advance='no') '*MD '
-    endif
-    if (io == 0) then
-      write (stdout,'(i0,a)') vz,' completed successfully'
-    else
-      write (stdout,'(i0,a)') vz,' terminated with early'
-    end if
-    !deallocate(moltmp%at,moltmp%xyz)
-    !$omp end critical
+    !>--- finish printout (thread safe)
+    call parallel_md_finish_printout(mddats(vz),vz,io,profiler)
     !$omp end task
   end do
   !$omp taskwait
   !$omp end single
   !$omp end parallel
 
-  !>--- collect trajectories into one
+!>--- collect trajectories into one
   call collect(nsim,mddats)
 
+  call profiler%clear()
   deallocate (calculations)
   if (allocated(moltmps)) deallocate (moltmps)
   return
@@ -649,4 +855,114 @@
     return
   end subroutine collect
 end subroutine crest_search_multimd2
+
+!========================================================================================!
+subroutine parallel_md_block_printout(MD,vz)
+!***********************************************
+!* subroutine parallel_md_block_printout
+!* This will print information about the MD/MTD
+!* simulation. The execution is omp threadsave
+!***********************************************
+  use crest_parameters,only:wp,stdout,sep
+  use crest_data
+  use crest_calculator
+  use strucrd
+  use dynamics_module
+  use shake_module
+  use iomod,only:to_str
+  implicit none
+  type(mddata),intent(in) :: MD
+  integer,intent(in) :: vz
+  character(len=40) :: atmp
+  integer :: il
+  !$omp critical
+
+  if (MD%simtype == type_md) then
+    write (atmp,'(a,1x,i3)') 'starting MD',vz
+  else if (MD%simtype == type_mtd) then
+    if (MD%cvtype(1) == cv_rmsd_static) then
+      write (atmp,'(a,1x,i3)') 'starting static MTD',vz
+    else
+      write (atmp,'(a,1x,i4)') 'starting MTD',vz
+    end if
+  end if
+  il = (44-len_trim(atmp))/2
+  write (stdout,'(2x,a,1x,a,1x,a)') repeat(':',il),trim(atmp),repeat(':',il)
+
+  write (stdout,'(2x,"|   MD simulation time   :",f8.1," ps       |")') MD%length_ps
+  write (stdout,'(2x,"|   target T             :",f8.1," K        |")') MD%tsoll
+  write (stdout,'(2x,"|   timestep dt          :",f8.1," fs       |")') MD%tstep
+  write (stdout,'(2x,"|   dump interval(trj)   :",f8.1," fs       |")') MD%dumpstep
+  if (MD%shake.and.MD%shk%shake_mode > 0) then
+    if (MD%shk%shake_mode == 2) then
+      write (stdout,'(2x,"|   SHAKE algorithm      :",a5," (all bonds) |")') to_str(MD%shake)
+    else
+      write (stdout,'(2x,"|   SHAKE algorithm      :",a5," (H only) |")') to_str(MD%shake)
+    end if
+  end if
+  if(allocated(MD%active_potentials))then
+      write (stdout,'(2x,"|   active potentials    :",i4," porential |")') size(MD%active_potentials,1)
+  endif
+  if (MD%simtype == type_mtd) then
+    if (MD%cvtype(1) == cv_rmsd) then
+      write (stdout,'(2x,"|   dump interval(Vbias) :",f8.2," ps       |")') &
+          & MD%mtd(1)%cvdump_fs/1000.0_wp
+    end if
+    write (stdout,'(2x,"|   Vbias prefactor (k)  :",f8.4," Eh       |")') &
+      &  MD%mtd(1)%kpush
+    if (MD%cvtype(1) == cv_rmsd.or.MD%cvtype(1) == cv_rmsd_static) then
+      write (stdout,'(2x,"|   Vbias exponent (α)   :",f8.4," bohr⁻²   |")') MD%mtd(1)%alpha
+    else
+      write (stdout,'(2x,"|   Vbias exponent (α)   :",f8.4,"          |")') MD%mtd(1)%alpha
+    end if
+  end if
+
+  !$omp end critical
+
+end subroutine parallel_md_block_printout
+
+subroutine parallel_md_finish_printout(MD,vz,io,profiler)
+!*******************************************
+!* subroutine parallel_md_finish_printout
+!* This will print information termination
+!* info about the MD/MTD simulation
+!*******************************************
+  use crest_parameters,only:wp,stdout,sep
+  use crest_data
+  use crest_calculator
+  use strucrd
+  use dynamics_module
+  use shake_module
+  implicit none
+  type(mddata),intent(in) :: MD
+  integer,intent(in) :: vz,io
+  type(timer),intent(inout) :: profiler
+  character(len=40) :: atmp
+  character(len=80) :: btmp
+
+  !$omp critical
+
+  !write(stdout,'(a)') repeat('-',45)
+  if (MD%simtype == type_mtd) then
+    if (MD%cvtype(1) == cv_rmsd_static) then
+      write (atmp,'(a)') '*sMTD'
+    else
+      write (atmp,'(a)') '*MTD'
+    end if
+  else
+    write (atmp,'(a)') '*MD'
+  end if
+  if (io == 0) then
+    write (btmp,'(a,1x,i3,a)') trim(atmp),vz,' completed successfully'
+  else
+    write (btmp,'(a,1x,i3,a)') trim(atmp),vz,' terminated with early'
+  end if
+  !write (stdout,'("* ",i0,a)') MD%dumped,' structures written to trajectory file'
+  !write(btmp,'(a,1x,i0,a)') trim(atmp),vz,' runtime'
+  call profiler%write_timing(stdout,vz,trim(btmp))
+
+  !$omp end critical
+
+end subroutine parallel_md_finish_printout
+!========================================================================================!
 !========================================================================================!
Index: src/select.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=================================================================!\n! subroutine mrec\n! molcount: number of total fragments (increased during search)\n! xyz: overall Cart. coordinates\n! nat: overall number of atoms\n! at: atomic number array\n! molvec: assignment vector of atom to fragment\n!=================================================================!\nsubroutine mrec(molcount,xyz,nat,at,molvec)\n      implicit none\n      real*8 xyz(3,nat),cn(nat),bond(nat,nat)\n      integer nat,molvec(nat),i,molcount,at(nat)\n      logical taken(nat)\n      molvec=0\n      molcount=1\n      taken=.false.\n      cn=0.0d0\n      bond=0.0d0\n      call xcoord(nat,at,xyz,cn,bond)\n      do i=1,nat\n       if(.not.taken(i)) then\n         molvec(i)=molcount\n         taken(i)=.true.\n         call neighbours(i,xyz,at,taken,nat,cn,bond,molvec,molcount)\n         molcount=molcount+1\n      endif\n      enddo\n      molcount=molcount-1\nend subroutine mrec\n\n!=================================================================!\n! subroutine mreclm\n! a variant of the mrec routine with less allocate statements\n! should be faster than the old version if several thousand\n! calls are done.\n!=================================================================!\nsubroutine mreclm(molcount,nat,at,xyz,molvec,bond,rcov,cn)\n      use iso_fortran_env, only: wp => real64\n      implicit none\n      integer :: molcount,nat\n      integer :: at(nat),molvec(nat)\n      real(wp) :: xyz(3,nat)\n      real(wp) :: cn(nat),bond(nat,nat)\n      real(wp) :: bref(nat,nat)\n      real(wp) :: rcov(94)\n      integer :: i\n      logical :: taken(nat)\n      molvec=0\n      molcount=1\n      taken=.false.\n      cn=0.0d0\n      bond=0.0d0\n      !call xcoord(nat,at,xyz,cn,bond)\n      call xcoord2(nat,at,xyz,rcov,cn,400.0_wp,bond)\n      bref = bond\n      do i=1,nat\n       if(.not.taken(i)) then\n         molvec(i)=molcount\n         taken(i)=.true.\n         call neighbours(i,xyz,at,taken,nat,cn,bond,molvec,molcount)\n         molcount=molcount+1\n      endif\n      enddo\n      molcount=molcount-1\n      bond = bref\nend subroutine mreclm\n\n!==================================================================================!\nrecursive subroutine neighbours(i,xyz,iat,taken,nat,cn,bond,molvec,molcnt)\n      implicit none\n      real*8 xyz(3,nat),tr,xi(3),cn(nat),bond(nat,nat)\n      integer i,nat, molcnt,molvec(nat),j,iat(nat),icn,k\n      logical taken(nat)\n      tr=2.0d0\n      \n      xi(1:3)=xyz(1:3,i) \n      icn=nint(cn(i))\n      do k=1,icn\n         j=maxloc(bond(:,i),1)\n         bond(j,i)=0.0d0\n         if (i .eq. j) cycle\n         if (.not.taken(j)) then\n            molvec(j)=molcnt\n            taken(j)=.true.\n            call neighbours(j,xyz,iat,taken,nat,cn,bond,molvec,molcnt)\n         endif\n      enddo\nend subroutine neighbours\n\n!================================================================================!\n! compute coordination numbers by adding an inverse damping function\n!================================================================================!\nsubroutine xcoord(natoms,iz,xyz,cn,bond)\n      implicit none\n      integer iz(natoms),natoms,i,k1\n      real*8 xyz(3,natoms),cn(natoms)\n      real*8 cn_thr,bond(natoms,natoms)\n      integer iat\n      real*8 dx,dy,dz,r,damp,xn,rr,rco,r2,rcovi,rcovj\n      real*8,allocatable :: rcov(:)\n      allocate(rcov(94))\n      call setrcov(rcov)\n\n      cn_thr=400.0d0\n      k1=16\n      bond=0.0d0\n      cn=0.0d0\n      do i=1,natoms\n        xn=0.0d0\n        rcovi=rcov(iz(i))\n        do iat=1,natoms\n         if(iat.ne.i)then\n            dx=xyz(1,iat)-xyz(1,i)\n            dy=xyz(2,iat)-xyz(2,i)\n            dz=xyz(3,iat)-xyz(3,i)\n            r2=dx*dx+dy*dy+dz*dz\n            r=sqrt(r2)\n            if (r2.gt.cn_thr) cycle\n            rcovj=rcov(iz(iat))\n! covalent distance in Bohr\n            rco=(rcovi+rcovj)*1.0  ! this scaling reduces the size of the clusters\n            rr=rco/r\n! counting function exponential has a better long-range behavior than MHGs inverse damping\n            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))\n            bond(iat,i)=damp\n            xn=xn+damp\n         endif\n        enddo\n        cn(i)=xn\n      enddo\n      deallocate(rcov)\nend subroutine xcoord\n\n\nsubroutine ycoord2(natoms,rcov,iz,xyz,cn,cn_thr,cthr,clash)\n      implicit none  \n      real*8 k1,k3\n      parameter (k1     =16)\n      parameter (k3     =-4)\n      integer iz(*),natoms,i\n      real*8 xyz(3,*),cn(*),rcov(94)\n      real*8 cn_thr,cthr\n      logical clash\n\n      integer iat    \n      real*8 dx,dy,dz,r,damp,xn,rr,rco,r2\n\n      clash=.false.\n      do i=1,natoms\n      xn=0.0d0\n      do iat=1,natoms\n         if(iat.ne.i)then\n            dx=xyz(1,iat)-xyz(1,i)\n            dy=xyz(2,iat)-xyz(2,i)\n            dz=xyz(3,iat)-xyz(3,i)\n            r2=dx*dx+dy*dy+dz*dz \n            if (r2.gt.cn_thr) cycle \n            r=sqrt(r2)                  \n!c covalent distance in Bohr\n            rco=rcov(iz(i))+rcov(iz(iat))\n            rr=rco/r\n!c counting function exponential has a better long-range behavior than MHGs inverse damping\n            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))\n            xn=xn+damp*iz(iat)\n         endif\n      enddo\n      if(abs(cn(i)-xn).gt.cthr) then                  !   clash check\n         clash=.true.\n         return\n      endif\n      enddo\nend subroutine ycoord2\n\n\nsubroutine ycoord(natoms,rcov,iz,xyz,cn,cn_thr)\n      implicit none  \n      real*8 k1,k3\n      parameter (k1     =16)\n      parameter (k3     =-4)\n      integer iz(*),natoms,i\n      real*8 xyz(3,*),cn(*),rcov(94)\n      real*8 cn_thr\n\n      integer iat    \n      real*8 dx,dy,dz,r,damp,xn,rr,rco,r2\n\n      do i=1,natoms\n      xn=0.0d0\n      do iat=1,natoms\n         if(iat.ne.i)then\n            dx=xyz(1,iat)-xyz(1,i)\n            dy=xyz(2,iat)-xyz(2,i)\n            dz=xyz(3,iat)-xyz(3,i)\n            r2=dx*dx+dy*dy+dz*dz \n            if (r2.gt.cn_thr) cycle \n            r=sqrt(r2)                  \n!c covalent distance in Bohr\n            rco=rcov(iz(i))+rcov(iz(iat))\n            rr=rco/r\n!c counting function exponential has a better long-range behavior than MHGs inverse damping\n            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))\n            xn=xn+damp*iz(iat)\n         endif\n      enddo\n      cn(i)=xn\n      enddo\n\nend subroutine ycoord\n\nsubroutine ycoord3(natoms,iz,xyz,cn,cn_thr,bond)\n      implicit none\n      integer :: natoms      ! = n\n      integer :: iz(natoms)  ! = at\n      integer :: i,k1\n      real*8 xyz(3,natoms),cn(natoms)\n      real*8 cn_thr,bond(natoms,natoms)\n      integer iat\n      real*8 dx,dy,dz,r,damp,xn,rr,rco,r2,rcovi,rcovj\n      real*8,allocatable :: rcov(:)\n     \n      allocate(rcov(94))\n      !cn_thr=1600.0d0\n      call setrcov(rcov)\n      k1=16\n      bond=0.0d0\n      cn=0.0d0\n      do i=1,natoms\n        xn=0.0d0\n        !call setrcov(iz(i),rcovi)\n        rcovi=rcov(iz(i))\n        do iat=1,natoms\n         if(iat.ne.i)then\n            dx=xyz(1,iat)-xyz(1,i)\n            dy=xyz(2,iat)-xyz(2,i)\n            dz=xyz(3,iat)-xyz(3,i)\n            r2=dx*dx+dy*dy+dz*dz\n            r=sqrt(r2)\n            if (r2.gt.cn_thr) cycle\n            !call setrcov(iz(iat),rcovj)\n            rcovj=rcov(iz(iat))\n!c covalent distance in Bohr\n            rco=rcovi+rcovj\n            rr=rco/r\n!            rr=rr*0.90d0\n!c counting function exponential has a better long-range behavior than MHGs inverse damping\n            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))\n            bond(iat,i)=damp\n!            bond(i,iat)=damp\n            xn=xn+damp\n         endif\n        enddo\n        cn(i)=xn\n      enddo\n      deallocate(rcov)\nend subroutine ycoord3\n\nsubroutine ncoord(natoms,rcov,iz,xyz,cn,cn_thr)\n      implicit none  \n      real*8 :: k1,k3\n      parameter (k1     =16)\n      parameter (k3     =-4)\n      integer :: iz(*),natoms,i\n      real*8 :: xyz(3,*),cn(*),rcov(94)\n      real*8 :: cn_thr\n\n      integer :: iat    \n      real*8 :: dx,dy,dz,r,damp,xn,rr,rco,r2\n\n      do i=1,natoms\n      xn=0.0d0\n      do iat=1,natoms\n         if(iat.ne.i)then\n            dx=xyz(1,iat)-xyz(1,i)\n            dy=xyz(2,iat)-xyz(2,i)\n            dz=xyz(3,iat)-xyz(3,i)\n            r2=dx*dx+dy*dy+dz*dz \n            if (r2.gt.cn_thr) cycle \n            r=sqrt(r2)                  \n!c covalent distance in Bohr\n            rco=rcov(iz(i))+rcov(iz(iat))\n            rr=rco/r\n!c counting function exponential has a better long-range behavior than MHGs inverse damping\n            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))\n            xn=xn+damp\n         endif\n      enddo\n      cn(i)=xn\n      enddo\nend subroutine ncoord\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/select.f90 b/src/select.f90
--- a/src/select.f90	
+++ b/src/select.f90	
@@ -26,25 +26,25 @@
 ! molvec: assignment vector of atom to fragment
 !=================================================================!
 subroutine mrec(molcount,xyz,nat,at,molvec)
-      implicit none
-      real*8 xyz(3,nat),cn(nat),bond(nat,nat)
-      integer nat,molvec(nat),i,molcount,at(nat)
-      logical taken(nat)
-      molvec=0
-      molcount=1
-      taken=.false.
-      cn=0.0d0
-      bond=0.0d0
-      call xcoord(nat,at,xyz,cn,bond)
-      do i=1,nat
-       if(.not.taken(i)) then
-         molvec(i)=molcount
-         taken(i)=.true.
-         call neighbours(i,xyz,at,taken,nat,cn,bond,molvec,molcount)
-         molcount=molcount+1
-      endif
-      enddo
-      molcount=molcount-1
+  implicit none
+  real*8 xyz(3,nat),cn(nat),bond(nat,nat)
+  integer nat,molvec(nat),i,molcount,at(nat)
+  logical taken(nat)
+  molvec = 0
+  molcount = 1
+  taken = .false.
+  cn = 0.0d0
+  bond = 0.0d0
+  call xcoord(nat,at,xyz,cn,bond)
+  do i = 1,nat
+    if (.not.taken(i)) then
+      molvec(i) = molcount
+      taken(i) = .true.
+      call neighbours(i,xyz,at,taken,nat,cn,bond,molvec,molcount)
+      molcount = molcount+1
+    end if
+  end do
+  molcount = molcount-1
 end subroutine mrec
 
 !=================================================================!
@@ -54,257 +54,297 @@
 ! calls are done.
 !=================================================================!
 subroutine mreclm(molcount,nat,at,xyz,molvec,bond,rcov,cn)
-      use iso_fortran_env, only: wp => real64
-      implicit none
-      integer :: molcount,nat
-      integer :: at(nat),molvec(nat)
-      real(wp) :: xyz(3,nat)
-      real(wp) :: cn(nat),bond(nat,nat)
-      real(wp) :: bref(nat,nat)
-      real(wp) :: rcov(94)
-      integer :: i
-      logical :: taken(nat)
-      molvec=0
-      molcount=1
-      taken=.false.
-      cn=0.0d0
-      bond=0.0d0
-      !call xcoord(nat,at,xyz,cn,bond)
-      call xcoord2(nat,at,xyz,rcov,cn,400.0_wp,bond)
-      bref = bond
-      do i=1,nat
-       if(.not.taken(i)) then
-         molvec(i)=molcount
-         taken(i)=.true.
-         call neighbours(i,xyz,at,taken,nat,cn,bond,molvec,molcount)
-         molcount=molcount+1
-      endif
-      enddo
-      molcount=molcount-1
-      bond = bref
+  use iso_fortran_env,only:wp => real64
+  implicit none
+  integer :: molcount,nat
+  integer :: at(nat),molvec(nat)
+  real(wp) :: xyz(3,nat)
+  real(wp) :: cn(nat),bond(nat,nat)
+  real(wp) :: bref(nat,nat)
+  real(wp) :: rcov(*)
+  integer :: i
+  logical :: taken(nat)
+  molvec = 0
+  molcount = 1
+  taken = .false.
+  cn = 0.0d0
+  bond = 0.0d0
+  !call xcoord(nat,at,xyz,cn,bond)
+  call xcoord2(nat,at,xyz,rcov,cn,400.0_wp,bond)
+  bref = bond
+  do i = 1,nat
+    if (.not.taken(i)) then
+      molvec(i) = molcount
+      taken(i) = .true.
+      call neighbours(i,xyz,at,taken,nat,cn,bond,molvec,molcount)
+      molcount = molcount+1
+    end if
+  end do
+  molcount = molcount-1
+  bond = bref
 end subroutine mreclm
 
 !==================================================================================!
 recursive subroutine neighbours(i,xyz,iat,taken,nat,cn,bond,molvec,molcnt)
-      implicit none
-      real*8 xyz(3,nat),tr,xi(3),cn(nat),bond(nat,nat)
-      integer i,nat, molcnt,molvec(nat),j,iat(nat),icn,k
-      logical taken(nat)
-      tr=2.0d0
-      
-      xi(1:3)=xyz(1:3,i) 
-      icn=nint(cn(i))
-      do k=1,icn
-         j=maxloc(bond(:,i),1)
-         bond(j,i)=0.0d0
-         if (i .eq. j) cycle
-         if (.not.taken(j)) then
-            molvec(j)=molcnt
-            taken(j)=.true.
-            call neighbours(j,xyz,iat,taken,nat,cn,bond,molvec,molcnt)
-         endif
-      enddo
+  implicit none
+  real*8 xyz(3,nat),tr,xi(3),cn(nat),bond(nat,nat)
+  integer i,nat,molcnt,molvec(nat),j,iat(nat),icn,k
+  logical taken(nat)
+  tr = 2.0d0
+
+  xi(1:3) = xyz(1:3,i)
+  icn = nint(cn(i))
+  do k = 1,icn
+    j = maxloc(bond(:,i),1)
+    bond(j,i) = 0.0d0
+    if (i .eq. j) cycle
+    if (.not.taken(j)) then
+      molvec(j) = molcnt
+      taken(j) = .true.
+      call neighbours(j,xyz,iat,taken,nat,cn,bond,molvec,molcnt)
+    end if
+  end do
 end subroutine neighbours
 
 !================================================================================!
 ! compute coordination numbers by adding an inverse damping function
 !================================================================================!
 subroutine xcoord(natoms,iz,xyz,cn,bond)
-      implicit none
-      integer iz(natoms),natoms,i,k1
-      real*8 xyz(3,natoms),cn(natoms)
-      real*8 cn_thr,bond(natoms,natoms)
-      integer iat
-      real*8 dx,dy,dz,r,damp,xn,rr,rco,r2,rcovi,rcovj
-      real*8,allocatable :: rcov(:)
-      allocate(rcov(94))
-      call setrcov(rcov)
+  use miscdata,only:rcov
+  implicit none
+  integer iz(natoms),natoms,i,k1
+  real*8 xyz(3,natoms),cn(natoms)
+  real*8 cn_thr,bond(natoms,natoms)
+  integer iat
+  real*8 dx,dy,dz,r,damp,xn,rr,rco,r2,rcovi,rcovj
 
-      cn_thr=400.0d0
-      k1=16
-      bond=0.0d0
-      cn=0.0d0
-      do i=1,natoms
-        xn=0.0d0
-        rcovi=rcov(iz(i))
-        do iat=1,natoms
-         if(iat.ne.i)then
-            dx=xyz(1,iat)-xyz(1,i)
-            dy=xyz(2,iat)-xyz(2,i)
-            dz=xyz(3,iat)-xyz(3,i)
-            r2=dx*dx+dy*dy+dz*dz
-            r=sqrt(r2)
-            if (r2.gt.cn_thr) cycle
-            rcovj=rcov(iz(iat))
+  cn_thr = 400.0d0
+  k1 = 16
+  bond = 0.0d0
+  cn = 0.0d0
+  do i = 1,natoms
+    xn = 0.0d0
+    rcovi = rcov(iz(i))
+    do iat = 1,natoms
+      if (iat .ne. i) then
+        dx = xyz(1,iat)-xyz(1,i)
+        dy = xyz(2,iat)-xyz(2,i)
+        dz = xyz(3,iat)-xyz(3,i)
+        r2 = dx*dx+dy*dy+dz*dz
+        r = sqrt(r2)
+        if (r2 .gt. cn_thr) cycle
+        rcovj = rcov(iz(iat))
 ! covalent distance in Bohr
-            rco=(rcovi+rcovj)*1.0  ! this scaling reduces the size of the clusters
-            rr=rco/r
+        rco = (rcovi+rcovj)*1.0  ! this scaling reduces the size of the clusters
+        rr = rco/r
 ! counting function exponential has a better long-range behavior than MHGs inverse damping
-            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
-            bond(iat,i)=damp
-            xn=xn+damp
-         endif
-        enddo
-        cn(i)=xn
-      enddo
-      deallocate(rcov)
+        damp = 1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
+        bond(iat,i) = damp
+        xn = xn+damp
+      end if
+    end do
+    cn(i) = xn
+  end do
 end subroutine xcoord
 
-
 subroutine ycoord2(natoms,rcov,iz,xyz,cn,cn_thr,cthr,clash)
-      implicit none  
-      real*8 k1,k3
-      parameter (k1     =16)
-      parameter (k3     =-4)
-      integer iz(*),natoms,i
-      real*8 xyz(3,*),cn(*),rcov(94)
-      real*8 cn_thr,cthr
-      logical clash
+  implicit none
+  real*8 k1,k3
+  parameter(k1=16)
+  parameter(k3=-4)
+  integer iz(*),natoms,i
+  real*8 xyz(3,*),cn(*),rcov(*)
+  real*8 cn_thr,cthr
+  logical clash
 
-      integer iat    
-      real*8 dx,dy,dz,r,damp,xn,rr,rco,r2
+  integer iat
+  real*8 dx,dy,dz,r,damp,xn,rr,rco,r2
 
-      clash=.false.
-      do i=1,natoms
-      xn=0.0d0
-      do iat=1,natoms
-         if(iat.ne.i)then
-            dx=xyz(1,iat)-xyz(1,i)
-            dy=xyz(2,iat)-xyz(2,i)
-            dz=xyz(3,iat)-xyz(3,i)
-            r2=dx*dx+dy*dy+dz*dz 
-            if (r2.gt.cn_thr) cycle 
-            r=sqrt(r2)                  
+  clash = .false.
+  do i = 1,natoms
+    xn = 0.0d0
+    do iat = 1,natoms
+      if (iat .ne. i) then
+        dx = xyz(1,iat)-xyz(1,i)
+        dy = xyz(2,iat)-xyz(2,i)
+        dz = xyz(3,iat)-xyz(3,i)
+        r2 = dx*dx+dy*dy+dz*dz
+        if (r2 .gt. cn_thr) cycle
+        r = sqrt(r2)
 !c covalent distance in Bohr
-            rco=rcov(iz(i))+rcov(iz(iat))
-            rr=rco/r
+        rco = rcov(iz(i))+rcov(iz(iat))
+        rr = rco/r
 !c counting function exponential has a better long-range behavior than MHGs inverse damping
-            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
-            xn=xn+damp*iz(iat)
-         endif
-      enddo
-      if(abs(cn(i)-xn).gt.cthr) then                  !   clash check
-         clash=.true.
-         return
-      endif
-      enddo
+        damp = 1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
+        xn = xn+damp*iz(iat)
+      end if
+    end do
+    if (abs(cn(i)-xn) .gt. cthr) then                  !   clash check
+      clash = .true.
+      return
+    end if
+  end do
 end subroutine ycoord2
 
-
 subroutine ycoord(natoms,rcov,iz,xyz,cn,cn_thr)
-      implicit none  
-      real*8 k1,k3
-      parameter (k1     =16)
-      parameter (k3     =-4)
-      integer iz(*),natoms,i
-      real*8 xyz(3,*),cn(*),rcov(94)
-      real*8 cn_thr
+  implicit none
+  real*8 k1,k3
+  parameter(k1=16)
+  parameter(k3=-4)
+  integer iz(*),natoms,i
+  real*8 xyz(3,*),cn(*),rcov(*)
+  real*8 cn_thr
 
-      integer iat    
-      real*8 dx,dy,dz,r,damp,xn,rr,rco,r2
+  integer iat
+  real*8 dx,dy,dz,r,damp,xn,rr,rco,r2
 
-      do i=1,natoms
-      xn=0.0d0
-      do iat=1,natoms
-         if(iat.ne.i)then
-            dx=xyz(1,iat)-xyz(1,i)
-            dy=xyz(2,iat)-xyz(2,i)
-            dz=xyz(3,iat)-xyz(3,i)
-            r2=dx*dx+dy*dy+dz*dz 
-            if (r2.gt.cn_thr) cycle 
-            r=sqrt(r2)                  
+  do i = 1,natoms
+    xn = 0.0d0
+    do iat = 1,natoms
+      if (iat .ne. i) then
+        dx = xyz(1,iat)-xyz(1,i)
+        dy = xyz(2,iat)-xyz(2,i)
+        dz = xyz(3,iat)-xyz(3,i)
+        r2 = dx*dx+dy*dy+dz*dz
+        if (r2 .gt. cn_thr) cycle
+        r = sqrt(r2)
 !c covalent distance in Bohr
-            rco=rcov(iz(i))+rcov(iz(iat))
-            rr=rco/r
+        rco = rcov(iz(i))+rcov(iz(iat))
+        rr = rco/r
 !c counting function exponential has a better long-range behavior than MHGs inverse damping
-            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
-            xn=xn+damp*iz(iat)
-         endif
-      enddo
-      cn(i)=xn
-      enddo
+        damp = 1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
+        xn = xn+damp*iz(iat)
+      end if
+    end do
+    cn(i) = xn
+  end do
 
 end subroutine ycoord
 
 subroutine ycoord3(natoms,iz,xyz,cn,cn_thr,bond)
-      implicit none
-      integer :: natoms      ! = n
-      integer :: iz(natoms)  ! = at
-      integer :: i,k1
-      real*8 xyz(3,natoms),cn(natoms)
-      real*8 cn_thr,bond(natoms,natoms)
-      integer iat
-      real*8 dx,dy,dz,r,damp,xn,rr,rco,r2,rcovi,rcovj
-      real*8,allocatable :: rcov(:)
-     
-      allocate(rcov(94))
-      !cn_thr=1600.0d0
-      call setrcov(rcov)
-      k1=16
-      bond=0.0d0
-      cn=0.0d0
-      do i=1,natoms
-        xn=0.0d0
-        !call setrcov(iz(i),rcovi)
-        rcovi=rcov(iz(i))
-        do iat=1,natoms
-         if(iat.ne.i)then
-            dx=xyz(1,iat)-xyz(1,i)
-            dy=xyz(2,iat)-xyz(2,i)
-            dz=xyz(3,iat)-xyz(3,i)
-            r2=dx*dx+dy*dy+dz*dz
-            r=sqrt(r2)
-            if (r2.gt.cn_thr) cycle
-            !call setrcov(iz(iat),rcovj)
-            rcovj=rcov(iz(iat))
+  use miscdata,only:rcov
+  implicit none
+  integer :: natoms      ! = n
+  integer :: iz(natoms)  ! = at
+  integer :: i,k1
+  real*8 xyz(3,natoms),cn(natoms)
+  real*8 cn_thr,bond(natoms,natoms)
+  integer iat
+  real*8 dx,dy,dz,r,damp,xn,rr,rco,r2,rcovi,rcovj
+
+  !cn_thr=1600.0d0
+  k1 = 16
+  bond = 0.0d0
+  cn = 0.0d0
+  do i = 1,natoms
+    xn = 0.0d0
+    !call setrcov(iz(i),rcovi)
+    rcovi = rcov(iz(i))
+    do iat = 1,natoms
+      if (iat .ne. i) then
+        dx = xyz(1,iat)-xyz(1,i)
+        dy = xyz(2,iat)-xyz(2,i)
+        dz = xyz(3,iat)-xyz(3,i)
+        r2 = dx*dx+dy*dy+dz*dz
+        r = sqrt(r2)
+        if (r2 .gt. cn_thr) cycle
+        !call setrcov(iz(iat),rcovj)
+        rcovj = rcov(iz(iat))
 !c covalent distance in Bohr
-            rco=rcovi+rcovj
-            rr=rco/r
+        rco = rcovi+rcovj
+        rr = rco/r
 !            rr=rr*0.90d0
 !c counting function exponential has a better long-range behavior than MHGs inverse damping
-            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
-            bond(iat,i)=damp
+        damp = 1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
+        bond(iat,i) = damp
 !            bond(i,iat)=damp
-            xn=xn+damp
-         endif
-        enddo
-        cn(i)=xn
-      enddo
-      deallocate(rcov)
+        xn = xn+damp
+      end if
+    end do
+    cn(i) = xn
+  end do
 end subroutine ycoord3
 
 subroutine ncoord(natoms,rcov,iz,xyz,cn,cn_thr)
-      implicit none  
-      real*8 :: k1,k3
-      parameter (k1     =16)
-      parameter (k3     =-4)
-      integer :: iz(*),natoms,i
-      real*8 :: xyz(3,*),cn(*),rcov(94)
-      real*8 :: cn_thr
+  implicit none
+  real*8 :: k1,k3
+  parameter(k1=16)
+  parameter(k3=-4)
+  integer :: iz(*),natoms,i
+  real*8 :: xyz(3,*),cn(*),rcov(*)
+  real*8 :: cn_thr
 
-      integer :: iat    
-      real*8 :: dx,dy,dz,r,damp,xn,rr,rco,r2
+  integer :: iat
+  real*8 :: dx,dy,dz,r,damp,xn,rr,rco,r2
 
-      do i=1,natoms
-      xn=0.0d0
-      do iat=1,natoms
-         if(iat.ne.i)then
-            dx=xyz(1,iat)-xyz(1,i)
-            dy=xyz(2,iat)-xyz(2,i)
-            dz=xyz(3,iat)-xyz(3,i)
-            r2=dx*dx+dy*dy+dz*dz 
-            if (r2.gt.cn_thr) cycle 
-            r=sqrt(r2)                  
+  do i = 1,natoms
+    xn = 0.0d0
+    do iat = 1,natoms
+      if (iat .ne. i) then
+        dx = xyz(1,iat)-xyz(1,i)
+        dy = xyz(2,iat)-xyz(2,i)
+        dz = xyz(3,iat)-xyz(3,i)
+        r2 = dx*dx+dy*dy+dz*dz
+        if (r2 .gt. cn_thr) cycle
+        r = sqrt(r2)
 !c covalent distance in Bohr
-            rco=rcov(iz(i))+rcov(iz(iat))
-            rr=rco/r
+        rco = rcov(iz(i))+rcov(iz(iat))
+        rr = rco/r
 !c counting function exponential has a better long-range behavior than MHGs inverse damping
-            damp=1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
-            xn=xn+damp
-         endif
-      enddo
-      cn(i)=xn
-      enddo
+        damp = 1.d0/(1.d0+exp(-k1*(rr-1.0d0)))
+        xn = xn+damp
+      end if
+    end do
+    cn(i) = xn
+  end do
 end subroutine ncoord
 
+!========================================================================================!
+
+subroutine neighdist(natoms,at,xyz,nb,dist)
+  use crest_parameters
+  use miscdata,only:rad => rcov
+  implicit none
+  integer :: at(natoms),natoms,nb(200,natoms)
+  real(wp) :: xyz(3,natoms),dist(natoms,natoms)
+  logical :: da
+  integer :: iat,i,j,k,nn
+  real(wp) :: dx,dy,dz,r,rco,r2,f
+
+  nb = 0
+  nn = min(natoms,2)-1
+
+  do i = 1,natoms
+    f = 1.0d0
+    k = 0
+    do while (k .lt. 1.and.f .lt. 1.5d0)
+100   do iat = 1,natoms
+        da = .false.
+        do j = 1,k
+          if (nb(j,i) .eq. iat) da = .true.
+        end do
+        dx = xyz(1,iat)-xyz(1,i)
+        dy = xyz(2,iat)-xyz(2,i)
+        dz = xyz(3,iat)-xyz(3,i)
+        r2 = dx*dx+dy*dy+dz*dz
+        r = sqrt(r2)
+        dist(iat,i) = r
+        if (iat .ne. i.and.(.not.da)) then
+          rco = rad(at(i))+rad(at(iat))
+!>-- critical step
+          if (r .lt. f*rco.and.k .lt. 199) then
+            k = k+1
+            nb(k,i) = iat
+          end if
+        end if
+      end do
+      !if(k.lt.1.and.f.lt.1.5)then
+      f = f*1.1d0
+      !   goto 100
+      !endif
+    end do
+    nb(200,i) = k
+  end do
+
+end subroutine neighdist
 
Index: src/sigterm.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\nsubroutine wsigint !> Ctrl+C\n  use crest_parameters, only:stderr,stdout\n  integer :: myunit\n  write(*,*)\n  write (stderr,'(\" recieved SIGINT, trying to terminate CREST...\")')\n  call exit(1)\n  error stop\nend subroutine wsigint\n\nsubroutine wsigquit !> Ctrl+D or Ctrl+\\\n  use crest_parameters, only:stderr,stdout\n  integer :: myunit\n  write(*,*)\n  write (stderr,'(\" recieved SIGQUIT, trying to terminate CREST...\")')\n  call exit(1)\n  error stop\nend subroutine wsigquit\n\nsubroutine wsigterm !> Recieved by the \"kill\" pid command\n  use crest_parameters, only:stderr,stdout\n  write(stdout,*)\n  write (stderr,'(\" recieved SIGTERM, trying to terminate CREST...\")')\n  call exit(1)\n  error stop\nend subroutine wsigterm\n\nsubroutine wsigkill\n  use crest_parameters, only:stderr,stdout\n  error stop 'CREST recieved SIGKILL.'\nend subroutine wsigkill\n\nsubroutine initsignal()\n  external :: wSIGINT\n  external :: wSIGTERM\n  external :: wSIGKILL\n  external :: wSIGQUIT\n\n  call signal(2,wSIGINT)\n  call signal(3,wSIGQUIT)\n  call signal(9,wSIGKILL)\n  call signal(15,wSIGTERM)\n  call signal(69,wSIGINT)\nend subroutine initsignal\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/sigterm.f90 b/src/sigterm.f90
--- a/src/sigterm.f90	
+++ b/src/sigterm.f90	
@@ -18,32 +18,50 @@
 !================================================================================!
 subroutine wsigint !> Ctrl+C
   use crest_parameters, only:stderr,stdout
-  integer :: myunit
+  use crest_restartlog, only: dump_restart
+  use ConfSolv_module
+  integer :: myunit,io
   write(*,*)
   write (stderr,'(" recieved SIGINT, trying to terminate CREST...")')
+  !call dump_restart()
+  call cs_shutdown(io)  
   call exit(1)
   error stop
 end subroutine wsigint
 
 subroutine wsigquit !> Ctrl+D or Ctrl+\
   use crest_parameters, only:stderr,stdout
-  integer :: myunit
+  use crest_restartlog, only: dump_restart 
+  use ConfSolv_module
+  integer :: myunit,io
   write(*,*)
   write (stderr,'(" recieved SIGQUIT, trying to terminate CREST...")')
+  !call dump_restart()
+  call cs_shutdown(io)
   call exit(1)
   error stop
 end subroutine wsigquit
 
 subroutine wsigterm !> Recieved by the "kill" pid command
   use crest_parameters, only:stderr,stdout
+  use crest_restartlog, only: dump_restart 
+  use ConfSolv_module
+  integer :: io 
   write(stdout,*)
   write (stderr,'(" recieved SIGTERM, trying to terminate CREST...")')
+  !call dump_restart()
+  call cs_shutdown(io)
   call exit(1)
   error stop
 end subroutine wsigterm
 
 subroutine wsigkill
   use crest_parameters, only:stderr,stdout
+  use crest_restartlog, only: dump_restart
+  use ConfSolv_module
+  integer :: io
+  !call dump_restart() 
+  call cs_shutdown(io) 
   error stop 'CREST recieved SIGKILL.'
 end subroutine wsigkill
 
Index: src/identifiers.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n! Nov 2017, PP \n! Updated Nov 2018\n! Updated May 2019\n! Updated Jan 2021\n\n!! --------------------------------------------------------------------------------------\n!  Sort all H atoms in the coord file to the bottom\n!! --------------------------------------------------------------------------------------\nsubroutine htothebottom(fname,ichrg,n,atmap)\n       use crest_parameters\n       use strucrd, only: rdnat,rdcoord,i2e\n       implicit none\n\n       integer :: i,j\n       character(len=*) :: fname\n       integer :: n,ichrg\n       integer :: atmap(n)\n       integer,allocatable :: at(:),atnew(:)\n       real(wp),allocatable :: xyz0(:,:)\n       integer :: ich,m\n\n       call rdnat(fname,n)\n       allocate(xyz0(3,n),at(n),atnew(n))\n       call rdcoord(fname,n,at,xyz0)\n\n       m=0\n       open (newunit=ich,file='coord')\n       write(ich,'(a)')'$coord'\n       do i=1,n\n          if(at(i).ne.1)then                                     !first all non-H-atoms\n             write(ich,'(3F24.14,6x,a2)')xyz0(1:3,i),i2e(at(i))\n             m=m+1\n             atmap(m) = i\n             atnew(m) = at(i)\n          endif\n       enddo\n       do j=1,n\n           if(at(j).eq.1)then                                    !then all H-atoms\n             write(ich,'(3F24.14,6x,a2)')xyz0(1:3,j),i2e(at(j))\n             m=m+1\n             atmap(m) = j\n             atnew(m) = at(j)\n          endif\n       enddo\n       write(ich,'(a)')'$end'\n       write(ich,'(1x,''$chrg'',1x,i0)')ichrg\n       write(ich,'(a)')'$end'\n       close(ich)\n\n       if(.not.(all(at==atnew)))then\n       write(*,*)'Input coordinate lines sorted:'\n       write(*,'(1x,a,1x,a5,1x,a5)') 'element','old','new'\n       call print_map(6,n,atnew,atmap)\n       endif\n\n       deallocate(at,xyz0)\n       return\nend subroutine htothebottom\n\nsubroutine print_map(prch,nat,at,atmap)\n    use crest_data\n    use strucrd, only: i2e\n    implicit none\n    integer :: prch\n    integer :: nat\n    integer :: at(nat)\n    integer :: atmap(nat)\n    integer :: i\n    do i=1,nat\n    write(prch,'(1x,a7,1x,i5,1x,i5)') i2e(at(i),'nc'),atmap(i),i\n    enddo\n    return\nend subroutine print_map\n\n!! --------------------------------------------------------------------------------------\n!  Sort out all topologically equivalent structures (i.e. conformers)\n!! --------------------------------------------------------------------------------------\nsubroutine cosort(iname,oname,wrscoord,verbose)\n      use crest_parameters\n      use iomod\n      use strucrd, only: wrc0,rdensembleparam,rdensemble,wrxyz\n      implicit none\n\n      character(len=*),intent(in) :: iname\n      character(len=*),intent(in) :: oname\n      logical,intent(in)          :: wrscoord\n\n      integer :: j,k,q,p,r\n      real(wp),allocatable :: eread(:),xyz(:,:,:),xyztmp(:,:)\n      real(wp),allocatable :: cn(:),bond(:,:)\n      integer,allocatable :: at(:),group(:)\n      real(wp) :: dE\n      character(len=10),allocatable :: itensr(:),itensl(:)   !identifier tensor\n      character(len=80) :: str\n      integer :: n,nall,nonh,gc,sgc,tgc\n\n      logical :: verbose\n      integer :: ochan,ich\n\n      write(*,*)\n      write(*,*)'==================================================='\n      write(*,'(a)')' Identifying topologically equivalent structures:'\n\n      call rdensembleparam(iname,n,nall)\n      allocate(xyz(3,n,nall),eread(nall),group(nall),at(n),xyztmp(3,n),cn(n),bond(n,n))\n      call rdensemble(iname,n,nall,at,xyz,eread)\n\n      call countnonh(n,at,nonh)\n      !allocate(itens(nonh,nall))\n      allocate(itensr(nonh),itensl(nonh))\n\n!---- identifier sorting loops\n      gc=1\n      group=0\n   \n      do r=1,nall\n        if(group(r).ne.0)cycle\n        xyztmp(:,:)=xyz(:,:,r)/bohr\n        call get_itens(n,xyztmp,at,nonh,itensr)\n        do q=1,nall\n          if(r.eq.q)then\n            group(r)=gc\n            tgc=1\n            cycle\n          endif\n          xyztmp(:,:)=xyz(:,:,q)/bohr\n          call get_itens(n,xyztmp,at,nonh,itensl)\n          sgc=0\n          do p=1,nonh\n             !if(itens(p,r)==itens(p,q))then\n             if(itensr(p)==itensl(p))then\n               sgc=sgc+1\n             else\n               exit\n            endif\n          enddo\n          if(sgc.eq.nonh)then\n             group(q)=gc\n             tgc=tgc+1\n          endif\n        enddo\n        if(tgc.gt.1)then\n        write(*,'(a,i0,a,i0,a)')' Equivalent to ',r,'. structure: ' &\n        &                        ,tgc,' structure(s).'\n        endif\n        gc=gc+1        \n      enddo\n      write(*,'(a)')' Done.'\n      write(*,'(a,a,a)')' Appending file <',trim(oname),'> with structures.'\n      write(*,*)\n\n      open(newunit=ochan,file='tmp')\n\n      write(ochan,*)'==================================================='\n      write(ochan,*)'============= ordered structure list =============='\n      write(ochan,*)'==================================================='\n      if(wrscoord)then\n      write(ochan,'(a,a)')' written to <scoord.*> and ',trim(oname)\n      write(ochan,*)\n      write(ochan,'('' scoord.*     ΔE(kcal/mol)   Etot(Eh)'')')\n      else\n      write(ochan,'(a,a,a)')' written to file <',trim(oname),'>'\n      write(ochan,*)\n      write(ochan,'('' structure    ΔE(kcal/mol)   Etot(Eh)'')')\n      endif\n\n      open(newunit=ich,file=oname)\n      k=0\n      do j=1,gc-1\n         do r=1,nall\n            if(group(r).eq.j)then\n              k=k+1\n              dE=(eread(r)-eread(1))*627.5095_wp\n              write(ochan,'(i5,6x,F10.2,4x,F14.6)') &\n              & k,dE,eread(r)\n              call wrxyz(ich,n,at,xyz(:,:,r),eread(r))\n              where(group.eq.j)group=0\n              if(wrscoord)then  ! write new scoord.* if necessary\n                write(str,'(''scoord.'',i0)')k\n                call wrc0(trim(str),n,at,xyz(:,:,r))\n              endif\n            else\n              cycle\n            endif\n         enddo\n      enddo\n      close(ich)\n      close(ochan)\n\n      gc=gc-1\n\n      if(nall.ne.gc)then\n        write(*,'(a,i0,a,a,a)')' Initial ',nall,' structures from file ',trim(iname),' have'\n        write(*,'(a,i0,a)')' been reduced to ',gc,' topologically unique structures.'\n      else\n        write(*,'(a,i0,a,a,a)')' All initial ',nall,' structures from file ',trim(iname),' are unique.'\n      endif\n\n      !deallocate(itens)\n      deallocate(itensl,itensr)\n      deallocate(bond,cn,xyztmp,at,eread,xyz)\n      \n      if(verbose) call cat('tmp')\n      call remove('tmp')\n      !call remove('identify')\n\nend subroutine cosort\n\n!! --------------------------------------------------------------------------------------\n!! --------------------------------------------------------------------------------------\n\nsubroutine countnonh(nat,iz,n)    !count all non-hydrogen atoms\n      implicit none\n      integer :: nat,iz(nat),n,i\n      n=0\n      do i=1,nat\n         if(iz(i).eq.1)then\n            cycle\n         else\n            n=n+1\n         endif\n      enddo\nend subroutine countnonh\n\nsubroutine counth(nat,iz,n)    !count all hydrogen atoms\n      implicit none\n      integer :: nat,iz(nat),n,i\n      n=0\n      do i=1,nat\n         if(iz(i).eq.1)then\n            cycle\n         else\n            n=n+1\n         endif\n      enddo\nend subroutine counth\n\n\nsubroutine countnonh2(icn,idarr,n2)\n      implicit none\n      integer :: icn,idarr(icn),n2,i\n      n2=0\n      do i=1,icn\n         if(idarr(i).eq.1)then\n            cycle\n         else\n            n2=n2+1\n         endif\n      enddo\nend subroutine countnonh2\n\n!! --------------------------------------------------------------------------------------\n!  build an identifier tensor for a single molecule\n!! --------------------------------------------------------------------------------------\nsubroutine get_itens(n,xyz,at,ni,itens)\n      use crest_parameters\n      implicit none\n      integer,intent(in)  :: n                    ! number of atoms\n      integer,intent(in)  :: ni                   ! number of elements in the identifier\n      real(wp),intent(in) :: xyz(3,n)             ! coordinates in Bohrs\n      integer,intent(in)  :: at(n)                ! integer atom types\n      character(len=10),intent(out) :: itens(ni)  ! Identifier\n      integer :: ntopo\n      integer,allocatable :: topo(:)\n      character(len=10) :: ident\n      integer :: p\n      itens=''\n      ntopo = n*(n+1)/2\n      allocate(topo(ntopo))\n      call quicktopo(n,at,xyz,ntopo,topo)\n      do p=1,ni\n        call analyze_neighbours(p,xyz,at,n,ntopo,topo,ident)\n        itens(p)=ident\n      enddo\n      deallocate(topo)\n      return\nend subroutine get_itens\n\n!! --------------------------------------------------------------------------------------\n!  modified version of the neighbours subroutine in select.f\n!! --------------------------------------------------------------------------------------\nsubroutine analyze_neighbours(i,xyz,iat,nat,ntopo,topo,ident)\n      use crest_parameters\n      implicit none\n      integer,intent(in)  :: i\n      real(wp),intent(in) :: xyz(3,nat)\n      integer,intent(in)  :: iat(nat)\n      integer,intent(in)  :: nat\n      integer,intent(in) :: ntopo\n      integer,intent(in) :: topo(ntopo)\n      character(len=10),intent(inout) :: ident\n      integer  :: j,k,l,icn,n2\n      integer :: lin !this is a function\n      integer,allocatable :: idarr(:),neighb(:)\n      character(len=10) :: str\n      character(len=9) :: str2     \n      character(len=1) :: chiral\n      logical :: chiralC,chiralX\n      chiralC=.false.\n      chiralX=.false.\n      l=0\n      ident=''\n      icn=0\n      do k=1,nat\n         j=lin(i,k)\n         if(topo(j)==1)icn=icn+1\n      enddo\n      allocate(idarr(icn),neighb(icn))                           !identifier array contains atoms\n      l=0\n      do k=1,nat\n         j=lin(i,k)\n         if(topo(j)==1)then\n             l=l+1\n             neighb(l)=k\n             idarr(l)=iat(k)\n         endif\n      enddo\n\n      call idwrite(icn,idarr,str)                   !write the identifier sorted by atom number (hydrogen first, then heavy atoms)\n      ident=trim(str)                               !i.e., idarr(1) should be a hydrogen if there are hydrogen bound to atom i\n      \n      !Check if (pseudo-)chirality has to be determined for atom i\n      if((iat(i).eq.6).and.(icn.eq.4))then     !for carbon\n         chiralC=.true.\n         call countnonh2(icn,idarr,n2)\n         !if((idarr(1).eq.idarr(2)).and.(iat(idarr(1)).eq.1))then !methyl and ehtyl group workaround\n         !   chiralC=.false.\n         if(n2.le.2)then                                          !methyl and ehtyl group workaround\n            chiralC=.false.\n         endif\n      endif\n      if((iat(i).ne.6).and.(icn.ge.3))then     !for other heavy atoms\n         chiralX=.true.\n         call countnonh2(icn,idarr,n2)\n         if((icn-n2).gt.1)then                     !if more than one hydrogen are present don't use the chirality identifier\n            chiralX=.false.                        !because the results might differ (hydrogen order not fixed in the coordinates)\n         endif\n         if((icn.eq.3).and.(iat(i).eq.7))chiralX=.false. !special case nitrogen because of the low inversion barrier\n         !write(*,*) icn,iat(i)\n      endif\n \n      if(chiralC.or.chiralX)then                    !add a (pseudo-)chirality identifier (+ or -)\n         chiral=''\n         call chispat(i,icn,neighb,nat,xyz,chiral)\n         str2=trim(ident)\n         write(ident,'(a,a)')trim(str2),trim(chiral)\n         chiralC=.false.\n         chiralX=.false.\n      endif\n \n      deallocate(neighb,idarr)\nend subroutine analyze_neighbours\n\n!! --------------------------------------------------------------------------------------\n!  idwrite writing ordered identifier\n!! --------------------------------------------------------------------------------------\nsubroutine idwrite(n,arr,str)\n      use strucrd, only: i2e\n      implicit none\n      integer :: n,arr(n)\n      integer :: i\n      character(len=*) :: str\n      character(len=6) :: dummy\n      call quicksort(n,arr)\n      str=''\n      do i=1,n\n         dummy=trim(str)\n         write(str,'(a,a)')trim(dummy),trim(i2e(arr(i)))\n      enddo      \nend subroutine idwrite\n\n!! --------------------------------------------------------------------------------------\n!  chispat -  chirality identifier by using a spat product\n!! --------------------------------------------------------------------------------------\nsubroutine chispat(c,icn,neighb,nat,xyz,chiral)\n      use crest_parameters\n      implicit none\n      integer  :: c\n      integer  :: nat\n      integer  :: icn\n      integer  :: neighb(icn)\n      real(wp) :: xyz(3,nat)\n      character(len=*) :: chiral\n\n      integer :: i,j,k\n      real(wp),allocatable :: xyz2(:,:)\n      real(wp) :: mat(3,3)\n      real(wp) :: sig\n\n      allocate(xyz2(3,icn))\n\n      chiral=''\n\n      !build xyz2 according to atom order of the coordinates. These loops are important since the\n      !matrix for the triple product always has to contain the same vectors in the same order.\n      xyz2=0\n      k=0\n      do i=1,nat\n         do j=1,icn\n            if(i.eq.neighb(j))then\n               k=k+1\n               xyz2(:,k)=(xyz(:,neighb(j)))-xyz(:,c)         !move coordinate system according to atom c\n               xyz2(:,k)=xyz2(:,k)/sqrt(sum(xyz2(1:3,k)**2))\n             endif\n         enddo\n      enddo\n\n      !calculate triple product to determine (pseudo-)chirality\n      mat=0\n      sig=0\n      mat(:,1)=xyz2(:,1)\n      mat(:,2)=xyz2(:,2)\n      mat(:,3)=xyz2(:,3)\n      if(icn.ge.4)then\n         do j=4,icn\n            mat(:,3)=mat(:,3)-xyz2(:,j)\n         enddo\n      endif\n      call det3x3(mat,sig)\n      !write(*,*)sig\n\n      if(sig.lt.0)then\n         chiral='-'\n      else\n         chiral='+'\n      endif\n\n      deallocate(xyz2)\n\nend subroutine chispat\n\n!! --------------------------------------------------------------------------------------\n\nsubroutine det3x3(m,detval)\n      use crest_parameters, only: wp\n      implicit none\n      real(wp) :: detval\n      real(wp) :: m(3,3)\n      real(wp) :: vec(3)\n      \n      vec(1)=(m(2,1)*m(3,2))-(m(3,1)*m(2,2))\n      vec(2)=(m(3,1)*m(1,2))-(m(1,1)*m(3,2))\n      vec(3)=(m(1,1)*m(2,2))-(m(2,1)*m(1,2))\n\n      detval=(vec(1)*m(1,3))+(vec(2)*m(2,3))+(vec(3)*m(3,3))\n\nend subroutine det3x3\n\n!! ------------------------------------------------------------------\n!  identification of methyl groups\n!! ------------------------------------------------------------------\nsubroutine methyl_autocomplete(n,xyz,at,equiv)\n      use crest_parameters, only: wp\n      implicit none\n      integer,intent(in)  :: n                    ! number of atoms\n      real(wp),intent(in) :: xyz(3,n)             ! coordinates\n      integer,intent(in)  :: at(n)                ! integer atom types\n      integer,allocatable :: eqv(:,:)\n      integer,intent(inout) :: equiv(n+1,n)\n\n      integer :: i,m\n       allocate(eqv(n,3))\n       call get_methyl(n,xyz,at,eqv)\n\n       do i=1,n\n          if(eqv(i,1).gt.0)then\n             m=equiv(1,i)\n             if(m.le.1)then\n                equiv(1,i)=3\n                equiv(2:4,i)=eqv(i,1:3)\n             endif\n          endif\n       enddo\n \n       deallocate(eqv)\nend subroutine methyl_autocomplete\n\n\nsubroutine get_methyl(n,xyz,at,eqv)\n      use crest_parameters, only: wp\n      implicit none\n      integer,intent(in)  :: n                    ! number of atoms\n      real(wp),intent(in) :: xyz(3,n)             ! coordinates\n      integer,intent(in)  :: at(n)                ! integer atom types\n      integer,intent(inout) :: eqv(n,3)\n\n      real(wp),allocatable :: cn(:)\n      real(wp),allocatable :: bond(:,:)\n\n      integer :: p,nonh\n      integer :: a,b,c\n\n      logical :: meth\n      integer :: nmeth\n      integer :: hyd(3)\n\n      allocate(cn(n),bond(n,n))\n\n      call countnonh(n,at,nonh) ! get number of non-Hydrogen atoms\n\n      cn=0.0d0\n      bond=0.0d0\n      call xcoord(n,at,xyz,cn,bond)\n      \n      eqv=0\n\n      nmeth=0\n      do p=1,n                                 \n        if(at(p).ne.6) cycle !only check for carbon\n        call methyl(p,at,n,cn,bond,meth,hyd)\n        !if(meth)nmeth=nmeth+1\n        if(meth)then\n          a=hyd(1)\n          b=hyd(2)\n          c=hyd(3)\n          eqv(a,1) = a\n          eqv(a,2) = b\n          eqv(a,3) = c\n          eqv(b,1) = b\n          eqv(b,2) = c\n          eqv(b,3) = a\n          eqv(c,1) = c\n          eqv(c,2) = a\n          eqv(c,3) = b\n        endif\n      enddo\n      deallocate(bond,cn)\n\nend subroutine get_methyl\n\n!! --------------------------------------------------------------------------------------\n!! --------------------------------------------------------------------------------------\n\nsubroutine methyl(i,iat,nat,cn,bond,meth,hydrogens)\n      use crest_parameters, only: wp\n      implicit none\n      integer,intent(in)  :: i\n      integer,intent(in)  :: iat(nat)\n      integer,intent(in)  :: nat\n      real(wp),intent(in) :: cn(nat)\n      real(wp),intent(inout) :: bond(nat,nat)\n      logical,intent(out) :: meth\n      integer,intent(out) :: hydrogens(3)\n      integer  :: j\n      integer  :: icn\n      integer  :: k,l\n      integer  :: nhyd\n      integer,allocatable :: neighb(:)\n      meth=.false.\n      hydrogens(1:3)=0\n      l=0\n      icn=floor(cn(i))\n      allocate(neighb(icn))                           !identifier array contains atoms\n      nhyd=0\n      do k=1,icn\n         j=maxloc(bond(:,i),1)\n         bond(j,i)=0.0d0\n         neighb(k)=j\n         if(iat(j).eq.1)nhyd=nhyd+1\n      enddo\n      if((icn.eq.4).and.(nhyd.eq.3))then\n        !write(*,*) neighb\n        meth=.true.\n        do k=1,icn\n           j=neighb(k)\n           !write(*,*) j,iat(j)\n           if(iat(j).eq.1)then\n              hydrogens(nhyd)=j\n              nhyd=nhyd-1\n           endif\n        enddo\n        !write(*,*) hydrogens\n      endif\nend subroutine methyl\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/identifiers.f90 b/src/identifiers.f90
--- a/src/identifiers.f90	
+++ b/src/identifiers.f90	
@@ -17,7 +17,7 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-! Nov 2017, PP 
+! Nov 2017, PP
 ! Updated Nov 2018
 ! Updated May 2019
 ! Updated Jan 2021
@@ -26,202 +26,202 @@
 !  Sort all H atoms in the coord file to the bottom
 !! --------------------------------------------------------------------------------------
 subroutine htothebottom(fname,ichrg,n,atmap)
-       use crest_parameters
-       use strucrd, only: rdnat,rdcoord,i2e
-       implicit none
+  use crest_parameters
+  use strucrd,only:rdnat,rdcoord,i2e
+  implicit none
 
-       integer :: i,j
-       character(len=*) :: fname
-       integer :: n,ichrg
-       integer :: atmap(n)
-       integer,allocatable :: at(:),atnew(:)
-       real(wp),allocatable :: xyz0(:,:)
-       integer :: ich,m
+  integer :: i,j
+  character(len=*) :: fname
+  integer :: n,ichrg
+  integer :: atmap(n)
+  integer,allocatable :: at(:),atnew(:)
+  real(wp),allocatable :: xyz0(:,:)
+  integer :: ich,m
 
-       call rdnat(fname,n)
-       allocate(xyz0(3,n),at(n),atnew(n))
-       call rdcoord(fname,n,at,xyz0)
+  call rdnat(fname,n)
+  allocate (xyz0(3,n),at(n),atnew(n))
+  call rdcoord(fname,n,at,xyz0)
 
-       m=0
-       open (newunit=ich,file='coord')
-       write(ich,'(a)')'$coord'
-       do i=1,n
-          if(at(i).ne.1)then                                     !first all non-H-atoms
-             write(ich,'(3F24.14,6x,a2)')xyz0(1:3,i),i2e(at(i))
-             m=m+1
-             atmap(m) = i
-             atnew(m) = at(i)
-          endif
-       enddo
-       do j=1,n
-           if(at(j).eq.1)then                                    !then all H-atoms
-             write(ich,'(3F24.14,6x,a2)')xyz0(1:3,j),i2e(at(j))
-             m=m+1
-             atmap(m) = j
-             atnew(m) = at(j)
-          endif
-       enddo
-       write(ich,'(a)')'$end'
-       write(ich,'(1x,''$chrg'',1x,i0)')ichrg
-       write(ich,'(a)')'$end'
-       close(ich)
+  m = 0
+  open (newunit=ich,file='coord')
+  write (ich,'(a)') '$coord'
+  do i = 1,n
+    if (at(i) .ne. 1) then                                     !first all non-H-atoms
+      write (ich,'(3F24.14,6x,a2)') xyz0(1:3,i),i2e(at(i))
+      m = m+1
+      atmap(m) = i
+      atnew(m) = at(i)
+    end if
+  end do
+  do j = 1,n
+    if (at(j) .eq. 1) then                                    !then all H-atoms
+      write (ich,'(3F24.14,6x,a2)') xyz0(1:3,j),i2e(at(j))
+      m = m+1
+      atmap(m) = j
+      atnew(m) = at(j)
+    end if
+  end do
+  write (ich,'(a)') '$end'
+  write (ich,'(1x,''$chrg'',1x,i0)') ichrg
+  write (ich,'(a)') '$end'
+  close (ich)
 
-       if(.not.(all(at==atnew)))then
-       write(*,*)'Input coordinate lines sorted:'
-       write(*,'(1x,a,1x,a5,1x,a5)') 'element','old','new'
-       call print_map(6,n,atnew,atmap)
-       endif
+  if (.not. (all(at == atnew))) then
+    write (*,*) 'Input coordinate lines sorted:'
+    write (*,'(1x,a,1x,a5,1x,a5)') 'element','old','new'
+    call print_map(6,n,atnew,atmap)
+  end if
 
-       deallocate(at,xyz0)
-       return
+  deallocate (at,xyz0)
+  return
 end subroutine htothebottom
 
 subroutine print_map(prch,nat,at,atmap)
-    use crest_data
-    use strucrd, only: i2e
-    implicit none
-    integer :: prch
-    integer :: nat
-    integer :: at(nat)
-    integer :: atmap(nat)
-    integer :: i
-    do i=1,nat
-    write(prch,'(1x,a7,1x,i5,1x,i5)') i2e(at(i),'nc'),atmap(i),i
-    enddo
-    return
+  use crest_data
+  use strucrd,only:i2e
+  implicit none
+  integer :: prch
+  integer :: nat
+  integer :: at(nat)
+  integer :: atmap(nat)
+  integer :: i
+  do i = 1,nat
+    write (prch,'(1x,a7,1x,i5,1x,i5)') i2e(at(i),'nc'),atmap(i),i
+  end do
+  return
 end subroutine print_map
 
 !! --------------------------------------------------------------------------------------
 !  Sort out all topologically equivalent structures (i.e. conformers)
 !! --------------------------------------------------------------------------------------
 subroutine cosort(iname,oname,wrscoord,verbose)
-      use crest_parameters
-      use iomod
-      use strucrd, only: wrc0,rdensembleparam,rdensemble,wrxyz
-      implicit none
+  use crest_parameters
+  use iomod
+  use strucrd,only:wrc0,rdensembleparam,rdensemble,wrxyz
+  implicit none
 
-      character(len=*),intent(in) :: iname
-      character(len=*),intent(in) :: oname
-      logical,intent(in)          :: wrscoord
+  character(len=*),intent(in) :: iname
+  character(len=*),intent(in) :: oname
+  logical,intent(in)          :: wrscoord
 
-      integer :: j,k,q,p,r
-      real(wp),allocatable :: eread(:),xyz(:,:,:),xyztmp(:,:)
-      real(wp),allocatable :: cn(:),bond(:,:)
-      integer,allocatable :: at(:),group(:)
-      real(wp) :: dE
-      character(len=10),allocatable :: itensr(:),itensl(:)   !identifier tensor
-      character(len=80) :: str
-      integer :: n,nall,nonh,gc,sgc,tgc
+  integer :: j,k,q,p,r
+  real(wp),allocatable :: eread(:),xyz(:,:,:),xyztmp(:,:)
+  real(wp),allocatable :: cn(:),bond(:,:)
+  integer,allocatable :: at(:),group(:)
+  real(wp) :: dE
+  character(len=10),allocatable :: itensr(:),itensl(:)   !identifier tensor
+  character(len=80) :: str
+  integer :: n,nall,nonh,gc,sgc,tgc
 
-      logical :: verbose
-      integer :: ochan,ich
+  logical :: verbose
+  integer :: ochan,ich
 
-      write(*,*)
-      write(*,*)'==================================================='
-      write(*,'(a)')' Identifying topologically equivalent structures:'
+  write (*,*)
+  write (*,*) '==================================================='
+  write (*,'(a)') ' Identifying topologically equivalent structures:'
 
-      call rdensembleparam(iname,n,nall)
-      allocate(xyz(3,n,nall),eread(nall),group(nall),at(n),xyztmp(3,n),cn(n),bond(n,n))
-      call rdensemble(iname,n,nall,at,xyz,eread)
+  call rdensembleparam(iname,n,nall)
+  allocate (xyz(3,n,nall),eread(nall),group(nall),at(n),xyztmp(3,n),cn(n),bond(n,n))
+  call rdensemble(iname,n,nall,at,xyz,eread)
 
-      call countnonh(n,at,nonh)
-      !allocate(itens(nonh,nall))
-      allocate(itensr(nonh),itensl(nonh))
+  call countnonh(n,at,nonh)
+  !allocate(itens(nonh,nall))
+  allocate (itensr(nonh),itensl(nonh))
 
 !---- identifier sorting loops
-      gc=1
-      group=0
-   
-      do r=1,nall
-        if(group(r).ne.0)cycle
-        xyztmp(:,:)=xyz(:,:,r)/bohr
-        call get_itens(n,xyztmp,at,nonh,itensr)
-        do q=1,nall
-          if(r.eq.q)then
-            group(r)=gc
-            tgc=1
-            cycle
-          endif
-          xyztmp(:,:)=xyz(:,:,q)/bohr
-          call get_itens(n,xyztmp,at,nonh,itensl)
-          sgc=0
-          do p=1,nonh
-             !if(itens(p,r)==itens(p,q))then
-             if(itensr(p)==itensl(p))then
-               sgc=sgc+1
-             else
-               exit
-            endif
-          enddo
-          if(sgc.eq.nonh)then
-             group(q)=gc
-             tgc=tgc+1
-          endif
-        enddo
-        if(tgc.gt.1)then
-        write(*,'(a,i0,a,i0,a)')' Equivalent to ',r,'. structure: ' &
-        &                        ,tgc,' structure(s).'
-        endif
-        gc=gc+1        
-      enddo
-      write(*,'(a)')' Done.'
-      write(*,'(a,a,a)')' Appending file <',trim(oname),'> with structures.'
-      write(*,*)
+  gc = 1
+  group = 0
+
+  do r = 1,nall
+    if (group(r) .ne. 0) cycle
+    xyztmp(:,:) = xyz(:,:,r)/bohr
+    call get_itens(n,xyztmp,at,nonh,itensr)
+    do q = 1,nall
+      if (r .eq. q) then
+        group(r) = gc
+        tgc = 1
+        cycle
+      end if
+      xyztmp(:,:) = xyz(:,:,q)/bohr
+      call get_itens(n,xyztmp,at,nonh,itensl)
+      sgc = 0
+      do p = 1,nonh
+        !if(itens(p,r)==itens(p,q))then
+        if (itensr(p) == itensl(p)) then
+          sgc = sgc+1
+        else
+          exit
+        end if
+      end do
+      if (sgc .eq. nonh) then
+        group(q) = gc
+        tgc = tgc+1
+      end if
+    end do
+    if (tgc .gt. 1) then
+      write (*,'(a,i0,a,i0,a)') ' Equivalent to ',r,'. structure: ' &
+      &                        ,tgc,' structure(s).'
+    end if
+    gc = gc+1
+  end do
+  write (*,'(a)') ' Done.'
+  write (*,'(a,a,a)') ' Appending file <',trim(oname),'> with structures.'
+  write (*,*)
 
-      open(newunit=ochan,file='tmp')
+  open (newunit=ochan,file='tmp')
 
-      write(ochan,*)'==================================================='
-      write(ochan,*)'============= ordered structure list =============='
-      write(ochan,*)'==================================================='
-      if(wrscoord)then
-      write(ochan,'(a,a)')' written to <scoord.*> and ',trim(oname)
-      write(ochan,*)
-      write(ochan,'('' scoord.*     ΔE(kcal/mol)   Etot(Eh)'')')
-      else
-      write(ochan,'(a,a,a)')' written to file <',trim(oname),'>'
-      write(ochan,*)
-      write(ochan,'('' structure    ΔE(kcal/mol)   Etot(Eh)'')')
-      endif
+  write (ochan,*) '==================================================='
+  write (ochan,*) '============= ordered structure list =============='
+  write (ochan,*) '==================================================='
+  if (wrscoord) then
+    write (ochan,'(a,a)') ' written to <scoord.*> and ',trim(oname)
+    write (ochan,*)
+    write (ochan,'('' scoord.*     ΔE(kcal/mol)   Etot(Eh)'')')
+  else
+    write (ochan,'(a,a,a)') ' written to file <',trim(oname),'>'
+    write (ochan,*)
+    write (ochan,'('' structure    ΔE(kcal/mol)   Etot(Eh)'')')
+  end if
 
-      open(newunit=ich,file=oname)
-      k=0
-      do j=1,gc-1
-         do r=1,nall
-            if(group(r).eq.j)then
-              k=k+1
-              dE=(eread(r)-eread(1))*627.5095_wp
-              write(ochan,'(i5,6x,F10.2,4x,F14.6)') &
-              & k,dE,eread(r)
-              call wrxyz(ich,n,at,xyz(:,:,r),eread(r))
-              where(group.eq.j)group=0
-              if(wrscoord)then  ! write new scoord.* if necessary
-                write(str,'(''scoord.'',i0)')k
-                call wrc0(trim(str),n,at,xyz(:,:,r))
-              endif
-            else
-              cycle
-            endif
-         enddo
-      enddo
-      close(ich)
-      close(ochan)
+  open (newunit=ich,file=oname)
+  k = 0
+  do j = 1,gc-1
+    do r = 1,nall
+      if (group(r) .eq. j) then
+        k = k+1
+        dE = (eread(r)-eread(1))*627.5095_wp
+        write (ochan,'(i5,6x,F10.2,4x,F14.6)') &
+        & k,dE,eread(r)
+        call wrxyz(ich,n,at,xyz(:,:,r),eread(r))
+        where (group .eq. j) group = 0
+        if (wrscoord) then  ! write new scoord.* if necessary
+          write (str,'(''scoord.'',i0)') k
+          call wrc0(trim(str),n,at,xyz(:,:,r))
+        end if
+      else
+        cycle
+      end if
+    end do
+  end do
+  close (ich)
+  close (ochan)
 
-      gc=gc-1
+  gc = gc-1
 
-      if(nall.ne.gc)then
-        write(*,'(a,i0,a,a,a)')' Initial ',nall,' structures from file ',trim(iname),' have'
-        write(*,'(a,i0,a)')' been reduced to ',gc,' topologically unique structures.'
-      else
-        write(*,'(a,i0,a,a,a)')' All initial ',nall,' structures from file ',trim(iname),' are unique.'
-      endif
+  if (nall .ne. gc) then
+    write (*,'(a,i0,a,a,a)') ' Initial ',nall,' structures from file ',trim(iname),' have'
+    write (*,'(a,i0,a)') ' been reduced to ',gc,' topologically unique structures.'
+  else
+    write (*,'(a,i0,a,a,a)') ' All initial ',nall,' structures from file ',trim(iname),' are unique.'
+  end if
 
-      !deallocate(itens)
-      deallocate(itensl,itensr)
-      deallocate(bond,cn,xyztmp,at,eread,xyz)
-      
-      if(verbose) call cat('tmp')
-      call remove('tmp')
-      !call remove('identify')
+  !deallocate(itens)
+  deallocate (itensl,itensr)
+  deallocate (bond,cn,xyztmp,at,eread,xyz)
+
+  if (verbose) call cat('tmp')
+  call remove('tmp')
+  !call remove('identify')
 
 end subroutine cosort
 
@@ -229,239 +229,238 @@
 !! --------------------------------------------------------------------------------------
 
 subroutine countnonh(nat,iz,n)    !count all non-hydrogen atoms
-      implicit none
-      integer :: nat,iz(nat),n,i
-      n=0
-      do i=1,nat
-         if(iz(i).eq.1)then
-            cycle
-         else
-            n=n+1
-         endif
-      enddo
+  implicit none
+  integer :: nat,iz(nat),n,i
+  n = 0
+  do i = 1,nat
+    if (iz(i) .eq. 1) then
+      cycle
+    else
+      n = n+1
+    end if
+  end do
 end subroutine countnonh
 
 subroutine counth(nat,iz,n)    !count all hydrogen atoms
-      implicit none
-      integer :: nat,iz(nat),n,i
-      n=0
-      do i=1,nat
-         if(iz(i).eq.1)then
-            cycle
-         else
-            n=n+1
-         endif
-      enddo
+  implicit none
+  integer :: nat,iz(nat),n,i
+  n = 0
+  do i = 1,nat
+    if (iz(i) .eq. 1) then
+      cycle
+    else
+      n = n+1
+    end if
+  end do
 end subroutine counth
 
-
 subroutine countnonh2(icn,idarr,n2)
-      implicit none
-      integer :: icn,idarr(icn),n2,i
-      n2=0
-      do i=1,icn
-         if(idarr(i).eq.1)then
-            cycle
-         else
-            n2=n2+1
-         endif
-      enddo
+  implicit none
+  integer :: icn,idarr(icn),n2,i
+  n2 = 0
+  do i = 1,icn
+    if (idarr(i) .eq. 1) then
+      cycle
+    else
+      n2 = n2+1
+    end if
+  end do
 end subroutine countnonh2
 
 !! --------------------------------------------------------------------------------------
 !  build an identifier tensor for a single molecule
 !! --------------------------------------------------------------------------------------
 subroutine get_itens(n,xyz,at,ni,itens)
-      use crest_parameters
-      implicit none
-      integer,intent(in)  :: n                    ! number of atoms
-      integer,intent(in)  :: ni                   ! number of elements in the identifier
-      real(wp),intent(in) :: xyz(3,n)             ! coordinates in Bohrs
-      integer,intent(in)  :: at(n)                ! integer atom types
-      character(len=10),intent(out) :: itens(ni)  ! Identifier
-      integer :: ntopo
-      integer,allocatable :: topo(:)
-      character(len=10) :: ident
-      integer :: p
-      itens=''
-      ntopo = n*(n+1)/2
-      allocate(topo(ntopo))
-      call quicktopo(n,at,xyz,ntopo,topo)
-      do p=1,ni
-        call analyze_neighbours(p,xyz,at,n,ntopo,topo,ident)
-        itens(p)=ident
-      enddo
-      deallocate(topo)
-      return
+  use crest_parameters
+  implicit none
+  integer,intent(in)  :: n                    ! number of atoms
+  integer,intent(in)  :: ni                   ! number of elements in the identifier
+  real(wp),intent(in) :: xyz(3,n)             ! coordinates in Bohrs
+  integer,intent(in)  :: at(n)                ! integer atom types
+  character(len=10),intent(out) :: itens(ni)  ! Identifier
+  integer :: ntopo
+  integer,allocatable :: topo(:)
+  character(len=10) :: ident
+  integer :: p
+  itens = ''
+  ntopo = n*(n+1)/2
+  allocate (topo(ntopo))
+  call quicktopo(n,at,xyz,ntopo,topo)
+  do p = 1,ni
+    call analyze_neighbours(p,xyz,at,n,ntopo,topo,ident)
+    itens(p) = ident
+  end do
+  deallocate (topo)
+  return
 end subroutine get_itens
 
 !! --------------------------------------------------------------------------------------
 !  modified version of the neighbours subroutine in select.f
 !! --------------------------------------------------------------------------------------
 subroutine analyze_neighbours(i,xyz,iat,nat,ntopo,topo,ident)
-      use crest_parameters
-      implicit none
-      integer,intent(in)  :: i
-      real(wp),intent(in) :: xyz(3,nat)
-      integer,intent(in)  :: iat(nat)
-      integer,intent(in)  :: nat
-      integer,intent(in) :: ntopo
-      integer,intent(in) :: topo(ntopo)
-      character(len=10),intent(inout) :: ident
-      integer  :: j,k,l,icn,n2
-      integer :: lin !this is a function
-      integer,allocatable :: idarr(:),neighb(:)
-      character(len=10) :: str
-      character(len=9) :: str2     
-      character(len=1) :: chiral
-      logical :: chiralC,chiralX
-      chiralC=.false.
-      chiralX=.false.
-      l=0
-      ident=''
-      icn=0
-      do k=1,nat
-         j=lin(i,k)
-         if(topo(j)==1)icn=icn+1
-      enddo
-      allocate(idarr(icn),neighb(icn))                           !identifier array contains atoms
-      l=0
-      do k=1,nat
-         j=lin(i,k)
-         if(topo(j)==1)then
-             l=l+1
-             neighb(l)=k
-             idarr(l)=iat(k)
-         endif
-      enddo
+  use crest_parameters
+  use utilities,only:lin
+  implicit none
+  integer,intent(in)  :: i
+  real(wp),intent(in) :: xyz(3,nat)
+  integer,intent(in)  :: iat(nat)
+  integer,intent(in)  :: nat
+  integer,intent(in) :: ntopo
+  integer,intent(in) :: topo(ntopo)
+  character(len=10),intent(inout) :: ident
+  integer  :: j,k,l,icn,n2
+  integer,allocatable :: idarr(:),neighb(:)
+  character(len=10) :: str
+  character(len=9) :: str2
+  character(len=1) :: chiral
+  logical :: chiralC,chiralX
+  chiralC = .false.
+  chiralX = .false.
+  l = 0
+  ident = ''
+  icn = 0
+  do k = 1,nat
+    j = lin(i,k)
+    if (topo(j) == 1) icn = icn+1
+  end do
+  allocate (idarr(icn),neighb(icn))                           !identifier array contains atoms
+  l = 0
+  do k = 1,nat
+    j = lin(i,k)
+    if (topo(j) == 1) then
+      l = l+1
+      neighb(l) = k
+      idarr(l) = iat(k)
+    end if
+  end do
 
-      call idwrite(icn,idarr,str)                   !write the identifier sorted by atom number (hydrogen first, then heavy atoms)
-      ident=trim(str)                               !i.e., idarr(1) should be a hydrogen if there are hydrogen bound to atom i
-      
-      !Check if (pseudo-)chirality has to be determined for atom i
-      if((iat(i).eq.6).and.(icn.eq.4))then     !for carbon
-         chiralC=.true.
-         call countnonh2(icn,idarr,n2)
-         !if((idarr(1).eq.idarr(2)).and.(iat(idarr(1)).eq.1))then !methyl and ehtyl group workaround
-         !   chiralC=.false.
-         if(n2.le.2)then                                          !methyl and ehtyl group workaround
-            chiralC=.false.
-         endif
-      endif
-      if((iat(i).ne.6).and.(icn.ge.3))then     !for other heavy atoms
-         chiralX=.true.
-         call countnonh2(icn,idarr,n2)
-         if((icn-n2).gt.1)then                     !if more than one hydrogen are present don't use the chirality identifier
-            chiralX=.false.                        !because the results might differ (hydrogen order not fixed in the coordinates)
-         endif
-         if((icn.eq.3).and.(iat(i).eq.7))chiralX=.false. !special case nitrogen because of the low inversion barrier
-         !write(*,*) icn,iat(i)
-      endif
- 
-      if(chiralC.or.chiralX)then                    !add a (pseudo-)chirality identifier (+ or -)
-         chiral=''
-         call chispat(i,icn,neighb,nat,xyz,chiral)
-         str2=trim(ident)
-         write(ident,'(a,a)')trim(str2),trim(chiral)
-         chiralC=.false.
-         chiralX=.false.
-      endif
- 
-      deallocate(neighb,idarr)
+  call idwrite(icn,idarr,str)                   !write the identifier sorted by atom number (hydrogen first, then heavy atoms)
+  ident = trim(str)                               !i.e., idarr(1) should be a hydrogen if there are hydrogen bound to atom i
+
+  !Check if (pseudo-)chirality has to be determined for atom i
+  if ((iat(i) .eq. 6).and.(icn .eq. 4)) then     !for carbon
+    chiralC = .true.
+    call countnonh2(icn,idarr,n2)
+    !if((idarr(1).eq.idarr(2)).and.(iat(idarr(1)).eq.1))then !methyl and ehtyl group workaround
+    !   chiralC=.false.
+    if (n2 .le. 2) then                                          !methyl and ehtyl group workaround
+      chiralC = .false.
+    end if
+  end if
+  if ((iat(i) .ne. 6).and.(icn .ge. 3)) then     !for other heavy atoms
+    chiralX = .true.
+    call countnonh2(icn,idarr,n2)
+    if ((icn-n2) .gt. 1) then                     !if more than one hydrogen are present don't use the chirality identifier
+      chiralX = .false.                        !because the results might differ (hydrogen order not fixed in the coordinates)
+    end if
+    if ((icn .eq. 3).and.(iat(i) .eq. 7)) chiralX = .false. !special case nitrogen because of the low inversion barrier
+    !write(*,*) icn,iat(i)
+  end if
+
+  if (chiralC.or.chiralX) then                    !add a (pseudo-)chirality identifier (+ or -)
+    chiral = ''
+    call chispat(i,icn,neighb,nat,xyz,chiral)
+    str2 = trim(ident)
+    write (ident,'(a,a)') trim(str2),trim(chiral)
+    chiralC = .false.
+    chiralX = .false.
+  end if
+
+  deallocate (neighb,idarr)
 end subroutine analyze_neighbours
 
 !! --------------------------------------------------------------------------------------
 !  idwrite writing ordered identifier
 !! --------------------------------------------------------------------------------------
 subroutine idwrite(n,arr,str)
-      use strucrd, only: i2e
-      implicit none
-      integer :: n,arr(n)
-      integer :: i
-      character(len=*) :: str
-      character(len=6) :: dummy
-      call quicksort(n,arr)
-      str=''
-      do i=1,n
-         dummy=trim(str)
-         write(str,'(a,a)')trim(dummy),trim(i2e(arr(i)))
-      enddo      
+  use strucrd,only:i2e
+  implicit none
+  integer :: n,arr(n)
+  integer :: i
+  character(len=*) :: str
+  character(len=6) :: dummy
+  call quicksort(n,arr)
+  str = ''
+  do i = 1,n
+    dummy = trim(str)
+    write (str,'(a,a)') trim(dummy),trim(i2e(arr(i)))
+  end do
 end subroutine idwrite
 
 !! --------------------------------------------------------------------------------------
 !  chispat -  chirality identifier by using a spat product
 !! --------------------------------------------------------------------------------------
 subroutine chispat(c,icn,neighb,nat,xyz,chiral)
-      use crest_parameters
-      implicit none
-      integer  :: c
-      integer  :: nat
-      integer  :: icn
-      integer  :: neighb(icn)
-      real(wp) :: xyz(3,nat)
-      character(len=*) :: chiral
+  use crest_parameters
+  implicit none
+  integer  :: c
+  integer  :: nat
+  integer  :: icn
+  integer  :: neighb(icn)
+  real(wp) :: xyz(3,nat)
+  character(len=*) :: chiral
 
-      integer :: i,j,k
-      real(wp),allocatable :: xyz2(:,:)
-      real(wp) :: mat(3,3)
-      real(wp) :: sig
+  integer :: i,j,k
+  real(wp),allocatable :: xyz2(:,:)
+  real(wp) :: mat(3,3)
+  real(wp) :: sig
 
-      allocate(xyz2(3,icn))
+  allocate (xyz2(3,icn))
 
-      chiral=''
+  chiral = ''
 
-      !build xyz2 according to atom order of the coordinates. These loops are important since the
-      !matrix for the triple product always has to contain the same vectors in the same order.
-      xyz2=0
-      k=0
-      do i=1,nat
-         do j=1,icn
-            if(i.eq.neighb(j))then
-               k=k+1
-               xyz2(:,k)=(xyz(:,neighb(j)))-xyz(:,c)         !move coordinate system according to atom c
-               xyz2(:,k)=xyz2(:,k)/sqrt(sum(xyz2(1:3,k)**2))
-             endif
-         enddo
-      enddo
+  !build xyz2 according to atom order of the coordinates. These loops are important since the
+  !matrix for the triple product always has to contain the same vectors in the same order.
+  xyz2 = 0
+  k = 0
+  do i = 1,nat
+    do j = 1,icn
+      if (i .eq. neighb(j)) then
+        k = k+1
+        xyz2(:,k) = (xyz(:,neighb(j)))-xyz(:,c)         !move coordinate system according to atom c
+        xyz2(:,k) = xyz2(:,k)/sqrt(sum(xyz2(1:3,k)**2))
+      end if
+    end do
+  end do
 
-      !calculate triple product to determine (pseudo-)chirality
-      mat=0
-      sig=0
-      mat(:,1)=xyz2(:,1)
-      mat(:,2)=xyz2(:,2)
-      mat(:,3)=xyz2(:,3)
-      if(icn.ge.4)then
-         do j=4,icn
-            mat(:,3)=mat(:,3)-xyz2(:,j)
-         enddo
-      endif
-      call det3x3(mat,sig)
-      !write(*,*)sig
+  !calculate triple product to determine (pseudo-)chirality
+  mat = 0
+  sig = 0
+  mat(:,1) = xyz2(:,1)
+  mat(:,2) = xyz2(:,2)
+  mat(:,3) = xyz2(:,3)
+  if (icn .ge. 4) then
+    do j = 4,icn
+      mat(:,3) = mat(:,3)-xyz2(:,j)
+    end do
+  end if
+  call det3x3(mat,sig)
+  !write(*,*)sig
 
-      if(sig.lt.0)then
-         chiral='-'
-      else
-         chiral='+'
-      endif
+  if (sig .lt. 0) then
+    chiral = '-'
+  else
+    chiral = '+'
+  end if
 
-      deallocate(xyz2)
+  deallocate (xyz2)
 
 end subroutine chispat
 
 !! --------------------------------------------------------------------------------------
 
 subroutine det3x3(m,detval)
-      use crest_parameters, only: wp
-      implicit none
-      real(wp) :: detval
-      real(wp) :: m(3,3)
-      real(wp) :: vec(3)
-      
-      vec(1)=(m(2,1)*m(3,2))-(m(3,1)*m(2,2))
-      vec(2)=(m(3,1)*m(1,2))-(m(1,1)*m(3,2))
-      vec(3)=(m(1,1)*m(2,2))-(m(2,1)*m(1,2))
+  use crest_parameters,only:wp
+  implicit none
+  real(wp) :: detval
+  real(wp) :: m(3,3)
+  real(wp) :: vec(3)
+
+  vec(1) = (m(2,1)*m(3,2))-(m(3,1)*m(2,2))
+  vec(2) = (m(3,1)*m(1,2))-(m(1,1)*m(3,2))
+  vec(3) = (m(1,1)*m(2,2))-(m(2,1)*m(1,2))
 
-      detval=(vec(1)*m(1,3))+(vec(2)*m(2,3))+(vec(3)*m(3,3))
+  detval = (vec(1)*m(1,3))+(vec(2)*m(2,3))+(vec(3)*m(3,3))
 
 end subroutine det3x3
 
@@ -469,81 +468,80 @@
 !  identification of methyl groups
 !! ------------------------------------------------------------------
 subroutine methyl_autocomplete(n,xyz,at,equiv)
-      use crest_parameters, only: wp
-      implicit none
-      integer,intent(in)  :: n                    ! number of atoms
-      real(wp),intent(in) :: xyz(3,n)             ! coordinates
-      integer,intent(in)  :: at(n)                ! integer atom types
-      integer,allocatable :: eqv(:,:)
-      integer,intent(inout) :: equiv(n+1,n)
+  use crest_parameters,only:wp
+  implicit none
+  integer,intent(in)  :: n                    ! number of atoms
+  real(wp),intent(in) :: xyz(3,n)             ! coordinates
+  integer,intent(in)  :: at(n)                ! integer atom types
+  integer,allocatable :: eqv(:,:)
+  integer,intent(inout) :: equiv(n+1,n)
 
-      integer :: i,m
-       allocate(eqv(n,3))
-       call get_methyl(n,xyz,at,eqv)
+  integer :: i,m
+  allocate (eqv(n,3))
+  call get_methyl(n,xyz,at,eqv)
 
-       do i=1,n
-          if(eqv(i,1).gt.0)then
-             m=equiv(1,i)
-             if(m.le.1)then
-                equiv(1,i)=3
-                equiv(2:4,i)=eqv(i,1:3)
-             endif
-          endif
-       enddo
- 
-       deallocate(eqv)
+  do i = 1,n
+    if (eqv(i,1) .gt. 0) then
+      m = equiv(1,i)
+      if (m .le. 1) then
+        equiv(1,i) = 3
+        equiv(2:4,i) = eqv(i,1:3)
+      end if
+    end if
+  end do
+
+  deallocate (eqv)
 end subroutine methyl_autocomplete
 
-
 subroutine get_methyl(n,xyz,at,eqv)
-      use crest_parameters, only: wp
-      implicit none
-      integer,intent(in)  :: n                    ! number of atoms
-      real(wp),intent(in) :: xyz(3,n)             ! coordinates
-      integer,intent(in)  :: at(n)                ! integer atom types
-      integer,intent(inout) :: eqv(n,3)
+  use crest_parameters,only:wp
+  implicit none
+  integer,intent(in)  :: n                    ! number of atoms
+  real(wp),intent(in) :: xyz(3,n)             ! coordinates
+  integer,intent(in)  :: at(n)                ! integer atom types
+  integer,intent(inout) :: eqv(n,3)
 
-      real(wp),allocatable :: cn(:)
-      real(wp),allocatable :: bond(:,:)
+  real(wp),allocatable :: cn(:)
+  real(wp),allocatable :: bond(:,:)
 
-      integer :: p,nonh
-      integer :: a,b,c
+  integer :: p,nonh
+  integer :: a,b,c
 
-      logical :: meth
-      integer :: nmeth
-      integer :: hyd(3)
+  logical :: meth
+  integer :: nmeth
+  integer :: hyd(3)
 
-      allocate(cn(n),bond(n,n))
+  allocate (cn(n),bond(n,n))
 
-      call countnonh(n,at,nonh) ! get number of non-Hydrogen atoms
+  call countnonh(n,at,nonh) ! get number of non-Hydrogen atoms
 
-      cn=0.0d0
-      bond=0.0d0
-      call xcoord(n,at,xyz,cn,bond)
-      
-      eqv=0
+  cn = 0.0d0
+  bond = 0.0d0
+  call xcoord(n,at,xyz,cn,bond)
+
+  eqv = 0
 
-      nmeth=0
-      do p=1,n                                 
-        if(at(p).ne.6) cycle !only check for carbon
-        call methyl(p,at,n,cn,bond,meth,hyd)
-        !if(meth)nmeth=nmeth+1
-        if(meth)then
-          a=hyd(1)
-          b=hyd(2)
-          c=hyd(3)
-          eqv(a,1) = a
-          eqv(a,2) = b
-          eqv(a,3) = c
-          eqv(b,1) = b
-          eqv(b,2) = c
-          eqv(b,3) = a
-          eqv(c,1) = c
-          eqv(c,2) = a
-          eqv(c,3) = b
-        endif
-      enddo
-      deallocate(bond,cn)
+  nmeth = 0
+  do p = 1,n
+    if (at(p) .ne. 6) cycle !only check for carbon
+    call methyl(p,at,n,cn,bond,meth,hyd)
+    !if(meth)nmeth=nmeth+1
+    if (meth) then
+      a = hyd(1)
+      b = hyd(2)
+      c = hyd(3)
+      eqv(a,1) = a
+      eqv(a,2) = b
+      eqv(a,3) = c
+      eqv(b,1) = b
+      eqv(b,2) = c
+      eqv(b,3) = a
+      eqv(c,1) = c
+      eqv(c,2) = a
+      eqv(c,3) = b
+    end if
+  end do
+  deallocate (bond,cn)
 
 end subroutine get_methyl
 
@@ -551,43 +549,43 @@
 !! --------------------------------------------------------------------------------------
 
 subroutine methyl(i,iat,nat,cn,bond,meth,hydrogens)
-      use crest_parameters, only: wp
-      implicit none
-      integer,intent(in)  :: i
-      integer,intent(in)  :: iat(nat)
-      integer,intent(in)  :: nat
-      real(wp),intent(in) :: cn(nat)
-      real(wp),intent(inout) :: bond(nat,nat)
-      logical,intent(out) :: meth
-      integer,intent(out) :: hydrogens(3)
-      integer  :: j
-      integer  :: icn
-      integer  :: k,l
-      integer  :: nhyd
-      integer,allocatable :: neighb(:)
-      meth=.false.
-      hydrogens(1:3)=0
-      l=0
-      icn=floor(cn(i))
-      allocate(neighb(icn))                           !identifier array contains atoms
-      nhyd=0
-      do k=1,icn
-         j=maxloc(bond(:,i),1)
-         bond(j,i)=0.0d0
-         neighb(k)=j
-         if(iat(j).eq.1)nhyd=nhyd+1
-      enddo
-      if((icn.eq.4).and.(nhyd.eq.3))then
-        !write(*,*) neighb
-        meth=.true.
-        do k=1,icn
-           j=neighb(k)
-           !write(*,*) j,iat(j)
-           if(iat(j).eq.1)then
-              hydrogens(nhyd)=j
-              nhyd=nhyd-1
-           endif
-        enddo
-        !write(*,*) hydrogens
-      endif
+  use crest_parameters,only:wp
+  implicit none
+  integer,intent(in)  :: i
+  integer,intent(in)  :: iat(nat)
+  integer,intent(in)  :: nat
+  real(wp),intent(in) :: cn(nat)
+  real(wp),intent(inout) :: bond(nat,nat)
+  logical,intent(out) :: meth
+  integer,intent(out) :: hydrogens(3)
+  integer  :: j
+  integer  :: icn
+  integer  :: k,l
+  integer  :: nhyd
+  integer,allocatable :: neighb(:)
+  meth = .false.
+  hydrogens(1:3) = 0
+  l = 0
+  icn = floor(cn(i))
+  allocate (neighb(icn))                           !identifier array contains atoms
+  nhyd = 0
+  do k = 1,icn
+    j = maxloc(bond(:,i),1)
+    bond(j,i) = 0.0d0
+    neighb(k) = j
+    if (iat(j) .eq. 1) nhyd = nhyd+1
+  end do
+  if ((icn .eq. 4).and.(nhyd .eq. 3)) then
+    !write(*,*) neighb
+    meth = .true.
+    do k = 1,icn
+      j = neighb(k)
+      !write(*,*) j,iat(j)
+      if (iat(j) .eq. 1) then
+        hydrogens(nhyd) = j
+        nhyd = nhyd-1
+      end if
+    end do
+    !write(*,*) hydrogens
+  end if
 end subroutine methyl
Index: src/choose_settings.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!> The routines contained here take care of setting MTD runtimes\n!> and how to set corresponding bias parameters.\n!> Naturally, this is quite imporant for the overall performance of CREST\n\n!=========================================================================================!\n!=========================================================================================!\nsubroutine md_length_setup(env)\n!***********************************************************\n!* set the total run time according to flexibility measures\n!***********************************************************\n  use crest_parameters\n  use crest_data\n  use strucrd\n  use zdata, only:readwbo\n  implicit none\n  !> IN/OUTPUT\n  type(systemdata) :: env    !> MAIN STORAGE OS SYSTEM DATA\n  !> LOCAL\n  real(wp) :: total,minimum,lenthr\n  real(wp) :: flex,av1,rfac,nciflex\n  type(coord) :: mol \n  logical :: ex\n!> get reference geometry  \n  call env%ref%to( mol ) \n\n!> at least 5ps per MTD\n  minimum = 5.0d0\n!> Maximum of 200 ps, longer runs can only be conducted by user input\n  lenthr = 200.0d0\n\n  call smallhead('Generating MTD length from a flexibility measure')\n\n  if ((env%crestver .ne. crest_solv).and..not.env%NCI) then\n    write(stdout,'(1x,a)',advance='no') 'Calculating GFN0-xTB WBOs   ...'\n!>-- xtb singlepoint to get WBOs (always GFN0)\n    call xtbsp(env,0)\n    write (stdout,'(1x,a)') 'done.'\n!>-- save those WBOs to the reference\n    inquire(file='wbo',exist = ex)\n    if(ex)then\n    if(.not.allocated(env%ref%wbo)) allocate(env%ref%wbo( mol%nat, mol%nat), source=0.0_wp)   \n    call readwbo('wbo',mol%nat, env%ref%wbo)\n    endif\n\n!>-- covalent flexibility measure based on WBO and structure only\n    call flexi( mol, env%rednat, env%includeRMSD, flex)\n!>-- NCI flexi based on E(HB)/Nat and E(disp)/Nat\n    call nciflexi(env,nciflex)\n    write (stdout,'(1x,''    covalent flexibility measure :'',f8.3)') flex\n    write (stdout,'(1x,''non-covalent flexibility measure :'',f8.3)') nciflex\n!>-- the NCI flex is only relevant if the covalent framework is flexible\n    flex = 0.5*flex+0.5*nciflex*sqrt(flex)\n\n    if (env%entropic) then\n!>--- special case for entropy mode that depends more strongly on the flexibility than on size\n!>--- -8 accounts for small systems having no conf.\n      av1 = (flex**1.333333)*max(1,env%rednat-8)\n!>--- Maximum of 3000 ps, longer runs can only be conducted by user input\n      lenthr = 3000.0d0\n!>--- minimum is 5 ps set above\n      env%tmtd = 4.50d0*exp(0.165d0*av1)\n    else\n!>--- normal case\n      av1 = (flex**1.000000)*max(1,env%rednat-8)\n!>--- Maximum of 500 ps\n      lenthr = 500.0d0\n      env%tmtd = 3.0d0*exp(0.10d0*av1)\n    end if\n  else\n    write (stdout,'(1x,\"System flexiblity is set to 1.0 for NCI mode\")')\n    flex = 1.0d0\n    env%tmtd = 0.10*(env%rednat+0.1*env%rednat*env%rednat)\n  end if\n  env%flexi = flex\n  write (stdout,'(1x,''flexibility measure :'',f8.3)') env%flexi\n\n!>-- rfac is used to scale the total MD length according to special runtypes\n  total = max(minimum,env%tmtd)\n  select case (env%runver)\n  case (2,5,6,33)   !> \"-quick\",\"-squick\",\"-mquick\"\n    rfac = 0.5d0\n  case (3)          !> \"-qcg\"\n    rfac = 0.25d0\n  case (77)\n    rfac = 1.50d0\n  case (8)\n    rfac = 2.0d0\n  case (787878)\n    rfac = 14.0d0/float(env%nmetadyn)\n  case default  !> everything else 1=default, 4=NCI\n    rfac = 1.0d0\n  end select\n!>-- additional user set scaling\n  if (env%scallen) then\n    write (stdout,'(1x,''t(MTD) based on flexibility :'',  f8.1)') env%tmtd*rfac\n    rfac = env%mdlenfac*rfac\n    write (stdout,'(1x,''MTD length is scaled by     :'',  f6.3)') env%mdlenfac\n  end if\n\n!>-- ONLY use generated MD length if not already set by the user\n  if (env%mdtime .le. 0.0d0) then\n    if (total .gt. lenthr) then\n      total = lenthr\n      call mtdwarning(lenthr*rfac)\n    end if\n    env%mdtime = anint(total)*rfac\n  else\n    write (stdout,'(1x,''t(MTD) / ps set by command line  :'',  f8.1)') env%mdtime\n  end if\n\n  write (stdout,'(1x,''t(MTD) / ps    :'',  f8.1)') env%mdtime\n  write (stdout,'(1x,''Σ(t(MTD)) / ps :'',  f8.1,'' ('',i0,'' MTDs)'')') &\n  & env%mdtime*float(env%nmetadyn),env%nmetadyn\n\n!> A MTD Vbias snapshot is taken every 1 ps\n  env%metadlist(:) = ceiling(env%mdtime)\n\n  return\nend subroutine md_length_setup\n\n!========================================================================================!\n!========================================================================================!\nsubroutine defaultGF(env)\n!************************************************************\n!* Setmetadynamics default Guiding Force Parameter\n!* There are different combinations depending on the runtype\n!************************************************************\n  use crest_parameters \n  use crest_data\n  use filemod\n  implicit none\n  !> IN/OUTPUT\n  type(systemdata) :: env\n  !> LOCAL\n  integer  :: ia,ik,na,nk,m,nmtdyn,nmtdynmax,nrem\n  real(wp) :: alp,k\n  real(wp) :: kstart,kinc\n  real(wp) :: alpinc\n  type(filetype) :: biasfile\n  logical :: ex\n  integer :: i,io\n  character(len=:),allocatable :: atmp\n\n  nrem = 0\n\n  if (.not.env%metadynset) then\n!+++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n    if (env%readbias) then\n!+++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n      inquire (file='mtdbias',exist=ex)\n      if (ex) then\n        atmp = ''\n        call biasfile%open('mtdbias')\n        call biasfile%clearblanks()\n        nmtdyn = biasfile%nlines\n        call env%allocate(nmtdyn)\n        do i = 1,nmtdyn\n          atmp = getlarg(biasfile%line(i),1)\n          read (atmp,*,iostat=io) k\n          if (io == 0) then\n            env%metadfac(i) = k*env%rednat\n          end if\n          atmp = getlarg(biasfile%line(i),2)\n          read (atmp,*,iostat=io) alp\n          if (io == 0) then\n            env%metadexp(i) = alp\n          end if\n        end do\n        !write(*,*) env%metadfac\n        !write(*,*) env%metadexp\n      else\n        error stop \"no file 'mtdbias'\"\n      end if\n!+++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n    else\n!+++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n      select case (env%runver)\n!---------- \"-quick\",\"-squick\"\n      case (2,5) \n        na = 3\n        nk = 2\n        nmtdyn = na*nk\n        alp = 1.2d0 ! start value alpha\n        kstart = 0.002d0 ! start value k\n        alpinc = 2.0 ! increment\n        kinc = 2.0     ! increment\n!---------- \"-mquick\"\n      case (6) \n        na = 3\n        nk = 2\n        nmtdyn = na*nk\n        alp = 1.0d0 ! start value alpha\n        kstart = 0.002d0 ! start value k\n        alpinc = 2.0 ! increment\n        kinc = 2.0     ! increment\n!---------- \"-qcg\"\n      case (3) \n        na = 4\n        nk = 3\n        nmtdyn = na*nk\n        alp = 1.0d0 ! start value alpha\n        kstart = 0.00125d0 ! start value k\n        alpinc = (3./2.) ! increment\n        kinc = (3./2.)   ! increment\n!---------- \"-nci\"\n      case (4) \n        na = 3\n        nk = 2\n        nmtdyn = na*nk\n        alp = 1.0d0 ! start value alpha\n        kstart = 0.001d0 ! start value k\n        alpinc = 2.0 ! increment\n        kinc = 2.0     ! increment\n!---------- \"-singlerun\"\n      case (45) \n        na = 1\n        nk = 1\n        nmtdyn = na*nk\n        alp = 1.0d0 ! start value alpha\n        kstart = 0.001d0 ! start value k\n        alpinc = 2.0 ! increment\n        kinc = 2.0     ! increment\n!---------- \"-relax\"\n      case (33)\n        na = 1\n        nk = 3\n        nmtdyn = na*nk\n        alp = 0.8d0 ! start value alpha\n        kstart = 0.0030 ! start value k\n        alpinc = 2.0 ! increment\n        kinc = 2.0     ! increment\n!---------- \"-compress\"\n      case (77) \n        na = 3\n        nk = 3\n        nmtdyn = na*nk\n        alp = 1.61803 ! start value alpha\n        kstart = 0.005d0 ! start value k\n        alpinc = 1.61803 ! increment\n        kinc = 2.0     ! increment\n!--------- \"search_1\"\n      case (crest_s1,crest_mecp) \n        na = 3\n        nk = 3\n        nmtdyn = (na*nk)\n        alp = 1.61803 ! start value alpha\n        kstart = 0.0075d0 ! start value k\n        alpinc = 1.61803 ! increment\n        kinc = 2.0     ! increment\n!---------- \"-nmtd <x>\"\n      case (787878)\n        call gfdistribute(env%nmetadyn,nk,na,nrem)\n        nmtdyn = na*nk !> nrem will be substracted at the end\n        alp = 1.3 ! start value alpha\n        kstart = 0.0050 ! start value k\n        alpinc = (5./3.) ! increment\n        kinc = 1.5d0     ! increment\n!---------- \"-entropy\"\n      case (111) \n        na = 6\n        nk = 4\n        nmtdyn = (na*nk)\n        alp = 1.61803 ! start value alpha\n        kstart = 0.0075d0 ! start value k\n        alpinc = 1.61803 ! increment\n        kinc = 2.0     ! increment\n!---------- default\n      case default\n        if (env%iterativeV2) then  !for the default iterative mode\n          !=======================================================!\n          na = 4\n          nk = 3\n          nrem = 0\n          nmtdyn = (na*nk)+2\n          call env%allocate(nmtdyn)   !allocate k(Vbias) and α(Vbias)\n          alp = 1.3 ! start value alpha\n          kstart = 0.0030 ! start value k\n          alpinc = (5./3.) ! increment\n          kinc = 2.0     ! increment\n\n          !-- two additional MTDs with extreme values\n          env%metadfac(nmtdyn-1) = 0.001*env%rednat\n          env%metadexp(nmtdyn-1) = 0.1\n\n          env%metadfac(nmtdyn) = 0.005*env%rednat\n          env%metadexp(nmtdyn) = 0.8\n          !=======================================================!\n        else  !for the non-iterative mode\n          !=======================================================!\n          na = 6\n          nk = 4\n          nmtdyn = na*nk\n          alp = 1.3 ! start value alpha\n          kstart = 0.003d00 ! start value k\n          alpinc = (4./3.) ! increment\n          kinc = (3./2.)     ! increment\n          !======================================================!\n        end if\n      end select\n!>---- settings are generated here\n      m = 0\n      nmtdynmax = nmtdyn-nrem\n      call env%allocate(nmtdynmax)   !allocate k(Vbias) and α(Vbias)\n      do ia = 1,na\n        k = kstart  ! start value k\n        do ik = 1,nk\n          m = m+1\n          if (m > nmtdynmax) cycle !> skip the last nrem setups\n          env%metadfac(m) = k*env%rednat\n          env%metadexp(m) = alp\n          k = k/kinc ! increment\n        end do\n        alp = alp/alpinc ! increment\n      end do\n!+++++++++++++++++++++++++++++++++++++++++++++++++++++!\n    end if\n!+++++++++++++++++++++++++++++++++++++++++++++++++++++!\n  end if\n  return\n!====================================================================!\ncontains\n!====================================================================!\n\n  subroutine gfdistribute(nsoll,k,a,rem)\n!**********************************************************\n!* subroutine gfdistribute\n!* for a given number of requested MTDs (nsoll),\n!* specify the number of different kpush (k) and\n!* alpha (a) values, and from the product (k*a),\n!* determine how many MTDs have to be neglected (nrem).\n!* I.e.,\n!*        (k*a)-nrem = nsoll\n!*\n!**********************************************************\n    implicit none\n    integer,intent(in) :: nsoll\n    integer,intent(out) :: k,a,rem\n    real(wp) :: nn,nsq\n    k = 1\n    a = 1\n    rem = 0\n    if (nsoll < 1) then\n      error stop 'MTD setup failure.'\n    end if\n    nn = float(nsoll)\n    nsq = sqrt(nn)\n    a = ceiling(nsq)\n    k = nint(nsq)\n    rem = abs(nsoll-(a*k))\n    return\n  end subroutine gfdistribute\nend subroutine defaultGF\n\n!=========================================================================================!\n!=========================================================================================!\nsubroutine adjustnormmd(env)\n!*************************************************************************\n!* Dynamically determine the number of normMDs and settings of staticMTDs\n!* Set their number and the different temperatures.\n!* Defaults for the static MTDs are more lengthy...\n!*************************************************************************\n  use crest_parameters\n  use crest_data\n  implicit none\n  !> IN/OUTPUT\n  type(systemdata) :: env\n  !> LOCAL\n  integer :: ndum\n\n  if (env%rotamermds) then\n!>--- first the number of normMDs on low conformers\n    if (env%nrotammds .le. 0) then !> if no user input was set\n      !> multiple short MDs, which has a better parallel efficiency\n      !> default is 4 \n      env%nrotammds = max(1,nint(float(env%nmetadyn)/4.0d0)) \n    end if\n\n!>--- then the temperature range\n    if (env%temps .le. 0) then\n      !> at how many different temperatures? \n      !> starting at 400k and increasing 100K for each (200 K for -entropy mode)\n      env%temps = 2\n      if (env%entropic) then\n        env%temps = 1\n      end if\n    end if\n!>--- total number of NORMMDs is temps*nrotammds\n  end if\n\n!==============================================!\n!>--- settings for static MTDS in entropy mode\n!==============================================!\n  if (env%entropymd) then \n    env%emtd%iter = 20    !> max number of iterations\n    env%emtd%nbias = min(150,nint(env%tmtd/4)) !> max number of bias structures\n    env%emtd%nbiasgrow = min(1.4d0,1.2d0+env%tmtd*1.d-3) !> increase of nBias in each cycle\n    env%emtd%nMDs = 36          !> number of static MTDs\n    env%emtd%lenfac = 0.5d0     !> length (relativ to regular MTDs)\n    env%emtd%temperature = env%nmdtemp !> sMTD temperature (default 600 K)\n    env%emtd%kpush = 1.d-4+env%tmtd*1.0d-6   !> kpush constant PER ATOM, a bit more for flexible systems 1.d-4+env%tmtd*1.d-6 1.5 zu viel, 0.5 zu wenig\n    env%emtd%alpha = 1.0d0        !> some alpha\n    env%emtd%mtdramp = 0.015d0    !> parameter to control how \"fast\" bias is applied in MTD\n    if (env%crestver == crest_imtd) then\n      if (env%emtd%confthr < 0.0d0) then\n        env%emtd%confthr = 0.02d0    !> if we gain less than x% NEW conformers, exit\n      end if\n      if (env%emtd%sconvthr < 0.0d0) then\n        env%emtd%sconvthr = 0.005d0   !> if we gain less than x% NEW entropy, exit\n      end if\n    end if\n\n    if (env%nmdtemp < 0.d0) then   !> if temperature is not set by the user\n      env%nmdtemp = 600.0d0\n    end if\n\n!>--- for the new alternative iMTD-sMTD runtype, re-adjust settings\n    if (env%crestver == crest_imtd2) then\n      ndum = 2\n      env%emtd%nklist = ndum\n      allocate (env%emtd%klist(ndum))\n      env%emtd%klist(1) = env%emtd%kpush\n      env%emtd%klist(2) = env%emtd%kpush*2.5d0\n      env%emtd%nMDs = 12           !> number of static MTDs\n      env%emtd%lenfac = 0.5d0      !> half the length because we have 2 kpush\n      if (env%emtd%confthr < 0.0d0) then\n        env%emtd%confthr = 0.05d0  !> if we gain less than x% NEW conformers, exit\n      end if\n      if (env%emtd%sconvthr < 0.0d0) then\n        env%emtd%sconvthr = 0.01d0  !> if we gain less than x% NEW entropy, exit\n      end if\n    end if\n\n!>--- Exclude atoms from static MTD bias\n    env%emtd%rmax = 0    !> ignore small rings up to this size in bias\n    call mtdatoms(env)\n  end if\n!==============================================!\n\n  return\nend subroutine adjustnormmd\n\n!========================================================================================!\n!========================================================================================!\nsubroutine env_to_mddat(env)\n!**********************************************\n!* Convert CREST's global MD settings to the\n!* MD calculator object that will be used as\n!* A basis for the newer calculator routines\n!**********************************************\n  use crest_parameters\n  use crest_data\n  implicit none\n  type(systemdata) :: env\n  real(wp) :: dum\n!!>--- dont override user-defined settings\n!  if(env%mddat%requested) return\n!> we will check if any default settings were already set individually, instead\n!> the if-statements in the following take care of that\n\n!>--- necessary transfer global settings into mddat object\n   if(env%mddat%length_ps <= 0.0_wp)then\n   !> total runtime in ps\n     env%mddat%length_ps    = env%mdtime\n   endif\n   if(env%mddat%tstep <= 0.0_wp)then\n   !> time step in fs \n     env%mddat%tstep        = env%mdstep\n   endif\n   !> simulation steps (would be recovered automatically later, but just to make sure)\n   env%mddat%length_steps = nint(env%mddat%length_ps*1000.0_wp / env%mddat%tstep)\n   if(env%mddat%tsoll <= 0.0_wp)then\n   !> target temperature\n     env%mddat%tsoll = env%mdtemp\n   endif\n\n   if( env%mddat%dumpstep <= 0.0_wp ) then \n   !> dump frequency in fs\n     env%mddat%dumpstep = float(env%mddumpxyz)\n   endif\n   if(env%mddat%sdump <= 0)then\n   !> trajectory structure dump every x steps \n     dum = max(1.0_wp, (env%mddat%dumpstep / env%mddat%tstep))\n     env%mddat%sdump = nint(dum)\n   endif\n\n   !> The SHAKE setup (special condition referring to the default)\n   env%mddat%shake = env%mddat%shake .and.(env%shake > 0) !> SHAKE algorithm?\n   if( env%mddat%shake .and. env%mddat%shk%shake_mode == 0)then\n   env%mddat%shk%shake_mode = env%shake     !> H-only shake =1, all atom =2\n   endif \n\n   if(env%mddat%md_hmass <= 0.0_wp)then\n   !> hydrogen mass (to enable longer timesteps)\n     env%mddat%md_hmass = env%hmass \n   endif\n\n   ! TODO: WBO reader if shake is applied and wbo file is present\n\n!>--- set flag to signal present settings\n  env%mddat%requested = .true.\n\nend subroutine env_to_mddat\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/choose_settings.f90 b/src/choose_settings.f90
--- a/src/choose_settings.f90	
+++ b/src/choose_settings.f90	
@@ -325,7 +325,7 @@
         do ik = 1,nk
           m = m+1
           if (m > nmtdynmax) cycle !> skip the last nrem setups
-          env%metadfac(m) = k*env%rednat
+          env%metadfac(m) = k*env%rednat*env%mtd_kscal
           env%metadexp(m) = alp
           k = k/kinc ! increment
         end do
Index: src/strucreader.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2020-2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=========================================================================================!\n! STRUCRD is a module for reading and writing molecular structures.\n!\n! The source is organized as follows:\n!   0. Variable declarations\n!   1. Routines for reading and writing ensemble files/trajectories in the XYZ format\n!   2. Routines for reading single structures in various formats\n!   3. Routines for writing structures in various formats\n!   4. Utility routines mainly used only within the module\n!\n! Currently supported formats:\n!   .xyz (Xmol) files and trajectories (read and write)\n!   coord (turbomole) files (read and write)\n!   .sdf/.mol files (V2000, read only)\n!   .pdb files (in development)\n!\n!=========================================================================================!\nmodule strucrd\n  use iso_fortran_env,only:wp => real64\n  use iso_c_binding\n  use geo !> simple geomerty and vector operations\n  implicit none\n\n!=========================================================================================!\n!>--- private module variables and parameters\n  private\n\n!>--- some constants and name mappings\n  real(wp),parameter :: bohr = 0.52917726_wp\n  real(wp),parameter :: autokcal = 627.509541_wp\n!>-- filetypes as integers\n  integer,parameter :: tmcoord = 1\n  integer,parameter :: xmol = 2\n  integer,parameter :: sdf = 3  !currently unused\n  integer,parameter :: sdfV2000 = 31\n  integer,parameter :: sdfV3000 = 32\n  integer,parameter :: pdbfile = 4  !currently unused\n  ! [...]\n\n!>--- private utility subroutines\n  private :: upperCase,lowerCase\n  private :: convertlable,fextension,sgrep\n\n!>--- Element symbols\n!&<\n  character(len=2),private,parameter :: PSE(118) = [ &\n & 'H ',                                                                                'He', &\n & 'Li','Be',                                                  'B ','C ','N ','O ','F ','Ne', &\n & 'Na','Mg',                                                  'Al','Si','P ','S ','Cl','Ar', &\n & 'K ','Ca','Sc','Ti','V ','Cr','Mn','Fe','Co','Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr', &\n & 'Rb','Sr','Y ','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn','Sb','Te','I ','Xe', &\n & 'Cs','Ba','La',                                                                            &\n &                'Ce','Pr','Nd','Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu',      &\n &                'Hf','Ta','W ','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At','Rn', &\n & 'Fr','Ra','Ac',                                                                            &\n &                'Th','Pa','U ','Np','Pu','Am','Cm','Bk','Cf','Es','Fm','Md','No','Lr',      &\n &                'Rf','Db','Sg','Bh','Hs','Mt','Ds','Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og' ]\n!&>\n\n!=========================================================================================!\n!>--- public subroutines\n  public :: i2e          !> function to convert atomic number to element symbol\n  public :: asym         !> \"\n  interface asym         !> \"\n    module procedure i2e !> \"\n  end interface asym\n  public :: e2i          !> function to convert element symbol into atomic number\n  public :: grepenergy\n  public :: checkcoordtype\n\n  public :: rdnat       !-- procedure to read number of atoms Nat\n  public :: rdcoord     !-- read an input file, determine format automatically\n  public :: rdxmol      !-- read a file in the Xmol (.xyz) format specifically\n  public :: rdxmolselec !-- read only a certain structure in Xmol file\n\n  !>--- write a TM coord file\n  public :: wrc0\n  interface wrc0\n    module procedure wrc0_file\n    module procedure wrc0_channel\n  end interface wrc0\n  public :: wrcoord\n  interface wrcoord\n    module procedure wrc0_file\n    module procedure wrc0_channel\n  end interface wrcoord\n\n  !>--- write a XYZ coord file\n  public :: wrxyz\n  interface wrxyz\n    module procedure wrxyz_file\n    module procedure wrxyz_file_mask\n    module procedure wrxyz_channel_energy\n    module procedure wrxyz_channel\n  end interface wrxyz\n\n  !>--- write a sdf molfile\n  public :: wrsdf\n  interface wrsdf\n    module procedure wrsdf_channel\n  end interface wrsdf\n\n  public :: xyz2coord\n  public :: coord2xyz\n\n  public :: rdensembleparam   !-- read Nat and Nall for a XYZ trajectory\n  public :: rdensemble        !-- read a XYZ trajectory\n  interface rdensemble\n    module procedure rdensemble_conf1\n    module procedure rdensemble_conf2\n    module procedure rdensemble_conf3\n\n    module procedure rdensemble_mixed2\n    \n    module procedure rdensemble_coord_type\n  end interface rdensemble\n\n  public :: wrensemble\n  interface wrensemble\n    module procedure wrensemble_conf\n    module procedure wrensemble_conf_energy\n    module procedure wrensemble_conf_energy_comment\n  end interface wrensemble\n\n  public :: pdbdata\n  public :: coord\n  public :: ensemble\n  public :: coordline\n\n!=========================================================================================!\n  !coord class. contains a single structure in the PDB format.\n  !coordinates by definition are in Angstroem.\n  type :: pdbdata\n\n    !--- data\n    integer :: nat = 0\n    integer :: frag = 0\n    !--- arrays\n    integer,allocatable  :: athet(:) !ATOM (1) or HETATM (2)\n    character(len=4),allocatable :: pdbat(:) !PDB atom specifier\n    character(len=3),allocatable :: pdbas(:) !PDB amino acid specifier\n    integer,allocatable :: pdbfrag(:) !PDB fragment specifier\n    character(len=1),allocatable :: pdbgrp(:)  !PDB group specifier\n    real(wp),allocatable :: pdbocc(:) !PDB occupancy\n    real(wp),allocatable :: pdbtf(:)  !PDB temperature factor\n\n  contains\n    procedure :: deallocate => deallocate_pdb !clear memory space\n    procedure :: allocate => allocate_pdb\n\n  end type pdbdata\n!=========================================================================================!\n  !coord class. contains a single structure\n  !by convention coordinates are in atomic units (Bohr) for a single structure!\n  type :: coord\n\n    !********************************************!\n    !> data that's typically used in coord type <!\n    !********************************************!\n    !>-- number of atoms\n    integer :: nat = 0\n    !>-- energy\n    real(wp) :: energy = 0.0_wp\n    !>-- atom types as integer, dimension will be at(nat)\n    integer,allocatable  :: at(:)\n    !>-- atomic coordinates, by convention in Bohrs\n    real(wp),allocatable :: xyz(:,:)\n\n    !**************************************!\n    !> (optional) data, often not present <!\n    !**************************************!\n    !>-- a comment line\n    character(len=:),allocatable :: comment\n    !>-- molecular charge\n    integer :: chrg = 0\n    !>-- multiplicity information\n    integer :: uhf = 0\n    !>-- number of bonds\n    integer :: nbd = 0\n    !>-- bond info\n    integer,allocatable :: bond(:,:)\n    !>-- lattice vectors\n    real(wp),allocatable :: lat(:,:)\n\n    !--- (optional) PDB data\n    type(pdbdata) :: pdb\n\n  contains\n    procedure :: deallocate => deallocate_coord !> clear memory space\n    procedure :: open => opencoord              !> read an coord file\n    procedure :: write => writecoord            !> write\n    procedure :: append => appendcoord          !> append\n    procedure :: get => getcoord                !> allocate & fill with data\n    procedure :: appendlog                      !> append .log file with coordinates and energy\n    procedure :: dist => coord_getdistance      !> calculate distance between two atoms\n    procedure :: angle => coord_getangle        !> calculate angle between three atoms\n    procedure :: dihedral => coord_getdihedral  !> calculate dihedral angle between four atoms\n  end type coord\n!=========================================================================================!\n  !ensemble class. contains all structures of an ensemble\n  !by convention coordinates are in Angström for an ensemble!\n  type :: ensemble\n\n    !--- data\n    integer :: nat = 0             !number of total atoms\n    integer :: nall = 0             !number of structures\n    integer,allocatable :: vnat(:)     !used instead of nat if not all structures have the same      number of atoms, in which case nat will be  =maxval(vnat,1)\n\n    integer,allocatable  :: at(:)      !atom types as integer, dimension will be at(nat)\n    real(wp),allocatable :: xyz(:,:,:) !coordinates, dimension will be xyz(3,nat,nall)\n    real(wp),allocatable :: er(:)   !energy of each structure, dimension will be eread(nall)\n\n    real(wp)            :: g         !gibbs free energy\n    real(wp)            :: s         !entropy\n    real(wp),allocatable :: gt(:)    !gibbs free energy of each member\n    real(wp),allocatable :: ht(:)    !enthalpy of each member\n    real(wp),allocatable :: svib(:)  !vibrational entropy of each member\n    real(wp),allocatable :: srot(:)  !rotational entropy of each member\n    real(wp),allocatable :: stra(:)  !translational entropy of each member\n\n  contains\n    procedure :: deallocate => deallocate_ensembletype !clear memory space\n    procedure :: open => openensemble !read an ensemble file\n    procedure :: write => write_ensemble !write to file\n\n  end type ensemble\n!=========================================================================================!\n!=========================================================================================!\ncontains  !> MODULE PROCEDURES START HERE\n!=========================================================================================!\n!=========================================================================================!\n!  1. ROUTINES FOR READING ENTIRE ENSEMBLES (OR TRAJECTORIES)\n!=========================================================================================!\n!=========================================================================================!\n\n!==================================================================!\n! subroutine rdensembleparam\n! read a ensemble file and get some information from\n! it:\n! On Input: fname - name of the file, should be in\n!                   the Xmol (*.xyz) format.\n!\n! On Output: nat  - number of atoms\n!                   (if different sized structures are present,\n!                    nat is the largest)\n!            nall - number of structures\n!            conform - (optional) do all structures\n!                      have the same number of atoms?\n!=================================================================!\n  subroutine rdensembleparam(fname,nat,nall,conform)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(out) :: nat\n    integer,intent(out) :: nall\n    logical,optional :: conform\n    logical :: conformdum\n    integer :: dum,iosum\n    integer :: natref\n    real(wp) :: x,y,z\n    integer :: i,j,k,ich,io\n    logical :: ex\n    character(len=10) :: str\n    conformdum = .true.\n    nat = 0\n    nall = 0\n    natref = 0\n    inquire (file=fname,exist=ex)\n    if (.not.ex) return\n    open (newunit=ich,file=fname)\n    do\n      read (ich,*,iostat=io) dum\n      if (io < 0) exit\n      if (io > 0) cycle\n      if (nat == 0) natref = dum\n      read (ich,*,iostat=io)\n      if (io < 0) exit\n      iosum = 0\n      do i = 1,dum\n        read (ich,*,iostat=io) str,x,y,z\n        if (io < 0) exit\n        iosum = iosum+io\n      end do\n      if (iosum > 0) cycle\n      nat = max(dum,nat)\n      if (dum .ne. natref) conformdum = .false.\n      nall = nall+1\n    end do\n    close (ich)\n    if (present(conform)) conform = conformdum\n    return\n  end subroutine rdensembleparam\n\n!==================================================================!\n! subroutine rdensemble_conf1\n! read a conformer ensemble/a MD trajectory, i.e.,\n! all structures have the same number and order of atoms.\n! version 1 also reads the energy\n!=================================================================!\n  subroutine rdensemble_conf1(fname,nat,nall,at,xyz,eread)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(in) :: nall\n    integer :: at(nat)\n    real(wp) :: xyz(3,nat,nall)\n    real(wp) :: eread(nall)\n    integer :: i,j,k,ich,io\n    logical :: ex\n    integer :: dum\n    character(len=512) :: line\n    character(len=6) :: sym\n    eread = 0.0_wp\n    xyz = 0.0_wp\n    open (newunit=ich,file=fname)\n    do i = 1,nall\n      read (ich,*,iostat=io) dum\n      if (io < 0) exit\n      if (io > 0) cycle\n      if (dum .ne. nat) then\n        call ensemble_strucskip(ich,nat,io)\n        if (io < 0) exit\n      end if\n      read (ich,'(a)',iostat=io) line\n      if (io < 0) exit\n      eread(i) = grepenergy(line)\n      do j = 1,dum\n        read (ich,'(a)',iostat=io) line\n        if (io < 0) exit\n        call coordline(line,sym,xyz(1:3,j,i),io)\n        if (io .ne. 0) then\n          backspace (ich)\n          exit\n        end if\n        at(j) = e2i(sym)\n      end do\n    end do\n    close (ich)\n\n    if (io < 0) then\n      error stop 'error while reading ensemble file.'\n    end if\n\n    return\n  end subroutine rdensemble_conf1\n\n!==================================================================!\n! subroutine rdensemble_conf2\n! read a conformer ensemble/a MD trajectory, i.e.,\n! all structures have the same number and order of atoms.\n! version 2 does not read the energy\n!=================================================================!\n  subroutine rdensemble_conf2(fname,nat,nall,at,xyz)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(in) :: nall\n    integer :: at(nat)\n    real(wp) :: xyz(3,nat,nall)\n    integer :: i,j,k,ich,io\n    logical :: ex\n    integer :: dum,nallnew\n    character(len=512) :: line\n    character(len=6) :: sym\n    io = 0\n    xyz = 0.0_wp\n    open (newunit=ich,file=fname)\n    do i = 1,nall\n      read (ich,*,iostat=io) dum\n      if (io < 0) exit\n      if (io > 0) cycle\n      if (dum .ne. nat) then\n        call ensemble_strucskip(ich,nat,io)\n        if (io < 0) exit\n      end if\n      read (ich,'(a)',iostat=io) line\n      if (io < 0) exit\n      do j = 1,dum\n        read (ich,'(a)',iostat=io) line\n        if (io < 0) exit\n        call coordline(line,sym,xyz(1:3,j,i),io)\n        if (io .ne. 0) then\n          backspace (ich)\n          exit\n        end if\n        at(j) = e2i(sym)\n      end do\n    end do\n    close (ich)\n\n    if (io < 0) then\n      error stop 'error while reading ensemble file.'\n    end if\n\n    return\n  end subroutine rdensemble_conf2\n\n!==================================================================!\n! subroutine rdensemble_conf3\n! read a conformer ensemble/a MD trajectory, i.e.,\n! all structures have the same number and order of atoms.\n! version 3 saves the comment line for each structure\n!=================================================================!\n  subroutine rdensemble_conf3(fname,nat,nall,at,xyz,comments)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(in) :: nall\n    integer :: at(nat)\n    integer,allocatable :: atdum(:)\n    real(wp) :: xyz(3,nat,nall)\n    character(len=*) :: comments(nall)\n    integer :: i,j,k,ich,io\n    logical :: ex\n    integer :: dum,nallnew\n    character(len=512) :: line\n    character(len=6) :: sym\n    io = 0\n    xyz = 0.0_wp\n    k = 0\n    open (newunit=ich,file=fname)\n    do i = 1,nall\n      read (ich,*,iostat=io) dum\n      if (io < 0) exit\n      if (io > 0) cycle\n      if (dum .ne. nat) then\n        call ensemble_strucskip(ich,nat,io)\n        if (io < 0) exit\n      end if\n      read (ich,'(a)',iostat=io) line\n      if (io < 0) exit\n      comments(i) = trim(line)\n      do j = 1,dum\n        k = k+1\n        read (ich,'(a)',iostat=io) line\n        if (io < 0) exit\n        call coordline(line,sym,xyz(1:3,j,i),io)\n        if (io .ne. 0) then\n          backspace (ich)\n          exit\n        end if\n        at(j) = e2i(sym)\n      end do\n    end do\n    close (ich)\n\n    if (io < 0) then\n      error stop 'error while reading ensemble file.'\n    end if\n\n    return\n  end subroutine rdensemble_conf3\n\n  subroutine ensemble_strucskip(ich,nat,io)\n    implicit none\n    integer,intent(in) :: ich\n    integer,intent(in) :: nat\n    integer,intent(out) :: io\n    integer :: io2,dum,k\n    io = 0\n    dum = 0\n    k = 0\n    do while (dum .ne. nat)\n      read (ich,*,iostat=io) dum\n      if (io < 0) exit\n      k = k+1\n      if (io > 0) cycle\n    end do\n  end subroutine ensemble_strucskip\n\n!==================================================================!\n! subroutine rdensemble_mixed2\n! read an ensemble of mixed strcutres, i.e., all stuctures\n! can have a diferent number and order of atoms.\n! version 2 does not read energies\n!=================================================================!\n  subroutine rdensemble_mixed2(fname,natmax,nall,nats,ats,xyz)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: natmax\n    integer,intent(in) :: nall\n    integer  :: nats(nall)\n    integer  :: ats(natmax,nall)\n    real(wp) :: xyz(3,natmax,nall)\n    integer :: i,j,k,ich,io\n    logical :: ex\n    integer :: dum\n    character(len=512) :: line\n    character(len=6) :: sym\n    open (newunit=ich,file=fname)\n    do i = 1,nall\n      read (ich,*,iostat=io) dum\n      if (io < 0) exit\n      if (io > 0) cycle\n      nats(i) = dum\n      read (ich,'(a)',iostat=io) line\n      if (io < 0) exit\n      do j = 1,dum\n        read (ich,'(a)',iostat=io) line\n        if (io < 0) exit\n        call coordline(line,sym,xyz(1:3,j,i),io)\n        if (io < 0) exit\n        ats(j,i) = e2i(sym)\n      end do\n    end do\n    close (ich)\n\n    if (io < 0) then\n      error stop 'error while reading ensemble file.'\n    end if\n\n    return\n  end subroutine rdensemble_mixed2\n\n!========================================================================================!\n  subroutine rdensemble_coord_type(fname,nall,ensemble)\n!*********************************************************\n!* subroutine rdensemble_coord_type\n!* A variant of the rdensemble routine that automatically\n!* produces an array of coord containers\n!*********************************************************\n    implicit none\n    character(len=*),intent(in) :: fname !> name of the ensemble file\n    integer,intent(out) :: nall  !> number of structures in ensemble\n    type(coord),intent(out),allocatable :: ensemble(:)\n\n    real(wp),allocatable :: xyz(:,:,:)\n    integer :: nat\n    integer,allocatable :: at(:)\n    real(wp),allocatable :: eread(:)\n    integer :: i,j,k,ich,io\n    logical :: ex\n\n    call rdensembleparam(fname,nat,nall)\n    allocate (xyz(3,nat,nall),at(nat),eread(nall))\n    call rdensemble(fname,nat,nall,at,xyz,eread)\n    !>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<!\n    !>--- Important: coord types must be in Bohrs\n    xyz = xyz/bohr\n    !>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<!\n \n    allocate (ensemble(nall)) \n    do i=1,nall\n      ensemble(i)%nat = nat \n      allocate(ensemble(i)%at(nat))\n      ensemble(i)%at(:) = at(:)\n      allocate(ensemble(i)%xyz(3,nat))\n      ensemble(i)%xyz(:,:) = xyz(:,:,i)\n      ensemble(i)%energy = eread(i)\n    enddo\n\n    deallocate(eread,at,xyz)\n  end subroutine rdensemble_coord_type\n\n!=================================================================!\n! subroutine wrensemble_conf\n! write a ensemble file/a trajectory from memory.\n!=================================================================!\n  subroutine wrensemble_conf(fname,nat,nall,at,xyz)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(in) :: nall\n    integer :: at(nat)\n    real(wp) :: xyz(3,nat,nall)\n    integer :: i,j,k,ich,io\n    logical :: ex\n\n    open (newunit=ich,file=fname,status='replace')\n    do i = 1,nall\n      call wrxyz(ich,nat,at,xyz(:,:,i))\n    end do\n    close (ich)\n\n    return\n  end subroutine wrensemble_conf\n\n!=================================================================!\n! subroutine wrensemble_conf_energy\n! write a ensemble file/a trajectory from memory.\n!=================================================================!\n  subroutine wrensemble_conf_energy(fname,nat,nall,at,xyz,er)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(in) :: nall\n    integer :: at(nat)\n    real(wp) :: xyz(3,nat,nall)\n    real(wp) :: er(nall)\n    integer :: i,j,k,ich,io\n    logical :: ex\n\n    open (newunit=ich,file=fname,status='replace')\n    do i = 1,nall\n      call wrxyz(ich,nat,at,xyz(:,:,i),er(i))\n    end do\n    close (ich)\n\n    return\n  end subroutine wrensemble_conf_energy\n\n!=================================================================!\n! subroutine wrensemble_conf_energy_comment\n! write a ensemble file/a trajectory from memory.\n!=================================================================!\n  subroutine wrensemble_conf_energy_comment(fname,nat,nall,at,xyz,er,comments)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(in) :: nall\n    integer :: at(nat)\n    real(wp) :: xyz(3,nat,nall)\n    real(wp) :: er(nall)\n    character(len=*) :: comments(nall)\n    character(len=512) :: line\n    integer :: i,j,k,ich,io\n    logical :: ex\n\n    open (newunit=ich,file=fname,status='replace')\n    do i = 1,nall\n      write (line,'(2x,f18.8,2x,a)') er(i),trim(comments(i))\n      call wrxyz(ich,nat,at,xyz(:,:,i),trim(line))\n    end do\n    close (ich)\n\n    return\n  end subroutine wrensemble_conf_energy_comment\n\n!==================================================================!\n! subroutine write_ensemble\n! wrapper to write an ensemble from the \"ensemble\" class\n!==================================================================!\n  subroutine write_ensemble(self,fname)\n    implicit none\n    class(ensemble) :: self\n    character(len=*),intent(in) :: fname\n    call wrensemble_conf_energy(fname,self%nat,self%nall,self%at,self%xyz,self%er)\n    return\n  end subroutine write_ensemble\n\n!==================================================================!\n! subroutine deallocate_ensembletype\n! is used to clear memory for the ensemble type\n!==================================================================!\n  subroutine deallocate_ensembletype(self)\n    implicit none\n    class(ensemble) :: self\n    self%nat = 0\n    self%nall = 0\n    if (allocated(self%vnat)) deallocate (self%vnat)\n    if (allocated(self%at)) deallocate (self%at)\n    if (allocated(self%xyz)) deallocate (self%xyz)\n    if (allocated(self%er)) deallocate (self%er)\n    if (allocated(self%gt)) deallocate (self%gt)\n    if (allocated(self%ht)) deallocate (self%ht)\n    if (allocated(self%svib)) deallocate (self%svib)\n    if (allocated(self%srot)) deallocate (self%srot)\n    if (allocated(self%stra)) deallocate (self%stra)\n\n    return\n  end subroutine deallocate_ensembletype\n\n!==================================================================!\n! subroutine openensemble\n! is the open procedure for the \"ensemble\" class.\n! a ensemble (trajectory) fname is read into a new ensemble object\n!==================================================================!\n  subroutine openensemble(self,fname)\n    implicit none\n    class(ensemble) :: self\n    character(len=*),intent(in) :: fname\n    integer :: nat\n    integer,allocatable :: at(:)\n    real(wp),allocatable :: xyz(:,:,:)\n    real(wp),allocatable :: eread(:)\n    integer :: nall\n    integer :: i,j,k,ich,io\n    logical :: ex\n\n    inquire (file=fname,exist=ex)\n    if (.not.ex) then\n      error stop 'ensemble file does not exist.'\n    end if\n\n    call rdensembleparam(fname,nat,nall)\n\n    if (nat > 0.and.nall > 0) then\n      call self%deallocate()\n      allocate (at(nat),xyz(3,nat,nall),eread(nall))\n      call rdensemble(fname,nat,nall,at,xyz,eread)\n\n      self%nat = nat\n      self%nall = nall\n      call move_alloc(at,self%at)\n      call move_alloc(xyz,self%xyz)\n      call move_alloc(eread,self%er)\n    else\n      error stop 'format error while reading ensemble file.'\n    end if\n\n    return\n  end subroutine openensemble\n\n!=========================================================================================!\n!=========================================================================================!\n!  2. ROUTINES FOR READING SINGLE STRUCTURES (COORDS)\n!=========================================================================================!\n!=========================================================================================!\n\n!============================================================!\n! subroutine checkcoordtype\n! try to identify the filetype of the coord type.\n! first based on file extension, if that fails by\n! a keyword within the file.\n!============================================================!\n  subroutine checkcoordtype(fname,typint)\n    implicit none\n    character(len=*) :: fname\n    integer,intent(out) :: typint\n    typint = 0\n    !-- check file extension first\n    select case (fextension(fname))\n    case ('.coord','.COORD')\n      typint = tmcoord\n    case ('.xyz','.XYZ','.trj','.TRJ','.sorted')\n      typint = xmol\n    case ('.sd','.sdf','.SDF','.mol','.MOL')\n      typint = sdf\n      if (sgrep(fname,'V2000')) then\n        typint = sdfV2000\n      end if\n      if (sgrep(fname,'V3000')) then\n        typint = sdfV3000\n      end if\n    case ('.pdb','.PDB')\n      typint = pdbfile\n    case default\n      typint = 0\n    end select\n    if (typint .ne. 0) return !-- file extension was recognized\n    !-- grep for keywords otherwise\n    if (sgrep(fname,'$coord')) then\n      typint = tmcoord\n    else !--no match found\n      typint = 0\n    end if\n    return\n  end subroutine checkcoordtype\n\n!============================================================!\n! subroutine rdnat\n! read number of atoms \"nat\" form file\n!\n! On Input: fname  - name of the coord file\n!           ftype  - (OPTIONAL) format of the input coord file\n!                    if ftype is not present, it is determined\n! On Output: nat   - number of atoms\n!============================================================!\n  subroutine rdnat(fname,nat,ftype)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(out) :: nat\n    integer,optional :: ftype\n    integer :: ftypedum\n    integer :: ich,i,j,io,k\n    logical :: ex\n    character(len=256) :: atmp\n    nat = 0\n    inquire (file=fname,exist=ex)\n    if (.not.ex) then\n      error stop 'file does not exist.'\n    end if\n    if (present(ftype)) then\n      ftypedum = ftype\n    else\n      call checkcoordtype(fname,ftypedum)\n    end if\n    open (newunit=ich,file=fname)\n    select case (ftypedum)\n      !--- *.xyz files\n    case (xmol)\n      read (ich,*,iostat=io) nat\n      !--- TM coord file\n    case (tmcoord)\n      do\n        read (ich,'(a)',iostat=io) atmp\n        if (io < 0) exit\n        atmp = adjustl(atmp)\n        if (index(atmp,\"$coord\") .eq. 1) exit\n      end do\n      do\n        read (ich,'(a)',iostat=io) atmp\n        if (io < 0) exit\n        atmp = adjustl(atmp)\n        if (atmp(1:1) == '$') exit\n        nat = nat+1\n      end do\n      !--- sdf V2000 (or *.mol) file\n    case (sdfV2000)\n      do i = 1,3 !-- first three comment lines\n        read (ich,'(a)',iostat=io) atmp\n        if (io < 0) exit\n      end do\n      read (ich,'(a)',iostat=io) atmp\n      if (index(atmp,'V2000') .ne. 0) then\n        read (atmp,'(i3)') nat !- first argument is nat\n      end if\n      !--- sdf V3000 file\n    case (sdfV3000)\n      do\n        read (ich,'(a)',iostat=io) atmp\n        if (io < 0) exit\n        if ((index(atmp,'V30') .ne. 0).and. &\n        &  (index(atmp,'COUNTS') .ne. 0)) then\n          j = index(atmp,'COUNTS')+6\n          k = len_trim(atmp)\n          atmp = atmp(j:k)\n          atmp = adjustl(atmp)\n          read (atmp,*) nat\n        end if\n      end do\n      !--- pdb file\n    case (pdbfile)\n      !write(*,*) 'PDB file format not supported yet.'\n      nat = 0\n      do\n        read (ich,'(a)',iostat=io) atmp\n        if (io < 0) exit\n        if ((index(atmp,'ATOM') .eq. 1).or. &\n        &  (index(atmp,'HETATM') .eq. 1)) then\n          nat = nat+1\n        end if\n      end do\n    case default\n      continue\n    end select\n    close (ich)\n    return\n  end subroutine rdnat\n\n!============================================================!\n! subroutine rdcoord\n! read in a structure. The format is determined automatically\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!\n! On Output: at   - atom number as integer\n!            xyz  - coordinates (always in Bohr)\n!            energy - (OPTIONAL) if present, try to get energy\n!                      mainly from xyz files\n!============================================================!\n  subroutine rdcoord(fname,nat,at,xyz,energy)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(inout)  :: at(nat)\n    real(wp),intent(inout) :: xyz(3,nat)\n    real(wp),optional :: energy\n    character(len=256) :: atmp\n    integer :: ftype\n    type(pdbdata) :: pdbdummy\n\n    !--- determine the file type\n    call checkcoordtype(fname,ftype)\n\n    select case (ftype)\n    case (tmcoord)  !-- TM coord file, is already in Bohr\n      call rdtmcoord(fname,nat,at,xyz)\n    case (xmol)     !-- XYZ file, is Angström, needs conversion\n      if (present(energy)) then\n        call rdxmol(fname,nat,at,xyz,atmp)\n        energy = grepenergy(atmp)\n      else\n        call rdxmol(fname,nat,at,xyz)\n      end if\n      xyz = xyz/bohr\n    case (sdfV2000)      !-- SDF/MOL V2000 file, also Angström\n      call rdsdf(fname,nat,at,xyz)\n      xyz = xyz/bohr\n    case (sdfV3000)     !-- SDF V3000 file, Angström\n      call rdsdfV3000(fname,nat,at,xyz)\n      xyz = xyz/bohr\n    case (pdbfile)  !-- PDB file, Angström\n      !error stop 'PDB file format not supported yet.'\n      call rdPDB(fname,nat,at,xyz,pdbdummy)\n      xyz = xyz/bohr\n      call pdbdummy%deallocate()\n    case default\n      continue\n    end select\n\n    return\n  end subroutine rdcoord\n\n!============================================================!\n! subroutine rdtmcoord\n! read a struncture in the TM coord style.\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!\n! On Output: at   - atom number as integer\n!            xyz  - coordinates (always in Bohr)\n!============================================================!\n  subroutine rdtmcoord(fname,nat,at,xyz)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(inout)  :: at(nat)\n    real(wp),intent(inout) :: xyz(3,nat)\n    character(len=6) :: sym\n    integer :: ich,io,i\n    character(len=256) :: atmp\n    open (newunit=ich,file=fname)\n    do\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      atmp = adjustl(atmp)\n      if (index(atmp,\"$coord\") .eq. 1) exit\n    end do\n    do i = 1,nat\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      atmp = adjustl(atmp)\n      if (atmp(1:1) == '$') exit\n      call coordline(atmp,sym,xyz(1:3,i),io)\n      if (io < 0) then\n        write (*,*) 'error while reading coord line. EOF'\n        exit\n      end if\n      at(i) = e2i(sym)\n    end do\n    close (ich)\n    return\n  end subroutine rdtmcoord\n\n!============================================================!\n! subroutine rdxmol\n! read a struncture in the *.xyz (Xmol) style.\n! The commentary (second) line is ignored\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!\n! On Output: at   - atom number as integer\n!            xyz  - coordinates (in Angström)\n!            comment - (OPTIONAL) commentary line of the file\n!============================================================!\n  subroutine rdxmol(fname,nat,at,xyz,comment)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(inout)  :: at(nat)\n    real(wp),intent(inout) :: xyz(3,nat)\n    character(len=*),optional :: comment\n    character(len=6) :: sym\n    integer :: ich,io,i\n    integer :: dum\n    character(len=256) :: atmp\n    open (newunit=ich,file=fname)\n    read (ich,*,iostat=io) dum\n    if (nat .ne. dum) then\n      error stop 'error while reading input coordinates'\n    end if\n    read (ich,'(a)') atmp !--commentary line\n    if (present(comment)) comment = trim(adjustl(atmp))\n    do i = 1,nat\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      atmp = adjustl(atmp)\n      call coordline(atmp,sym,xyz(1:3,i),io)\n      if (io < 0) then\n        write (*,*) 'error while reading coord line. EOF'\n        exit\n      end if\n      at(i) = e2i(sym)\n    end do\n    close (ich)\n    return\n  end subroutine rdxmol\n\n!============================================================!\n! subroutine rdsdf\n! read a struncture in the .sdf/.mol V2000 style.\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!\n! On Output: at   - atom number as integer\n!            xyz  - coordinates (in Angström)\n!            comment - (OPTIONAL) commentary line of the file\n!============================================================!\n  subroutine rdsdf(fname,nat,at,xyz,comment)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(inout)  :: at(nat)\n    real(wp),intent(inout) :: xyz(3,nat)\n    character(len=*),optional :: comment\n    character(len=6) :: sym\n    integer :: ich,io,i\n    integer :: dum\n    character(len=256) :: atmp\n    open (newunit=ich,file=fname)\n    read (ich,'(a)',iostat=io) atmp\n    read (ich,'(a)',iostat=io) atmp\n    read (ich,'(a)',iostat=io) atmp\n    if (present(comment)) comment = trim(adjustl(atmp))\n    read (ich,'(i3)',iostat=io) dum\n    if (nat .ne. dum) then\n      error stop 'error while reading input coordinates'\n    end if\n    do i = 1,nat\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      atmp = adjustl(atmp)\n      call coordline(atmp,sym,xyz(1:3,i),io)\n      if (io < 0) then\n        write (*,*) 'error while reading coord line. EOF'\n        exit\n      end if\n      at(i) = e2i(sym)\n    end do\n    close (ich)\n    return\n  end subroutine rdsdf\n\n!============================================================!\n! subroutine rdsdfV3000\n! read a struncture in the .sdf/.mol V3000 style.\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!\n! On Output: at   - atom number as integer\n!            xyz  - coordinates (in Angström)\n!            comment - (OPTIONAL) commentary line of the file\n!============================================================!\n  subroutine rdsdfV3000(fname,nat,at,xyz,comment)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(inout)  :: at(nat)\n    real(wp),intent(inout) :: xyz(3,nat)\n    character(len=*),optional :: comment\n    character(len=6) :: sym\n    integer :: ich,io,i,j,k,l\n    integer :: dum\n    character(len=256) :: atmp\n    character(len=32) :: btmp\n    open (newunit=ich,file=fname)\n    read (ich,'(a)',iostat=io) atmp\n    read (ich,'(a)',iostat=io) atmp\n    read (ich,'(a)',iostat=io) atmp\n    if (present(comment)) comment = trim(adjustl(atmp))\n    do\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      if ((index(atmp,'V30') .ne. 0).and. &\n      &  (index(atmp,'COUNTS') .ne. 0)) then\n        j = index(atmp,'COUNTS')+6\n        k = len_trim(atmp)\n        atmp = atmp(j:k)\n        atmp = adjustl(atmp)\n        read (atmp,*) dum\n      end if\n      if ((index(atmp,'V30') .ne. 0).and. &\n      &  (index(atmp,'ATOM') .ne. 0)) then\n        exit\n      end if\n    end do\n    if (nat .ne. dum) then\n      error stop 'error while reading input coordinates'\n    end if\n    do i = 1,nat\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      write (btmp,'(i0)') i\n      l = len_trim(btmp)+1\n      j = index(atmp,'V30')+3\n      k = len_trim(atmp)\n      atmp = atmp(j:k)\n      atmp = adjustl(atmp)\n      atmp = atmp(l:k)\n      call coordline(atmp,sym,xyz(1:3,i),io)\n      if (io < 0) then\n        write (*,*) 'error while reading coord line. EOF'\n        exit\n      end if\n      at(i) = e2i(sym)\n    end do\n    close (ich)\n    return\n  end subroutine rdsdfV3000\n\n!============================================================!\n! subroutine rdPDB\n! read a struncture in the .PDB style.\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!\n! On Output: at   - atom number as integer\n!            xyz  - coordinates (in Angström)\n!            pdb  - pdbdata object\n!============================================================!\n  subroutine rdPDB(fname,nat,at,xyz,pdb)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat\n    integer,intent(inout)  :: at(nat)\n    real(wp),intent(inout) :: xyz(3,nat)\n    type(pdbdata) :: pdb\n    character(len=2) :: sym\n    integer :: ich,io,i,j,k\n    character(len=256) :: atmp\n    character(len=6) :: dum1\n    character(len=1) :: dum2,dum3,pdbgp\n    character(len=3) :: pdbas\n    character(len=2) :: dum4\n    character(len=4) :: pdbat\n    real(wp) :: r1,r2\n    call pdb%allocate(nat)\n    open (newunit=ich,file=fname)\n    k = 0\n    do\n      read (ich,'(a)',iostat=io) atmp\n      if (io < 0) exit\n      if ((index(atmp,'ATOM') .eq. 1).or. &\n      &  (index(atmp,'HETATM') .eq. 1)) then\n        k = k+1\n        read (atmp,'(A6,I5,1X,A4,A1,A3,1X,A1,I4,A1,3X,3F8.3,2F6.2,10X,A2,A2)') &\n        &  dum1,i,pdbat,dum2,pdbas,pdbgp,j,dum3,xyz(1:3,k),r1,r2,sym,dum4\n        at(k) = e2i(sym)\n        pdb%pdbat(k) = pdbat\n        pdb%pdbas(k) = pdbas\n        pdb%pdbgrp(k) = pdbgp\n        pdb%pdbfrag(k) = j\n        pdb%pdbocc(k) = r1\n        pdb%pdbtf(k) = r2\n      end if\n    end do\n    close (ich)\n    return\n  end subroutine rdPDB\n\n!============================================================!\n! subroutine rdxmolselec\n! Read a file with multiple structures in the *.xyz (Xmol) style.\n! Picks one structure.\n! The commentary (second) line is ignored\n!\n! On Input: fname  - name of the coord file\n!           m      - position of the desired structure\n!           nat    - number of atoms\n!\n! On Output: at   - atom number as integer\n!            xyz  - coordinates (in Angström)\n!============================================================!\n\n  subroutine rdxmolselec(fname,m,nat,at,xyz,comment)\n    implicit none\n    character(len=*),intent(in) :: fname\n    integer,intent(in) :: nat,m\n    integer,intent(inout)  :: at(nat)\n    real(wp),intent(inout) :: xyz(3,nat)\n    character(len=*),optional :: comment\n    character(len=6) :: sym\n    integer :: ich,io,i,j\n    integer :: dum\n    character(len=256) :: atmp\n\n    open (newunit=ich,file=fname)\n\n    do j = 1,m\n      read (ich,*,iostat=io) dum\n      if (nat .ne. dum) then\n        error stop 'error while reading input coordinates'\n      end if\n      read (ich,'(a)') atmp !--commentary line\n      if (present(comment)) comment = trim(adjustl(atmp))\n      do i = 1,nat\n        read (ich,'(a)',iostat=io) atmp\n        if (io < 0) exit\n        atmp = adjustl(atmp)\n        call coordline(atmp,sym,xyz(1:3,i),io)\n        if (io < 0) then\n          write (*,*) 'error while reading coord line. EOF'\n          exit\n        end if\n        at(i) = e2i(sym)\n      end do\n    end do\n    close (ich)\n    xyz = xyz/bohr\n    return\n  end subroutine rdxmolselec\n\n!==================================================================!\n! subroutine deallocate_coord\n! is used to clear memory for the coord type\n!==================================================================!\n  subroutine deallocate_coord(self)\n    implicit none\n    class(coord) :: self\n    self%nat = 0\n    if (allocated(self%at)) deallocate (self%at)\n    if (allocated(self%xyz)) deallocate (self%xyz)\n    call self%pdb%deallocate()\n    return\n  end subroutine deallocate_coord\n\n!==================================================================!\n! subroutine deallocate_pdb\n! is used to clear memory for the pdbdata type\n!==================================================================!\n  subroutine deallocate_pdb(self)\n    implicit none\n    class(pdbdata) :: self\n    self%nat = 0\n    self%frag = 0\n    if (allocated(self%athet)) deallocate (self%athet)\n    if (allocated(self%pdbat)) deallocate (self%pdbat)\n    if (allocated(self%pdbas)) deallocate (self%pdbas)\n    if (allocated(self%pdbfrag)) deallocate (self%pdbfrag)\n    if (allocated(self%pdbgrp)) deallocate (self%pdbgrp)\n    if (allocated(self%pdbocc)) deallocate (self%pdbocc)\n    if (allocated(self%pdbtf)) deallocate (self%pdbtf)\n    return\n  end subroutine deallocate_pdb\n\n!==================================================================!\n! subroutine allocate_pdb\n! is used to clear memory for the pdbdata type\n!==================================================================!\n  subroutine allocate_pdb(self,nat)\n    implicit none\n    class(pdbdata) :: self\n    integer :: nat\n    call deallocate_pdb(self)\n    self%nat = nat\n    allocate (self%athet(nat))\n    allocate (self%pdbat(nat))\n    allocate (self%pdbas(nat))\n    allocate (self%pdbfrag(nat))\n    allocate (self%pdbgrp(nat))\n    allocate (self%pdbocc(nat))\n    allocate (self%pdbtf(nat))\n    return\n  end subroutine allocate_pdb\n\n!==================================================================!\n! subroutine opencoord\n! is the open procedure for the \"coord\" class.\n!==================================================================!\n  subroutine opencoord(self,fname)\n    implicit none\n    class(coord) :: self\n    character(len=*),intent(in) :: fname\n    integer :: nat\n    integer,allocatable :: at(:)\n    real(wp),allocatable :: xyz(:,:)\n    integer :: ftype\n    integer :: i,j,k,ich,io\n    logical :: ex\n\n    inquire (file=fname,exist=ex)\n    if (.not.ex) then\n      error stop 'coord file does not exist.'\n    end if\n\n    call self%deallocate()\n\n    call checkcoordtype(fname,ftype)\n    call rdnat(fname,nat)\n\n    if (nat > 0) then\n      allocate (at(nat),xyz(3,nat))\n      if (ftype == pdbfile) then\n        call rdPDB(fname,nat,at,xyz,self%pdb)\n        xyz = xyz/bohr\n      else\n        call rdcoord(fname,nat,at,xyz)\n      end if\n\n      self%nat = nat\n      call move_alloc(at,self%at)\n      call move_alloc(xyz,self%xyz)\n    else\n      error stop 'format error while reading coord file.'\n    end if\n\n    return\n  end subroutine opencoord\n!==================================================================!\n! subroutine getcoord\n! allocate \"coord\" class and fill with data\n!==================================================================!\n  subroutine getcoord(self,convfac,nat,at,xyz)\n    implicit none\n    class(coord) :: self\n    real(wp),intent(in) :: convfac\n    integer,intent(in)  :: nat\n    integer,intent(in)  :: at(nat)\n    real(wp),intent(in) :: xyz(3,nat)\n    call self%deallocate()\n    allocate (self%at(nat))\n    allocate (self%xyz(3,nat))\n    self%nat = nat\n    self%at = at\n    self%xyz = xyz/convfac\n    return\n  end subroutine getcoord\n\n!==================================================================!\n! function coord_getdistance\n! calculate the distance for a given pair of atoms\n!==================================================================!\n  function coord_getdistance(self,a1,a2) result(d)\n    implicit none\n    class(coord) :: self\n    integer,intent(in) :: a1,a2\n    real(wp) :: d\n    d = 0.0_wp\n    if (allocated(self%xyz)) then\n      d = (self%xyz(1,a1)-self%xyz(1,a2))**2+ &\n      &   (self%xyz(2,a1)-self%xyz(2,a2))**2+ &\n      &   (self%xyz(3,a1)-self%xyz(3,a2))**2\n      d = sqrt(d)\n    end if\n    return\n  end function coord_getdistance\n\n!==================================================================!\n! function coord_getangle\n! calculate the angle for a given trio of atoms\n! A1-A2-A3\n!==================================================================!\n  function coord_getangle(self,a1,a2,a3) result(angle)\n    implicit none\n    class(coord) :: self\n    integer,intent(in) :: a1,a2,a3\n    real(wp) :: angle,u(3),v(3),o(3)\n    real(wp) :: d2ij,d2jk,d2ik,xy,temp\n    angle = 0.0_wp\n    if (allocated(self%xyz)) then\n      u(1:3) = self%xyz(1:3,a1)-self%xyz(1:3,a2)\n      v(1:3) = self%xyz(1:3,a3)-self%xyz(1:3,a2)\n      angle = tangle(u,v)\n    end if\n    return\n  end function coord_getangle\n\n!==================================================================!\n! function coord_getdihedral\n! calculate the dihedral angle for a given quartet of atoms\n! A1-A2-A3-A4\n!==================================================================!\n  function coord_getdihedral(self,a1,a2,a3,a4) result(dihed)\n    implicit none\n    class(coord) :: self\n    integer,intent(in) :: a1,a2,a3,a4\n    real(wp) :: dihed\n    real(wp) :: u(3),v(3),w(3)\n    real(wp) :: n1(3),n2(3)\n    real(wp) :: u1(3),u2(3),u3(3)\n\n    dihed = 0.0_wp\n    if (allocated(self%xyz)) then\n\n      u(1:3) = self%xyz(1:3,a2)-self%xyz(1:3,a1)\n      v(1:3) = self%xyz(1:3,a3)-self%xyz(1:3,a2)\n      w(1:3) = self%xyz(1:3,a4)-self%xyz(1:3,a3)\n      dihed = dihedral(u,v,w)\n    end if\n    return\n  end function coord_getdihedral\n\n!=========================================================================================!\n!=========================================================================================!\n!  3. ROUTINES FOR WRITING STRUCTURES AND CONVERTING THEM\n!=========================================================================================!\n!=========================================================================================!\n\n!============================================================!\n! subroutine wrc0_file\n! this is the typical quick write routine for TM coord files\n! version for writing directly to a new file\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!           at   - atom number as integer\n!           xyz  - coordinates (in Bohr)\n!\n! On Output: file written to \"fname\"\n!============================================================!\n  subroutine wrc0_file(fname,nat,at,xyz)\n    implicit none\n    character(len=*) :: fname\n    integer :: nat\n    integer :: at(nat)\n    real(wp) ::  xyz(3,nat)\n    integer :: i,j,k,ich,io\n    logical :: ex\n    open (newunit=ich,file=fname,status='replace')\n    write (ich,'(''$coord'')')\n    do j = 1,nat\n      write (ich,'(3F24.12,5x,a2)') xyz(1:3,j),i2e(at(j),'lc')\n    end do\n    write (ich,'(''$end'')')\n    close (ich)\n    return\n  end subroutine wrc0_file\n\n!============================================================!\n! subroutine wrc0_channel\n! this is the typical quick write routine for TM coord files\n! version for writing to a output channel\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!           at   - atom number as integer\n!           xyz  - coordinates (in Bohr)\n!\n! On Output: file written to \"fname\"\n!============================================================!\n  subroutine wrc0_channel(ch,nat,at,xyz)\n    implicit none\n    integer :: ch\n    integer :: nat\n    integer :: at(nat)\n    real(wp) ::  xyz(3,nat)\n    integer :: i,j,k,ich,io\n    logical :: ex\n    write (ch,'(''$coord'')')\n    do j = 1,nat\n      write (ch,'(3F24.12,5x,a2)') xyz(1:3,j),i2e(at(j),'lc')\n    end do\n    write (ch,'(''$end'')')\n    return\n  end subroutine wrc0_channel\n\n!============================================================!\n! subroutine wrxyz_file\n! this is the typical quick write routine for TM coord files\n! version for writing directly to a new file\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!           at   - atom number as integer\n!           xyz  - coordinates (in Angström)\n!           comment - (OPTIONAL) comment line\n!\n! On Output: file written to \"fname\"\n!============================================================!\n  subroutine wrxyz_file(fname,nat,at,xyz,comment)\n    implicit none\n    character(len=*) :: fname\n    integer :: nat\n    integer :: at(nat)\n    real(wp) ::  xyz(3,nat)\n    character(len=*),optional :: comment\n    integer :: i,j,k,ich,io\n    logical :: ex\n    open (newunit=ich,file=fname,status='replace')\n    write (ich,'(2x,i0)') nat\n    if (present(comment)) then\n      write (ich,'(a)') trim(comment)\n    else\n      write (ich,*)\n    end if\n    do j = 1,nat\n      write (ich,'(1x,a2,1x,3f20.10)') i2e(at(j),'nc'),xyz(1:3,j)\n    end do\n    close (ich)\n    return\n  end subroutine wrxyz_file\n\n!============================================================!\n! subroutine wrxyz_file_mask\n! this is the typical quick write routine for TM coord files\n! version for writing directly to a new file\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!           at   - atom number as integer\n!           xyz  - coordinates (in Angström)\n!           mask - a mask to determine to write which atoms\n!           comment - (OPTIONAL) comment line\n!\n! On Output: file written to \"fname\"\n!============================================================!\n  subroutine wrxyz_file_mask(fname,nat,at,xyz,mask,comment)\n    implicit none\n    character(len=*) :: fname\n    integer :: nat\n    integer :: at(nat)\n    real(wp) ::  xyz(3,nat)\n    logical :: mask(nat)\n    integer :: maskednat\n    character(len=*),optional :: comment\n    integer :: i,j,k,ich,io\n    logical :: ex\n    open (newunit=ich,file=fname,status='replace')\n    maskednat = count(mask(:))\n    write (ich,'(2x,i0)') maskednat\n    if (present(comment)) then\n      write (ich,'(a)') trim(comment)\n    else\n      write (ich,*)\n    end if\n    do j = 1,nat\n      if (mask(j)) then\n        write (ich,'(1x,a2,1x,3f20.10)') i2e(at(j),'nc'),xyz(1:3,j)\n      end if\n    end do\n    close (ich)\n    return\n  end subroutine wrxyz_file_mask\n\n!============================================================!\n! subroutine wrxyz_channel\n! this is the typical quick write routine for xyz files\n! version for writing to a output channel\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!           at   - atom number as integer\n!           xyz  - coordinates (in Angström)\n!           comment - (OPTIONAL) the comment line\n!\n! On Output: file written to \"fname\"\n!============================================================!\n  subroutine wrxyz_channel(ch,nat,at,xyz,comment)\n    implicit none\n    integer :: ch\n    integer :: nat\n    integer :: at(nat)\n    real(wp) ::  xyz(3,nat)\n    character(len=*),optional :: comment\n    integer :: i,j,k,ich,io\n    logical :: ex\n    write (ch,'(2x,i0)') nat\n    if (present(comment)) then\n      write (ch,'(a)') trim(comment)\n    else\n      write (ch,*)\n    end if\n    do j = 1,nat\n      write (ch,'(1x,a2,1x,3f20.10)') i2e(at(j),'nc'),xyz(1:3,j)\n    end do\n    return\n  end subroutine wrxyz_channel\n\n!============================================================!\n! subroutine wrxyz_channel\n! this is the typical quick write routine for xyz files\n! version for writing to a output channel\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!           at   - atom number as integer\n!           xyz  - coordinates (in Angström)\n!           er   - energy\n!\n! On Output: file written to \"fname\"\n!============================================================!\n  subroutine wrxyz_channel_energy(ch,nat,at,xyz,er)\n    implicit none\n    integer :: ch\n    integer :: nat\n    integer :: at(nat)\n    real(wp) ::  xyz(3,nat)\n    real(wp) :: er\n    integer :: i,j,k,ich,io\n    logical :: ex\n    write (ch,'(2x,i0)') nat\n    write (ch,'(2x,f18.8)') er\n    do j = 1,nat\n      write (ch,'(1x,a2,1x,3f20.10)') i2e(at(j),'nc'),xyz(1:3,j)\n    end do\n    return\n  end subroutine wrxyz_channel_energy\n\n!============================================================!\n! subroutine wrsdf_channel\n! this is the quick write routine for sdf files\n! version for writing to a output channel\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!           at   - atom number as integer\n!           xyz  - coordinates (in Angström)\n!           er   - energy\n!           wbo  - bond order matrix\n!\n! On Output: written to channel \"ch\"\n!============================================================!\n  subroutine wrsdf_channel(ch,nat,at,xyz,er,chrg,wbo,comment,icharges)\n    implicit none\n    integer,intent(in) :: ch\n    integer,intent(in) :: nat\n    integer,intent(in) :: at(nat)\n    real(wp),intent(in) ::  xyz(3,nat)\n    real(wp),intent(in) :: er\n    integer,intent(in) :: chrg\n    real(wp),intent(in) :: wbo(nat,nat)\n    character(len=*),intent(in) :: comment\n    real(wp),intent(in),optional :: icharges(nat)\n    character(len=8)  :: date\n    character(len=10) :: time\n    integer :: list12(12),nbd\n    integer,parameter :: list4(4) = 0\n    integer,parameter :: list8(8) = 0\n    character(len=*),parameter :: countsfmt = '(3i3, 8i3, 1x, a5)'\n    character(len=*),parameter :: atmfmt = '(3f10.4, 1x, a2, 12i3)'\n    character(len=*),parameter :: bndfmt = '(7i3)'\n    integer :: i,j,k,ich,io\n    logical :: ex\n\n    !>--- generate data\n    call date_and_time(date,time)\n    nbd = countbonds(nat,wbo)\n    list12 = 0\n    !>--- comment lines\n    call date_and_time(date,time)\n    write (ch,'(a)') trim(comment)\n    write (ch,'(1x,a, 3a2, a4, \"3D\",1x,a,f18.8,5x)') &\n    & 'crest',date(5:6),date(7:8),date(3:4),time(:4),'Energy =',er\n    write (ch,'(a)')\n    !>--- counts line\n    write (ch,countsfmt) nat,nbd,list8,999,'V2000'\n    !>--- atom block\n    do j = 1,nat\n      write (ch,atmfmt) xyz(1:3,j),i2e(at(j),'nc'),list12\n    end do\n    !>--- bonds block\n    do i = 1,nat\n      do j = i+1,nat\n        k = nint(wbo(j,i))\n        if (k > 0) then\n          write (ch,bndfmt) i,j,k,list4\n        end if\n      end do\n    end do\n    !>--- other\n    if (present(icharges)) then\n      do i = 1,nat\n        if (abs(nint(icharges(i))) /= 0) then\n          write (ch,'(a, *(i3, 1x, i3, 1x, i3))') \"M  CHG\",1,i,nint(icharges(i))\n        end if\n      end do\n    else if (chrg .ne. 0) then\n      write (ch,'(a, *(i3, 1x, i3, 1x, i3))') \"M  CHG\",1,1,chrg\n    end if\n    write (ch,'(a)') 'M  END'\n    write (ch,'(a)') '$$$$'\n    return\n  end subroutine wrsdf_channel\n\n!============================================================!\n! subroutine wrsdfV3000_channel\n! this is the quick write routine for sdf files\n! version for writing to a output channel\n!\n! On Input: fname  - name of the coord file\n!           nat    - number of atoms\n!           at   - atom number as integer\n!           xyz  - coordinates (in Angström)\n!           er   - energy\n!           wbo  - bond order matrix\n!\n! On Output: written to channel \"ch\"\n!============================================================!\n  subroutine wrsdfV3000_channel(ch,nat,at,xyz,er,chrg,wbo,comment)\n    implicit none\n    integer,intent(in) :: ch\n    integer,intent(in) :: nat\n    integer,intent(in) :: at(nat)\n    real(wp),intent(in) ::  xyz(3,nat)\n    real(wp),intent(in) :: er\n    real(wp),intent(in) :: chrg\n    real(wp),intent(in) :: wbo(nat,nat)\n    character(len=*),intent(in),optional :: comment\n    character(len=8)  :: date\n    character(len=10) :: time\n    integer :: list12(12),nbd,b\n    integer,parameter :: list4(4) = 0\n    character(len=*),parameter :: countsfmt = '(3i3, 8i3, 1x, a5)'\n    character(len=*),parameter :: countsfmt2 = '(a,2i3, 3i3)'\n    character(len=*),parameter :: atmfmt = '(a,1x,i0,1x, a,3f10.4, i2, 11i3)'\n    character(len=*),parameter :: bndfmt = '(a,1x,i0,1x,7i3)'\n    integer :: i,j,k,ich,io\n    logical :: ex\n\n    !>--- generate data\n    call date_and_time(date,time)\n    nbd = countbonds(nat,wbo)\n    !>--- comment lines\n    call date_and_time(date,time)\n    if (present(comment)) then\n      write (ch,'(1x,a)') comment\n    else\n      write (ch,'(1x,a)') 'structure written by crest'\n    end if\n    write (ch,'(1x,a,f18.8,5x, 3a2, a4, \"3D\")') &\n    & 'Energy =',er,date(5:6),date(7:8),date(3:4),time(:4)\n    write (ch,'(a)')\n    !>--- counts line\n    write (ch,countsfmt) nat,nbd,0,0,0,999,'V2000'\n    write (ch,'(\"M V30 BEGIN CTAB\")')\n    write (ch,countsfmt2) \"M V30 COUNTS\",nat,nbd,0,0,0\n    !>--- atom block\n    write (ch,'(\"M V30 BEGIN ATOM\")')\n    do j = 1,nat\n      write (ch,atmfmt) 'M V30',j, &\n      &     i2e(at(j),'nc'),xyz(1:3,j),list12\n    end do\n    write (ch,'(\"M V30 END ATOM\")')\n    !>--- bonds block\n    write (ch,'(\"M V30 BEGIN BOND\")')\n    b = 0\n    do i = 1,nat\n      do j = i+1,nat\n        k = nint(wbo(j,i))\n        if (k > 0) then\n          b = b+1\n          write (ch,bndfmt) \"M V30\",b,i,j,k,list4\n        end if\n      end do\n    end do\n    write (ch,'(\"M V30 END BOND\")')\n    !>--- other\n    if (chrg .ne. 0) then\n      write (ch,'(a, *(i3, 1x, i3, 1x, i3))') \"M V30 CHG\",1,1,chrg\n    end if\n    write (ch,'(a)') 'M V30 END CTAB'\n    write (ch,'(a)') 'M  END'\n    write (ch,'(a)') '$$$$'\n    return\n  end subroutine wrsdfV3000_channel\n\n!============================================================!\n! subroutine xyz2coord\n! simple conversion of a xyz to a coord file.\n!\n! On Input: iname  - name of the xyz file\n!           oname  - name of the coord file\n!\n! On Output: file written to \"oname\"\n!============================================================!\n  subroutine xyz2coord(iname,oname)\n    implicit none\n    character(len=*) :: iname\n    character(len=*) :: oname\n    type(coord) :: struc\n    call struc%open(iname)\n    call wrc0(oname,struc%nat,struc%at,struc%xyz)\n    call struc%deallocate()\n    return\n  end subroutine xyz2coord\n\n!============================================================!\n! subroutine coord2xyz\n! simple conversion of a coord to a xyz file.\n!\n! On Input: iname  - name of the coord file\n!           oname  - name of the xyz file\n!\n! On Output: file written to \"oname\"\n!============================================================!\n  subroutine coord2xyz(iname,oname)\n    implicit none\n    character(len=*) :: iname\n    character(len=*) :: oname\n    type(coord) :: struc\n    call struc%open(trim(iname))\n    struc%xyz = struc%xyz*bohr !to Angström\n    call wrxyz(oname,struc%nat,struc%at,struc%xyz)\n    call struc%deallocate()\n    return\n  end subroutine coord2xyz\n\n!==================================================================!\n! subroutine writecoord\n! is the write procedure for the \"coord\" class.\n!==================================================================!\n  subroutine writecoord(self,fname)\n    implicit none\n    class(coord) :: self\n    character(len=*),intent(in) :: fname\n    if (.not.allocated(self%xyz)) then\n      write (*,*) 'Cannot write ',trim(fname),'. not allocated'\n    end if\n    if (index(fname,'.xyz') .ne. 0) then\n      self%xyz = self%xyz*bohr !to Angström\n      call wrxyz(fname,self%nat,self%at,self%xyz)\n      self%xyz = self%xyz/bohr !back\n    else\n      call wrc0(fname,self%nat,self%at,self%xyz)\n    end if\n    return\n  end subroutine writecoord\n\n!==================================================================!\n! subroutine appendcoord\n! is the write procedure for the \"coord\" class.\n! coords will be written out in XYZ format!\n!==================================================================!\n  subroutine appendcoord(self,io)\n    implicit none\n    class(coord) :: self\n    integer :: io\n    character(len=64) :: atmp\n    self%xyz = self%xyz*bohr !to Angström\n    if (allocated(self%comment)) then\n      call wrxyz(io,self%nat,self%at,self%xyz,trim(self%comment))\n    else if (self%energy .ne. 0.0_wp) then\n      write (atmp,'(a,f22.10)') ' Etot= ',self%energy\n      call wrxyz(io,self%nat,self%at,self%xyz,trim(atmp))\n    else\n      call wrxyz(io,self%nat,self%at,self%xyz)\n    end if\n    self%xyz = self%xyz/bohr !back\n    return\n  end subroutine appendcoord\n\n  subroutine appendlog(self,io,energy,gnorm)\n    implicit none\n    class(coord) :: self\n    integer :: io\n    real(wp),optional :: energy\n    real(wp),optional :: gnorm\n    character(len=64) :: atmp\n    self%xyz = self%xyz*bohr !to Angström\n    if (present(gnorm).and.present(energy)) then\n      write (atmp,'(a,f22.10,a,f16.8)') ' Etot= ',energy,' grad.norm.= ',gnorm\n    else if (present(energy)) then\n      write (atmp,'(a,f22.10)') ' Etot= ',energy\n    else\n      atmp = ''\n    end if\n    call wrxyz(io,self%nat,self%at,self%xyz,trim(atmp))\n    self%xyz = self%xyz/bohr !back\n    return\n  end subroutine appendlog\n\n!=========================================================================================!\n!=========================================================================================!\n!  4. GENERAL UTILITY ROUTINES\n!=========================================================================================!\n!=========================================================================================!\n\n!============================================================!\n! read a line of coordinates and determine by itself\n! if the format is x,y,z,at or at,x,y,z\n!============================================================!\n  subroutine coordline(line,sym,xyz,io)\n    implicit none\n    character(len=*) :: line\n    character(len=*) :: sym\n    real(wp) :: xyz(3)\n    integer,intent(out) :: io\n\n    io = 0\n    read (line,*,iostat=io) xyz(1:3),sym\n    if (io .ne. 0) then\n      read (line,*,iostat=io) sym,xyz(1:3)\n      !if(io.ne.0)then\n      !  error stop 'error while reading coord line'\n      !endif\n    end if\n\n    return\n  end subroutine coordline\n\n!============================================================!\n! convert a string into uppercase\n!============================================================!\n  function upperCase(s)\n    implicit none\n    character(len=*),intent(in) :: s\n    character(len=:),allocatable :: sout\n    character(len=:),allocatable :: upperCase\n    integer :: ic,i\n    character(26),Parameter :: high = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(26),Parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n    sout = s\n    do i = 1,LEN_TRIM(s)\n      ic = INDEX(low,s(i:i))\n      if (ic > 0) sout(i:i) = high(ic:ic)\n    end do\n    call move_alloc(sout,upperCase)\n  end function upperCase\n\n!============================================================!\n! convert a string into lowercase\n!============================================================!\n  function lowerCase(s)\n    implicit none\n    character(len=*),intent(in) :: s\n    character(len=:),allocatable :: sout\n    character(len=:),allocatable :: lowerCase\n    integer :: ic,i\n    character(26),Parameter :: high = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(26),Parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n    sout = s\n    do i = 1,LEN_TRIM(s)\n      ic = INDEX(high,s(i:i))\n      if (ic > 0) sout(i:i) = low(ic:ic)\n    end do\n    call move_alloc(sout,lowerCase)\n  end function lowerCase\n\n!============================================================!\n! split element lable if some isotope indicator was given\n! and convert to uppercase\n!============================================================!\n  function convertlable(s)\n    implicit none\n    character(len=*),intent(in) :: s\n    character(len=:),allocatable :: sout\n    character(len=:),allocatable :: convertlable\n    integer :: ic,i\n    character(14),parameter :: lab = '0123456789*_+-'\n    character(26),parameter :: high = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(26),parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n    sout = s\n    do i = 1,len_trim(s)\n      ic = index(lab,s(i:i))\n      if (ic > 0) sout(i:i) = ' '\n      ic = index(low,s(i:i))\n      if (ic > 0) sout(i:i) = high(ic:ic)\n    end do\n    sout = trim(adjustl(sout))\n    if (len_trim(sout) .gt. 1) then\n      sout(2:2) = lowerCase(sout(2:2))\n    else\n      sout = sout//' '\n    end if\n    call move_alloc(sout,convertlable)\n  end function convertlable\n\n!============================================================!\n! e2i is used to map the element (as a string) to integer\n!============================================================!\n  integer function e2i(cin)\n    implicit none\n    character(len=*),intent(in) :: cin\n    character(len=:),allocatable :: c\n    integer :: iout\n    integer :: i,j,k,ich,io\n    logical :: ex\n    c = trim(convertlable(cin))\n    if (any(PSE(:) .eq. c)) then\n      do i = 1,118\n        if (trim(PSE(i)) .eq. c) then\n          iout = i\n          exit\n        end if\n      end do\n    else !> special cases\n      select case (trim(c))\n      case ('D'); iout = 1\n      case ('T'); iout = 1\n      case default; iout = 0\n      end select\n    end if\n    e2i = iout\n  end function e2i\n\n!============================================================!\n! i2e is used to map the element (as a integer) to a string\n!============================================================!\n  character(len=2) function i2e(iin,oformat)\n    implicit none\n    integer,intent(in) :: iin\n    character(len=:),allocatable :: c\n    character(len=*),optional :: oformat\n    if (iin <= 118) then\n      c = uppercase(PSE(iin))\n    else\n      c = 'XX'\n    end if\n    i2e = trim(c)\n    if (present(oformat)) then\n      select case (oformat)\n      case ('lc','lowercase')\n        i2e = lowerCase(trim(c))\n      case ('nc','nicecase')\n        if (len_trim(c) .gt. 1) then\n          c(2:2) = lowerCase(c(2:2))\n          i2e = trim(c)\n        end if\n      case default\n        continue\n      end select\n    end if\n  end function i2e\n\n!============================================================!\n! get the file extension\n!============================================================!\n  function fextension(s)\n    implicit none\n    character(len=*),intent(in) :: s !filename\n    character(len=:),allocatable :: sout\n    character(len=:),allocatable :: fextension !output\n    integer :: ic,i\n    sout = trim(adjustl(s))\n    i = len_trim(sout)\n    ic = index(sout,'.',.true.)\n    if (ic .ne. 0) then\n      fextension = sout(ic:i)\n    else\n      fextension = 'none'\n    end if\n    return\n  end function fextension\n\n!============================================================!\n! grep for a keyword within the file\n!============================================================!\n  function sgrep(fname,key)\n    implicit none\n    character(len=*),intent(in) :: fname\n    character(len=*),intent(in) :: key\n    logical :: sgrep\n    character(len=256) :: atmp\n    integer :: ic,io\n    sgrep = .false.\n    open (newunit=ic,file=fname)\n    do\n      read (ic,'(a)',iostat=io) atmp\n      if (io < 0) exit !EOF\n      if (index(atmp,key) .ne. 0) then\n        sgrep = .true.\n        exit\n      end if\n    end do\n    close (ic)\n    return\n  end function sgrep\n\n!============================================================!\n! grep the energy from a line of strings\n!============================================================!\n  function grepenergy(line)\n    implicit none\n    real(wp) :: grepenergy\n    character(len=*),intent(in) :: line\n    real(wp) :: energy\n    character(len=:),allocatable :: atmp\n    integer :: i,io\n    atmp = trim(line)\n    energy = 0.0_wp\n    !> assumes that the first float in the line is the energy\n    do i = 1,len_trim(atmp)\n      if (len_trim(atmp) .lt. 1) exit\n      read (atmp,*,iostat=io) energy\n      if (io > 0) then\n        atmp = atmp(2:)\n        atmp = adjustl(atmp)\n        cycle\n      else\n        exit\n      end if\n    end do\n    grepenergy = energy\n    return\n  end function grepenergy\n\n!============================================================!\n! count number of bonds from an wbo matrix\n!============================================================!\n  function countbonds(nat,wbo) result(nbd)\n    implicit none\n    integer,intent(in)  :: nat\n    real(wp),intent(in) :: wbo(nat,nat)\n    integer :: nbd\n    integer :: i,j,k\n    nbd = 0\n    do i = 1,nat\n      do j = 1,i-1\n        k = nint(wbo(i,j))\n        if (k > 0) nbd = nbd+1\n      end do\n    end do\n    return\n  end function countbonds\n\n!=========================================================================================!\n!=========================================================================================!\n! end of the module\n!=========================================================================================!\n!=========================================================================================!\nend module strucrd\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/strucreader.f90 b/src/strucreader.f90
--- a/src/strucreader.f90	
+++ b/src/strucreader.f90	
@@ -37,7 +37,10 @@
 module strucrd
   use iso_fortran_env,only:wp => real64
   use iso_c_binding
-  use geo !> simple geomerty and vector operations
+!> simple geomerty and vector operations
+  use geo
+!> element symbols
+  use miscdata,only:PSE
   implicit none
 
 !=========================================================================================!
@@ -60,21 +63,21 @@
   private :: upperCase,lowerCase
   private :: convertlable,fextension,sgrep
 
-!>--- Element symbols
-!&<
-  character(len=2),private,parameter :: PSE(118) = [ &
- & 'H ',                                                                                'He', &
- & 'Li','Be',                                                  'B ','C ','N ','O ','F ','Ne', &
- & 'Na','Mg',                                                  'Al','Si','P ','S ','Cl','Ar', &
- & 'K ','Ca','Sc','Ti','V ','Cr','Mn','Fe','Co','Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr', &
- & 'Rb','Sr','Y ','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn','Sb','Te','I ','Xe', &
- & 'Cs','Ba','La',                                                                            &
- &                'Ce','Pr','Nd','Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu',      &
- &                'Hf','Ta','W ','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At','Rn', &
- & 'Fr','Ra','Ac',                                                                            &
- &                'Th','Pa','U ','Np','Pu','Am','Cm','Bk','Cf','Es','Fm','Md','No','Lr',      &
- &                'Rf','Db','Sg','Bh','Hs','Mt','Ds','Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og' ]
-!&>
+!!>--- Element symbols
+!!&<
+!  character(len=2),private,parameter :: PSE(118) = [ &
+! & 'H ',                                                                                'He', &
+! & 'Li','Be',                                                  'B ','C ','N ','O ','F ','Ne', &
+! & 'Na','Mg',                                                  'Al','Si','P ','S ','Cl','Ar', &
+! & 'K ','Ca','Sc','Ti','V ','Cr','Mn','Fe','Co','Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr', &
+! & 'Rb','Sr','Y ','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn','Sb','Te','I ','Xe', &
+! & 'Cs','Ba','La',                                                                            &
+! &                'Ce','Pr','Nd','Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu',      &
+! &                'Hf','Ta','W ','Re','Os','Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At','Rn', &
+! & 'Fr','Ra','Ac',                                                                            &
+! &                'Th','Pa','U ','Np','Pu','Am','Cm','Bk','Cf','Es','Fm','Md','No','Lr',      &
+! &                'Rf','Db','Sg','Bh','Hs','Mt','Ds','Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og' ]
+!!&>
 
 !=========================================================================================!
 !>--- public subroutines
@@ -130,7 +133,7 @@
     module procedure rdensemble_conf3
 
     module procedure rdensemble_mixed2
-    
+
     module procedure rdensemble_coord_type
   end interface rdensemble
 
@@ -145,6 +148,7 @@
   public :: coord
   public :: ensemble
   public :: coordline
+  public :: get_atlist
 
 !=========================================================================================!
   !coord class. contains a single structure in the PDB format.
@@ -178,8 +182,6 @@
     !********************************************!
     !>-- number of atoms
     integer :: nat = 0
-    !>-- energy
-    real(wp) :: energy = 0.0_wp
     !>-- atom types as integer, dimension will be at(nat)
     integer,allocatable  :: at(:)
     !>-- atomic coordinates, by convention in Bohrs
@@ -188,6 +190,8 @@
     !**************************************!
     !> (optional) data, often not present <!
     !**************************************!
+    !>-- energy
+    real(wp) :: energy = 0.0_wp
     !>-- a comment line
     character(len=:),allocatable :: comment
     !>-- molecular charge
@@ -201,7 +205,7 @@
     !>-- lattice vectors
     real(wp),allocatable :: lat(:,:)
 
-    !--- (optional) PDB data
+    !>-- (optional) PDB data
     type(pdbdata) :: pdb
 
   contains
@@ -214,6 +218,7 @@
     procedure :: dist => coord_getdistance      !> calculate distance between two atoms
     procedure :: angle => coord_getangle        !> calculate angle between three atoms
     procedure :: dihedral => coord_getdihedral  !> calculate dihedral angle between four atoms
+    procedure :: cutout => coord_getcutout      !> create a substructure 
   end type coord
 !=========================================================================================!
   !ensemble class. contains all structures of an ensemble
@@ -318,16 +323,23 @@
   subroutine rdensemble_conf1(fname,nat,nall,at,xyz,eread)
     implicit none
     character(len=*),intent(in) :: fname
-    integer,intent(in) :: nat
-    integer,intent(in) :: nall
-    integer :: at(nat)
-    real(wp) :: xyz(3,nat,nall)
-    real(wp) :: eread(nall)
+    integer,intent(inout) :: nat
+    integer,intent(inout) :: nall
+    integer,intent(inout),allocatable :: at(:)
+    real(wp),intent(inout),allocatable :: xyz(:,:,:)
+    real(wp),intent(inout),allocatable :: eread(:)
     integer :: i,j,k,ich,io
     logical :: ex
     integer :: dum
     character(len=512) :: line
     character(len=6) :: sym
+    if (.not.allocated(xyz).or..not.allocated(at)) then
+      call rdensembleparam(fname,nat,nall)
+    end if
+    if (.not.allocated(xyz)) allocate (xyz(3,nat,nall))
+    if (.not.allocated(at)) allocate (at(nat))
+    if (.not.allocated(eread)) allocate (eread(nall))
+
     eread = 0.0_wp
     xyz = 0.0_wp
     open (newunit=ich,file=fname)
@@ -371,15 +383,20 @@
   subroutine rdensemble_conf2(fname,nat,nall,at,xyz)
     implicit none
     character(len=*),intent(in) :: fname
-    integer,intent(in) :: nat
-    integer,intent(in) :: nall
-    integer :: at(nat)
-    real(wp) :: xyz(3,nat,nall)
+    integer,intent(inout) :: nat
+    integer,intent(inout) :: nall
+    integer,intent(inout),allocatable :: at(:)
+    real(wp),intent(inout),allocatable :: xyz(:,:,:)
     integer :: i,j,k,ich,io
     logical :: ex
     integer :: dum,nallnew
     character(len=512) :: line
     character(len=6) :: sym
+    if (.not.allocated(xyz).or..not.allocated(at)) then
+      call rdensembleparam(fname,nat,nall)
+    end if
+    if (.not.allocated(xyz)) allocate (xyz(3,nat,nall))
+    if (.not.allocated(at)) allocate (at(nat))
     io = 0
     xyz = 0.0_wp
     open (newunit=ich,file=fname)
@@ -422,8 +439,8 @@
   subroutine rdensemble_conf3(fname,nat,nall,at,xyz,comments)
     implicit none
     character(len=*),intent(in) :: fname
-    integer,intent(in) :: nat
-    integer,intent(in) :: nall
+    integer,intent(inout) :: nat
+    integer,intent(inout) :: nall
     integer :: at(nat)
     integer,allocatable :: atdum(:)
     real(wp) :: xyz(3,nat,nall)
@@ -556,18 +573,18 @@
     !>--- Important: coord types must be in Bohrs
     xyz = xyz/bohr
     !>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<!
- 
-    allocate (ensemble(nall)) 
-    do i=1,nall
-      ensemble(i)%nat = nat 
-      allocate(ensemble(i)%at(nat))
+
+    allocate (ensemble(nall))
+    do i = 1,nall
+      ensemble(i)%nat = nat
+      allocate (ensemble(i)%at(nat))
       ensemble(i)%at(:) = at(:)
-      allocate(ensemble(i)%xyz(3,nat))
+      allocate (ensemble(i)%xyz(3,nat))
       ensemble(i)%xyz(:,:) = xyz(:,:,i)
       ensemble(i)%energy = eread(i)
-    enddo
+    end do
 
-    deallocate(eread,at,xyz)
+    deallocate (eread,at,xyz)
   end subroutine rdensemble_coord_type
 
 !=================================================================!
@@ -1395,6 +1412,38 @@
     return
   end function coord_getdihedral
 
+!==================================================================!
+! function coord_getgutout
+! create a cutout mol object
+!==================================================================!
+  function coord_getcutout(self,atlist) result(molout)
+    implicit none
+    class(coord) :: self
+    logical,intent(in) :: atlist(self%nat)
+    type(coord) :: molout
+    integer :: newnat,i,j,k,l
+    
+    newnat = count(atlist,1)
+    if(newnat == self%nat)then
+       molout = self
+    else
+      allocate(molout%at( newnat ), source = 0)
+      allocate(molout%xyz(3,newnat), source = 0.0_wp)
+      k = 0
+      do i=1,self%nat
+        if(atlist(i))then
+          k = k + 1 
+          molout%at(k) = self%at( i )
+          molout%xyz(1:3,k) = self%xyz(1:3, i) 
+        endif
+      enddo
+    endif
+    return
+  end function coord_getcutout
+
+
+
+
 !=========================================================================================!
 !=========================================================================================!
 !  3. ROUTINES FOR WRITING STRUCTURES AND CONVERTING THEM
@@ -1968,9 +2017,11 @@
     character(len=*),intent(in) :: cin
     character(len=:),allocatable :: c
     integer :: iout
-    integer :: i,j,k,ich,io
+    integer :: i,j,k,ich,io,Z
     logical :: ex
     c = trim(convertlable(cin))
+    read (cin,*,iostat=io) j
+    if (io == 0) Z = j
     if (any(PSE(:) .eq. c)) then
       do i = 1,118
         if (trim(PSE(i)) .eq. c) then
@@ -1978,6 +2029,8 @@
           exit
         end if
       end do
+    else if (io == 0.and.Z <= 118) then
+      iout = Z
     else !> special cases
       select case (trim(c))
       case ('D'); iout = 1
@@ -2108,6 +2161,90 @@
     return
   end function countbonds
 
+!=========================================================================================!
+
+  subroutine get_atlist(nat,atlist,line,at)
+!******************************************************
+!* Analyze a string containing atom specifications.
+!* "atlist" is a array of booleans for each atom,
+!* which is set to .true. should the atom be contained
+!* in atlist.
+!******************************************************
+    implicit none
+    integer,intent(in) :: nat
+    logical,intent(out),allocatable :: atlist(:)
+    character(len=*),intent(in) :: line
+    integer,intent(in),optional :: at(nat)
+    character(len=:),allocatable :: substr(:)
+    integer :: i,j,k,l,io,ns,ll,i1,i2,io1,io2,i3,i4
+    character(len=:),allocatable :: atmp,btmp
+
+    allocate (atlist(nat),source=.false.)
+!>-- count stuff
+    ll = len_trim(line)
+    ns = 1
+    do i = 1,ll
+      if (line(i:i) .eq. ',') ns = ns+1
+    end do
+    allocate (substr(ns),source=repeat(' ',ll))
+!>-- cut stuff
+    if (ns > 1) then
+      j = 1
+      k = 1
+      do i = 1,ll
+        if (k == ns) then
+          substr(k) = lowercase(adjustl(line(j:)))
+          exit
+        end if
+        if (line(i:i) .eq. ',') then
+          substr(k) = lowercase(adjustl(line(j:i-1)))
+          k = k+1
+          j = i+1
+        end if
+      end do
+    else
+      substr(1) = trim(line)
+    end if
+!>--- analyze stuff
+    do i = 1,ns
+      atmp = trim(substr(i))
+      if(atmp.eq.'all')then
+         atlist(:) = .true.
+         exit
+      endif
+      if(index(atmp,'.').ne.0) cycle !> exclude floats
+      l = index(atmp,'-')
+      if (l .eq. 0) then
+        read (atmp,*,iostat=io) i1
+        !> check if it is an element symbol
+        if (io /= 0) then
+          if(len_trim(atmp) > 2) cycle !> exclude non-elements
+          k = e2i(atmp)
+          if (present(at)) then
+            do j = 1,nat
+              if (at(j) == k) atlist(j) = .true.
+            end do
+          end if
+        else
+          atlist(i1) = .true.
+        end if
+      else
+        btmp = atmp(:l-1)
+        read (btmp,*,iostat=io1) i1
+        btmp = atmp(l+1:)
+        read (btmp,*,iostat=io2) i2
+        if (io1 .eq. 0.and.io2 .eq. 0) then
+          i4 = max(i1,i2)
+          i3 = min(i1,i2)
+          do j = 1,nat
+            if (i3 <= j.and.j <= i4) atlist(j) = .true.
+          end do
+        end if
+      end if
+    end do
+    deallocate(substr)
+  end subroutine get_atlist
+
 !=========================================================================================!
 !=========================================================================================!
 ! end of the module
Index: src/printouts.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!===================================================================================================!\n! Print Header\n!===================================================================================================!\nsubroutine confscript_head(vers)\n  implicit none\n  logical,intent(in) :: vers\n  logical :: niceprint\n  include 'crest_metadata.fh' !> this file should be created by meson or CMake\n\n  niceprint = .true.\n  call box3(version,date,commit,author)\n  write (*,*)\n\n  if (vers) then\n    write (*,*) \"crest \",trim(version)\n    stop\n  end if\n\n  write (*,'(3x,''Cite work conducted with this code as'')')\n  write (*,'(/,3x,''• P.Pracht, F.Bohle, S.Grimme, PCCP, 2020, 22, 7169-7192.'')')\n  write (*,'(  3x,''• S.Grimme, JCTC, 2019, 15, 2847-2862.'')')\n  write (*,'(/,3x,''for works involving QCG cite'')')\n  write (*,'(/,3x,''• S.Spicher, C.Plett, P.Pracht, A.Hansen, S.Grimme,'')')\n  write (*,'(  3x,''  JCTC, 2022, 18 (5), 3174-3189.'')')\n  write (*,'(  3x,''• C.Plett, S. Grimme,'')')\n  write (*,'(  3x,''  Angew. Chem. Int. Ed. 2023, 62, e202214477.'')')\n  write (*,'(/,3x,''for works involving MECP screening cite'')')\n  write (*,'(/,3x,''• P.Pracht, C.Bannwarth, JCTC, 2022, 18 (10), 6370-6385.'')')\n  write (*,*)\n\n  write (*,'(3x,a)') 'Original code'\n  write (*,'(4x,a)') 'P.Pracht, S.Grimme, Universität Bonn, MCTC'\n  write (*,'(3x,a)') 'with help from (alphabetical order):'\n  write (*,'(4x,a)') 'C.Bannwarth, F.Bohle, S.Ehlert, G.Feldmann, S.Grimme,'\n  write (*,'(4x,a)') 'C.Plett, P.Pracht, S.Spicher, P.Steinbach'\n  write (*,*)\n\n  write (*,'(3x,a)') 'Online documentation is available at'\n  write (*,'(3x,a)') 'https://crest-lab.github.io/crest-docs/'\n  write (*,*)\n\n  call disclaimer()\n\nend subroutine confscript_head\n\nsubroutine box3(version,date,commit,author)\n  implicit none\n  character(len=*) :: version\n  character(len=*) :: date\n  character(len=*) :: commit\n  character(len=*) :: author\n  character(len=200) :: logo(10)\n  character(len=200) :: info(2)\n  integer,parameter :: pad_left=7\n  integer :: i,lcount\n  write (*,*)\n  write (logo( 1),'(''╔════════════════════════════════════════════╗'')')\n  write (logo( 2),'(''║            ___ ___ ___ ___ _____           ║'')')\n  write (logo( 3),'(''║           / __| _ \\ __/ __|_   _|          ║'')')\n  write (logo( 4),'(''║          | (__|   / _|\\__ \\ | |            ║'')')\n  write (logo( 5),'(''║           \\___|_|_\\___|___/ |_|            ║'')')\n  write (logo( 6),'(''║                                            ║'')')\n  write (logo( 7),'(''║  Conformer-Rotamer Ensemble Sampling Tool  ║'')')\n  write (logo( 8),'(''║          based on the GFN methods          ║'')')\n  write (logo( 9),'(''║                                            ║'')')\n  write (logo(10),'(''╚════════════════════════════════════════════╝'')')\n  do i=1,10\n    write(*,'(a,a)') repeat(\" \",pad_left),trim(logo(i))\n  enddo\n  write (*,'(a,''Version '',a,'', '',a)') repeat(\" \",pad_left),trim(version),trim(date)\n  write (*,'(a,\"commit (\",a,\") compiled by \",a)') repeat(\" \",pad_left),commit,author\nend subroutine box3\n\nsubroutine disclaimer\n\n  write (*,'(3x,a)') 'This program is distributed in the hope that it will be useful,'\n  write (*,'(3x,a)') 'but WITHOUT ANY WARRANTY; without even the implied warranty of'\n  write (*,'(3x,a)') 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the'\n  write (*,'(3x,a)') 'GNU Lesser General Public License for more details.'\n\nend subroutine disclaimer\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c Confscript help printout\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine confscript_help()\n  use crest_data\n  implicit none\n\n  write (*,*)\n  write (*,'(1x, ''usage        :'')')\n  write (*,'(1x, ''crest [input] [options]'')')\n  write (*,*)\n  write (*,'(1x, ''The FIRST argument CAN be a coordinate file in the'')')\n  write (*,'(1x, ''TM (coord, Bohr) or Xmol (*.xyz, Ang.) format.'')')\n  write (*,'(1x, ''If no such file is present as the first argument crest will'')')\n  write (*,'(1x, ''automatically search for a file called \"coord\" in the TM format.'')')\n  write (*,'(/,1x,''General and technical options:'')')\n  write (*,'(5x,''-v1                : use the MF-MD-GC workflow. (OUTDATED)'')')\n  write (*,'(5x,''-v2                : use the MTD-GC workflow. (OUTDATED)'')')\n  write (*,'(5x,''-v3 (or -v2i)      : use the iMTD-GC workflow. [default]'')')\n  write (*,'(5x,''-v4                : use the iMTD-sMTD workflow.'')')\n  write (*,'(5x,''-entropy           : the same workflow as with \"-v4\", specialized'')')\n  write (*,'(5x,''                     for the calculation of conformational entropy.'')')\n  write (*,'(5x,''-xnam <\"bin\">      : specify name of the xtb binary'')')\n  write (*,'(5x,''                     that should be used.'')')\n  write (*,'(5x,''-niceprint         : progress bar printout for optimizations'')')\n  write (*,'(5x,''-dry               : perform a \"dry run\". Only prints the settings'')')\n  write (*,'(5x,''                     that would be applied with the CMD input'')')\n  write (*,'(5x,''                     and stops the run before any calculations'')')\n  write (*,'(5x,''-T <int>           : Set total number of CPUs(threads)'')')\n  write (*,'(5x,''                     to be used. Parallel settings are then'')')\n  write (*,'(5x,''                     determined automatically for each step.'')')\n  write (*,'(5x,''                     If not set by \"-T\", this number is read'')')\n  write (*,'(5x,''                     from the OMP_NUM_THREADS global variable.'')')\n  write (*,*)\n  write (*,*)\n\n  write (*,'(1x,''Calculation options:'')')\n  write (*,'(5x,''-g <string>        : use GBSA implicit solvent'')')\n  write (*,'(5x,''                     for solvent <string>'')')\n  write (*,'(5x,''-alpb <string>     : use ALPB implicit solvent'')')\n  write (*,'(5x,''                     for solvent <string>'')')\n  write (*,'(5x,''-chrg <int>        : set the molecules´ charge'')')\n  write (*,'(5x,''-uhf <int>         : set <int>=Nα-Nβ electrons'')')\n  write (*,'(5x,''-charges <file>    : copy a existing atomic charges file for'')')\n  write (*,'(5x,''                     all optimizations (can be used by GFN-FF)'')')\n  write (*,'(5x,''-nozs              : do not perform z-mat sorting [default]'')')\n  write (*,'(5x,''-opt <\"lev\">       : set opt. level for ALL GFN-xTB'')')\n  write (*,'(5x,''                     optimizations.'')')\n  write (*,'(5x,''                     <lev>=vloose,loose,normal,tight,vtight'')')\n  write (*,'(5x,''                     [default: vtight]'')')\n  write (*,'(5x,''-gfn1              : use GFN1-xTB'')')\n  write (*,'(5x,''-gfn2              : use GFN2-xTB [default]'')')\n  !write(*,'(5x,''-gfn0              : use GFN0-xTB'')')\n  write (*,'(5x,''-gff, -gfnff       : use GFN-FF (requires xtb 6.3 or newer)'')')\n  write (*,'(5x,''                     (for GFN-FF searches bond constraints are applied automatically)'')')\n  write (*,'(5x,''-gfn2//gfnff       : GFN2-xTB//GFN-FF composite mode)'')')\n  write (*,'(3x,''Adding additional constraints to the calculations:'')')\n  write (*,'(3x,''The user is able to include additional constraints to ALL'')')\n  write (*,'(3x,''xtb calculations that are conducted by CREST.'')')\n  write (*,'(5x,''-cinp <file>       : read in a file containing the constraints.'')')\n  write (*,'(5x,''                     constraints have to be in the same format as in xtb.'')')\n  write (*,'(5x,''                     (this was done previously via the \".constrains\" file)'')')\n  write (*,'(5x,''-cbonds            : define automatic bond constraints (set up from topology)'')')\n  write (*,'(5x,''-nocbonds          : turn of -cbonds (for GFN-FF, mainly. see above)'')')\n  write (*,'(5x,''-fc <float>        : define force constant for defined constraints (-cbonds)'')')\n  write (*,*)\n  write (*,*)\n\n  write (*,'(1x,''Options for ensemble comparisons:'')')\n  write (*,'(5x,''-cregen [file]     : use ONLY the CREGEN subroutine'')')\n  write (*,'(5x,''                     to sort a given ensemble file.'')')\n  write (*,'(5x,''-ewin <real>       : set energy window in kcal/mol,'')')\n  write (*,'(5x,''                     [default: 6.0 kcal/mol]'')')\n  write (*,'(5x,''-rthr <real>       : set RMSD threshold in Ang,'')')\n  write (*,'(5x,''                     [default: 0.125 Ang]'')')\n  write (*,'(5x,''-ethr <real>       : set E threshold in kcal/mol,'')')\n  write (*,'(5x,''                     [default: 0.05 kcal/mol]'')')\n  write (*,'(5x,''-bthr <real>       : set Rot. const. threshold ,'')')\n  write (*,'(5x,''                     [default: 0.01 (= 1%)]'')')\n  write (*,'(5x,''-pthr <real>       : Boltzmann population threshold'')')\n  write (*,'(5x,''                     [default: 0.05 (= 5%)]'')')\n  write (*,'(5x,''-temp <real>       : set temperature in cregen, [default: 298.15 K]'')')\n  write (*,'(5x,''-prsc              : create a scoord.* file for each conformer'')')\n  write (*,'(5x,''-nowr              : don´t write new ensemble files'')')\n  write (*,'(5x,''-eqv,-nmr,-entropy : compare nuclear equivalences (requires rotamers)'')')\n  write (*,'(5x,''-cluster <int>     : PCA and k-Means clustering of sorted ensemble.'')')\n  write (*,'(5x,''                     Works as extenstion to the CREGEN sorting.'')')\n  write (*,'(5x,''                     <int> is the number of clusters to be formed.'')')\n  write (*,'(5x,''-notopo            : turn off any topology checks in CREGEN.'')')\n  write (*,*)\n  write (*,*)\n  write (*,'(1x,''Options for the iMTD-GC workflows:'')')\n  write (*,'(5x,''-cross             : do the GC part [default]'')')\n  write (*,'(5x,''-nocross           : don´t do the GC part'')')\n  write (*,'(5x,''-shake <int>       : set SHAKE mode for MD'')')\n  write (*,'(5x,''                     (0=off,1=H-only,2=all bonds) [default: 2]'')')\n  write (*,'(5x,''-tstep <int>       : set MD time step in fs'')')\n  write (*,'(5x,''                     [default: 5 fs]'')')\n  write (*,'(5x,''-mdlen/-len <real> : set MD length (all MTDs) in ps.'')')\n  write (*,'(5x,''                     Also possible are multiplicative factors'')')\n  write (*,'(5x,''                     for the default MD length with \"x<real>\"'')')\n  write (*,'(5x,''-mddump <int>      : xyz dumpstep to Trajectory in fs'')')\n  write (*,'(5x,''                     [default: 100 fs]'')')\n  write (*,'(5x,''-vbdump <real>     : set Vbias dump frequency in ps'')')\n  write (*,'(5x,''                     [default: 1.0 ps]'')')\n  write (*,'(5x,''-tnmd <real>       : set temperature for additional normal MDs'')')\n  write (*,'(5x,''                     [default: 400 K]'')')\n  write (*,'(5x,''-norotmd           : don´t do the regular MDs after the '')')\n  write (*,'(5x,''                     second multilevel optimization step'')')\n  write (*,'(5x,''-hflip/-noflip     : turn on/off a small enhancement routine to'')')\n  write (*,'(5x,''                     rotate OH groups after MTD. [default: OFF]'')')\n  write (*,'(5x,''-maxflip <int>     : max. number of new structures by the above'')')\n  write (*,'(5x,''                     enhancement routine. [default: 1000]'')')\n  write (*,'(5x,''-quick             : perform a search with reduced settings'')')\n  write (*,'(5x,''                     for a crude ensemble.'')')\n  write (*,'(5x,''-squick            : perform a even further reduced search'')')\n  write (*,'(5x,''-mquick            : perform a search with maximum reduced settings'')')\n  write (*,'(5x,''                     (do not reduce the settings more than that)'')')\n  write (*,'(5x,''-origin            : track the step of generation for'')')\n  write (*,'(5x,''                     each conformer/rotamer. [default]'')')\n  write (*,'(5x,''-keepdir           : keep sub-directories of the conformer'')')\n  write (*,'(5x,''                     generation step.'')')\n  write (*,'(5x,''-nci               : generate an ellipsoide potential around the'')')\n  write (*,'(5x,''                     input structure and add it to the MTD simulation.'')')\n  write (*,'(5x,''                     This can be used to find aggregates of NCI complexes.'')')\n  write (*,'(5x,''-wscal <real>      : scale the ellipsoide potential axes by factor <real>.'')')\n  write (*,*)\n  write (*,*)\n  write (*,'(1x,''Thermostatistical options (used in entropy mode):'')')\n  write (*,'(5x,''-trange <lower> <upper> <step>   : entropies are calculated for different temperatures.'')')\n  write (*,'(5x,''                                   these are calculated in a temperature range from'')')\n  write (*,'(5x,''                                   <lower> to <upper> with <step> in between.'')')\n  write (*,'(5x,''                                   [default: 280K-380K in 10K steps]'')')\n  write (*,'(5x,''-fscal <float>     : frequency scaling factor. [default: 1.0]'')')\n  write (*,'(5x,''-sthr <float>      : vibrational/rotational entropy interpolation threshold (τ)'')')\n  write (*,'(5x,''                     [default: 25.0 cm^-1]'')')\n  write (*,'(5x,''-ithr <float>      : imaginary mode inversion cutoff [default: -50.0 cm^-1]'')')\n  write (*,'(5x,''-ptot <float>      : sum of population for structures considered in msRRHO average.'')')\n  write (*,'(5x,''                     [default: 0.9 (=90%)]'')')\n\n  write (*,*)\n  write (*,*)\n\n  write (*,'(1x,''Quantum Cluster Growth (QCG)'')')\n  write (*,'(1x,''General usage :'')')\n  write (*,'(5x,''<solute> -qcg <solvent> [options]'')')\n  write (*,'(1x,''options (additionally to the iMTD-GC options above):'')')\n  write (*,'(5x,''-keepdir           : keep the tmp folder'')')\n  write (*,'(5x,''-nopreopt          : do not perform preoptimization (only for qcg).'')')\n  write (*,'(5x,''-xtbiff            : use the xTB-IFF standalone for docking of solvent'')')\n  write (*,'(5x,''-grow              : cluster generation'')')\n  write (*,'(5x,''-fixsolute         : fix the solute during the growth (recommended for rigid ones)'')')\n  write (*,'(5x,''                   : done automatically for water'')')\n  write (*,'(5x,''-nofix             : fix the solute not during the growth (needed only for water)'')')\n!      write(*,'(5x,''-fixens            : fix the solute during the ensemble generation'')')\n  write (*,'(5x,''-nsolv <INT>       : number of solvent molecules to add'')')\n  write (*,'(5x,''-normdock          : Perform a more extensive docking during grow'')')\n  write (*,'(5x,''-maxsolv           : set limit of convergence, if no number of solutes was given. Default 150 '')')\n  write (*,'(5x,''-wscal <FLOAT>     : Scaling factor for outer wall potential'')')\n  write (*,'(5x,''-samerand          : use same random number for every xtbiff run'')')\n  write (*,'(5x,''-ensemble          : ensemble generation'')')\n  write (*,'(5x,''-qcgmtd            : NCI-MTD CREST ensemble generation (Default)'')')\n  write (*,'(5x,''-ncimtd            : NCI-MTD CREST ensemble generation'')')\n  write (*,'(5x,''-mtd               : MTD for QCG ensemble generation'')')\n  write (*,'(5x,''-md                : normal MD for QCG ensemble search'')')\n  write (*,'(5x,''-enslvl [method]   : define a method for ensemble search. All gfn methods are supported'')')\n  write (*,'(5x,''-clustering        : Turn on clustering for the ensemble search (only for qcgmtd and ncimtd'')')\n  write (*,'(5x,''-esolv             : reference cluster generation and comp. of solvation energy'')')\n  write (*,'(5x,''-gsolv             : reference cluster generation and comp. of solvation free energy'')')\n  write (*,'(5x,''-nclus             : defines how many clusters are taken for reference cluster generation'')')\n  write (*,'(5x,''                   : default 4'')')\n  write (*,'(5x,''-nocff             : switches off the CFF algorithm'')')\n  write (*,'(5x,''-freqscal          : defines frequency scale factor. Only for outprint'')')\n  write (*,'(5x,''-freqlvl [method]  : define a method for frequency computation. All gfn versions are supported'')')\n\n  write (*,*)\n  write (*,*)\n  write (*,'(1x,''Other tools for standalone use:'')')\n  write (*,'(5x,''-zsort             : use only the zsort subroutine'')')\n  write (*,'(5x,''                     to sort the z-matrix of the input'')')\n  write (*,'(5x,''                     coord file.'')')\n  write (*,'(5x,''-mdopt <file>      : optimize along trajectory or'')')\n  write (*,'(5x,''                     ensemble file in the XYZ format.'')')\n  write (*,'(5x,''                     Each point on the file is optimized.'')')\n  write (*,'(5x,''-screen <file>     : optimize along ensemble file'')')\n  write (*,'(5x,''                     in the XYZ format. A multilevel'')')\n  write (*,'(5x,''                     optimization is performed with continiously'')')\n  write (*,'(5x,''                     increasing thresholds. After each step'')')\n  write (*,'(5x,''                     the ensemble file is sorted.'')')\n  write (*,'(5x,''-protonate         : find a molecules protomes by using a'')')\n  write (*,'(5x,''                     LMO π- or LP-center approach.'')')\n  write (*,'(5x,''-deprotonate       : find a molecules deprotomers.'')')\n  write (*,'(5x,''-tautomerize       : combine the protonation and deprotonation'')')\n  write (*,'(5x,''                     to find prototropic tautomers.'')')\n  write (*,'(6x,''↳ -trev           : do first the deprotonation and then the'')')\n  write (*,'(8x,''                  protonation in the -tautomerize mode, i.e.,'')')\n  write (*,'(8x,''                  reverse of the default procedure.'')')\n  write (*,'(6x,''↳ -iter <int>     : set number of protonation/deprotonation cycles'')')\n  write (*,'(8x,''                  in the tautomerization script. [default: 2]'')')\n  write (*,'(5x,''-compare <f1> <f2> : compare two ensembles <f1> and <f2>.'')')\n  write (*,'(5x,''                     Both ensembles must have the same'')')\n  write (*,'(5x,''                     order of atoms of the molecule and'')')\n  write (*,'(5x,''                     should contain rotamers.'')')\n  write (*,'(6x,''↳ -maxcomp <int>  : Selcect the lowest <int> conformers'')')\n  write (*,'(8x,''                  out of each ensemble to be compared'')')\n  write (*,'(8x,''                  with \"-compare\". [default: 10]'')')\n  write (*,'(5x,''-testtopo <file>   : Analyze some stuctural info (topology) for a given file.'')')\n  write (*,'(5x,''-constrain <atoms> : write example file \".xcontrol.sample\" for constraints'')')\n  write (*,'(5x,''                     in crest. (see -cinp option above)'')')\n  write (*,'(5x,''-thermo <file>     : Calculate thermo data for given structure. Also requires vibrational'')')\n  write (*,'(5x,''                     frequencies in the TM format, saved as file called \"vibspectrum\"'')')\n  write (*,'(5x,''-rmsd,-rmsdheavy <file1> <file2>  : Calculate RMSD or heavy atom RMSD between two structures.'')')\n  write (*,'(5x,''                                    Input coords are automatically transformed to Angstroem.'')')\n  write (*,'(5x,''-splitfile <file> [from] [to]     : Split an ensemble from <file> into seperate directories'')')\n  write (*,'(5x,''                                    for each structure. [from] and [to] can be used to select'')')\n  write (*,'(5x,''                                    specific structures from the file.'')')\n  write (*,'(5x,''                                    The new directories are collected in the SPLIT directory.'')')\n\n  write (*,*)\n  write (*,*)\n  write (*,*) 'View literature references with [--cite]'\n  write (*,*) 'Also refer to:'\n  write (*,*) 'https://crest-lab.github.io/crest-docs/'\n  write (*,*)\n\n  stop '   [-h] displayed. exit.'\nend subroutine confscript_help\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n\nsubroutine crestcite\n  write (*,*)\n  write (*,'(4x,''MAIN REFERENCES:'')')\n  write (*,'(/5x,''• P. Pracht, F. Bohle, S. Grimme,'')')\n  write (*,'( 5x,''  PCCP, 2020, 22, 7169-7192.'')')\n  write (*,'(/5x,''• S.Grimme, JCTC, 2019, 15, 2847-2862.'')')\n  write (*,'(/5x,''• P.Pracht, S.Grimme, Chem. Sci., 2021, 12, 6551-6568.'')')\n  write (*,'(/5x,''• S.Spicher, C.Plett, P.Pracht, A.Hansen, S.Grimme,'')')\n  write (*,'( 5x,''  JCTC, 2022, 18 (5), 3174-3189.'')')\n  write (*,'(/5x,''• P.Pracht, C.Bannwarth, JCTC, 2022, 18 (10), 6370-6385.'')')\n  write (*,'(/,/)')\n  write (*,'(4x,''GFNn-xTB references:'')')\n  write (*,'(5x,''GFN1-xTB'')')\n  write (*,'(5x,''• S.Grimme, C.Bannwarth, P.Shushkov, JCTC, 2017,'')')\n  write (*,'(5x,''  13, 1989-2009. DOI: 10.1021/acs.jctc.7b00118'')')\n  write (*,'(5x,''GFN2-xTB'')')\n  write (*,'(5x,''• C.Bannwarth, S.Ehlert and S.Grimme., JCTC, 2019,'')')\n  write (*,'(5x,''  15, 1652-1671. DOI: 10.1021/acs.jctc.8b01176'')')\n  write (*,'(5x,''GFN0-xTB'')')\n  write (*,'(5x,''• P.Pracht, E.Caldeweyher, S.Ehlert, S.Grimme, 2019,'')')\n  write (*,'(5x,''  ChemRxiv preprint, DOI: 10.26434/chemrxiv.8326202.v1'')')\n  write (*,'(5x,''GFN-FF'')')\n  write (*,'(5x,''• S.Spicher, S.Grimme, Angew. Chem. Int. Ed., 2020,'')')\n  write (*,'(5x,''  132, 2-11, DOI: 10.1002/ange.202004239'')')\n\n  write (*,'(/,/)')\n  write (*,'(4x,''related references:'')')\n  write (*,'(5x, ''• S.Grimme, C.Bannwarth, S.Dohm, A.Hansen,'')')\n  write (*,'(5x, ''  J.Pisarek, P.Pracht, J.Seibert, F.Neese,'')')\n  write (*,'(5x, ''  Angew. Chem. Int. Ed., 2017, 56, 14763-14769'')')\n  write (*,'(/5x,''• P.Pracht, C.A.Bauer, S.Grimme, JCC, 2017,'')')\n  write (*,'(5x, ''  38, 2618–2631, DOI: 10.1002/jcc.24922'')')\n  write (*,'(/5x,''• P.Pracht, R.Wilcken, A.Udvarhelyi, S.Rodde, S.Grimme,'')')\n  write (*,'(5x, ''  JCAMD, 2018, 32, 1139-1149.'')')\n  write (*,'(/5x,''• P.Pracht, S.Grimme, JPCA, 2021, 125, 5681-5692'')')\n  write (*,'(/5x,''• J.Gorges, S.Grimme, A.Hansen, P.Pracht,'')')\n  write (*,'(5x, ''  PCCP, 2022,24, 12249-12259.'')')\n\n  write (*,'(/,/)')\n  write (*,'(3x,''Please cite work conducted with this code appropriately.'')')\n  stop '   [--cite] displayed. exit.'\nend subroutine crestcite\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n\nsubroutine crestcrest\n  write (*,'(7x,''|                                            |'')')\n  write (*,'(7x,''|              ###############               |'')')\n  write (*,'(7x,''|              #//////|@@@@@@#               |'')')\n  write (*,'(7x,''|              #\\\\\\\\\\\\|@@@@@@#               |'')')\n  write (*,'(7x,''|              #//////|@@@@@@#               |'')')\n  write (*,'(7x,''|              #@@@@@@|\\\\\\\\\\\\#               |'')')\n  write (*,'(7x,''|              #@@@@@@|//////#               |'')')\n  write (*,'(7x,''|               #@@@@@|\\\\\\\\\\#                |'')')\n  write (*,'(7x,''|                ###@@|//###                 |'')')\n  write (*,'(7x,''|                   #####                    |'')')\n  write (*,'(7x,''|                                            |'')')\n  write (*,'(7x,''|                 C R E S T                  |'')')\nend subroutine crestcrest\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n\nsubroutine prchd\n  write (*,*)\n  write (*,'(7x,''========================================'')')\n  write (*,'(7x,''|             C R E G E N              |'')')\n  write (*,'(7x,''|     conformer/rotamer generation     |'')')\n  write (*,'(7x,''| & NMR symmetry/equivalence analysis  |'')')\n  write (*,'(7x,''|      SG, Universitaet Bonn, MCTC     |'')')\n  write (*,'(7x,''|     Fri Aug 11 13:16:16 CEST 2017    |'')')\n  write (*,'(7x,''========================================'')')\n  write (*,*)\nend\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n\nsubroutine header_stereo\n  write (*,*)\n  write (*,'(5x,''========================================'')')\n  write (*,'(5x,''|   automated stereoisomer generator   |'')')\n  write (*,'(5x,''|              P.Pracht                |'')')\n  write (*,'(5x,''|       Universitaet Bonn, MCTC        |'')')\n  write (*,'(5x,''|    Wed 9. Oct 11:20:34 CEST 2019     |'')')\n  write (*,'(5x,''========================================'')')\n  write (*,*)\n\n  write (*,*) 'NOTE: This is a work-in-progress project!'\nend subroutine header_stereo\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n\nsubroutine prreactorhd\n  write (*,*)\n  write (*,'(7x,''========================================'')')\n  write (*,'(7x,''|          GFNn-xTB NANOREACTOR        |'')')\n  write (*,'(7x,''|      SG, Universitaet Bonn, MCTC     |'')')\n  write (*,'(7x,''========================================'')')\n  write (*,'(/,7x,''JCTC, 2019, 15, 2847-2862.'')')\n  write (*,*)\nend\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n\nsubroutine zsortwarning2(env)\n  use crest_data\n  implicit none\n  type(systemdata) :: env\n  logical :: ex\n  inquire (file=env%constraints,exist=ex)\n  if (ex.and.env%autozsort) then\n    write (*,*) '==========================================='\n    write (*,*) 'WARNING:'\n    write (*,*) 'The input coordinate file would be sorted'\n    write (*,*) 'by zsort and a constraining file is'\n    write (*,*) 'present. To avoid constrainment of the'\n    write (*,*) 'wrong atoms zsort will be turned off.'\n    write (*,*) 'This also might influence the results.'\n    write (*,*) '==========================================='\n    write (*,*)\n    env%autozsort = .false.\n  end if\nend subroutine zsortwarning2\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\nsubroutine qcg_head()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''========================================'')')\n  write (*,'(2x,''|           ----------------           |'')')\n  write (*,'(2x,''|                 Q C G                |'')')\n  write (*,'(2x,''|           ----------------           |'')')\n  write (*,'(2x,''|        Quantum Cluster Growth        |'')')\n  write (*,'(2x,''|       University of Bonn, MCTC       |'')')\n  write (*,'(2x,''========================================'')')\n  write (*,'(2x,'' S. Grimme, S. Spicher, C. Plett.'')')\n  write (*,*)\n  write (*,'(3x,''Cite work conducted with this code as'')')\n  write (*,'(/,3x,''S. Spicher, C. Plett, P. Pracht, A. Hansen, S. Grimme, JCTC, 2022, 18, 3174-3189.'')')\n  write (*,*)\nend subroutine qcg_head\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n!convert a string in a small header printout\nsubroutine smallhead(str)\n  use crest_parameters,only:stdout\n  implicit none\n  character(len=*) :: str\n  integer :: strlen\n  character(len=:),allocatable :: str2\n  strlen = len_trim(str)\n  str2 = repeat('-',strlen)\n  write (stdout,'(1x,a)') trim(str2)\n  write (stdout,'(1x,a)') trim(str)\n  write (stdout,'(1x,a)') trim(str2)\n  return\nend subroutine smallhead\nsubroutine smallheadline(line)\n  implicit none\n  character(len=*) :: line\n  integer :: lw\n  lw = len_trim(line)\n  write (*,'(/,1x,a)') repeat('=',lw)\n  write (*,'(1x,a)') trim(line)\n  write (*,'(1x,a)') repeat('=',lw)\n  return\nend subroutine smallheadline\nsubroutine underline(str)\n  implicit none\n  character(len=*) :: str\n  integer :: strlen\n  character(len=:),allocatable :: str2\n  strlen = len_trim(str)\n  str2 = repeat('-',strlen)\n  write (*,'(1x,a)') trim(str)\n  write (*,'(1x,a)') trim(str2)\n  return\nend subroutine underline\n\nfunction str_center_align(str,ilen) result(res)\ncharacter(len=*), intent(in) :: str\ninteger,intent(in) :: ilen\ncharacter(len=:),allocatable :: res\ninteger :: i,slen, str_len, pad_left, pad_right\n\nstr_len = len_trim(str)\nif(str_len >= ilen)then\n  slen = str_len + 2\nelse\n  slen = ilen\nendif\nwrite(*,*) slen,ilen,str_len\npad_left = (slen - str_len) / 2\npad_right = slen - pad_left - str_len\n\nres = \"\"\nwrite(*,*) pad_left\ndo i = 1,pad_left\n res = res // \" \"\nenddo\n!res = repeat(\" \",pad_left)\nres = res // trim(str)\nend function str_center_align\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n! a warning when the MTD length exceeds 200ps\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n\nsubroutine mtdwarning(lenv)\n  implicit none\n  real*8 :: lenv\n\n  write (*,*)\n  write (*,'(a,f5.1,a)') \"! WARNING: the estimated MTD time exceeds \",lenv,\" ps.\"\n  write (*,'(a       )') \"! Because the estimate is uncertain, the program restricts\"\n  write (*,'(a,f5.1,a)') \"! this to \",lenv,\" ps and continues. The user may\"\n  write (*,'(a       )') \"! re-run crest with manual setting by '-mdlen <time>' and\"\n  write (*,'(a       )') \"! check the results carefully.\"\n  write (*,*)\n\nend subroutine mtdwarning\n\n!--------------------------------------------------------------------------------------------\n! iteration cycler printout\n!--------------------------------------------------------------------------------------------\nsubroutine printiter\n  implicit none\n  write (*,*)\n  write (*,'(''*******************************************************************************************'')')\n  write (*,'(''**                        N E W    I T E R A T I O N    C Y C L E                        **'')')\n  write (*,'(''*******************************************************************************************'')')\nend subroutine printiter\n!--------------------------------------------------------------------------------------------\nsubroutine printiter2(i)\n  implicit none\n  integer :: i\n  write (*,*)\n  write (*,'(90(\"*\"))')\n  write (*,'(\"**\",26x,\"I T E R A T I O N    C Y C L E    \",i3,23x,\"**\")') i\n  write (*,'(90(\"*\"))')\nend subroutine printiter2\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n!convert a string in a large header printout\nsubroutine largehead(str)\n  implicit none\n  character(len=*) :: str\n  call construct_large_headline('*',str)\n  return\nend subroutine largehead\nsubroutine largehead2(str)\n  implicit none\n  character(len=*) :: str\n  call construct_large_headline('+',str)\n  return\nend subroutine largehead2\nsubroutine construct_large_headline(symb,str)\n  implicit none\n  character(len=1) :: symb\n  character(len=*) :: str\n  integer :: strlen,strlen2\n  integer :: k\n  integer :: i,j\n  character(len=128) :: str2\n  character(len=128) :: str3\n  strlen = len_trim(str)\n  str2 = repeat(symb,90)\n  strlen2 = len_trim(str2)\n  if (strlen .ge. strlen2) then\n    str2 = ''\n    do i = 1,strlen+6\n      str2 = trim(str2)//symb\n    end do\n    strlen = strlen+6\n  end if\n  k = strlen2-strlen\n  j = k/2-2\n  str3 = symb//symb\n  str3(j+1:) = trim(str)\n  str3(strlen2-1:strlen2) = symb//symb\n  write (*,*)\n  write (*,'(a)') trim(str2)\n  write (*,'(a)') trim(str3)\n  write (*,'(a)') trim(str2)\n  return\nend subroutine construct_large_headline\n\n!========================================================================================!\n!> metadata from include\nsubroutine print_crest_metadata()\n   include 'crest_metadata.fh'\n\n   write(*,'(2x,a,1x,a)') 'CREST version    :',version\n   write(*,'(2x,a,1x,a)') 'timestamp        :',date\n   write(*,'(2x,a,1x,a)') 'commit           :',commit\n   write(*,'(2x,a,1x,a)') 'compiled by      :',author\n   write(*,'(2x,a,1x,a)') 'Fortran compiler :',fcompiler\n   write(*,'(2x,a,1x,a)') 'C compiler       :',ccompiler \n   write(*,'(2x,a,1x,a)') 'build system     :',bsystem\n   write(*,'(2x,a,1x,a)') '-DWITH_TOMLF     :',tomlfvar\n   write(*,'(2x,a,1x,a)') '-DWITH_GFN0      :',gfn0var\n   write(*,'(2x,a,1x,a)') '-DWITH_GFNFF     :',gfnffvar\n   write(*,'(2x,a,1x,a)') '-DWITH_TBLITE    :',tblitevar\n   write(*,'(2x,a,1x,a)') '-DWITH_XHCFF     :',xhcffvar\n\nend subroutine print_crest_metadata\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c Confscript dry-run printout\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine crest_dry(env)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use iomod\n  implicit none\n\n  type(systemdata),intent(inout) :: env\n  character(len=1024) :: dumstr\n  character(len=:),allocatable :: dum\n  logical :: cregenpr = .false.\n  logical :: mdsetpr = .false.\n  logical :: jobpr = .true.\n  logical :: xtbpr = .true.\n  logical :: techpr = .true.\n\n  call largehead('D R Y    R U N')\n  write (*,'(1x,a)') 'Dry run was requested.'\n  write (*,'(1x,a)') 'Running CREST with the chosen cmd arguments will result in the following settings:'\n\n  write (*,'(/,1x,a,a)') 'Input file : ',trim(env%inputcoords)\n\n  write (*,'(/,1x,a)') 'Job type :'\n  if (env%onlyZsort) then\n    write (*,'(2x,a)',advance='no') '1.'\n    write (*,'(2x,a)') 'Standalone use of ZSORT routine.'\n    xtbpr = .false.\n    techpr = .false.\n    jobpr = .false.\n  else if (env%properties .lt. 0) then\n    jobpr = .false.\n    write (*,'(2x,a)',advance='no') '1.'\n    select case (env%properties)\n    case (-1)\n      write (*,'(2x,a)') 'Standalone use of CREGEN sorting routine.'\n      cregenpr = .true.\n      xtbpr = .false.\n    case (-2)\n      write (*,'(2x,a)') 'Comparison of two conformer-rotamer ensembles'\n      cregenpr = .true.\n      xtbpr = .false.\n    case (-3)\n      write (*,'(2x,a)') 'Automated protonation'\n    case (-4)\n      write (*,'(2x,a)') 'Automated deprotonation'\n    case (-5)\n      write (*,'(2x,a)') 'Automated tautomerization'\n    case (-666)\n      write (*,'(2x,a)') '\"Property\" calculation (-prop) for a given ensemble.'\n    case default\n      write (*,'(2x,a)') '<undefined>'\n    end select\n  else\n    cregenpr = .true.\n    write (*,'(2x,a)',advance='no') '1.'\n    select case (env%crestver)\n    case (1)\n      write (*,'(2x,a)') 'Conformational search via the MF-MD-GC algo'\n    case (2)\n      if (env%properties == 45) then\n        write (*,'(2x,a)') 'Conformational search via the iMTD-sMTD algo'\n      else if (env%iterativeV2) then\n        write (*,'(2x,a)') 'Conformational search via the iMTD-GC algo'\n      else\n        write (*,'(2x,a)') 'Conformational search via the MTD-GC algo'\n      end if\n      mdsetpr = .true.\n    case (crest_imtd2)\n      write (*,'(2x,a)') 'Conformational search cia the iMTD-sMTD algo (-v4)'\n      mdsetpr = .true.\n    case (3)\n      write (*,'(2x,a)') 'Reoptimization of all structures in a given ensemble (-mdopt)'\n    case (4)\n      write (*,'(2x,a)') 'Reoptimization and sorting of all structures in a given ensemble (-screen)'\n    case (7)\n      write (*,'(2x,a)') 'GFNn-xTB nano reactor (-reactor)'\n    case (crest_pka)\n      write (*,'(2x,a)') 'GFN2-xTB/ALPB(H2O) pKa calculation (-pka)'\n    case default\n      write (*,'(2x,a)') '<undefined>'\n    end select\n    if (env%properties .gt. 0) then\n      select case (env%properties)\n      case (45)\n        write (*,'(2x,a,2x,a)') '2.','Calculation of molecular ensemble entropy (-entropy)'\n      case default\n        write (*,'(2x,a,2x,a)') '2.','Additional \"property\" calculation requested (-prop)'\n      end select\n    end if\n  end if\n\n  if (jobpr) then\n    write (*,'(/,1x,a)') 'Job settings'\n    write (*,'(2x,a,l6)') 'sort Z-matrix        : ',env%autozsort\n    if (env%crestver .eq. 2) then\n      select case (env%runver)\n      case (2)\n        write (*,'(2x,a,a)') 'MTD-GC modified mode : ','\"-quick\"'\n      case (4)\n        write (*,'(2x,a,a)') 'MTD-GC modified mode : ','\"-nci\"'\n      case (5)\n        write (*,'(2x,a,a)') 'MTD-GC modified mode : ','\"-squick\"'\n      case (6)\n        write (*,'(2x,a,a)') 'MTD-GC modified mode : ','\"-mquick\"'\n      case (111)\n        write (*,'(2x,a,a)') 'iMTD-sMTD mode       : ','\"-entropy\"'\n      case default\n        continue\n      end select\n    end if\n    if (env%properties .gt. 0) then\n      select case (env%properties)\n      case (1)\n        dum = '\"hess\"'\n      case (10)\n        dum = '\"ohess\"'\n      case (2)\n        dum = '\"autoIR (GFN)\"'\n      case (20)\n        dum = '\"reopt\"'\n      case (3:7,100)\n        dum = 'DFT'\n      case (45)\n        dum = 'none'\n      case default\n        dum = '<undefined>'\n      end select\n      if (dum .ne. 'none') then\n        write (*,'(2x,a,a)') 'PROP mode (-prop)    : ',dum\n      end if\n    end if\n  end if\n\n  if (cregenpr) then\n    write (*,'(/,1x,a)') 'CRE settings'\n    write (*,'(2x,a,f10.4)') 'energy window         (-ewin) :',env%ewin\n    write (*,'(2x,a,f10.4)') 'RMSD threshold        (-rthr) :',env%rthr          !RTHR - RMSD thr in Angstroem\n    write (*,'(2x,a,f10.4)') 'energy threshold      (-ethr) :',env%ethr          !ETHR - E threshold in kcal\n    write (*,'(2x,a,f10.2)') 'rot. const. threshold (-bthr) :',env%bthr2         !BTHR - rot const  thr\n    write (*,'(2x,a,f10.2)') 'T (for boltz. weight) (-temp) :',env%tboltz\n  end if\n\n  if (mdsetpr) then\n    write (*,'(/,1x,a)') 'General MD/MTD settings'\n    if (env%mdtime .gt. 0.0d0) then\n      write (*,'(2x,a,f10.1)') 'simulation length [ps]    (-len) :',env%mdtime\n    else\n      write (*,'(2x,a,a)') 'simulation length [ps]    (-len) : ','<system dependent>'\n    end if\n    write (*,'(2x,a,f10.1)') 'time step [fs]          (-tstep) :',env%mdstep\n    write (*,'(2x,a,i10)') 'shake mode              (-shake) :',env%shake\n    write (*,'(2x,a,f10.2)') 'MTD temperature [K]    (-mdtemp) :',env%mdtemp\n    write (*,'(2x,a,i10)') 'trj dump step  [fs]    (-mddump) :',env%mddumpxyz\n    write (*,'(2x,a,f10.1)') 'MTD Vbias dump [ps]    (-vbdump) :',real(env%mddump)/1000.0d0\n  end if\n\n  if (env%cts%used) then\n    write (*,'(/,1x,a)') 'Constrainment info'\n    write (*,'(2x,a,l7)') 'applying constraints?  : ',env%cts%used\n    write (*,'(2x,a,a)') 'constraining file      : ',trim(env%constraints)\n    write (*,'(2x,a)') 'file content :'\n    call cat_mod(6,'  > ',env%constraints,'')\n  end if\n\n  if (xtbpr) then\n    if(env%legacy)then\n    write (*,'(/,1x,a)') 'XTB settings'\n    write (*,'(2x,a,a)') 'binary name        (-xnam) : ',trim(env%ProgName)\n    call checkbinary(env)\n    write (*,'(2x,a,a)') 'GFN method         (-gfn)  : ',trim(env%gfnver)\n    else\n    write (*,'(/,1x,a)') 'Calculation settings' \n    endif\n    write (*,'(2x,a,i0)') '(final) opt level  (-opt)  : ',nint(env%optlev)\n    if (env%gbsa) then\n      if (index(env%solv,'--alpb') .ne. 0) then\n        write (*,'(2x,a,a)') 'Implicit solvation (-alpb) : ',trim(env%solvent)\n      else\n        write (*,'(2x,a,a)') 'Implicit solvation (-gbsa) : ',trim(env%solvent)\n      end if\n    end if\n    if (env%chrg .ne. 0.0d0) then\n      write (*,'(2x,a,i0)') 'Molecular charge   (-chrg) : ',env%chrg\n    end if\n    if (env%uhf .ne. 0) then\n      write (*,'(2x,a,i0)') 'UHF (nα-nβ elec.)  (-uhf)  : ',env%uhf\n    end if\n  end if\n\n  if (techpr) then\n    call getcwd(dumstr)\n    write (*,'(/,1x,a)') 'Technical settings'\n    write (*,'(2x,a,a)') 'working directory : ',trim(dumstr)\n    write (*,'(2x,a,i0)') 'CPUs (threads)     (-T) : ',env%threads\n\n  end if\n\n  write (*,'(/,1x,a)') 'CREST binary info'\n  call print_crest_metadata()\n\n  write (*,'(/)')\n  stop 'normal dry run termination.'\nend subroutine crest_dry\n\nsubroutine cat_mod(ch,pre,fname,post)\n  implicit none\n  integer :: ch\n  character(len=*) :: pre\n  character(len=*) :: fname\n  character(len=*) :: post\n  character(len=256) :: adum\n  integer :: ich,io\n\n  open (newunit=ich,file=fname)\n  do\n    read (ich,'(a)',iostat=io) adum\n    if (io < 0) exit\n    write (ch,'(a,a,a)') pre,trim(adum),post\n  end do\n  close (ich)\n  return\nend subroutine cat_mod\n\nsubroutine checkbinary(env)\n  use crest_data\n  use iomod, only: checkprog\n  implicit none\n  type(systemdata) :: env\n  integer :: r\n\n  r = 0\n  call checkprog(trim(env%ProgName),r)\n\n  if (r .ne. 0) then\n    write (*,'(4x,a)') 'Warning! The xtb binary was not found and hence CREST might crash'\n  end if\n\n  if (env%crestver .eq. crest_solv) then\n    call checkprog(trim('xtbiff'),r)\n    if (r .ne. 0) then\n      write (*,'(4x,a)') 'Warning! The xtbiff binary was not found and hence the qcg mode in CREST will probably crash'\n    end if\n  end if\n  return\nend subroutine checkbinary\n\n!==============================================================================!\n!  QCG-printouts\n!==============================================================================!\n\n!____________________________________________________________________________\n\nsubroutine print_qcg_grow()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''========================================='')')\n  write (*,'(2x,''|   quantum cluster growth: GROW        |'')')\n  write (*,'(2x,''========================================='')')\n  write (*,*)\nend subroutine print_qcg_grow\n\n!____________________________________________________________________________\n\nsubroutine pr_qcg_fastgrow()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''========================================='')')\n  write (*,'(2x,''|   quantum cluster growth: FASTGROW    |'')')\n  write (*,'(2x,''========================================='')')\n  write (*,*)\nend subroutine pr_qcg_fastgrow\n\n!____________________________________________________________________________\n\nsubroutine print_qcg_ensemble()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''========================================='')')\n  write (*,'(2x,''|   quantum cluster growth: ENSEMBLE    |'')')\n  write (*,'(2x,''========================================='')')\n  write (*,*)\nend subroutine print_qcg_ensemble\n\n!____________________________________________________________________________\n\nsubroutine print_qcg_opt()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''========================================='')')\n  write (*,'(2x,''|   quantum cluster growth: OPT         |'')')\n  write (*,'(2x,''========================================='')')\n  write (*,*)\n  write (*,'(2x,''Very tight post optimization of lowest cluster'')')\nend subroutine print_qcg_opt\n\n!____________________________________________________________________________\n\nsubroutine pr_qcg_fill()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''========================================='')')\n  write (*,'(2x,''|   quantum cluster growth: CFF         |'')')\n  write (*,'(2x,''========================================='')')\n  write (*,*)\n  write (*,'(2x,''CUT-FREEZE-FILL Algorithm to generate reference solvent cluster'')')\nend subroutine pr_qcg_fill\n\n!____________________________________________________________________________\n\nsubroutine pr_qcg_freq()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''========================================='')')\n  write (*,'(2x,''|          Frequency evaluation         |'')')\n  write (*,'(2x,''========================================='')')\n  write (*,*)\nend subroutine pr_qcg_freq\n\n!____________________________________________________________________________\n\nsubroutine pr_eval_solute()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''________________________________________________________________________'')')\n  write (*,*)\n  write (*,'(2x,''__________________     Solute Cluster Generation   _____________________'')')\n  write (*,*)\n  write (*,'(2x,''________________________________________________________________________'')')\n  write (*,*)\nend subroutine pr_eval_solute\n\n!____________________________________________________________________________\n\nsubroutine pr_eval_solvent()\n  implicit none\n  write (*,*)\n  write (*,*)\n  write (*,'(2x,''________________________________________________________________________'')')\n  write (*,*)\n  write (*,'(2x,''_________________     Solvent Cluster Generation   _____________________'')')\n  write (*,*)\n  write (*,'(2x,''________________________________________________________________________'')')\n  write (*,*)\nend subroutine pr_eval_solvent\n\n!____________________________________________________________________________\n\nsubroutine pr_eval_eval()\n  implicit none\n  write (*,*)\n  write (*,*)\n  write (*,'(2x,''________________________________________________________________________'')')\n  write (*,*)\n  write (*,'(2x,''_________________________     Evaluation    ____________________________'')')\n  write (*,*)\n  write (*,'(2x,''________________________________________________________________________'')')\n  write (*,*)\n  write (*,*)\nend subroutine pr_eval_eval\n\n!____________________________________________________________________________\n\nsubroutine pr_freq_energy()\n  implicit none\n  write (*,'(2x,\"#       H(T)       SVIB      SROT       STRA      G(T)\")')\n  write (*,'(2x,\"     [kcal/mol]    [      cal/mol/K        ]    [kcal/mol]\")')\n  write (*,'(2x,\"--------------------------------------------------------\")')\nend subroutine pr_freq_energy\n\n!____________________________________________________________________________\n\nsubroutine pr_eval_1(G,H)\n  use iso_fortran_env,only:wp => real64\n  implicit none\n  real(wp),intent(in)       :: G,H\n  write (*,'(2x,\"-----------------------------------------------------\")')\n  write (*,'(2x,\"Gsolv and Hsolv ref. state: [1 M gas/solution] \")')\n  write (*,'(2x,\"G_solv (incl.RRHO)      =\",F8.2,\" kcal/mol\")') G\n  write (*,'(2x,\"H_solv (incl.RRHO)      =\",F8.2,\" kcal/mol\")') H\n  write (*,'(2x,\"-----------------------------------------------------\")')\n  write (*,*)\nend subroutine pr_eval_1\n\n!____________________________________________________________________________\n\nsubroutine pr_eval_2(srange,G,scal)\n  use iso_fortran_env,only:wp => real64\n  implicit none\n! Dummy\n  integer,intent(in)        :: srange\n  real(wp),intent(in)       :: G(srange)\n  real(wp),intent(in)       :: scal(srange)\n! Stack\n  integer                   :: i\n  write (*,'(2x,\"-----------------------------------------------------\")')\n  write (*,'(2x,\"Solvation free energies with scaled translational\")')\n  write (*,'(2x,\"and rotational degrees of freedom: Gsolv (scaling)\")')\n  do i = 1,srange\n    write (*,'(10x,\">>\",2x,f8.2,\" (\",f4.2,\")\",4x,\"<<\")') G(i),scal(i)\n  end do\n  write (*,'(2x,\"-----------------------------------------------------\")')\nend subroutine pr_eval_2\n\n!____________________________________________________________________________\n\nsubroutine pr_eval_3(srange,freqscal,scal,G)\n  use iso_fortran_env,only:wp => real64\n  implicit none\n! Dummy\n  integer,intent(in)        :: srange\n  integer,intent(in)        :: freqscal\n  real(wp),intent(in)       :: scal\n  real(wp),intent(in)       :: G(srange)\n  write (*,*)\n  write (*,'(2x,\"==================================================\")')\n  write (*,'(2x,\"|  Gsolv with SCALED RRHO contributions: \",f4.2,4x\"|\")') scal\n  write (*,'(2x,\"|  [1 bar gas/ 1 M solution]                     |\")')\n  write (*,'(2x,\"|                                                |\")')\n  write (*,'(2x,\"|  G_solv (incl.RRHO)+dV(T)=\",F8.2,\" kcal/mol    |\")') G(freqscal)\n  write (*,'(2x,\"==================================================\")')\n  write (*,*)\nend subroutine pr_eval_3\n\n!____________________________________________________________________________\n\nsubroutine pr_fill_energy()\n  implicit none\n  write (*,'(x,'' Size'',2x,''Cluster '',2x,''E /Eh '',7x,''De/kcal'',3x,&\n          &''Detot/kcal'',2x,''Opt'',4x)')\nend subroutine pr_fill_energy\n\n!____________________________________________________________________________\n\nsubroutine pr_ensemble_energy()\n  implicit none\n  write (*,*)\n  write (*,'(x,'' Cluster'',3x,''E /Eh '',7x,&\n           &''Density'',2x,''Efix'',7x,''R   av/act.'',1x,&\n           &''Surface'',3x,''Opt'',4x)')\nend subroutine pr_ensemble_energy\n\n!____________________________________________________________________________\n\nsubroutine pr_qcg_esolv()\n  implicit none\n  write (*,*)\n  write (*,'(2x,''========================================='')')\n  write (*,'(2x,''|   quantum cluster growth: ESOLV       |'')')\n  write (*,'(2x,''|                                       |'')')\nend subroutine pr_qcg_esolv\n\n!____________________________________________________________________________\n\nsubroutine pr_grow_energy()\n  implicit none\n  write (*,'(x,'' Size'',7x,''E'',8x,''De'',7x,''Detot'',6x,&\n           &''Density'',5x,''Eatom'',4x,''av. R'', 1x,'' Rlast'',3x,&\n           &''Volume'',4x,''Opt'')')\n  write (*,'(12x,''[Eh]'',4x,''[kcal]'',5x,''[kcal]'',5x,&\n           &''[u/Å^3]'',5x,''[kcal]'',3x,''[bohr]'', 1x,''[bohr]'',1x,&\n           &''[bohr^3]'')')\n\nend subroutine pr_grow_energy\n\n!==============================================================================!\n!  printout percent calculation for GUI mode\n!==============================================================================!\nsubroutine wrGUIpercent(current,maxv,interval)\n  use iso_fortran_env,wp => real64\n  implicit none\n  integer :: current,maxv,interval\n  real(wp) :: perc,inc,trc\n  integer :: i,interval2\n\n  if (current == maxv) then\n    write (*,'(1x,f6.2,a)') 100.0d0,' percent done. finished loop.'\n    return\n  end if\n\n  interval2 = interval\n  inc = float(maxv)/float(interval)\n  if (inc .gt. 1.0d0) interval2 = maxv\n  trc = 0.0d0\n  do i = 1,interval2\n    trc = floor(float(i)*inc)\n    if (current == nint(trc)) then\n      perc = (float(current)/float(maxv))*100.0d0\n      write (*,'(1x,f6.2,a)') perc,' percent done'\n      exit\n    end if\n  end do\n\n  return\nend subroutine wrGUIpercent\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/printouts.f90 b/src/printouts.f90
--- a/src/printouts.f90	
+++ b/src/printouts.f90	
@@ -59,7 +59,6 @@
   write (*,*)
 
   call disclaimer()
-
 end subroutine confscript_head
 
 subroutine box3(version,date,commit,author)
@@ -254,77 +253,80 @@
   write (*,'(5x,''                   : done automatically for water'')')
   write (*,'(5x,''-nofix             : fix the solute not during the growth (needed only for water)'')')
 !      write(*,'(5x,''-fixens            : fix the solute during the ensemble generation'')')
-  write (*,'(5x,''-nsolv <INT>       : number of solvent molecules to add'')')
-  write (*,'(5x,''-normdock          : Perform a more extensive docking during grow'')')
-  write (*,'(5x,''-maxsolv           : set limit of convergence, if no number of solutes was given. Default 150 '')')
-  write (*,'(5x,''-wscal <FLOAT>     : Scaling factor for outer wall potential'')')
-  write (*,'(5x,''-samerand          : use same random number for every xtbiff run'')')
-  write (*,'(5x,''-ensemble          : ensemble generation'')')
-  write (*,'(5x,''-qcgmtd            : NCI-MTD CREST ensemble generation (Default)'')')
-  write (*,'(5x,''-ncimtd            : NCI-MTD CREST ensemble generation'')')
-  write (*,'(5x,''-mtd               : MTD for QCG ensemble generation'')')
-  write (*,'(5x,''-md                : normal MD for QCG ensemble search'')')
-  write (*,'(5x,''-enslvl [method]   : define a method for ensemble search. All gfn methods are supported'')')
-  write (*,'(5x,''-clustering        : Turn on clustering for the ensemble search (only for qcgmtd and ncimtd'')')
-  write (*,'(5x,''-esolv             : reference cluster generation and comp. of solvation energy'')')
-  write (*,'(5x,''-gsolv             : reference cluster generation and comp. of solvation free energy'')')
-  write (*,'(5x,''-nclus             : defines how many clusters are taken for reference cluster generation'')')
-  write (*,'(5x,''                   : default 4'')')
-  write (*,'(5x,''-nocff             : switches off the CFF algorithm'')')
-  write (*,'(5x,''-freqscal          : defines frequency scale factor. Only for outprint'')')
-  write (*,'(5x,''-freqlvl [method]  : define a method for frequency computation. All gfn versions are supported'')')
+      write(*,'(5x,''-nsolv <INT>       : number of solvent molecules to add'')')
+      write(*,'(5x,''-normdock          : Perform a more extensive docking during grow'')')
+      write(*,'(5x,''-maxsolv           : set limit of convergence, if no number of solutes was given. Default 150 '')')
+      write(*,'(5x,''-wscal <FLOAT>     : Scaling factor for outer wall potential'')')
+      write(*,'(5x,''-samerand          : use same random number for every xtbiff run'')')
+      write(*,'(5x,''-fin_opt_gfn2      : perform GFN2-xTB optimizations for final grow and ensemble structures'')')
+      write(*,'(5x,''-directed <FILE>   : Perform directed solvation at positions defined in <FILE>'')')
+      write(*,'(5x,''-ensemble          : ensemble generation'')')
+      write(*,'(5x,''-qcgmtd            : NCI-MTD CREST ensemble generation (Default)'')')
+      write(*,'(5x,''-ncimtd            : NCI-MTD CREST ensemble generation'')')
+      write(*,'(5x,''-mtd               : MTD for QCG ensemble generation'')')
+      write(*,'(5x,''-md                : normal MD for QCG ensemble search'')')
+      write(*,'(5x,''-enslvl [method]   : define a method for ensemble search. All gfn methods are supported'')')
+      write(*,'(5x,''-clustering        : Turn on clustering for the ensemble search (only for qcgmtd and ncimtd'')')
+      write(*,'(5x,''-esolv             : reference cluster generation and comp. of solvation energy'')')
+      write(*,'(5x,''-gsolv             : reference cluster generation and comp. of solvation free energy'')')
+      write(*,'(5x,''-nclus             : defines how many clusters are taken for reference cluster generation'')')
+      write(*,'(5x,''                   : default 4'')')
+      write(*,'(5x,''-nocff             : switches off the CFF algorithm'')')
+      write(*,'(5x,''-freqscal          : defines frequency scale factor. Only for outprint'')')
+      write(*,'(5x,''-freqlvl [method]  : define a method for frequency computation. All gfn versions are supported'')')
 
-  write (*,*)
-  write (*,*)
-  write (*,'(1x,''Other tools for standalone use:'')')
-  write (*,'(5x,''-zsort             : use only the zsort subroutine'')')
-  write (*,'(5x,''                     to sort the z-matrix of the input'')')
-  write (*,'(5x,''                     coord file.'')')
-  write (*,'(5x,''-mdopt <file>      : optimize along trajectory or'')')
-  write (*,'(5x,''                     ensemble file in the XYZ format.'')')
-  write (*,'(5x,''                     Each point on the file is optimized.'')')
-  write (*,'(5x,''-screen <file>     : optimize along ensemble file'')')
-  write (*,'(5x,''                     in the XYZ format. A multilevel'')')
-  write (*,'(5x,''                     optimization is performed with continiously'')')
-  write (*,'(5x,''                     increasing thresholds. After each step'')')
-  write (*,'(5x,''                     the ensemble file is sorted.'')')
-  write (*,'(5x,''-protonate         : find a molecules protomes by using a'')')
-  write (*,'(5x,''                     LMO π- or LP-center approach.'')')
-  write (*,'(5x,''-deprotonate       : find a molecules deprotomers.'')')
-  write (*,'(5x,''-tautomerize       : combine the protonation and deprotonation'')')
-  write (*,'(5x,''                     to find prototropic tautomers.'')')
-  write (*,'(6x,''↳ -trev           : do first the deprotonation and then the'')')
-  write (*,'(8x,''                  protonation in the -tautomerize mode, i.e.,'')')
-  write (*,'(8x,''                  reverse of the default procedure.'')')
-  write (*,'(6x,''↳ -iter <int>     : set number of protonation/deprotonation cycles'')')
-  write (*,'(8x,''                  in the tautomerization script. [default: 2]'')')
-  write (*,'(5x,''-compare <f1> <f2> : compare two ensembles <f1> and <f2>.'')')
-  write (*,'(5x,''                     Both ensembles must have the same'')')
-  write (*,'(5x,''                     order of atoms of the molecule and'')')
-  write (*,'(5x,''                     should contain rotamers.'')')
-  write (*,'(6x,''↳ -maxcomp <int>  : Selcect the lowest <int> conformers'')')
-  write (*,'(8x,''                  out of each ensemble to be compared'')')
-  write (*,'(8x,''                  with "-compare". [default: 10]'')')
-  write (*,'(5x,''-testtopo <file>   : Analyze some stuctural info (topology) for a given file.'')')
-  write (*,'(5x,''-constrain <atoms> : write example file ".xcontrol.sample" for constraints'')')
-  write (*,'(5x,''                     in crest. (see -cinp option above)'')')
-  write (*,'(5x,''-thermo <file>     : Calculate thermo data for given structure. Also requires vibrational'')')
-  write (*,'(5x,''                     frequencies in the TM format, saved as file called "vibspectrum"'')')
-  write (*,'(5x,''-rmsd,-rmsdheavy <file1> <file2>  : Calculate RMSD or heavy atom RMSD between two structures.'')')
-  write (*,'(5x,''                                    Input coords are automatically transformed to Angstroem.'')')
-  write (*,'(5x,''-splitfile <file> [from] [to]     : Split an ensemble from <file> into seperate directories'')')
-  write (*,'(5x,''                                    for each structure. [from] and [to] can be used to select'')')
-  write (*,'(5x,''                                    specific structures from the file.'')')
-  write (*,'(5x,''                                    The new directories are collected in the SPLIT directory.'')')
+
+  write(*,*)
+  write(*,*)
+      write(*,'(1x,''Other tools for standalone use:'')')
+      write(*,'(5x,''-zsort             : use only the zsort subroutine'')')
+      write(*,'(5x,''                     to sort the z-matrix of the input'')')
+      write(*,'(5x,''                     coord file.'')')
+      write(*,'(5x,''-mdopt <file>      : optimize along trajectory or'')')
+      write(*,'(5x,''                     ensemble file in the XYZ format.'')')
+      write(*,'(5x,''                     Each point on the file is optimized.'')')
+      write(*,'(5x,''-screen <file>     : optimize along ensemble file'')')
+      write(*,'(5x,''                     in the XYZ format. A multilevel'')')
+      write(*,'(5x,''                     optimization is performed with continiously'')')
+      write(*,'(5x,''                     increasing thresholds. After each step'')')
+      write(*,'(5x,''                     the ensemble file is sorted.'')')
+      write(*,'(5x,''-protonate         : find a molecules protomes by using a'')')
+      write(*,'(5x,''                     LMO π- or LP-center approach.'')')
+      write(*,'(5x,''-deprotonate       : find a molecules deprotomers.'')')
+      write(*,'(5x,''-tautomerize       : combine the protonation and deprotonation'')')
+      write(*,'(5x,''                     to find prototropic tautomers.'')')
+      write(*,'(6x,''↳ -trev           : do first the deprotonation and then the'')')
+      write(*,'(8x,''                  protonation in the -tautomerize mode, i.e.,'')')
+      write(*,'(8x,''                  reverse of the default procedure.'')')
+      write(*,'(6x,''↳ -iter <int>     : set number of protonation/deprotonation cycles'')')
+      write(*,'(8x,''                  in the tautomerization script. [default: 2]'')')
+      write(*,'(5x,''-compare <f1> <f2> : compare two ensembles <f1> and <f2>.'')')
+      write(*,'(5x,''                     Both ensembles must have the same'')')
+      write(*,'(5x,''                     order of atoms of the molecule and'')')
+      write(*,'(5x,''                     should contain rotamers.'')')
+      write(*,'(6x,''↳ -maxcomp <int>  : Selcect the lowest <int> conformers'')')
+      write(*,'(8x,''                  out of each ensemble to be compared'')')
+      write(*,'(8x,''                  with "-compare". [default: 10]'')')
+      write(*,'(5x,''-testtopo <file>   : Analyze some stuctural info (topology) for a given file.'')')
+      write(*,'(5x,''-constrain <atoms> : write example file ".xcontrol.sample" for constraints'')')
+      write(*,'(5x,''                     in crest. (see -cinp option above)'')')
+      write(*,'(5x,''-thermo <file>     : Calculate thermo data for given structure. Also requires vibrational'')')
+      write(*,'(5x,''                     frequencies in the TM format, saved as file called "vibspectrum"'')')
+      write(*,'(5x,''-rmsd,-rmsdheavy <file1> <file2>  : Calculate RMSD or heavy atom RMSD between two structures.'')')
+      write(*,'(5x,''                                    Input coords are automatically transformed to Angstroem.'')')      
+      write(*,'(5x,''-splitfile <file> [from] [to]     : Split an ensemble from <file> into seperate directories'')')
+      write(*,'(5x,''                                    for each structure. [from] and [to] can be used to select'')')      
+      write(*,'(5x,''                                    specific structures from the file.'')')      
+      write(*,'(5x,''                                    The new directories are collected in the SPLIT directory.'')')      
 
-  write (*,*)
-  write (*,*)
-  write (*,*) 'View literature references with [--cite]'
-  write (*,*) 'Also refer to:'
-  write (*,*) 'https://crest-lab.github.io/crest-docs/'
-  write (*,*)
+  write(*,*)
+  write(*,*)
+      write(*,*) 'View literature references with [--cite]'
+      write(*,*) 'Also refer to:'
+      write(*,*) 'https://crest-lab.github.io/crest-docs/'
+      write(*,*)
 
-  stop '   [-h] displayed. exit.'
+      stop '   [-h] displayed. exit.'
 end subroutine confscript_help
 
 !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
@@ -1091,10 +1093,10 @@
 
 subroutine pr_grow_energy()
   implicit none
-  write (*,'(x,'' Size'',7x,''E'',8x,''De'',7x,''Detot'',6x,&
+  write(*,'(x,'' Size'',7x,''E'',8x,''De'',7x,''Detot'',6x,&
            &''Density'',5x,''Eatom'',4x,''av. R'', 1x,'' Rlast'',3x,&
            &''Volume'',4x,''Opt'')')
-  write (*,'(12x,''[Eh]'',4x,''[kcal]'',5x,''[kcal]'',5x,&
+  write(*,'(12x,''[Eh]'',4x,''[kcal]'',5x,''[kcal]'',5x,&
            &''[u/Å^3]'',5x,''[kcal]'',3x,''[bohr]'', 1x,''[bohr]'',1x,&
            &''[bohr^3]'')')
 
Index: src/legacy_wrappers.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2023 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!================================================================================!\nsubroutine env2calc(env,calc,molin)\n!******************************************\n!* This piece of code generates a calcdata\n!* object from the global settings in env\n!******************************************\n  use crest_parameters\n  use crest_data\n  use crest_calculator\n  use strucrd\n  implicit none\n  !> INPUT\n  type(systemdata),intent(in) :: env\n  type(coord),intent(in),optional :: molin\n  !> OUTPUT\n  type(calcdata) :: calc\n  !> LOCAL\n  type(calculation_settings) :: cal\n  type(coord) :: mol\n\n  call calc%reset()\n\n  cal%uhf = env%uhf\n  cal%chrg = env%chrg\n  !>-- obtain WBOs OFF by default\n  cal%rdwbo = .false.\n\n  !>-- defaults to whatever env has selected or gfn0\n  select case (trim(env%gfnver))\n  case ('--gfn0')\n    cal%id = jobtype%gfn0\n  case ('--gfn1')\n    cal%id = jobtype%tblite\n    cal%tblitelvl = 1\n  case ('--gfn2')\n    cal%id = jobtype%tblite\n    cal%tblitelvl = 2\n  case ('--gff','--gfnff')\n    cal%id = jobtype%gfnff\n  case default\n    cal%id = jobtype%gfn0\n  end select\n  if (present(molin)) then\n    mol = molin\n    !else\n    !  call mol%open('coord')\n  end if\n\n  !> implicit solvation\n  if (env%gbsa) then\n    if (index(env%solv,'gbsa') .ne. 0) then\n      cal%solvmodel = 'gbsa'\n    else if (index(env%solv,'alpb') .ne. 0) then\n      cal%solvmodel = 'alpb'\n    else\n      cal%solvmodel = 'unknown'\n    end if\n    cal%solvent = trim(env%solvent)\n  end if\n\n  !> do not reset parameters between calculations (opt for speed)\n  cal%apiclean = .false.\n\n  call cal%autocomplete(1)\n\n  call calc%add(cal)\n\n  return\nend subroutine env2calc\n\nsubroutine env2calc_setup(env)\n!***********************************\n!* Setup the calc object within env\n!***********************************\n  use crest_data\n  use crest_calculator\n  use strucrd\n  implicit none\n  !> INOUT\n  type(systemdata),intent(inout) :: env\n  !> LOCAL\n  type(calcdata) :: calc\n  type(coord) :: mol\n  interface\n    subroutine env2calc(env,calc,molin)\n      use crest_parameters\n      use crest_data\n      use crest_calculator\n      use strucrd\n      implicit none\n      type(systemdata),intent(in) :: env\n      type(coord),intent(in),optional :: molin\n      type(calcdata) :: calc\n    end subroutine env2calc\n\n  end interface\n\n  call env2calc(env,calc,mol)\n\n  env%calc = calc\nend subroutine env2calc_setup\n\n!================================================================================!\nsubroutine confscript2i(env,tim)\n  use iso_fortran_env,only:wp => real64\n  use crest_data\n  implicit none\n  type(systemdata) :: env\n  type(timer)   :: tim\n  if (env%legacy) then\n    call confscript2i_legacy(env,tim)\n  else\n    if (.not.env%entropic) then\n      call crest_search_imtdgc(env,tim)\n    else\n      call crest_search_entropy(env,tim)\n    end if\n  end if\nend subroutine confscript2i\n\n!=================================================================================!\nsubroutine xtbsp(env,xtblevel)\n  use iso_fortran_env,only:wp => real64\n  use crest_data\n  use strucrd,only:coord\n  implicit none\n  type(systemdata) :: env\n  integer,intent(in),optional :: xtblevel\n  interface\n    subroutine crest_xtbsp(env,xtblevel,molin)\n      import :: systemdata,coord\n      type(systemdata) :: env\n      integer,intent(in),optional :: xtblevel\n      type(coord),intent(in),optional :: molin\n    end subroutine crest_xtbsp\n  end interface\n  if (env%legacy) then\n    call xtbsp_legacy(env,xtblevel)\n  else\n    call crest_xtbsp(env,xtblevel)\n  end if\nend subroutine xtbsp\nsubroutine xtbsp2(fname,env)\n  use iso_fortran_env,only:wp => real64\n  use crest_data\n  use strucrd\n  implicit none\n  type(systemdata) :: env\n  character(len=*),intent(in) :: fname\n  type(coord) :: mol\n  interface\n    subroutine crest_xtbsp(env,xtblevel,molin)\n      import :: systemdata,coord\n      type(systemdata) :: env\n      integer,intent(in),optional :: xtblevel\n      type(coord),intent(in),optional :: molin\n    end subroutine crest_xtbsp\n  end interface\n  if (env%legacy) then\n    call xtbsp2_legacy(fname,env)\n  else\n    call mol%open(trim(fname))\n    call crest_xtbsp(env,xtblevel=-1,molin=mol)\n  end if\nend subroutine xtbsp2\n\n!=================================================================================!\n\nsubroutine confscript1(env,tim)\n  use crest_parameters\n  use crest_data\n  implicit none\n  type(systemdata) :: env\n  type(timer)   :: tim\n  write (stdout,*)\n  write (stdout,*) 'This runtype has been entirely deprecated.'\n  write (stdout,*) 'You may try an older version of the program if you want to use it.'\n  stop\nend subroutine confscript1\n\n!=================================================================================!\n\nsubroutine nciflexi(env,flexval)\n  use crest_parameters\n  use crest_data\n  use strucrd\n  implicit none\n  type(systemdata) :: env\n  type(coord) ::mol\n  real(wp) :: flexval\n  if (env%legacy) then\n    call nciflexi_legacy(env,flexval)\n  else\n    call env%ref%to(mol)\n    call nciflexi_gfnff(mol,flexval)\n  end if\nend subroutine nciflexi\n\n!================================================================================!\n\nsubroutine thermo_wrap(env,pr,nat,at,xyz,dirname, &\n        &  nt,temps,et,ht,gt,stot,bhess)\n!******************************************\n!* Wrapper for a Hessian calculation\n!* to get thermodynamics of the molecule\n!*****************************************\n  use crest_parameters,only:wp\n  use crest_data\n  implicit none\n  !> INPUT\n  type(systemdata) :: env\n  logical,intent(in) :: pr\n  integer,intent(in) :: nat\n  integer,intent(inout) :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat)  !> in Angstroem!\n  character(len=*) :: dirname\n  integer,intent(in)  :: nt\n  real(wp),intent(in)  :: temps(nt)\n  logical,intent(in) :: bhess       !> calculate bhess instead?\n  !> OUTPUT\n  real(wp),intent(out) :: et(nt)    !> enthalpy in Eh\n  real(wp),intent(out) :: ht(nt)    !> enthalpy in Eh\n  real(wp),intent(out) :: gt(nt)    !> free energy in Eh\n  real(wp),intent(out) :: stot(nt)  !> entropy in cal/molK\n\n  if (env%legacy) then\n    call thermo_wrap_legacy(env,pr,nat,at,xyz,dirname, &\n    &                    nt,temps,et,ht,gt,stot,bhess)\n  else\n    call thermo_wrap_new(env,pr,nat,at,xyz,dirname, &\n    &                    nt,temps,et,ht,gt,stot,bhess)\n  end if\nend subroutine thermo_wrap\n\n!================================================================================!\n\nsubroutine trialMD(env)\n!***********************************************\n!* subroutine trialMD\n!* Takes the global metadynamics settings\n!* And performs a short 1 ps simulation to\n!* check if the molecular dynamis/metadynamics\n!* will run, or if the timestep is too large\n!***********************************************\n   use crest_parameters,only:wp\n   use crest_data\n   implicit none\n   !> INPUT\n   type(systemdata) :: env\n\n   if (env%legacy) then\n     !> old xtb subprocess version\n     call trialMD_legacy(env) \n   else\n     !> new calculator implementation\n     call trialMD_calculator(env)\n   end if\n\nend subroutine trialMD\n\n!================================================================================!\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/legacy_wrappers.f90 b/src/legacy_wrappers.f90
--- a/src/legacy_wrappers.f90	
+++ b/src/legacy_wrappers.f90	
@@ -27,44 +27,33 @@
   use crest_data
   use crest_calculator
   use strucrd
+  use iomod
   implicit none
   !> INPUT
-  type(systemdata),intent(in) :: env
+  type(systemdata),intent(inout) :: env
   type(coord),intent(in),optional :: molin
   !> OUTPUT
   type(calcdata) :: calc
   !> LOCAL
-  type(calculation_settings) :: cal
+  type(calculation_settings) :: cal,cal2
   type(coord) :: mol
 
+!>--- Calculator level
   call calc%reset()
 
-  cal%uhf = env%uhf
-  cal%chrg = env%chrg
-  !>-- obtain WBOs OFF by default
-  cal%rdwbo = .false.
-
   !>-- defaults to whatever env has selected or gfn0
-  select case (trim(env%gfnver))
-  case ('--gfn0')
-    cal%id = jobtype%gfn0
-  case ('--gfn1')
-    cal%id = jobtype%tblite
-    cal%tblitelvl = 1
-  case ('--gfn2')
-    cal%id = jobtype%tblite
-    cal%tblitelvl = 2
-  case ('--gff','--gfnff')
-    cal%id = jobtype%gfnff
-  case default
-    cal%id = jobtype%gfn0
-  end select
+  call cal%create(trim(env%gfnver))
   if (present(molin)) then
     mol = molin
     !else
     !  call mol%open('coord')
   end if
 
+  cal%uhf = env%uhf
+  cal%chrg = env%chrg
+  !>-- obtain WBOs OFF by default
+  cal%rdwbo = .false.
+
   !> implicit solvation
   if (env%gbsa) then
     if (index(env%solv,'gbsa') .ne. 0) then
@@ -84,12 +73,34 @@
 
   call calc%add(cal)
 
+
+!>--- Refinement level
+  if (trim(env%gfnver2) .ne. '') then
+    env%gfnver2 = lowercase(env%gfnver2)
+    call cal2%create(trim(env%gfnver2))
+
+    cal2%chrg = cal%chrg
+    cal2%uhf = cal%uhf
+    if (env%gbsa) then
+      cal2%solvmodel = cal%solvmodel
+      cal2%solvent = cal%solvent
+    end if
+
+    call cal2%autocomplete(2)
+        
+    cal2%refine_lvl = refine%singlepoint
+    call calc%add(cal2)
+    if(allocated(env%refine_queue)) deallocate(env%refine_queue)
+    call env%addrefine( refine%singlepoint )  
+  end if
+
   return
 end subroutine env2calc
 
 subroutine env2calc_setup(env)
 !***********************************
 !* Setup the calc object within env
+!* (wrapper to get the mol object)
 !***********************************
   use crest_data
   use crest_calculator
@@ -107,7 +118,7 @@
       use crest_calculator
       use strucrd
       implicit none
-      type(systemdata),intent(in) :: env
+      type(systemdata),intent(inout) :: env
       type(coord),intent(in),optional :: molin
       type(calcdata) :: calc
     end subroutine env2calc
@@ -137,7 +148,36 @@
   end if
 end subroutine confscript2i
 
+!================================================================================!
+subroutine mdopt(env,tim)
+  use iso_fortran_env,only:wp => real64
+  use crest_data
+  implicit none
+  type(systemdata) :: env
+  type(timer)   :: tim
+  if (env%legacy) then
+    call mdopt_legacy(env,tim)
+  else
+    call crest_ensemble_optimization(env,tim)
+  end if
+end subroutine mdopt
+
+!================================================================================!
+subroutine screen(env,tim)
+  use iso_fortran_env,only:wp => real64
+  use crest_data
+  implicit none
+  type(systemdata) :: env
+  type(timer)   :: tim
+  if (env%legacy) then
+    call screen_legacy(env,tim)
+  else
+    call crest_ensemble_screening(env,tim)
+  end if
+end subroutine screen
+
 !=================================================================================!
+
 subroutine xtbsp(env,xtblevel)
   use iso_fortran_env,only:wp => real64
   use crest_data
@@ -261,20 +301,41 @@
 !* check if the molecular dynamis/metadynamics
 !* will run, or if the timestep is too large
 !***********************************************
-   use crest_parameters,only:wp
-   use crest_data
-   implicit none
-   !> INPUT
-   type(systemdata) :: env
+  use crest_parameters,only:wp
+  use crest_data
+  implicit none
+  !> INPUT
+  type(systemdata) :: env
 
-   if (env%legacy) then
-     !> old xtb subprocess version
-     call trialMD_legacy(env) 
-   else
-     !> new calculator implementation
-     call trialMD_calculator(env)
-   end if
+  if (env%legacy) then
+    !> old xtb subprocess version
+    call trialMD_legacy(env)
+  else
+    !> new calculator implementation
+    call trialMD_calculator(env)
+  end if
 
 end subroutine trialMD
 
 !================================================================================!
+
+subroutine trialOPT(env)
+!**********************************************************
+!* subroutine trialOPT
+!* Performs a geometry optimization of the structure
+!* saved to env%ref and checks for changes in the topology
+!**********************************************************
+  use crest_data
+  implicit none
+  !> INPUT
+  type(systemdata) :: env
+
+  if (env%legacy) then
+    call xtbopt_legacy(env)
+  else
+    call trialOPT_calculator(env)
+  end if
+end subroutine trialOPT
+
+!================================================================================!
+
Index: src/cleanup.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n!C\n!C All subroutines related to removing stuff\n!C\n!C  system calls are the easiest way to remove files, although they introduce\n!C  an additional dependence on the operating system.\n!C  But since there are no simple kernel alternatives to do the same thing\n!C  I will keep them for now.\n!C\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n\n!-------------------------------------------------------------------------\n! Basic subroutine for removing files or directories\n!-------------------------------------------------------------------------\nsubroutine rmrf(dataname)\n  use iomod, only: command\n  implicit none\n  character(len=*) :: dataname\n  integer :: io\n  call command('rm -rf '//trim(dataname)//' 2>/dev/null', io)\n  return\nend subroutine rmrf\n!-------------------------------------------------------------------------\n! Basic subroutine for removing files or directories (with wild card ending)\n!-------------------------------------------------------------------------\nsubroutine rmrfw(dataname)\n  implicit none\n  character(len=*) :: dataname\n  call rmrf(trim(dataname)//'*')\n  return\nend subroutine rmrfw\n\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n!C Specific cleanup routines for different parts of the CREST code\n!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n!-------------------------------------------------------------------------\n! General cleanup function. Wipes most files that may be written by crest\n!-------------------------------------------------------------------------\nsubroutine V2cleanup(restartopt)\n  use iomod\n  use crest_data\n  implicit none\n  logical :: restartopt\n  character(len=12),parameter :: pipe = ' 2>/dev/null'\n\n  call rmrf('.tmpxtbmodef hessian .xtboptok')\n  call rmrf('xtbrestart xtbmdok')\n  if (.not.restartopt) then\n    call rmrfw('METADYN')\n    call rmrfw('NORMMD')\n    call rmrf('MRMSD')\n    call rmrf('TRIALMD')\n    call rmrf('MDFILES')\n    call rmrf('OPTIM')\n    call rmrf('PROP')\n    call rmrf('crest_best.xyz')\n    call rmrf(conformerfile)\n    call rmrfw(crefile)\n    call rmrfw('.cre_')\n    call rmrf('cregen_*.tmp')\n  else\n    call rmrfw('NORMMD')\n    call rename(crefile//'_0.xyz','.tmp_full.xyz')\n    call rmrfw(crefile)\n    call rename('.tmp_full.xyz',crefile//'_0.xyz')\n  end if\n  return\nend subroutine V2cleanup\n\n!-------------------------------------------------------------------------\n! Cleanup function for MTD and MD dirs (confscript2_misc.f90)\n!-------------------------------------------------------------------------\nsubroutine cleanMTD\n  implicit none\n  call rmrfw('METADYN')\n  call rmrfw('NORM')\n  call rmrfw('STATICMTD')\n  call rmrf('MRMSD')\n  call rmrf('TRIALMD')\n  call rmrf('MDFILES')\n  return\nend subroutine cleanMTD\n\n!------------------------------------------------------------------------\n! last bit of file removing and renaming (confscript2_misc.f90)\n!------------------------------------------------------------------------\nsubroutine V2terminating\n  use iomod\n  use crest_data\n  implicit none\n  character(len=256) :: inpnam,outnam\n  call remove('scoord.1')\n  call catdel('cregen.out.tmp') !print to screen\n  call checkname_xyz(crefile,inpnam,outnam)\n  call rename(inpnam,\"crest_rotamers.xyz\")\n  call rmrfw('crest_rotamers_')\n  call rmrfw('crest_smtd_')\n  return\nend subroutine V2terminating\n\n!------------------------------------------------------------------------\n! clean Dir between iterations (confscript2_misc.f90)\n!------------------------------------------------------------------------\nsubroutine clean_V2i\n  use iomod\n  use crest_data\n  implicit none\n  call rmrfw('METADYN')\n  call rmrfw('NORM')\n  call rmrfw('STATICMTD')\n  call rmrfw('MDFILES')\n  call rmrfw(crefile)\n  return\nend subroutine clean_V2i\n\n!-----------------------------------------------------------------------\n! Remove all crest_conformers and crest_rotamers files (confscript2_misc.f90)\n!-----------------------------------------------------------------------\nsubroutine rmcres()\n  use crest_data\n  implicit none\n  call rmrfw(crefile)\n  call rmrf(conformerfile)\n  return\nend subroutine rmcres\n\n!-----------------------------------------------------------------------\n! Remove the OPTIM dir and scoord files (confscript2_misc.f90)\n!-----------------------------------------------------------------------\nsubroutine rmoptim()\n  implicit none\n  call rmrf('OPTIM')\n  call rmrfw('scoord.')\n  return\nend subroutine rmoptim\n\n!-----------------------------------------------------------------------\n! Cleanup options for SCREEN mode (confscript3.f90)\n!-----------------------------------------------------------------------\nsubroutine screen_cleanup\n  use crest_data\n  implicit none\n  call rmrf('OPTIM')\n  call rmrf('scoord.1')\n  call rmrf(conformerfile)\n  call rmrfw(crefile)\n  return\nend subroutine screen_cleanup\n\n!-----------------------------------------------------------------------\n! Cleanup routine for xtb files\n!-----------------------------------------------------------------------\nsubroutine xtbclean\n  implicit none\n  call rmrf('xtbrestart xtbtopo.mol xtbopt.log xtbopt.xyz')\n  call rmrf('charges wbo')\n  call rmrf('gfnff_topo gfnff_adjacency gfnff_topo')\n  return\nend subroutine xtbclean\n\n!-----------------------------------------------------------------------\n! Cleanup routine for protonation tool (protonate.f90)\n!-----------------------------------------------------------------------\nsubroutine protclean\n  implicit none\n  call rmrf('xtblmoinfo coordprot.0 lmocent.coord')\n  call rmrf('protonate_*.xyz xtbscreen.xyz protonated.xyz')\n  return\nend subroutine protclean\n\n!-----------------------------------------------------------------------\n! Cleanup routine for deprotonation tool (deprotonate.f90)\n!-----------------------------------------------------------------------\nsubroutine deprotclean\n  implicit none\n  call rmrf('xtblmoinfo coordprot.0 lmocent.coord')\n  call rmrf('deprotonate_*.xyz xtbscreen.xyz')\n  return\nend subroutine deprotclean\n\n!-----------------------------------------------------------------------\n! Cleanup routine for tautomerization (tautomerize.f90)\n!-----------------------------------------------------------------------\nsubroutine tautclean\n  implicit none\n  call rmrf('xtblmoinfo coordprot.0 lmocent.coord')\n  call rmrf('protonate_*.xyz deprotonate_*.xyz')\n  call rmrf('tautomerize_*.xyz tautomers.xyz xtbscreen.xyz')\n  return\nend subroutine tautclean\nsubroutine tautclean2\n  implicit none\n  call rmrf('xtblmoinfo coordprot.0 lmocent.coord')\n  call rmrf('protonate_*.xyz deprotonate_*.xyz')\n  call rmrf('protonated.xyz deprotonated.xyz xtbscreen.xyz')\n  return\nend subroutine tautclean2\n\n!-----------------------------------------------------------------------\n! Cleanup routine for MF-MD-GC (confscript1.f90)\n!-----------------------------------------------------------------------\nsubroutine clean\n  use crest_data\n  implicit none\n  call rmrfw('MODEF')\n  call rmrfw('NORMMD')\n  call rmrfw('TMPCONF')\n  call rmrfw(crefile)\n  return\nend subroutine clean\n\n!-----------------------------------------------------------------------\n! change the dir and then remove mos and dh (dft_propcalc.f90)\n!-----------------------------------------------------------------------\nsubroutine cleanDFT(TMPCONF)\n  use iomod, only: command\n  implicit none\n  integer :: TMPCONF\n  character(len=:),allocatable :: str\n  character(len=:),allocatable :: pipe\n  character(len=10) :: nmmr\n  integer :: i,io\n  pipe = ' 2>/dev/null'\n  do i = 1,TMPCONF\n    write (nmmr,'(i0)') i\n    str = 'cd TMPCONF'//trim(nmmr)//' && rm -rf '\n    call command(str//'mos'//pipe, io)\n    call command(str//'dh'//pipe, io)\n  end do\n  return\nend subroutine cleanDFT\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/cleanup.f90 b/src/cleanup.f90
--- a/src/cleanup.f90	
+++ b/src/cleanup.f90	
@@ -105,6 +105,7 @@
 !------------------------------------------------------------------------
 subroutine V2terminating
   use iomod
+  use utilities
   use crest_data
   implicit none
   character(len=256) :: inpnam,outnam
Index: src/flexi.F90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2023 Philipp Pracht, Stefan Grimme\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!=========================================================================================!\n! estimate conformational flexibility from geom. and WBO\n! the value of flex is normalized i.e. between 0(rigid) and 1(long alkane)\n!=========================================================================================!\nsubroutine flexi(mol,rednat,includeAtom,flex)\n  use iso_fortran_env,only:wp => real64\n  use strucrd\n  use zdata,only:readwbo\n  implicit none\n  !> INPUT\n  type(coord),intent(in) :: mol                  !> input molecule\n  integer,intent(in)     :: rednat               !> should equal sum(includeAtom(:))\n  integer,intent(in)     :: includeAtom(mol%nat) !> 0 if not considered, 1 if considered\n  !> OUTPUT\n  real(wp),intent(out) :: flex\n  !> LOCAL\n  real(wp),allocatable::xyz(:,:),rcov(:),cn(:),cring(:,:),wbo(:,:),wbofull(:,:)\n  integer,allocatable::at(:),map(:),b(:,:),sring(:),map2(:)\n  real(wp) :: dx,dy,dz,r,r2,rco,val,ringf,doublef,branch,effectivNat,hybf\n  real(wp) :: av2\n  integer :: i,j,k,l,m,n,rn\n  logical :: ex\n\n  !> CN less than this is considerd as terminating atom (H, F, ...)\n  real(wp),parameter :: thr = 1.2_wp\n\n  flex = 0.0_wp\n\n  n = mol%nat !> local modification\n  rn = rednat !> Number of atoms selected by atomlist+/-\n  !> rn=n if atomlist+/- is not used\n\n  allocate (xyz(3,rn),at(rn),rcov(94),map(rn),cn(rn),b(rn,rn))\n  allocate (sring(rn),cring(12,rn),wbo(rn,rn),wbofull(n,n),map2(n))\n  call setrcov(rcov)\n\n!>--- map given structure to considered substructure\n  if (rn .ne. n) then\n    call rdcoord_reduced('coord',n,rn,xyz,at,includeAtom)\n  else\n    !call rdcoord('coord',rn,at,xyz)\n    at = mol%at\n    xyz = mol%xyz\n  end if\n  call ncoord(rn,rcov,at,xyz,cn,400.0d0)\n\n!>--- map the new (reduced) coordinate order to the original\n  j = 0\n  map2 = 0   !> every EXcluded atom should get a zero\n  do i = 1,n\n    if (includeAtom(i) .gt. 0) then\n      j = j+1\n      map2(i) = j\n    end if\n  end do\n\n!>--- read the WBO file and map it to the (reduced) coordinates\n!>--- if it does not exist, single and double bonds are not distinguished\n  wbo = 0\n  wbofull = 0\n  inquire (file='wbo',exist=ex)\n  if (ex) then\n    call readwbo('wbo',n,wbofull)\n\n!>--- map wbofull to wbo (only if atoms are excluded from the rmsd)\n    if (rn .ne. n) then\n      do i = 1,n-1\n        if (includeAtom(i) .gt. 0) then\n          k = map2(i)\n          do j = i+1,n\n            if (includeAtom(j) .gt. 0) then\n              l = map2(j)\n              wbo(k,l) = wbofull(i,j)\n              wbo(l,k) = wbo(k,l)\n            else\n              cycle !> j cycle\n            end if\n          end do\n        else\n          cycle !> i cycle\n        end if\n      end do\n    else !> rn == n\n      wbo = wbofull\n    end if !>-- if(rn.ne.n) end\n  end if !>-- if(ex) end\n  deallocate (map2,wbofull)\n\n!+++++++++++++++++++++++++++++++++++++++!\n  n = rn !<---- so I don't have to change the following original code\n!+++++++++++++++++++++++++++++++++++++++!\n\n!>--- adjacency matrix b setup\n  map = 0\n  b(:,:) = 0\n  do i = 1,n\n    if (cn(i) .lt. thr) cycle\n    do j = 1,n\n      if (i .eq. j) cycle\n      dx = xyz(1,j)-xyz(1,i)\n      dy = xyz(2,j)-xyz(2,i)\n      dz = xyz(3,j)-xyz(3,i)\n      r2 = dx*dx+dy*dy+dz*dz\n      r = sqrt(r2)\n      rco = rcov(at(i))+rcov(at(j))\n      if (r .lt. rco) then\n        if (cn(j) .gt. thr) then\n          b(j,i) = 1\n          map(i) = map(i)+1\n        end if\n      end if\n    end do\n  end do\n\n!>--- setup ring data for all atoms, i.e., in which ring and how large\n  call minringsizes(n,at,xyz,sring)\n\n!>--- the actual flexibility measure calculation\n  m = 0\n  av2 = 0.0d0\n  do i = 1,n\n    do j = 1,i-1\n      !> count all \"bonds\"\n      if (b(j,i) .gt. 0) m = m+1\n\n      !> no branch on terminating bonds (e.g. Me)\n      if (map(i) .eq. 1.or.map(j) .eq. 1) cycle\n\n      !> adjacent pair ij\n      if (b(j,i) .gt. 0) then\n\n        hybf = 1.0\n\n        !> sp2 C are less flexible\n        if (at(i) .eq. 6.and.cn(i) .lt. 3.3) hybf = hybf*0.5_wp\n        if (at(j) .eq. 6.and.cn(j) .lt. 3.3) hybf = hybf*0.5_wp\n\n        !> double bond term\n        doublef = 1.0-exp(-4.0*(wbo(j,i)-2.0)**6)\n\n        !> branching measure\n        branch = 2.0/sqrt(dble(map(i))*dble(map(j)))\n\n        !> flex. reduction for atoms in rings\n        ringf = 1.0\n        k = min(sring(i),sring(j))\n        !> a ring is (even at infinite size) a factor of 2 less flexible, factors are empirical\n        if (k .gt. 0) ringf = 0.5*(1.0-exp(-0.06*float(k)))\n        !> (adjusted such that c-C20 is converged)\n\n        !>  put it together\n        val = branch*ringf*doublef*hybf\n        !> quadratic av\n        av2 = av2+val**2\n      end if\n    end do\n  end do\n  if (m .gt. 0) then\n    av2 = sqrt(av2/dble(m))\n  end if\n\n  flex = av2\n  effectivNat = av2*dble(n)\n  deallocate (xyz,at,rcov,map,cn,b,sring,cring,wbo)\n\n  return\nend subroutine flexi\nsubroutine minringsizes(nat,at,xyz,sring)\n  use crest_parameters\n  use zdata\n  implicit none\n  integer :: nat\n  integer :: at(nat)\n  real(wp) :: xyz(3,nat)\n  integer :: sring(nat)\n  type(zmolecule) :: zmol\n  integer :: i,j\n\n  call simpletopo(nat,at,xyz,zmol,.false.,.true.,'')\n  do i = 1,zmol%nat\n    sring(i) = 0\n    do j = 1,zmol%nri\n      if (any(zmol%zri(j)%rlist == i)) then\n        if (sring(i) == 0) then\n          sring(i) = zmol%zri(j)%rs\n        else if (zmol%zri(j)%rs < sring(i)) then\n          sring(i) = zmol%zri(j)%rs\n        end if\n      end if\n    end do\n  end do\n  call zmol%deallocate()\n  return\nend subroutine minringsizes\n!========================================================================================!\n\nsubroutine nciflexi_gfnff(mol,flexval)\n!*************************************************************\n!* new version of the non-covalent flexibility measure.\n!* the nci-flexibility is estimated RELATIVE to a bioorganic\n!* molecule (crambin) and its hydrogen-bond and dispersion\n!* energy per atom.\n!*************************************************************\n  use crest_parameters\n  use crest_calculator\n  use strucrd\n  use gfnff_api\n  implicit none\n  !> INPUT\n  type(coord),intent(in) :: mol\n  !> OUTPUT\n  real(wp),intent(out)   :: flexval\n  !> LOCAL\n  integer :: io\n  logical :: ex\n  real(wp) :: ehb,edisp\n  real(wp) :: energy\n  real(wp),allocatable :: grad(:,:)\n  type(gfnff_data),allocatable :: ff_dat\n!>--- reset\n  flexval = 0.0_wp\n  ehb = 0.0_wp\n  edisp = 0.0_wp\n\n!>--- preprocessor statement (only executed when compiled with GFN-FF support)\n#ifdef WITH_GFNFF\n  allocate (ff_dat)\n  allocate (grad(3,mol%nat),source=0.0_wp)\n\n!>--- set up a GFN-FF calculation\n  write (stdout,'(1x,a)',advance='no') 'Calculating NCI flexibility ...'\n  flush (stdout)\n  call gfnff_api_setup(mol,mol%chrg,ff_dat,io,.false.)\n  if (io /= 0) then\n    write (stdout,'(a)') ' failed.'\n    deallocate (grad,ff_dat)\n    return\n  end if\n\n!>--- perform a singlepoint calculation\n  call gfnff_sp(mol,ff_dat,energy,grad,io)\n  if (io /= 0) then\n    write (stdout,'(a)') ' failed.'\n    deallocate (grad,ff_dat)\n    return\n  end if\n  ehb = ff_dat%res%e_hb\n  edisp = ff_dat%res%e_disp\n  write (stdout,'(a)') ' done.'\n\n!>--- normalize by number of atoms\n  ehb = ehb/mol%nat\n  edisp = edisp/mol%nat\n\n!>--- NCI flexi is determined RELATIVE to a reference molecule (Crambin)\n  flexval = 0.5_wp*(1.0_wp-(ehb/(-0.00043374_wp)))\n  flexval = flexval+0.5_wp*(1.0_wp-(edisp/(-0.00163029_wp)))\n\n  deallocate (grad,ff_dat)\n#else\n\n  write (stdout,'(a)') 'Caclulation of NCI flexibility skipped.'\n  write (stdout,'(a)') 'Set up compilation with -DWITH_GFNFF=true to enable this feature.'\n  flexval = 0.0_wp\n\n#endif\n\n  return\nend subroutine nciflexi_gfnff\n!========================================================================================!\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/flexi.F90 b/src/flexi.F90
--- a/src/flexi.F90	
+++ b/src/flexi.F90	
@@ -25,6 +25,7 @@
   use iso_fortran_env,only:wp => real64
   use strucrd
   use zdata,only:readwbo
+  use miscdata, only: rcov
   implicit none
   !> INPUT
   type(coord),intent(in) :: mol                  !> input molecule
@@ -33,7 +34,7 @@
   !> OUTPUT
   real(wp),intent(out) :: flex
   !> LOCAL
-  real(wp),allocatable::xyz(:,:),rcov(:),cn(:),cring(:,:),wbo(:,:),wbofull(:,:)
+  real(wp),allocatable::xyz(:,:),cn(:),cring(:,:),wbo(:,:),wbofull(:,:)
   integer,allocatable::at(:),map(:),b(:,:),sring(:),map2(:)
   real(wp) :: dx,dy,dz,r,r2,rco,val,ringf,doublef,branch,effectivNat,hybf
   real(wp) :: av2
@@ -49,9 +50,8 @@
   rn = rednat !> Number of atoms selected by atomlist+/-
   !> rn=n if atomlist+/- is not used
 
-  allocate (xyz(3,rn),at(rn),rcov(94),map(rn),cn(rn),b(rn,rn))
+  allocate (xyz(3,rn),at(rn),map(rn),cn(rn),b(rn,rn))
   allocate (sring(rn),cring(12,rn),wbo(rn,rn),wbofull(n,n),map2(n))
-  call setrcov(rcov)
 
 !>--- map given structure to considered substructure
   if (rn .ne. n) then
@@ -180,7 +180,7 @@
 
   flex = av2
   effectivNat = av2*dble(n)
-  deallocate (xyz,at,rcov,map,cn,b,sring,cring,wbo)
+  deallocate (xyz,at,map,cn,b,sring,cring,wbo)
 
   return
 end subroutine flexi
Index: src/cregen.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!===============================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!===============================================================================!\n\n!=========================================================================================!\n!=========================================================================================!\n!> CREGEN is the universal ensemble sorting routine of CREST.\n!> This is a rewrite of the original routines since the old ones\n!> got a bit messy over time.\n!> the quickset variable can be used for some special runtypes:\n!>   quickset:  2 - do symmetry analysis\n!>              3 - switch off equivalency analysis\n!>              6 - energy sorting only\n!>              9 - no sorting, only check groups\n!>             12 - no topology check, turn ewin to infty\n!=========================================================================================!\n!=========================================================================================!\nsubroutine newcregen(env,quickset)\n  use crest_parameters\n  use crest_data\n  use strucrd\n  implicit none\n  type(systemdata) :: env      !> MAIN STORAGE OS SYSTEM DATA\n  integer,optional :: quickset !> quick access to predefined CREGEN modes\n  integer :: simpleset\n  character(len=258) :: fname  !> input file\n  character(len=258) :: oname  !> sorted output file\n  character(len=258) :: cname  !> unique structure file\n  !>--- ensemble arguments\n  integer :: nat                      !> number of atoms\n  integer :: nall                     !> number of structures\n  integer,allocatable  :: at(:)       !> atom numbers\n  real(wp),allocatable :: xyz(:,:,:)  !> Cartesian coordinates\n  character(len=128),allocatable :: comments(:)\n  character(len=128),allocatable :: comref(:)\n  real(wp),allocatable :: er(:)       !> energies\n  !>--- dummy ensemble arguments\n  integer :: nallref\n  integer :: nallnew\n  real(wp),allocatable :: xyzref(:,:,:)\n  !>--- sorting arguments\n  integer,allocatable :: gref(:),group(:)\n  integer :: ng\n  integer,allocatable :: degen(:,:)\n\n  !>--- float data\n  real(wp) :: ewin\n  real(wp) :: rthr\n  real(wp) :: bthr\n  real(wp) :: pthr\n  real(wp) :: ethr\n  real(wp) :: athr\n  real(wp) :: T\n  real(wp) :: couthr\n\n  !>--- boolean data\n  logical :: checkbroken\n  logical :: topocheck\n  logical :: checkez\n  logical :: sorte\n  logical :: sortRMSD\n  logical :: sortRMSD2\n  logical :: newfile\n  logical :: repairord\n  logical :: conffile\n  logical :: bonusfiles\n  logical :: anal\n  logical :: saveelow = .true.\n\n  !--- printout directions\n  integer :: prch  !the main printout channel\n  logical :: pr1,pr2,pr3,pr4\n\n!====================================================================!\n! S E T T I N G S\n!====================================================================!\n  if (present(quickset)) then\n    simpleset = quickset\n  else\n    simpleset = 0\n  end if\n\n  !-- determine filenames and output channel\n  call cregen_files(env,fname,oname,cname,simpleset,prch)\n  !-- determine which printouts are required\n  call cregen_prout(env,simpleset,pr1,pr2,pr3,pr4)\n  !-- determine which subroutines are required\n  call cregen_director(env,simpleset,checkbroken,sorte,sortRMSD,sortRMSD2, &\n  &  repairord,newfile,conffile,bonusfiles,anal,topocheck,checkez)\n\n!--- DATA SECTION\n  call cregen_filldata1(env,ewin,rthr,ethr,bthr,athr,pthr,T,couthr)\n  call cregen_filldata2(simpleset,ewin)\n\n!--- setting the threads for OMP parallel usage\n  call cregen_setthreads(prch,env,.false.)\n\n!=====================================================================!\n\n!--- read in the ensemble parameters\n  call rdensembleparam(fname,nat,nallref)\n\n!--- print a summary about the ensemble and thresholds\n  if (pr1) call cregen_pr1(prch,env,nat,nallref,rthr,bthr,pthr,ewin)\n\n!--- allocate space and read in the ensemble\n  allocate (at(nat),comments(nallref),xyz(3,nat,nallref))\n  call rdensemble(fname,nat,nallref,at,xyz,comments)\n\n!--- check if the ensemble contains broken structures? i.e., fusion or dissociation\n  if (checkbroken) then\n    call discardbroken(prch,env,nat,nallref,at,xyz,comments,nall)\n    !--- if structures were discarded, resize xyz\n    if (nall .lt. nallref) then\n      xyzref = xyz(:,:,1:nall)\n      call move_alloc(xyzref,xyz)\n      comref = comments(1:nall)\n      call move_alloc(comref,comments)\n    end if\n  else\n    nall = nallref\n  end if\n\n!--- compare neighbourlists to sort out chemically transformed structures\n  if (topocheck) then\n    call cregen_topocheck(prch,env,checkez,nat,nall,at,xyz,comments,nallnew)\n    !--- if structures were discarded, resize xyz\n    if (nallnew .lt. nall) then\n      !-- special fallback if all are discared\n      if (nallnew == 0) then\n        call rdcoord('coord',nat,at,xyz(:,:,1))\n        xyz = xyz * bohr\n        write (comments(1),'(f18.8)') env%elowest\n        nallnew = 1\n      end if\n      nall = nallnew\n      xyzref = xyz(:,:,1:nall)\n      call move_alloc(xyzref,xyz)\n      comref = comments(1:nall)\n      call move_alloc(comref,comments)\n    end if\n  end if\n  if (topocheck .or. checkbroken) then\n    write (prch,'('' number of reliable points      :'',i6)') nall\n  end if\n\n!--- sort the ensemble by its energies and make a cut (EWIN)\n  if (sorte) then\n    call cregen_esort(prch,nat,nall,xyz,comments,nallnew,ewin)\n    !--- if structures were discarded, resize xyz\n    if (nallnew .lt. nall) then\n      nall = nallnew\n      xyzref = xyz(:,:,1:nall)\n      call move_alloc(xyzref,xyz)\n      comref = comments(1:nall)\n      call move_alloc(comref,comments)\n    end if\n  end if\n\n!--- do the rotational constants and RMSD check\n  if (sortRMSD) then\n    allocate (group(0:nall))\n    call cregen_CRE(prch,env,nat,nall,at,xyz,comments,nallnew,group)\n    !--- if structures were discarded, resize xyz\n    if (nallnew .lt. nall) then\n      nall = nallnew\n      xyzref = xyz(:,:,1:nall)\n      call move_alloc(xyzref,xyz)\n      comref = comments(1:nall)\n      call move_alloc(comref,comments)\n      allocate (gref(0:nallnew))\n      gref(0:nallnew) = group(0:nallnew)\n      call move_alloc(gref,group)\n      nall = nallnew\n    end if\n    !--- repair the order\n    if (repairord) then\n      call cregen_repairorder(nat,nall,xyz,comments,group)\n    end if\n    !--- get group info to degen\n    ng = group(0)\n    allocate (degen(3,ng))\n    call cregen_groupinfo(nall,ng,group,degen)\n  end if\n  if (sortRMSD2) then\n    allocate (group(0:nall))\n    call cregen_CRE_2(prch,env,nat,nall,at,xyz,comments,nallnew,group)\n  end if\n\n!--- align all structures to the first structure using the RMSD\n  call cregen_rmsdalign(nat,nall,at,xyz)\n\n!--- write new file with ALL remaining structures\n  if (newfile) then\n    call cregen_file_wr(env,oname,nat,nall,at,xyz,comments)\n  end if\n!--- write a file only containing the conformers.\n  if (conffile) then\n    call cregen_conffile(env,cname,nat,nall,at,xyz,comments,ng,degen)\n  end if\n  if (saveelow) then\n    env%elowest = grepenergy(comments(1))\n    !-- and update reference geometry (in Bohrs!)\n    env%ref%xyz = xyz(:,:,1) / bohr\n  end if\n\n!--- additional files for entropy mode\n  if (bonusfiles) then\n    call cregen_bonusfiles(ng,degen)\n  end if\n\n!--- several printouts\n  if (pr2) then\n    allocate (er(nall))\n    call cregen_pr2(prch,env,nall,comments,ng,degen,er)\n    call cregen_econf_list(prch,nall,er,ng,degen)\n    deallocate (er)\n  end if\n  if (pr3) then !alternative to pr2\n    call cregen_pr3(prch,oname,nall,comments)\n  end if\n  if (pr4) then !group dara printout\n    call cregen_pr4(prch,fname,nall,group)\n  end if\n\n!--- analyze nuclear equivalencies, e.g. for NMR and Entropy\n  if (anal) then\n    call cregen_EQUAL(prch,nat,nall,at,xyz,group,athr,.not. env%entropic)\n  end if\n\n!--- deallocate data\n  if (prch .ne. stdout) then\n    close (prch)\n  end if\n  if (allocated(er)) deallocate (er)\n  if (allocated(degen)) deallocate (degen)\n  if (allocated(group)) deallocate (group)\n  deallocate (xyz,comments,at)\n  return\nend subroutine newcregen\n!=========================================================================================!\n!=========================================================================================!\n!  CREGEN DATA SECTION\n!=========================================================================================!\n!=========================================================================================!\n\n!============================================================!\n! subroutine cregen_files\n! handle all settings regarding input and output file names\n! including where to print the cregen output\n!============================================================!\nsubroutine cregen_files(env,fname,oname,cname,simpleset,iounit)\n  use crest_parameters\n  use crest_data\n  use iomod\n  implicit none\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n  character(len=*) :: fname\n  character(len=*) :: oname\n  character(len=*) :: cname\n  integer,intent(in) :: simpleset\n  integer,intent(out) :: iounit\n  character(len=:),allocatable :: outfile\n  logical :: ex\n  !--------------------------------------------------------------------\n  outfile = 'cregen.out.tmp'\n  if (env%cgf(6)) outfile = 'tmp'\n\n  !-- the entire cregen output can be printed printed to a seperate file\n  !   or to the terminal\n  call remove(outfile)\n  if (simpleset > 0) then\n    select case (simpleset)\n    case (6,9,12)\n      iounit = stdout\n    case default\n      open (newunit=iounit,file=outfile)\n    end select\n  else if (env%confgo .and. .not. (env%properties .eq. -2) .and. .not. env%relax) then\n    iounit = stdout\n    !iounit=6\n  else\n    open (newunit=iounit,file=outfile)\n  end if\n\n  fname = trim(env%ensemblename)\n  if (env%confgo .and. (index(trim(fname),'none selected') .eq. 0)) then\n    fname = trim(env%ensemblename)\n    oname = trim(env%ensemblename)//'.sorted'\n    cname = 'crest_ensemble.xyz'\n    if (env%fullcre) then\n      env%ensemblename = trim(oname)\n    end if\n  else !internal mode for conformational search\n    call checkname_xyz(crefile,fname,oname)\n    cname = conformerfile\n  end if\n  if( simpleset == 12 ) then !> MECP files\n    fname = \"crest_mecp_search.xyz\"\n    oname = \"crest_mecp_search.xyz.sorted\"\n    cname = \"crest_ensemble.xyz\"\n  endif\n  if( simpleset == 15 ) then !> crossing files\n    call checkname_xyz('confcross',fname,oname)\n    cname = trim(fname)//'.unique'\n  endif\n\n  write (iounit,*) 'input  file name : ',trim(fname)\n  select case (simpleset)\n  case (9)\n    continue\n  case default\n    write (iounit,*) 'output file name : ',trim(oname)\n  end select\n\n  inquire (file=fname,exist=ex)\n  if (.not. ex) then\n    write (0,*) 'Warning, file ',trim(fname),' does not exist!'\n    error stop\n  end if\n\n  return\nend subroutine cregen_files\n\n!============================================================!\n! subroutine cregen_prout\n! handle all settings regarding which printouts are active\n! (currently only those for default cregen runs)\n!============================================================!\nsubroutine cregen_prout(env,simpleset,pr1,pr2,pr3,pr4)\n  use crest_parameters\n  use crest_data\n  use iomod\n  implicit none\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n  integer,intent(in) :: simpleset\n  logical,intent(out) :: pr1,pr2,pr3,pr4\n\n  pr1 = .true.  !threshold summary\n  pr2 = .true.  !detailed energy/group list\n  pr3 = .false. !plain energy list\n  pr4 = .false. !group list printout\n\n  if (simpleset == 6) then\n    pr1 = .false.\n    pr2 = .false.\n    if (env%crestver .ne. crest_solv) pr3 = .true.\n  end if\n\n  if (simpleset == 9) then\n    pr1 = .true.\n    pr2 = .false.\n    pr3 = .false.\n    pr4 = .true.\n  end if\n\n  return\nend subroutine cregen_prout\n\n!============================================================!\n! subroutine cregen_director !IMPORTANT!\n! handle which comparisons are required and which files shall\n! be written\n!============================================================!\nsubroutine cregen_director(env,simpleset,checkbroken,sorte,sortRMSD,sortRMSD2, &\n        &  repairord,newfile,conffile,bonusfiles,anal,topocheck,checkez)\n  use crest_parameters\n  use crest_data\n  use iomod\n  implicit none\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n  integer,intent(in) :: simpleset\n  logical,intent(out) :: checkbroken\n  logical,intent(out) :: sorte,sortRMSD,sortRMSD2\n  logical,intent(out) :: repairord\n  logical,intent(out) :: newfile,conffile\n  logical,intent(out) :: bonusfiles\n  logical,intent(out) :: anal\n  logical,intent(out) :: topocheck\n  logical,intent(out) :: checkez\n\n  checkbroken = .true.  !fragmentized structures are sorted out\n  sorte = .true.  !sort based on energy\n  sortRMSD = .true.  !sort based on RMSD\n  sortRMSD2 = .false. !check groups for whole ensemble\n  repairord = .true.  !double-check the sorted Ensemble\n\n  newfile = .true.  !sorted input file\n\n  conffile = .true. !sorted unique structure file\n\n  topocheck = env%checktopo !topology is compared to reference structure\n  checkez = env%checkiso  !check for C=C cis/trans isomerizations\n  if (env%relax) then\n    topocheck = .false.\n  end if\n\n  bonusfiles = .false.\n  if (env%entropic .or. env%doNMR) then\n    bonusfiles = .true.\n  end if\n\n  anal = .false.\n  if (env%doNMR .or. env%cgf(3) .or. simpleset == 2) then\n    anal = .true.\n  end if\n  if (simpleset == 3) then\n    anal = .false.\n  end if\n\n  if (simpleset == 6) then  !energy sorting only\n    checkbroken = .false.\n    sorte = .true.\n    sortRMSD = .false.\n    repairord = .false.\n    newfile = .true.\n    if ((env%crestver .eq. crest_solv) .and. (.not. env%QCG)) then\n      conffile = .true. !Conffile is needed for confscript in QCG\n    else\n      conffile = .false.\n    end if\n    topocheck = .false.\n    checkez = .false.\n    bonusfiles = .false.\n    anal = .false.\n  end if\n\n  if (simpleset == 9) then  !optpurge mode\n    checkbroken = .false.\n    sorte = .false.\n    sortRMSD = .false.\n    sortRMSD2 = .true.\n    repairord = .false.\n    newfile = .false.\n    conffile = .false.\n    topocheck = .false.\n    checkez = .false.\n    bonusfiles = .false.\n    anal = .false.\n  end if\n\n  !> MECP search final sorting\n  if (simpleset == 12) then\n    topocheck = .false.\n    checkez = .false.\n    bonusfiles = .false.\n    anal = .false.\n  end if\n\n  return\nend subroutine cregen_director\n\n!============================================================!\n! subroutine cregen_filldata1\n! get important threshold from \"opt\" and \"sys\" objects\n!============================================================!\nsubroutine cregen_filldata1(env,ewin,rthr,ethr,bthr,athr,pthr,T,couthr)\n  use crest_parameters\n  use crest_data\n  implicit none\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n  real(wp),intent(out) :: ewin,rthr,ethr,bthr,athr,pthr,T,couthr\n  !--------------------------------------------------------------------\n  ewin = env%ewin          !ensemble energy window in kcal/mol\n  rthr = env%rthr          ! RMSD thr in Ang\n  ethr = env%ethr          ! E threshold in kcal\n  bthr = env%bthr2         ! rot const thr (lower bound)\n  athr = env%athr          ! to det. int. rotation. equal atoms for NMR, CRITICAL!\n  pthr = env%pthr          ! population thr\n  T = env%tboltz        ! Temperature\n  couthr = env%couthr      ! coulomb sorting threshold\n  return\nend subroutine cregen_filldata1\nsubroutine cregen_filldata2(simpleset,ewin)\n  use crest_parameters\n  use crest_data\n  implicit none\n  integer,intent(in) :: simpleset\n  real(wp),intent(out) :: ewin\n  !--------------------------------------------------------------------\n  if (simpleset == 6) then\n    ewin = 100000\n  end if\n  if (simpleset == 12) then\n    ewin = huge(ewin)\n  end if\n  return\nend subroutine cregen_filldata2\n\n!============================================================!\n! subroutine cregen_groupinfo\n! get info about each conformer group and save it to \"degen\"\n!============================================================!\nsubroutine cregen_groupinfo(nall,ng,group,degen)\n  use crest_parameters\n  implicit none\n  integer :: nall,ng\n  integer :: group(0:nall)\n  integer :: degen(3,ng)\n  integer :: i,j,k\n  integer :: a,b\n  do i = 1,ng\n    a = 0; b = 0; k = 0\n    do j = 1,nall\n      if (group(j) .eq. i) then\n        k = k + 1\n        if (a == 0) a = j\n        b = j\n      end if\n    end do\n    degen(1,i) = k !>-- number of members in group i\n    degen(2,i) = a !>-- first member of group i\n    degen(3,i) = b !>-- last member of group i\n  end do\n  return\nend subroutine cregen_groupinfo\n\n!=========================================================================================!\n!=========================================================================================!\n!  CREGEN SUBROUTINES\n!=========================================================================================!\n!=========================================================================================!\n\n!============================================================!\n! subroutine discardbroken\n! analyze an ensemble and track broken structures\n! to be discarded.\n!============================================================!\nsubroutine discardbroken(ch,env,nat,nall,at,xyz,comments,newnall)\n  use crest_parameters\n  use crest_data\n  use strucrd\n  implicit none\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n  integer :: ch ! printout channel\n  integer :: nat,nall\n  integer :: at(nat)\n  real(wp) :: xyz(3,nat,nall)\n  character(len=*) :: comments(nall)\n  integer :: newnall\n  integer :: llan\n  integer,allocatable :: order(:),orderref(:)\n  integer :: nat0\n  real(wp),allocatable :: cref(:,:),c0(:,:),c1(:,:)\n  integer,allocatable  :: at0(:),atdum(:)\n  real(wp),allocatable :: rcov(:),cn(:),bond(:,:)\n  integer :: frag,frag0\n  real(wp) :: erj\n  integer :: j\n  logical :: substruc\n  logical :: distok,distcheck\n  real(wp) :: cnorm\n  logical :: dissoc\n\n  !>--- if we don't wish to include all atoms:\n  substruc = (nat .ne. env%rednat .and. env%subRMSD)\n\n  !>--- settings\n  allocate (rcov(94))\n  call setrcov(rcov)\n\n  !>--- read the reference structure\n  allocate (cref(3,nat),atdum(nat))\n  call rdcoord('coord',nat,atdum,cref)\n  !>--- check fragements\n  allocate (bond(nat,nat),cn(nat),source=0.0_wp)\n  call mreclm(frag0,nat,at,cref,atdum,bond,rcov,cn)\n  deallocate (bond,cn)\n\n  write (ch,'('' # fragment in coord            :'',i6)') frag0\n  deallocate (atdum)\n  if (substruc) then\n    nat0 = env%rednat\n    allocate (c0(3,nat0),at0(nat0),c1(3,nat0),atdum(nat0))\n    call maskedxyz(nat,nat0,cref,c0,at,at0,env%includeRMSD)\n  else\n    allocate (c0(3,nat),at0(nat),c1(3,nat),atdum(nat))\n    c0 = cref\n    at0 = at\n    nat0 = nat\n  end if\n  !>--- fragments for actual reference\n  allocate (bond(nat0,nat0),cn(nat0))\n  call mreclm(frag0,nat0,at0,c0,atdum,bond,rcov,cn)\n\n  allocate (order(nall),orderref(nall))\n  !>--- loop over the structures\n  newnall = 0\n  llan = nall\n  do j = 1,nall\n    erj = grepenergy(comments(j)) !> get energy of structure j\n    if (.not. substruc) then\n      c1(:,:) = xyz(:,:,j) / bohr\n    else\n      call maskedxyz(nat,nat0,xyz(:,:,j),c1,at,at0,env%includeRMSD)\n      c1 = c1 / bohr\n    end if\n    distok = distcheck(nat0,c1) !> distance check\n    cnorm = sum(abs(c1))        !> clash check\n\n    !>--- further checks?\n    dissoc = .false.\n    if (abs(erj) .gt. 1.0d-6 .and. cnorm .gt. 1.0d-6 .and. distok) then\n      dissoc = .false.\n      call mreclm(frag,nat0,at0,c1,atdum,bond,rcov,cn)\n      if (frag .gt. frag0) then\n        dissoc = .true.\n      end if\n    end if\n\n!    if (dissoc .or. (abs(erj) .lt. 1.0d-6) .or. &\n    if (dissoc .or. &\n  &   (cnorm .lt. 1.0d-6) .or. (.not. distok)) then\n      !>--- move broken structures to the end of the matrix\n      orderref(j) = llan\n      llan = llan - 1\n      !write(ch,*) 'removing structure',j\n    else\n      newnall = newnall + 1\n      orderref(j) = newnall\n    end if\n  end do\n\n  !>--- sort the xyz array (only if structures have been discarded)\n  if (newnall .lt. nall) then\n    order = orderref\n    call xyzqsort(nat,nall,xyz,c0,order,1,nall)\n    order = orderref\n    call stringqsort(nall,comments,1,nall,order)\n\n    llan = nall - newnall\n    write (ch,'('' number of removed clashes      :'',i6)') llan\n  end if\n  !>--- otherwise the ensemble is ok\n\n  if(allocated(orderref)) deallocate(orderref)\n  if(allocated(order))  deallocate (order)\n  if(allocated(cn)) deallocate(cn)\n  if(allocated(bond)) deallocate(bond)\n  if(allocated(atdum)) deallocate(atdum)\n  if(allocated(c1)) deallocate(c1)\n  if(allocated(at0)) deallocate(at0)\n  if(allocated(c0)) deallocate(c0)\n  if(allocated(cref)) deallocate(cref)\n  if(allocated(rcov)) deallocate(rcov)\n  return\nend subroutine discardbroken\n\n!============================================================!\n!> subroutine cregen_topocheck\n!> analyze an ensemble and compare topology (neighbourlist)\n!> to the reference structure\n!============================================================!\nsubroutine cregen_topocheck(ch,env,checkez,nat,nall,at,xyz,comments,newnall)\n  use crest_parameters\n  use crest_data\n  use strucrd\n  implicit none\n  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n  integer,intent(in) :: ch ! printout channel\n  logical,intent(in) :: checkez\n  integer,intent(in) :: nat,nall\n  integer,intent(in) :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat,nall)\n  character(len=*),intent(inout) :: comments(nall)\n  integer,intent(out) :: newnall\n  integer :: llan\n  integer,allocatable :: order(:),orderref(:)\n  real(wp),allocatable :: cref(:,:),c1(:,:)\n  integer,allocatable  :: atdum(:)\n  real(wp),allocatable :: rcov(:),cn(:),bond(:,:)\n  integer,allocatable :: toporef(:)\n  integer,allocatable :: topo(:)\n  logical,allocatable :: neighmat(:,:)\n  integer :: nbonds\n  integer :: j,l\n  integer :: ntopo,ncc,ccfail\n  logical :: discard\n  integer,allocatable :: ezat(:,:)\n  real(wp),allocatable :: ezdihedref(:)\n  real(wp),allocatable :: ezdihed(:)\n  real(wp) :: winkeldiff\n\n  !--- settings\n  allocate (rcov(94))\n  call setrcov(rcov)\n\n  !--- read the reference structure\n  allocate (cref(3,nat),atdum(nat))\n  call rdcoord('coord',nat,atdum,cref)\n\n  !--- get the reference topology matrix (bonds)\n  ntopo = nat * (nat + 1) / 2\n  allocate (toporef(ntopo),topo(ntopo))\n  allocate (neighmat(nat,nat),source=.false.)\n  allocate (bond(nat,nat),cn(nat),source=0.0_wp)\n  cn = 0.0d0\n  bond = 0.0d0\n  call xcoord2(nat,atdum,cref,rcov,cn,400.0_wp,bond)\n  !do i=1,nat\n  !   write(*,*) i,i2e(at(i),'nc'),nint(cn(i))\n  !enddo\n  if (allocated(env%excludeTOPO)) then\n    call bondtotopo_excl(nat,at,bond,cn,ntopo,toporef,neighmat,env%excludeTOPO)\n  else\n    call bondtotopo(nat,at,bond,cn,ntopo,toporef,neighmat)\n  end if\n\n  nbonds = sum(toporef)\n  write (ch,'('' # bonds in reference structure :'',i6)') nbonds\n  !--- if required, check for C=C bonds (based only on structure!)\n  if (checkez) then\n    cref = cref * bohr\n    call nezcc(nat,atdum,cref,cn,ntopo,toporef,ncc)\n    if (ncc > 0) then\n      write (ch,'(''   => # of C=C bonds :'',i6)') ncc\n      allocate (ezat(4,ncc))\n      allocate (ezdihedref(ncc),ezdihed(ncc),source=0.0d0)\n      call ezccat(nat,atdum,cref,cn,ntopo,toporef,ncc,ezat)\n      call ezccdihed(nat,cref,ncc,ezat,ezdihedref)\n      !do i=1,ncc\n      !  write(*,'(1x,a,4i4,a,f6.2)') 'C=C bond atoms:',ezat(1:4,i),\" angle: \",ezdihedref(i)\n      !enddo\n    end if\n  end if\n\n  allocate (order(nall),orderref(nall))\n  allocate (c1(3,nat))\n  !--- loop over the structures\n  ccfail = 0\n  newnall = 0\n  llan = nall\n  do j = 1,nall\n    c1(1:3,1:nat) = xyz(1:3,1:nat,j) / bohr\n    !--- generate topo and compare\n    discard = .false.\n    cn = 0.0d0\n    bond = 0.0d0\n    call xcoord2(nat,at,c1,rcov,cn,400.0_wp,bond)\n    if (allocated(env%excludeTOPO)) then\n      call bondtotopo_excl(nat,at,bond,cn,ntopo,topo,neighmat,env%excludeTOPO)\n    else\n      call bondtotopo(nat,at,bond,cn,ntopo,topo,neighmat)\n    end if\n    do l = 1,ntopo\n      if (toporef(l) .ne. topo(l)) then\n        !call revlin(int(l,kind=8),k,i)\n        !write(*,*) 'structure',j,'mismatch in ',k,i\n        !write(*,*) nint(cn(k)),nint(cn(i))\n        discard = .true.   !if there is any mismatch in neighbor lists\n        exit\n      end if\n    end do\n    !--- get E/Z info of C=C, discard isomers\n    if (checkez .and. .not. discard .and. ncc > 0) then\n      c1 = c1 * bohr\n      call ezccdihed(nat,c1,ncc,ezat,ezdihed)\n      do l = 1,ncc\n        winkeldiff = ezdihedref(l) - ezdihed(l)\n        winkeldiff = abs(winkeldiff)\n        if (winkeldiff > 90.0_wp) then\n          discard = .true.\n          ccfail = ccfail + 1\n          exit\n        end if\n      end do\n    end if\n\n    if (discard) then\n      !-- move broken structures to the end of the matrix\n      orderref(j) = llan\n      llan = llan - 1\n      !write(ch,*) 'removing structure',j\n    else\n      newnall = newnall + 1\n      orderref(j) = newnall\n    end if\n  end do\n\n  !--- sort the xyz array (only if structures have been discarded)\n  if (newnall .lt. nall) then\n    order = orderref\n    call xyzqsort(nat,nall,xyz,c1,order,1,nall)\n    order = orderref\n    call stringqsort(nall,comments,1,nall,order)\n\n    llan = nall - newnall\n    write (ch,'('' number of topology mismatches  :'',i6)') llan\n    if (checkez .and. ccfail > 0) then\n      write (ch,'(''  => discared due to E/Z isom.  :'',i6)') ccfail\n    end if\n  end if\n  !--- otherwise the ensemble is ok\n\n  !write(ch,'('' number of reliable points      :'',i6)')newnall\n\n  deallocate (c1)\n  deallocate (orderref,order)\n  if (allocated(ezdihedref)) deallocate (ezdihedref)\n  if (allocated(ezdihed)) deallocate (ezdihed)\n  if (allocated(ezat)) deallocate (ezat)\n  deallocate (cn,bond)\n  deallocate (neighmat)\n  deallocate (topo,toporef)\n  deallocate (atdum)\n  deallocate (cref,rcov)\n  return\n\ncontains\n  !=================================================!\n  ! Check how many (potential) C=C bonds are present\n  !=================================================!\n  subroutine nezcc(nat,at,xyz,cn,ntopo,topo,ncc)\n    use crest_parameters\n    integer,intent(in)  :: nat\n    integer,intent(in)  :: at(nat)\n    real(wp),intent(in) :: xyz(3,nat)\n    real(wp),intent(in) :: cn(nat)\n    integer,intent(in)  :: ntopo\n    integer,intent(in)  :: topo(ntopo)\n    integer,intent(out) :: ncc\n    real(wp) :: dist\n    integer :: l\n    integer :: ci,cj,lin\n    real(wp),parameter :: distcc = 1.384_wp\n    ncc = 0\n    do ci = 1,nat\n      do cj = 1,ci - 1\n        if (ci == cj) cycle\n        l = lin(ci,cj)\n        if (topo(l) == 0) cycle\n        if (at(ci) == 6 .and. at(cj) == 6 .and. &\n        &  nint(cn(ci)) == 3 .and. nint(cn(cj)) == 3) then\n          dist = (xyz(1,ci) - xyz(1,cj))**2 + &\n          &    (xyz(2,ci) - xyz(2,cj))**2 + &\n          &    (xyz(3,ci) - xyz(3,cj))**2\n          dist = sqrt(dist)\n          if (dist < distcc) then\n            ncc = ncc + 1\n          end if\n        end if\n      end do\n    end do\n    return\n  end subroutine nezcc\n  !=================================================!\n  ! Check which atoms can be used for C=C dihedral angles\n  !=================================================!\n  subroutine ezccat(nat,at,xyz,cn,ntopo,topo,ncc,ezat)\n    use crest_parameters\n    integer,intent(in)  :: nat\n    integer,intent(in)  :: at(nat)\n    real(wp),intent(in) :: xyz(3,nat)\n    real(wp),intent(in) :: cn(nat)\n    integer,intent(in)  :: ntopo\n    integer,intent(in)  :: topo(ntopo)\n    integer,intent(in)  :: ncc\n    integer,intent(out) :: ezat(4,ncc)\n    real(wp) :: dist\n    integer :: i,j,k,l\n    integer :: ci,cj,lin\n    real(wp),parameter :: distcc = 1.384_wp\n    if (ncc < 1) return\n    k = 0\n    do ci = 1,nat\n      do cj = 1,ci - 1\n        if (ci == cj) cycle\n        l = lin(ci,cj)\n        if (topo(l) == 0) cycle\n        if (at(ci) == 6 .and. at(cj) == 6 .and. &\n        &  nint(cn(ci)) == 3 .and. nint(cn(cj)) == 3) then\n          dist = (xyz(1,ci) - xyz(1,cj))**2 + &\n          &    (xyz(2,ci) - xyz(2,cj))**2 + &\n          &    (xyz(3,ci) - xyz(3,cj))**2\n          dist = sqrt(dist)\n          if (dist < distcc) then\n            k = k + 1\n            ezat(2,k) = ci\n            ezat(3,k) = cj\n            !-- get a neighbour for ci\n            do i = 1,nat\n              if (i == cj .or. i == ci) cycle\n              l = lin(ci,i)\n              if (topo(l) == 1) then\n                ezat(1,k) = i\n                exit\n              end if\n            end do\n            !-- get a neighbour for cj\n            do j = 1,nat\n              if (j == cj .or. j == ci) cycle\n              l = lin(cj,j)\n              if (topo(l) == 1) then\n                ezat(4,k) = j\n                exit\n              end if\n            end do\n          end if\n        end if\n      end do\n    end do\n    return\n  end subroutine ezccat\n  !=================================================!\n  ! Check which atoms can be used for C=C dihedral angles\n  !=================================================!\n  subroutine ezccdihed(nat,xyz,ncc,ezat,ezdihed)\n    use crest_parameters\n    integer,intent(in)  :: nat\n    real(wp),intent(in) :: xyz(3,nat)\n    integer,intent(in)  :: ncc\n    integer,intent(in) :: ezat(4,ncc)\n    real(wp),intent(out) :: ezdihed(ncc)\n    integer :: i,k\n    integer :: a,b,c,d\n    real(wp) :: winkel\n    if (ncc < 1) return\n    k = 0\n    do i = 1,ncc\n      a = ezat(1,i)\n      b = ezat(2,i)\n      c = ezat(3,i)\n      d = ezat(4,i)\n      call DIHED(xyz,a,b,c,d,winkel) !-- from intmodes.f\n      winkel = abs(winkel * (180.0_wp / pi))\n      if (winkel > 180.0_wp) then\n        winkel = 360.0_wp - winkel\n      end if\n      ezdihed(i) = winkel\n    end do\n    return\n  end subroutine ezccdihed\nend subroutine cregen_topocheck\n\n!============================================================!\n!> subroutine cregen_esort\n!> sort the ensemble by energy and determine the new\n!> ensemble size within the energy threshold.\n!> On Input: ch - printout channel\n!>           nat - number of atoms\n!>           nall - number of structure in ensemble\n!>           xyz  - Cartesian coordinates\n!>           comments - commentary lines containing the energy\n!>           ewin - energy window in kcal/mol\n!> On Output: nallout - number of strucutres after cutoff\n!============================================================!\nsubroutine cregen_esort(ch,nat,nall,xyz,comments,nallout,ewin)\n  use crest_parameters\n  use strucrd\n  implicit none\n  integer,intent(in) :: ch\n  integer,intent(in) :: nat\n  integer,intent(in) :: nall\n  real(wp),intent(inout) :: xyz(3,nat,nall)\n  character(len=*) :: comments(nall)\n  integer :: nallout\n  real(wp),intent(in) :: ewin\n\n  real(wp),allocatable :: energies(:)\n  integer,allocatable :: orderref(:)\n  integer,allocatable :: order(:)\n  real(wp),allocatable :: c0(:,:)\n  integer :: i\n  real(wp) :: de,emax\n\n  allocate (energies(nall))\n  allocate (orderref(nall),order(nall))\n  do i = 1,nall\n    energies(i) = grepenergy(comments(i))\n    orderref(i) = i\n    order(i) = i\n  end do\n  !-- sort the energies and obtain the order\n  call qsort(energies,1,nall,orderref)\n  !-- after the sorting orderref contains information:\n  !   before the sorting element \"i\" WAS at position \"orderref(i)\"\n  !   but to use it as a mask, we need to invert it,\n  !   so that it is: element \"i\" IS NOW at position \"orderref(i)\"\n  call maskinvert(nall,orderref)\n\n  !-- sort structures and comments based on the order\n  order = orderref\n  allocate (c0(3,nat))\n  call xyzqsort(nat,nall,xyz,c0,order,1,nall)\n  deallocate (c0)\n  order = orderref\n\n  call stringqsort(nall,comments,1,nall,order)\n\n  !-- determine cut-off of energies\n  emax = maxval(energies(:),1)\n  de = (emax - energies(1)) * autokcal\n  if (de .gt. ewin) then\n    nallout = 1 !lowes is always taken\n    do i = 2,nall\n      de = (energies(i) - energies(1)) * autokcal\n      if (de .lt. ewin) then\n        nallout = nallout + 1\n      else\n        exit\n      end if\n    end do\n    write (ch,'('' number of removed by energy    :'',i6)') (nall - nallout)\n    write (ch,'('' number of remaining points     :'',i6)') nallout\n  else\n    nallout = nall\n  end if\n  write (ch,*) 'reference state Etot :',energies(1)\n\n  deallocate (order,orderref)\n  deallocate (energies)\n  return\nend subroutine cregen_esort\n\n!============================================================!\n!> subroutine cregen_CRE\n!> sort the ensemble based on rotational constants,RMSD and\n!> energy to determine rotamers and duplicates.\n!> On Input: ch - printout channel\n!>           nat - number of atoms\n!>           nall - number of structure in ensemble\n!>           at   - atom types\n!>           xyz  - Cartesian coordinates\n!>           comments - commentary lines containing the energy\n!> On Output: nallout - new total number of structures\n!>            group   - to which group every structure belongs\n!============================================================!\nsubroutine cregen_CRE(ch,env,nat,nall,at,xyz,comments,nallout,group)\n  use crest_parameters, id => dp  \n  use crest_data\n  use strucrd\n  use ls_rmsd\n  use axis_module\n  implicit none\n  type(systemdata) :: env\n  integer,intent(in) :: ch\n  integer,intent(in) :: nat\n  integer,intent(in) :: nall\n  integer,intent(in) :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat,nall)\n  integer,intent(inout) :: group(0:nall)\n  character(len=*) :: comments(nall)\n  integer :: nallout\n  logical :: enantio = .true.   !check for enantiomers?\n\n  !>--- float data\n  real(wp) :: ewin,rthr,bthr,pthr,ethr,athr,T\n  !>--- energy data\n  real(wp),allocatable :: er(:)\n  integer,allocatable :: orderref(:),order(:)\n  real(wp) :: de\n  !>--- dummy structure data\n  integer,allocatable :: includeRMSD(:)\n  real(wp),allocatable :: c0(:,:),c1(:,:),cdum(:,:)\n  real(wp),allocatable :: c0h(:,:),c1h(:,:)\n  integer,allocatable  :: maskheavy(:)\n  integer,allocatable :: at0(:)\n  logical :: substruc\n  integer :: nat0\n  real(wp),allocatable :: rot(:,:)\n  real(wp) :: rotdum(3),bdum\n  !>--- RMSD data\n  real(sp),allocatable :: rmat(:) !SINGLE PRECISION\n  real(wp) :: rdum,dr,rdum2\n  real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:),ydum(:) !dummy tensors\n  integer(id) :: klong\n  integer(id) :: linr  !this is a function\n  integer(id),allocatable :: rmap1(:)\n  integer,allocatable :: rmap2(:)\n  logical :: l1,l2,l3\n  !>--- CRE comparison data\n  integer,allocatable :: double(:)\n  logical :: equalrotaniso !> this is a function\n  logical,allocatable :: mask(:)\n  real(wp) :: couthr\n  real(wp),allocatable :: enuc(:)\n  real(wp),allocatable :: ecoul(:)\n  real(wp) :: r\n  integer :: i,j,k,l,natnoh\n  logical :: heavy\n\n!>--- set parameters\n  call cregen_filldata1(env,ewin,rthr,ethr,bthr,athr,pthr,T,couthr)\n  if (env%entropic) enantio = .false.\n  heavy = env%heavyrmsd\n  substruc = (nat .ne. env%rednat .and. env%subRMSD)\n  if (substruc) then\n    nat0 = env%rednat\n    includeRMSD = env%includeRMSD\n  end if\n  allocate (rot(3,nall))\n\n!>--- get energies from the comment line\n  allocate (er(nall))\n  allocate (orderref(nall),order(nall))\n  do i = 1,nall\n    er(i) = grepenergy(comments(i))\n    orderref(i) = i\n  end do\n\n!>--- get dummy structure memory space\n  if (substruc) then\n    allocate (c0(3,nat0),c1(3,nat0),at0(nat0))\n  else\n    allocate (c0(3,nat),c1(3,nat),at0(nat))\n    at0 = at\n    nat0 = nat\n  end if\n\n!>--- transform the coordinates to CMA and get rot.constants\n  do i = 1,nall\n    call axis(nat,at,xyz(:,:,i)) !-- all coordinates to CMA\n    if (substruc) then\n      call maskedxyz(nat,nat0,xyz(:,:,i),c1,at,at0,includeRMSD)\n    else\n      c1(:,:) = xyz(:,:,i)\n    end if\n    call axis(nat0,at0,c1,rot(1:3,i),bdum)  !-- B0 in MHz\n  end do\n\n!>--- Calculate an artificial Coulomb energy used to compare structures\n!    !--- settings\n!    allocate(ecoul(nall), source=0.0_wp)\n!    allocate(rcov(94))\n!    call setrcov(rcov)\n!    allocate(bond(nat,nat),cn(nat), source=0.0_wp)\n!    allocate(cref(3,nat),source=0.0_wp)\n!    allocate(maskheavy(nat), source=0)\n!    call heavymask(nat,at,maskheavy)\n!    !maskheavy=1\n!    do i=1,nall\n!    cn=0.0_wp\n!    bond=0.0_wp\n!    cref(1:3,1:nat) = xyz(1:3,1:nat,i)/bohr\n!    call xcoord2(nat,at,cref,rcov,cn,1400.0_wp,bond)\n!    call calc_ecoul(nat,at,cref,cn,maskheavy,ecoul(i))\n!    if(i>1)then\n!       !courel =  abs(1.0-(ecoul(i)/ecoul(1)))\n!       courel =  abs(ecoul(1)-ecoul(i))\n!       write(*,'(i10,1x,2f16.8)')i,ecoul(i),courel\n!    else\n!      write(*,'(i10,1x,f16.8)')i,ecoul(i)\n!    endif\n!    enddo\n!    deallocate(maskheavy)\n!    deallocate(cref,cn,bond,rcov)\n\n!>--- RMSD part\n  allocate (double(nall),source=0)\n  !========================================================!\n  !>-- crucial point: rmat is huge. VERY huge, potentially.\n  !klong=nall\n  !klong=klong*(nall+1)\n  !klong=klong/2\n  !write(*,*) nall,klong\n\n  !>-- for large ensembles the size of rmat can be strongly reduced\n  !>   but this requires additional tracking and counting.\n  !>   It will pay off, however.\n  allocate (rmap1(nall),rmap2(nall))\n  klong = 0\n  do i = 1,nall\n    rmap1(i) = klong\n    l1 = .true.\n    do j = 1,i - 1\n      !ekcal(j) should always be smaller than ekcal(i) because i>j\n      de = (er(i) - er(j)) * autokcal\n      if (de .lt. ethr) then !>-- we only need RMSDs for structures close in energy\n        klong = klong + 1\n        if (l1) then\n          rmap2(i) = j\n          l1 = .false.\n        end if\n      end if\n    end do\n  end do\n\n  !>-- now klong is the size of rmat with only the minimum required RMSDs\n  !>   rmat itself can be single precision.\n  allocate (rmat(klong),source=0.0_sp)\n  allocate (gdum(3,3),Udum(3,3),xdum(3),ydum(3))\n  !>-- begin calculation of RMSDs\n  klong = 0\n  write (*,'(1x,a)') 'running RMSDs...'\n  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n  if (.not. substruc) then !regular case, all atoms included in RMSD\n    if (.not. heavy) then    !really, the regular case\n      do i = 1,nall\n        c0(1:3,1:nat) = xyz(1:3,1:nat,i)\n!$OMP PARALLEL PRIVATE ( j,klong,c1,xdum,ydum,Udum,gdum,rdum,rdum2,de) &\n!$OMP SHARED ( i,c0,rmat,nat,xyz,rmap1,rmap2,er,ethr,enantio)\n!$OMP DO\n        do j = 1,i - 1\n          de = (er(i) - er(j)) * autokcal\n          if (de .lt. ethr) then\n            c1(1:3,1:nat) = xyz(1:3,1:nat,j)\n            call rmsd(nat,c0,c1,0,Udum,xdum,ydum,rdum,.false.,gdum) ! all atoms\n            if (enantio) then  !also check for enantiomer by inverting a coordinate\n              c1(1,:) = -c1(1,:)\n              call rmsd(nat,c0,c1,0,Udum,xdum,ydum,rdum2,.false.,gdum) ! all atoms\n            else\n              rdum2 = rdum\n            end if\n            klong = linr(rmap1(i),rmap2(i),j)\n            rmat(klong) = real(min(rdum,rdum2),sp)\n          end if\n        end do\n!$OMP END DO\n!$OMP END PARALLEL\n      end do\n    else  !heavy atom case\n      natnoh = nat - counth(nat,at)\n      allocate (c0h(3,natnoh),c1h(3,natnoh),source=0.0_wp)\n      allocate (maskheavy(nat),source=0)\n      call heavymask(nat,at,maskheavy)\n      write (*,*) 'doing heavy atom rmsds with ',natnoh,' atoms'\n      do i = 1,nall\n        call maskedxyz2(nat,natnoh,xyz(:,:,i),c0h,maskheavy)\n!$OMP PARALLEL PRIVATE ( j,klong,c1h,xdum,ydum,Udum,gdum,rdum,rdum2,de) &\n!$OMP SHARED ( i,c0h,rmat,nat,xyz,rmap1,rmap2,er,ethr,enantio,maskheavy)\n!$OMP DO\n        do j = 1,i - 1\n          de = (er(i) - er(j)) * autokcal\n          if (de .lt. ethr) then\n            call maskedxyz2(nat,natnoh,xyz(:,:,j),c1h,maskheavy)\n            call rmsd(natnoh,c0h,c1h,0,Udum,xdum,ydum,rdum,.false.,gdum) ! all atoms\n            if (enantio) then  !also check for enantiomer by inverting a coordinate\n              c1h(1,:) = -c1h(1,:)\n              call rmsd(natnoh,c0h,c1h,0,Udum,xdum,ydum,rdum2,.false.,gdum) ! all atoms\n            else\n              rdum2 = rdum\n            end if\n            klong = linr(rmap1(i),rmap2(i),j)\n            rmat(klong) = real(min(rdum,rdum2),sp)\n          end if\n        end do\n!$OMP END DO\n!$OMP END PARALLEL\n      end do\n      deallocate (maskheavy,c1h,c0h)\n    end if\n    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n  else !substruc == .true., RMSDs only on a part of the structure\n    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n    do i = 1,nall\n      call maskedxyz2(nat,nat0,xyz(:,:,i),c0,includeRMSD)\n!$OMP PARALLEL PRIVATE ( j,klong,c1,xdum,ydum,Udum,gdum,rdum,rdum2,de) &\n!$OMP SHARED ( i,c0,rmat,nat,nat0,xyz,rmap1,rmap2,er,ethr,includeRMSD,enantio )\n!$OMP DO\n      do j = 1,i - 1\n        de = (er(i) - er(j)) * autokcal\n        if (de .lt. ethr) then\n          call maskedxyz2(nat,nat0,xyz(:,:,j),c1,includeRMSD)\n          call rmsd(nat0,c0,c1,0,Udum,xdum,ydum,rdum,.false.,gdum) ! all atoms\n          if (enantio) then  !also check for enantiomer by inverting a coordinate\n            c1(1,:) = -c1(1,:)\n            call rmsd(nat0,c0,c1,0,Udum,xdum,ydum,rdum2,.false.,gdum) ! all atoms\n          else\n            rdum2 = rdum\n          end if\n          klong = linr(rmap1(i),rmap2(i),j)\n          rmat(klong) = real(min(rdum,rdum2),sp)\n        end if\n      end do\n!$OMP END DO\n!$OMP END PARALLEL\n    end do\n  end if\n  write (*,'(1x,a)') 'done.'\n  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n!>-- Now, with the RMSDs and rotational constants we can kick out duplicates\n  do i = 1,nall\n    do j = 1,i - 1\n      !-- only check for structures in energy range\n      de = (er(i) - er(j)) * autokcal\n      if (de .lt. ethr) then\n        klong = linr(rmap1(i),rmap2(i),j)\n        dr = rmat(klong)\n      else\n        cycle\n      end if\n      !>-- very small RMSD --> same structure\n      if (dr .lt. rthr) then\n        double(i) = j !-- \"i\" is the same structure as \"j\"\n        !>-- slightly larger RMSD, but same rot. constants --> same structure\n      elseif (dr .lt. 2.0_wp * rthr) then\n        l1 = equalrotaniso(i,j,nall,rot,0.5d0 * bthr,env%bthrmax,env%bthrshift)\n        if (l1) then\n          double(i) = j  !>-- \"i\" is the same structure as \"j\"\n        end if\n      end if\n    end do\n    !>-- find the original reference. k is a dummy variable\n    call backtrack(double,i,k)\n  end do\n  deallocate (c0,c1,at0)\n  deallocate (ydum,xdum,Udum,gdum)\n  deallocate (rmat,rmap2,rmap1)\n\n  !>-- for ENSO write a file with duplicate info (if required)\n  call enso_duplicates(env,nall,double)\n\n!>-- count how many duplicates we have found\n  allocate (mask(nall))\n  mask(:) = double(:) .ne. 0\n  k = count(mask,1)\n  nallout = nall - k\n  deallocate (mask)\n  write (ch,*) 'number of doubles removed by rot/RMSD         :',k\n  write (ch,*) 'total number unique points considered further :',nallout\n!>-- sort structures, energies, rot const. and comments\n  j = 0\n  l = nall + 1\n  do i = 1,nall\n    if (double(i) .eq. 0) then\n      j = j + 1\n      orderref(i) = j\n    else\n      l = l - 1\n      orderref(i) = l\n    end if\n  end do\n  order = orderref\n  allocate (cdum(3,nat))\n  call xyzqsort(nat,nall,xyz,cdum,order,1,nall)\n  deallocate (cdum)\n  order = orderref\n  call maskqsort(er,1,nall,order)\n  order = orderref\n  call stringqsort(nall,comments,1,nall,order)\n  order = orderref\n  call matqsort(3,nall,rot,rotdum,1,nall,order)\n\n!>-- finally, determine conformer groups and their rotamers\n  allocate (c1(3,nat))\n  allocate (enuc(nallout))\n  do k = 1,nallout\n    c1(1:3,1:nat) = xyz(1:3,1:nat,k)\n    enuc(k) = 0.0_wp\n    do i = 1,nat - 1\n      do j = i + 1,nat\n        r = (c1(1,i) - c1(1,j))**2 &\n    &    + (c1(2,i) - c1(2,j))**2 &\n    &    + (c1(3,i) - c1(3,j))**2 + 1.d-12\n        enuc(k) = enuc(k) + at(i) * at(j) / r\n      end do\n    end do\n  end do\n!>-- check energy, rot. const. and nuclear permutation\n  double = 0 !-- re-use \"double\"\n  SORTI: do i = 1,nallout\n    SORTJ: do j = 1,i - 1\n      !-- energy difference\n      de = (er(i) - er(j)) * autokcal\n      l3 = double(j) .eq. 0\n      if (.not. l3) cycle\n      if (abs(de) .lt. ethr) then\n        !-- rotational constant difference\n        l1 = equalrotaniso(i,j,nall,rot,bthr,env%bthrmax,env%bthrshift)\n        !-- nuclear permutation\n        l2 = 2.0d0 * abs(enuc(i) - enuc(j)) / (enuc(i) + enuc(j)) .lt. 1.d-3\n        if (l1 .and. l2 .and. l3) then\n          double(i) = j   !-- \"i\" is a rotamer of \"j\"\n          call backtrack(double,i,k)\n          cycle SORTI\n        end if\n      end if\n    end do SORTJ\n  end do SORTI\n!>-- assign conformer groups\n  k = 0\n  group = 0\n  do i = 1,nallout\n    if (double(i) .eq. 0) then\n      k = k + 1\n      group(i) = k\n    else\n      j = double(i)\n      group(i) = group(j)\n    end if\n  end do\n  group(0) = k !-- total number of groups\n\n  deallocate (enuc,c1,double)\n  deallocate (order,orderref)\n  if (allocated(ecoul)) deallocate (ecoul)\n  deallocate (er)\n  deallocate (rot)\n  return\ncontains\n  function counth(nat,at) result(nh)\n    implicit none\n    integer :: nat\n    integer :: at(nat)\n    integer :: nh,i\n    nh = 0\n    do i = 1,nat\n      if (at(i) == 1) nh = nh + 1\n    end do\n    return\n  end function counth\n  subroutine heavymask(nat,at,mask)\n    implicit none\n    integer :: nat\n    integer :: at(nat)\n    integer :: mask(nat)\n    integer :: i\n    mask = 0\n    do i = 1,nat\n      if (at(i) .ne. 1) mask(i) = 1\n    end do\n    return\n  end subroutine heavymask\nend subroutine cregen_CRE\n!======================================================!\n! subroutine calc_ecoul\n! calculate a (artificial) coulomb energy for a given\n! structure. Some atoms can be ignored via a mask\n!======================================================!\nsubroutine calc_ecoul(nat,at,xyz,cn,atommask,ecoulomb)\n  use crest_parameters\n  implicit none\n  integer :: nat\n  integer :: at(nat)\n  real(wp) :: xyz(3,nat) !should be in Bohrs\n  real(wp) :: cn(nat)\n  integer :: atommask(nat) !contains 1 or 0\n  real(wp) :: ecoulomb\n  integer :: i,j\n  real(wp) :: cnexp,rexp,natexp\n  real(wp) :: r,dum,zi,zj\n  ecoulomb = 0.0_wp\n  !cn=1.0_wp  !comment in to ignore cn\n  cnexp = 1.0_wp\n  rexp = 1.0_wp\n  natexp = 3.5_wp\n  do i = 1,nat\n    if (atommask(i) == 0) cycle\n    zi = ((cn(i)**cnexp) * float(at(i)))\n    do j = 1,i - 1\n      if (atommask(j) == 0) cycle\n      r = (xyz(1,i) - xyz(1,j))**2 &\n      &  + (xyz(2,i) - xyz(2,j))**2 &\n      &  + (xyz(3,i) - xyz(3,j))**2\n      r = sqrt(r)\n      zj = ((cn(j)**cnexp) * float(at(j)))\n      dum = (zi * zj)\n      dum = dum / (r**rexp)\n      !dum = dum * exp( -0.5_wp * (r-5)**2)\n      ecoulomb = ecoulomb + dum\n    end do\n  end do\n  !-- normalization to the number of included(!) atoms\n  dum = float(sum(atommask))\n  ecoulomb = ecoulomb / (dum**natexp)\n  ecoulomb = ecoulomb * 627.5095\n  return\nend subroutine calc_ecoul\n\n!============================================================!\n! subroutine cregen_CRE_2\n! an anlternate version to the above routine to be used\n! with an unsorted (small) ensemble to determine\n! duplicate groups, but nothing is sorted!\n! On Input: ch - printout channel\n!           nat - number of atoms\n!           nall - number of structure in ensemble\n!           at   - atom types\n!           xyz  - Cartesian coordinates\n!           comments - commentary lines containing the energy\n! On Output: nallout - new total number of structures\n!            group   - to which group every structure belongs\n!============================================================!\nsubroutine cregen_CRE_2(ch,env,nat,nall,at,xyz,comments,nallout,group)\n  use crest_parameters, id => dp \n  use crest_data\n  use strucrd\n  use ls_rmsd\n  use axis_module\n  implicit none\n  type(systemdata) :: env\n  integer,intent(in) :: ch\n  integer,intent(in) :: nat\n  integer,intent(in) :: nall\n  integer,intent(in) :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat,nall)\n  integer,intent(inout) :: group(0:nall)\n  character(len=*) :: comments(nall)\n  integer :: nallout\n  logical :: enantio = .true.   !> check for enantiomers?\n\n  !>--- float data\n  real(wp) :: ewin,rthr,bthr,pthr,ethr,athr,T\n  !>--- energy data\n  real(wp),allocatable :: er(:)\n  integer,allocatable :: orderref(:),order(:)\n  real(wp) :: de\n  !>--- dummy structure data\n  real(wp),allocatable :: c0(:,:),c1(:,:)\n  real(wp),allocatable :: c0h(:,:),c1h(:,:)\n  integer,allocatable  :: maskheavy(:)\n  integer,allocatable :: at0(:)\n  integer :: nat0\n  real(wp),allocatable :: rot(:,:)\n  real(wp) :: bdum\n  !>--- RMSD data\n  real(sp),allocatable :: rmat(:) !> SINGLE PRECISION\n  real(wp) :: rdum,dr,rdum2\n  real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:),ydum(:) !> dummy tensors\n  integer(id) :: klong\n  integer(id) :: lina  !> this is a function\n  integer(id),allocatable :: rmap1(:)\n  integer,allocatable :: rmap2(:)\n  logical :: l1,l2,l3\n  !>--- CRE comparison data\n  integer,allocatable :: double(:)\n  logical :: equalrotaniso !> this is a function\n  logical,allocatable :: mask(:)\n  real(wp),allocatable :: enuc(:)\n  real(wp) :: couthr\n  real(wp),allocatable :: ecoul(:)\n  real(wp) :: r\n  integer :: i,j,k,natnoh\n  logical :: heavy\n\n!>--- set parameters\n  call cregen_filldata1(env,ewin,rthr,ethr,bthr,athr,pthr,T,couthr)\n  if (env%entropic) enantio = .false.\n  heavy = env%heavyrmsd\n  allocate (rot(3,nall))\n\n!>--- get energies from the comment line\n  allocate (er(nall))\n  allocate (orderref(nall),order(nall))\n  do i = 1,nall\n    er(i) = grepenergy(comments(i))\n    orderref(i) = i\n  end do\n\n!--- get dummy structure memory space\n  allocate (c0(3,nat),c1(3,nat),at0(nat))\n  at0 = at\n  nat0 = nat\n\n!--- transform the coordinates to CMA and get rot.constants\n  do i = 1,nall\n    call axis(nat,at,xyz(:,:,i)) !-- all coordinates to CMA\n    c1(:,:) = xyz(:,:,i)\n    call axis(nat0,at0,c1,rot(1:3,i),bdum)  !-- B0 in MHz\n  end do\n\n!--- Calculate an artificial Coulomb energy used to compare structures\n  !--- settings\n!    allocate(ecoul(nall), source=0.0_wp)\n!    allocate(rcov(94))\n!    call setrcov(rcov)\n!    allocate(bond(nat,nat),cn(nat), source=0.0_wp)\n!    allocate(cref(3,nat),source=0.0_wp)\n!    allocate(maskheavy(nat), source=0)\n!    call heavymask(nat,at,maskheavy)\n!    do i=1,nall\n!    cn=0.0_wp\n!    bond=0.0_wp\n!    cref(1:3,1:nat) = xyz(1:3,1:nat,i)/bohr\n!    call xcoord2(nat,at,cref,rcov,cn,400.0_wp,bond)\n!    call calc_ecoul(nat,at,cref,cn,maskheavy,ecoul(i))\n!    enddo\n!    deallocate(maskheavy)\n!    deallocate(cref,cn,bond,rcov)\n\n!--- RMSD part\n  allocate (double(nall),source=0)\n  !========================================================!\n  !-- crucial point: rmat is huge. VERY huge, potentially.\n  !                  use only for small ensembles!\n  klong = nall\n  klong = klong * (nall + 1)\n  klong = klong / 2\n  !write(*,*) nall,klong\n  allocate (rmat(klong),source=0.0_sp)\n  allocate (gdum(3,3),Udum(3,3),xdum(3),ydum(3))\n  !-- begin calculation of RMSDs\n  klong = 0\n  write (*,'(1x,a)') 'running RMSDs...'\n  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n  if (.not. heavy) then    !really, the regular case\n    do i = 1,nall\n      c0(1:3,1:nat) = xyz(1:3,1:nat,i)\n!$OMP PARALLEL PRIVATE ( j,klong,c1,xdum,ydum,Udum,gdum,rdum,rdum2,de) &\n!$OMP SHARED ( i,c0,rmat,nat,xyz,rmap1,rmap2,er,ethr,enantio)\n!$OMP DO\n      do j = 1,i - 1\n        de = (er(i) - er(j)) * autokcal\n        if (de .lt. ethr) then\n          c1(1:3,1:nat) = xyz(1:3,1:nat,j)\n          call rmsd(nat,c0,c1,0,Udum,xdum,ydum,rdum,.false.,gdum) ! all atoms\n          if (enantio) then  !also check for enantiomer by inverting a coordinate\n            c1(1,:) = -c1(1,:)\n            call rmsd(nat,c0,c1,0,Udum,xdum,ydum,rdum2,.false.,gdum) ! all atoms\n          else\n            rdum2 = rdum\n          end if\n          !klong=linr(rmap1(i),rmap2(i),j)\n          klong = lina(i,j)\n          rmat(klong) = real(min(rdum,rdum2),sp)\n        end if\n      end do\n!$OMP END DO\n!$OMP END PARALLEL\n    end do\n  else  !heavy atom case\n    natnoh = nat - counth(nat,at)\n    allocate (c0h(3,natnoh),c1h(3,natnoh),source=0.0_wp)\n    allocate (maskheavy(nat),source=0)\n    call heavymask(nat,at,maskheavy)\n    write (*,*) 'doing heavy atom rmsds with ',natnoh,' atoms'\n    do i = 1,nall\n      call maskedxyz2(nat,natnoh,xyz(:,:,i),c0h,maskheavy)\n!$OMP PARALLEL PRIVATE ( j,klong,c1h,xdum,ydum,Udum,gdum,rdum,rdum2,de) &\n!$OMP SHARED ( i,c0h,rmat,nat,xyz,rmap1,rmap2,er,ethr,enantio,maskheavy)\n!$OMP DO\n      do j = 1,i - 1\n        de = (er(i) - er(j)) * autokcal\n        if (de .lt. ethr) then\n          call maskedxyz2(nat,natnoh,xyz(:,:,j),c1h,maskheavy)\n          call rmsd(natnoh,c0h,c1h,0,Udum,xdum,ydum,rdum,.false.,gdum) ! all atoms\n          if (enantio) then  !also check for enantiomer by inverting a coordinate\n            c1h(1,:) = -c1h(1,:)\n            call rmsd(natnoh,c0h,c1h,0,Udum,xdum,ydum,rdum2,.false.,gdum) ! all atoms\n          else\n            rdum2 = rdum\n          end if\n          !klong=linr(rmap1(i),rmap2(i),j)\n          klong = lina(i,j)\n          rmat(klong) = real(min(rdum,rdum2),sp)\n        end if\n      end do\n!$OMP END DO\n!$OMP END PARALLEL\n    end do\n    deallocate (maskheavy,c1h,c0h)\n  end if\n  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n  write (*,'(1x,a)') 'done.'\n  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!\n!-- Now, with the RMSDs and rotational constants we can kick out duplicates\n  do i = 1,nall\n    do j = 1,i - 1\n      !-- only check for structures in energy range\n      de = (er(i) - er(j)) * autokcal\n      if (de .lt. ethr) then\n        !klong= linr(rmap1(i),rmap2(i),j)\n        klong = lina(i,j)\n        dr = rmat(klong)\n      else\n        cycle\n      end if\n      !-- very small RMSD --> same structure\n      if (dr .lt. rthr) then\n        double(i) = j !-- \"i\" is the same structure as \"j\"\n        !-- slightly larger RMSD, but same rot. constants --> same structure\n      elseif (dr .lt. 2.0_wp * rthr) then\n        l1 = equalrotaniso(i,j,nall,rot,0.5d0 * bthr,env%bthrmax,env%bthrshift)\n        if (l1) then\n          double(i) = j  !-- \"i\" is the same structure as \"j\"\n        end if\n      end if\n    end do\n    !-- find the original reference. k is a dummy variable\n    call backtrack(double,i,k)\n  end do\n  deallocate (c0,c1,at0)\n  deallocate (ydum,xdum,Udum,gdum)\n  deallocate (rmat)\n\n  !-- for ENSO write a file with duplicate info (if required)\n  call enso_duplicates(env,nall,double)\n\n!-- count how many duplicates we have found\n  allocate (mask(nall))\n  mask(:) = double(:) .ne. 0\n  k = count(mask,1)\n  nallout = nall - k\n  deallocate (mask)\n  write (ch,'(1x,a,i10)') 'number of doubles removed by rot/RMSD:',k\n  !write(ch,*)'total number unique points remaining :',nallout\n\n!-- finally, determine conformer groups and their rotamers\n  allocate (c1(3,nat))\n  allocate (enuc(nall))\n  do k = 1,nall\n    c1(1:3,1:nat) = xyz(1:3,1:nat,k)\n    enuc(k) = 0.0_wp\n    do i = 1,nat - 1\n      do j = i + 1,nat\n        r = (c1(1,i) - c1(1,j))**2 &\n    &    + (c1(2,i) - c1(2,j))**2 &\n    &    + (c1(3,i) - c1(3,j))**2 + 1.d-12\n        enuc(k) = enuc(k) + at(i) * at(j) / r\n      end do\n    end do\n  end do\n!-- check energy, rot. const. and nuclear permutation\n  !double=0 !-- re-use \"double\"  !in this version we do not overwrite\n  SORTI: do i = 1,nall\n    SORTJ: do j = 1,i - 1\n      !-- energy difference\n      de = (er(i) - er(j)) * autokcal\n      l3 = double(j) .eq. 0\n      if (.not. l3) cycle\n      if (abs(de) .lt. ethr) then\n        !-- rotational constant difference\n        l1 = equalrotaniso(i,j,nall,rot,bthr,env%bthrmax,env%bthrshift)\n        !-- nuclear permutation\n        l2 = 2.0d0 * abs(enuc(i) - enuc(j)) / (enuc(i) + enuc(j)) .lt. 1.d-3\n        if (l1 .and. l2 .and. l3) then\n          double(i) = j   !-- \"i\" is a rotamer of \"j\"\n          call backtrack(double,i,k)\n          cycle SORTI\n        end if\n      end if\n    end do SORTJ\n  end do SORTI\n!-- assign conformer groups\n  k = 0\n  group = 0\n  do i = 1,nall\n    if (double(i) .eq. 0) then\n      k = k + 1\n      group(i) = k\n    else\n      j = double(i)\n      group(i) = group(j)\n    end if\n  end do\n  group(0) = k !-- total number of groups\n  write (ch,'(1x,a,i10)') 'number of removed rotamers           :', (nallout - k)\n  nallout = k\n  write (ch,'(1x,a,i10)') 'total number unique points remaining :',nallout\n\n  deallocate (enuc,c1,double)\n  deallocate (order,orderref)\n  if (allocated(ecoul)) deallocate (ecoul)\n  deallocate (er)\n  deallocate (rot)\n  return\ncontains\n  function counth(nat,at) result(nh)\n    implicit none\n    integer :: nat\n    integer :: at(nat)\n    integer :: nh,i\n    nh = 0\n    do i = 1,nat\n      if (at(i) == 1) nh = nh + 1\n    end do\n    return\n  end function counth\n  subroutine heavymask(nat,at,mask)\n    implicit none\n    integer :: nat\n    integer :: at(nat)\n    integer :: mask(nat)\n    integer :: i\n    mask = 0\n    do i = 1,nat\n      if (at(i) .ne. 1) mask(i) = 1\n    end do\n    return\n  end subroutine heavymask\nend subroutine cregen_CRE_2\n\n!============================================================!\n! subroutine cregen_EQUAL\n! subroutine for the generation of nuclear equivalencies\n! On Input: ch - printout channel\n!           nat - number of atoms\n!           nall - number of structure in ensemble\n!           at   - atom types\n!           xyz  - Cartesian coordinates\n!           group - to which group does every strucutre belong\n!           athr  - threshold for equivalency comparison\n!           rotfil - wirte anmr_rotamer file?\n! On Output: resorted xyz and comments\n!============================================================!\nsubroutine cregen_EQUAL(ch,nat,nall,at,xyz,group,athr,rotfil)\n  use crest_parameters, id => dp\n  use crest_data\n  use strucrd\n  implicit none\n  integer,intent(in) :: ch\n  integer,intent(in) :: nat\n  integer,intent(in) :: nall\n  integer,intent(in) :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat,nall)\n  integer,intent(inout) :: group(0:nall)\n  real(wp),intent(in) :: athr\n  logical,intent(in) :: rotfil\n  real(wp),allocatable :: cdum(:,:)\n  integer :: ng,n\n  integer :: i,j,k,l\n  integer :: lin\n  logical :: ex\n\n  !--- arrays and variable for the analysis\n  integer :: gmax\n  integer,allocatable :: glist(:,:)\n  integer :: current\n  real(wp) :: dum\n  real(wp) :: shortest_distance\n  integer,allocatable  :: equiv(:,:,:)\n  integer,allocatable  :: pair(:),pre(:),nb(:,:)\n  logical,allocatable  :: vis(:)\n  real(wp),allocatable :: metric(:,:)\n  real(wp),allocatable :: dist(:,:,:)\n  integer,allocatable  :: relat(:,:)\n  real(wp),allocatable :: tmp2(:)\n  integer :: m,m1,m2,s1,s2,iat,j1,k2\n\n  !-- further NMR-mode related data\n  integer,allocatable :: nmract(:)\n  integer,allocatable :: elist(:,:),flist(:,:)\n  integer,allocatable :: jnd(:)\n  real(wp),allocatable :: sd(:,:),jfake(:),cn(:)\n  real(wp),allocatable :: rcov(:)\n\n  character(len=:),allocatable :: atmp\n  integer :: ig,ir,irr,nr\n\n!--- variable declarations\n  n = nat       !other variable name for number of atoms\n  ng = group(0) !number of different groups (conformers)\n  gmax = 0        !max number of\n  do i = 1,ng\n    k = 0\n    do j = 1,nall\n      if (group(j) == i) k = k + 1\n    end do\n    if (k .gt. gmax) gmax = k\n  end do\n  allocate (glist(0:gmax,ng),source=0)\n  do i = 1,ng\n    k = 0\n    do j = 1,nall\n      if (group(j) == i) then\n        k = k + 1\n        glist(k,i) = j !the k-th member of group i is structure j\n      end if\n    end do\n    glist(0,i) = k !number of members in group i\n  end do\n\n!---distance neighbor list\n  allocate (cdum(3,nat))\n\n!--- set up the \"pair\" array --> how many bonds are between two nuclei?\n  allocate (pair(n * (n + 1) / 2),metric(n,n),vis(n),pre(n),nb(200,n))\n  cdum(1:3,1:n) = xyz(1:3,1:n,1) / bohr\n  call neighdist(n,at,cdum,nb,metric)\n  k = 0\n  pair = 0\n  do i = 1,n - 1\n    do j = i + 1,n\n!---the shortest bond path\n      current = j\n      dum = shortest_distance(n,i,j,nb,metric,vis,pre)\n      k = 0\n      do while (pre(current) /= 0)\n        current = pre(current)\n        k = k + 1\n      end do ! End loop: while precessor(current) /= 0\n      pair(lin(j,i)) = k  ! # of bonds between i and j\n    end do\n  end do\n  deallocate (nb,pre,vis,metric)\n\n  allocate (tmp2(n),relat(0:n,n))\n  allocate (equiv(0:n,n,0:nall),dist(n,n,nall))\n  equiv = 0\n!-- (costly) symmetry analyis of all rotamers for NMR. this is complicated stuff also\n!   and the end of the program where this is completed...\n  do i = 1,nall\n    call distance(n,xyz(1,1,i),dist(1,1,i))   ! distance matrix\n    do j = 1,n\n      do k = 1,n\n        tmp2(k) = dist(k,j,i) * dble(at(k))  ! the distance of j to all atoms * Z to distinguish\n      end do\n      call qqsort(tmp2,1,n)\n      dist(1:n,j,i) = tmp2(1:n)\n    end do\n  end do\n  write (ch,*) 'compare nuclear equivalencies ...'\n  do i = 1,ng\n    m = glist(0,i)\n    if (m .lt. 2) cycle                      ! det equivalent atoms in each group\n    relat = 0\n    do m1 = 1,m\n!$OMP PARALLEL PRIVATE ( m2, s1, s2 ) SHARED ( relat )\n!$OMP DO\n      do m2 = 1,m1 - 1                       ! compare all members\n        s1 = glist(m1,i)                  ! struc 1\n        s2 = glist(m2,i)                  ! struc 2\n        call compare(n,nall,s1,s2,dist,athr,relat) ! athr is distance vector equivalence threshold\n      end do\n!$OMP END DO\n!$OMP END PARALLEL\n    end do\n    equiv(0:n,1:n,i) = relat(0:n,1:n)\n  end do\n  deallocate (dist)\n!-- symmetrize result i.e. if iat is in list of jat, jat must be in list of iat\n!   done again at the end of this part\n  do i = 1,ng\n    do j1 = 1,n\n      m1 = equiv(0,j1,i)\n      do k = 1,m1\n        iat = equiv(k,j1,i)\n!--            is atom j1 in the list of atom iat?\n        ex = .false.\n        m2 = equiv(0,iat,i)\n        do k2 = 1,m2\n          if (j1 .eq. equiv(k2,iat,i)) ex = .true.\n        end do\n        if (.not. ex) then\n          equiv(0,iat,i) = equiv(0,iat,i) + 1\n          equiv(equiv(0,iat,i),iat,i) = j1\n        end if\n      end do\n    end do\n  end do\n\n!-- inlcude equivalence info from the other conformers as well i.e.\n!   assume that all conformers have the same chemical equivalencies\n!   the result is put into equiv(:,:,0)\n  equiv(0:n,1:n,0) = equiv(0:n,1:n,1)\n  ILOOP: do i = 2,ng\n    JLOOP: do j = 1,n\n      m2 = equiv(0,j,0)      ! end of list of lowest\n      MLOOP: do m = 1,equiv(0,j,i)  ! list of higher\n        k = equiv(m,j,i)    ! in the one in the higher list\n        M1LOOP: do m1 = 1,m2\n          if (equiv(m1,j,0) .eq. k) then !already there?\n!                    goto 19\n            cycle MLOOP\n          end if\n        end do M1LOOP\n        equiv(0,j,0) = equiv(0,j,0) + 1 ! append\n        equiv(equiv(0,j,0),j,0) = k\n! 19            continue\n      end do MLOOP\n    end do JLOOP\n  end do ILOOP\n\n!--- NMR part and writeout\n  !get NMR-active nuclei\n  allocate (nmract(86))\n  call cregen_nmract(ch,nmract)\n\n  allocate (elist(n,n),flist(n,n))\n  ig = 0\n  atmp = 'anmr_nucinfo'\n  open (unit=3,file=atmp)\n  write (ch,'(''::::::::::: conformer group all :::::::::::'')')\n  write (3,*) n\n!cccccccccccccccccc\n!c chem eq. first\n!cccccccccccccccccc\n  elist = 0\n  do i = 1,n\n    m = equiv(0,i,ig)\n    do k = 1,m\n      l = equiv(k,i,ig)\n      elist(l,i) = 1\n    end do\n    elist(i,i) = 1\n  end do\n  do i = 1,n\n    do j = 1,equiv(0,i,ig)\n      k = equiv(j,i,ig)\n      elist(1:n,k) = elist(1:n,k) + elist(1:n,i)\n    end do\n  end do\n!---  prepare write out\n  do i = 1,n\n    k = 1\n    equiv(1,i,ig) = i\n    elist(i,i) = 0\n    do j = 1,n\n      if (elist(j,i) .ne. 0) then\n        k = k + 1\n        equiv(k,i,ig) = j\n      end if\n    end do\n    equiv(0,i,ig) = k\n  end do\n  write (ch,*) 'chemical equivalencies (mag.active nuclei):'\n\n  allocate (jnd(n))\n  jnd = 1\n  do j = 1,n\n    m = equiv(0,j,ig)\n    write (3,'(3x,i0,3x,i0)') j,m\n    do l = 1,m\n      if (l .ne. m) then\n        write (3,'(1x,i0)',advance='no') equiv(l,j,ig)  ! include the atom ie if there are no equiv.\n      else\n        write (3,'(1x,i0)',advance='yes') equiv(l,j,ig)\n      end if\n    end do\n    if (nmract(at(j)) .eq. 0) cycle\n    if (m .gt. 1 .and. jnd(j) .eq. 1) then  ! just print\n      write (ch,'(''reference atom'',i4,'' # :'',i2)') equiv(1,j,ig),m\n      do k = 1,m\n        jnd(equiv(k,j,ig)) = 0\n      end do\n    end if\n  end do\n!cccccccccccccccccc\n!c mag eq.\n!cccccccccccccccccc\n!c make a check list of atoms for the mag. eq.\n  elist = 0\n  flist = 1\n  do i = 1,n\n    m = equiv(0,i,ig)        ! the following lines fill the equiv list\n    do k = 1,m\n      l = equiv(k,i,ig)\n      elist(l,i) = 1\n    end do\n    elist(i,i) = 1\n  end do\n  flist = elist\n\n  do i = 1,n\n    m = equiv(0,i,ig)\n    do k = 1,m\n      l = equiv(k,i,ig)\n      if (l .eq. i) cycle\n      do j = 1,n\n        if (flist(j,i) .eq. 1 .or. nmract(at(j)) .eq. 0) cycle   ! don't check non-magnetic nuclei\n!c              write(*,*) l,j,pair(lin(i,j)),pair(lin(l,j))      ! and chem. equiv. ones (ie in the same\n        if (pair(lin(i,j)) .ne. pair(lin(l,j))) elist(l,i) = 0 ! group\n      end do\n    end do\n  end do\n!---  symmetrize\n  do i = 1,n\n    k = 1\n    equiv(1,i,ig) = i\n    elist(i,i) = 0\n    do j = 1,n\n      if (elist(j,i) .ne. 0) then\n        k = k + 1\n        equiv(k,i,ig) = j\n      end if\n    end do\n    equiv(0,i,ig) = k\n  end do\n  do i = 1,n\n    do j = 1,equiv(0,i,ig)\n      k = equiv(j,i,ig)\n      elist(1:n,k) = elist(1:n,k) + elist(1:n,i)\n    end do\n  end do\n!---  prepare write out\n  do i = 1,n\n    k = 1\n    equiv(1,i,ig) = i\n    elist(i,i) = 0\n    do j = 1,n\n      if (elist(j,i) .ne. 0) then\n        k = k + 1\n        equiv(k,i,ig) = j\n      end if\n    end do\n!old     equiv(0,i,ig)=k\n    if (k .gt. 2) then\n      equiv(0,i,ig) = k    ! CH3 etc\n    else\n      equiv(0,i,ig) = 1    ! this makes CH2-CH2 not mag. equiv. !\n    end if\n  end do\n  jnd = 1\n  write (ch,*) 'magnetic equivalencies:'\n  do j = 1,n\n    m = equiv(0,j,ig)\n    write (3,*) j,m\n    write (3,'(20i5)') (equiv(l,j,ig),l=1,m)  ! include the atom ie if there are no equiv.\n    if (nmract(at(j)) .eq. 0) cycle\n    if (m .gt. 1 .and. jnd(j) .eq. 1) then  ! just print\n      write (ch,'(''reference atom'',i4,'' # :'',i2)') equiv(1,j,ig),m\n      do k = 1,m\n        jnd(equiv(k,j,ig)) = 0\n      end do\n    end if\n  end do\n  close (3)\n\n!ccccccccccccccccccccc\n!c J averaging matrix\n!ccccccccccccccccccccc\n  if (rotfil) then\n    allocate (jfake(n * (n + 1) / 2),sd(n,n),cn(n))\n    allocate (rcov(94))\n    call setrcov(rcov)\n    atmp = 'anmr_rotamer'\n    open (unit=112,file=atmp,form='unformatted')\n    !open(unit=112,file=fname)\n    write (112) ng\n    jfake = 0\n    do ig = 1,ng     ! all conf groups\n      nr = glist(0,ig) ! how many rotamers?\n      write (112) nr\n      do ir = 1,nr\n        irr = glist(ir,ig)\n        call distance(n,xyz(1,1,irr),sd)   ! distance matrix\n        cdum(1:3,1:n) = xyz(1:3,1:n,irr)\n        call ncoord(n,rcov,at,cdum,cn,500.0d0)\n        do i = 1,n - 1\n          do j = i + 1,n\n            jfake(lin(j,i)) = cn(i) * cn(j) * sqrt(dble(at(i) * at(j))) &\n       &    / (dble(pair(lin(j,i))) * sd(j,i)**5) ! the approx. \"J\" is topologically equivalent to J\n            ! R^3 was wrong in one case because Hs were artificially paired\n            ! R^5 seems to be save\n          end do\n        end do\n        write (112) jfake(1:n * (n + 1) / 2)        ! read by anmr\n      end do\n    end do\n    close (112)\n    deallocate (rcov,cn)\n    deallocate (sd,jfake)\n  end if\n\n  if (allocated(jnd)) deallocate (jnd)\n  if (allocated(elist)) deallocate (elist)\n  if (allocated(flist)) deallocate (flist)\n  if (allocated(equiv)) deallocate (equiv)\n  if (allocated(dist)) deallocate (dist)\n  if (allocated(relat)) deallocate (relat)\n  if (allocated(tmp2)) deallocate (tmp2)\n  if (allocated(pair)) deallocate (pair)\n  if (allocated(glist)) deallocate (glist)\n\n  return\nend subroutine cregen_EQUAL\n\n!-- util to fill nmract array\nsubroutine cregen_nmract(ch,nmract)\n  use crest_parameters\n  implicit none\n  integer :: nmract(86)\n  character(len=:),allocatable :: atmp\n  logical :: fail\n  integer :: io,i\n  real(wp) :: xx(10)\n  integer :: ch,ich2\n\n  nmract = 0 !reset\n  !--- get NMR active nuclei\n  atmp = '.anmrrc'  ! <--- name of the .anmrrc written by ENSO\n  call getanmrrc(atmp,fail)\n  if (fail) then  !--- there is no .anmrrc from ENSO\n    !write(ch,*)'NMR mode.'\n    nmract = 0       ! all nuclei inactive\n    nmract(1) = 1  ! H active\n    !nmract(6) = 1  ! C active\n    nmract(9) = 1  ! F active\n    nmract(15) = 1  ! P active\n  else          !--- there IS a .anmrrc, and it is used.\n    write (ch,*) 'NMR mode. Reading <',trim(atmp),'> for atomic NMR data'\n    open (newunit=ich2,file=atmp)\n    read (ich2,'(a)') atmp\n    read (ich2,'(a)') atmp\n    if (index(atmp,'ENSO') .ne. 0) then\n      read (ich2,'(a)') atmp\n    end if\n    do\n      read (ich2,*,iostat=io) i,xx(1:2),nmract(i)\n      if (io < 0) exit\n    end do\n    close (ich2)\n  end if\n\n  return\nend subroutine cregen_nmract\n\n!============================================================!\n! subroutine cregen_repairorder\n! resort the ensemble to have groups grouped together\n! (can be important for small energy diff. between conformers)\n! On Input: ch - printout channel\n!           nat - number of atoms\n!           nall - number of structure in ensemble\n!           xyz  - Cartesian coordinates\n!           comments - commentary lines containing the energy\n!           group - to which group does every strucutre belong\n! On Output: resorted xyz and comments\n!============================================================!\nsubroutine cregen_repairorder(nat,nall,xyz,comments,group)\n  use crest_parameters, id => dp \n  use crest_data\n  use strucrd\n  implicit none\n  integer,intent(in) :: nat\n  integer,intent(in) :: nall\n  real(wp),intent(inout) :: xyz(3,nat,nall)\n  integer,intent(inout) :: group(0:nall)\n  character(len=*) :: comments(nall)\n  real(wp),allocatable :: cdum(:,:)\n  integer,allocatable :: order(:),orderref(:)\n  character(len=128) :: btmp\n  real(wp) :: edum\n  logical :: ttag\n  integer,allocatable :: timetag(:)\n  integer :: ng,tmax\n  integer :: i,j,k,l\n\n  !-- check if timetag info is present?\n  ttag = .false.\n  !if(env%entropic)then\n  !  call getorigin(comments(1),atmp)\n  !  if(atmp(1:1)=='t') then\n  !   ttag=.true.\n  !   allocate(timetag(nall))\n  !   do i=1,nall\n  !     call getorigin(comments(i),atmp)\n  !     if(atmp(1:1)=='t')then !should work only with timetag flag\n  !      atmp=atmp(2:) !cut the \"t\"\n  !      read(atmp,*)timetag(i)\n  !     else\n  !      timetag(i)=1\n  !     endif\n  !   enddo\n  !   tmax=maxval(timetag,1)\n  !  endif\n  !endif\n\n  ng = group(0)\n  allocate (order(nall),orderref(nall))\n  !-- determine new order\n  k = 0\n  if (ttag) then\n    do i = 1,ng\n      do l = 1,tmax  !-- with timetag info\n        do j = 1,nall\n          if (group(j) .eq. i .and. timetag(j) .eq. l) then\n            k = k + 1\n            orderref(k) = j\n            order(k) = i\n          end if\n        end do\n      end do\n    end do\n  else\n    do i = 1,ng\n      do j = 1,nall !-- without timetag info\n        if (group(j) .eq. i) then\n          k = k + 1\n          orderref(k) = j\n          order(k) = i\n        end if\n      end do\n    end do\n  end if\n\n  !-- sort xyz and comments\n  group(1:nall) = order(1:nall)\n  order = orderref\n  allocate (cdum(3,nat))\n  call xyzqsort(nat,nall,xyz,cdum,order,1,nall)\n  deallocate (cdum)\n  order = orderref\n  call stringqsort(nall,comments,1,nall,order)\n  if (ttag) then\n    edum = grepenergy(comments(1))\n    write (btmp,*) edum,'!t1'\n    comments(1) = trim(btmp)\n  end if\n\n  deallocate (orderref,order)\n  if (allocated(timetag)) deallocate (timetag)\n  return\nend subroutine cregen_repairorder\n\n!============================================================!\n! recursive subroutine xyzqsort\n! A quicksort derivative for sorting an ensemble.\n! On Input: nat  - number of atoms\n!           nall - number of structures\n!           xyz  - the ensemble ( xyz(3,nat,nall) )\n!           c0   - a dummy coord field for sorting\n!           ord  - order of the ensemble ( ord(nall) )\n!           first - lower limit of sorting (nall dimension)\n!           last  - upperl limit of sorting (nall dimension)\n!============================================================!\nrecursive subroutine xyzqsort(nat,nall,xyz,c0,ord,first,last)\n  use crest_parameters\n  implicit none\n  integer :: nat,nall\n  real(wp) :: xyz(3,nat,nall)\n  real(wp) :: c0(3,nat)\n  integer :: ord(nall)\n  integer :: first,last\n  integer :: x,t\n  integer :: i,j\n  x = ord((first + last) / 2)\n  i = first\n  j = last\n  do\n    do while (ord(i) < x)\n      i = i + 1\n    end do\n    do while (x < ord(j))\n      j = j - 1\n    end do\n    if (i >= j) exit\n    t = ord(i); ord(i) = ord(j); ord(j) = t\n    c0(:,:) = xyz(:,:,i)\n    xyz(:,:,i) = xyz(:,:,j)\n    xyz(:,:,j) = c0(:,:)\n    i = i + 1\n    j = j - 1\n  end do\n  if (first < i - 1) call xyzqsort(nat,nall,xyz,c0,ord,first,i - 1)\n  if (j + 1 < last) call xyzqsort(nat,nall,xyz,c0,ord,j + 1,last)\nend subroutine xyzqsort\n\n!================================================\n! a small routine to get masked xyz coordinates\n!================================================\nsubroutine maskedxyz(n,nm,c,cm,at,atm,mask)\n  use crest_parameters, only: wp\n  implicit none\n  integer,intent(in) :: n\n  integer,intent(in) :: nm\n  real(wp),intent(in) :: c(3,n)\n  real(wp),intent(out) :: cm(3,nm)\n  integer,intent(in) :: at(n)\n  integer,intent(out) :: atm(nm)\n  integer,intent(in) :: mask(n)\n  integer :: i,k\n  k = 1\n  do i = 1,n\n    if (mask(i) .gt. 0) then\n      cm(1:3,k) = c(1:3,i)\n      atm(k) = at(i)\n      k = k + 1\n    end if\n  end do\n  return\nend subroutine maskedxyz\nsubroutine maskedxyz2(n,nm,c,cm,mask) !without at arraay\n  use crest_parameters, only: wp\n  implicit none\n  integer,intent(in) :: n\n  integer,intent(in) :: nm\n  real(wp),intent(in) :: c(3,n)\n  real(wp),intent(out) :: cm(3,nm)\n  integer,intent(in) :: mask(n)\n  integer :: i,k\n  k = 1\n  do i = 1,n\n    if (mask(i) .gt. 0) then\n      cm(1:3,k) = c(1:3,i)\n      k = k + 1\n    end if\n  end do\n  return\nend subroutine maskedxyz2\n\n!=============================================!\n! write the output ensemble file\n!=============================================!\nsubroutine cregen_file_wr(env,fname,nat,nall,at,xyz,comments)\n  use crest_parameters, only: wp\n  use crest_data\n  use strucrd\n  implicit none\n  type(systemdata) :: env\n  character(len=*) :: fname\n  integer :: nat,nall\n  integer :: at(nat)\n  real(wp) :: xyz(3,nat,nall)\n  character(len=*) :: comments(nall)\n  character(len=128) :: newcomment\n\n  integer :: ich,i\n  real(wp),allocatable :: c0(:,:),xdum(:)\n  real(wp) :: eref,T\n  real(wp),allocatable :: er(:),erel(:),p(:)\n  character(len=40),allocatable :: origin(:)\n  real(wp),parameter :: autokcal = 627.509541_wp\n\n  allocate (er(nall),erel(nall),p(nall),origin(nall))\n  eref = grepenergy(comments(1))\n  do i = 1,nall\n    er(i) = grepenergy(comments(i))\n    erel(i) = (er(i) - eref) * autokcal\n    if (env%trackorigin) then\n      call getorigin(comments(i),origin(i))\n    end if\n  end do\n  T = env%tboltz\n  call boltz(nall,T,erel,p)\n\n  allocate (c0(3,nat),xdum(3))\n  open (newunit=ich,file=fname)\n  do i = 1,nall\n    c0(:,:) = xyz(:,:,i)\n    if (env%trackorigin) then\n      write (newcomment,*) er(i),p(i),'!'//trim(origin(i))\n    else\n      write (newcomment,*) er(i),p(i)\n    end if\n    call wrxyz(ich,nat,at,c0,newcomment)\n  end do\n  close (ich)\n  deallocate (xdum,c0)\n  deallocate (origin,p,erel,er)\n  return\nend subroutine cregen_file_wr\n\n!=============================================!\n! write the output ensemble file\n!=============================================!\nsubroutine cregen_conffile(env,cname,nat,nall,at,xyz,comments,ng,degen)\n  use crest_parameters, only: wp,bohr\n  use crest_data\n  use strucrd\n  use iomod\n  implicit none\n  type(systemdata) :: env\n  character(len=*) :: cname\n  integer :: nat,nall\n  integer :: at(nat)\n  real(wp) :: xyz(3,nat,nall)\n  character(len=*) :: comments(nall)\n  integer :: ng\n  integer :: degen(3,ng)\n  character(len=128) :: newcomment\n  integer :: ich,ich3,ichenso\n  integer :: i,k\n  real(wp),allocatable :: c0(:,:)\n  real(wp),allocatable :: er(:)\n  allocate (er(nall))\n  do i = 1,nall\n    er(i) = grepenergy(comments(i))\n  end do\n  allocate (c0(3,nat))\n  if (env%enso) then\n    open (newunit=ichenso,file='enso.tags')\n  end if\n  c0(:,:) = xyz(:,:,1)\n  write (newcomment,'(2x,f18.8)') er(1)\n  call wrxyz('crest_best.xyz',nat,at,xyz(:,:,1),newcomment)\n  open (newunit=ich,file=trim(cname))\n  do i = 1,ng\n    k = degen(2,i)\n    if (i .eq. 1 .or. env%printscoords) then   !write a scoord.* for each conformer? scoord.1 is always written\n      call getname1(i,newcomment)\n      c0(:,:) = xyz(:,:,k) / bohr\n      call wrc0(newcomment,nat,at,c0)\n    end if\n    write (newcomment,'(2x,f18.8)') er(k)\n    call wrxyz(ich,nat,at,xyz(:,:,k),newcomment)\n    if (env%enso) write (ichenso,*) trim(comments(k))\n  end do\n  close (ich)\n  deallocate (c0)\n  deallocate (er)\n\n  if (env%enso) then\n    close (ichenso)\n  end if\n\n  call remove('cre_members')\n  open (newunit=ich3,file='cre_members')\n  write (ich3,'(3x,i0)') ng\n  do i = 1,ng\n    k = degen(1,i)\n    write (ich3,'(3x,i8,1x,i10,1x,i10)') &\n    &   k,degen(2,i),degen(3,i)\n  end do\n  close (ich3)\n\n  return\nend subroutine cregen_conffile\n\n!====================================================================================!\n! Algin all structures in xyz to the first structure in the ensemble\n! based on the heavy-atom RMSD\n!====================================================================================!\nsubroutine cregen_rmsdalign(nat,nall,at,xyz)\n  use crest_parameters, only: wp\n  use crest_data\n  use ls_rmsd\n  use iomod\n  implicit none\n  integer :: nat,nall\n  integer :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat,nall)\n  integer :: nath\n  integer :: i,j,k\n  real(wp),allocatable :: c0(:,:)\n  real(wp),allocatable :: c1(:,:)\n  real(wp),allocatable :: c2(:,:)\n  real(wp) ::  g(3,3),U(3,3),x_center(3),y_center(3),rmsdval\n\n  nath = 0\n  do j = 1,nat\n    if (at(j) > 2) nath = nath + 1\n  end do\n  allocate (c0(3,nath),c1(3,nath),source=0.0d0)\n\n  allocate (c2(3,nat))\n  !>--- get the reference structure (the first one)\n  i = 0\n  do j = 1,nat\n    if (at(j) > 2) then\n      i = i + 1\n      c0(1:3,i) = xyz(1:3,j,1)\n    end if\n  end do\n\n  do k = 2,nall\n    !>--- and the other strucutres into c1\n    i = 0\n    do j = 1,nat\n      if (at(j) > 2) then\n        i = i + 1\n        c1(1:3,i) = xyz(1:3,j,k)\n      end if\n    end do\n    call rmsd(i,c1,c0,1,U,x_center,y_center,rmsdval,.false.,g)\n\n    c2 = matmul(U(1:3,1:3),xyz(1:3,1:nat,k))\n    xyz(1:3,1:nat,k) = c2\n  end do\n\n  deallocate (c2)\n  deallocate (c1,c0)\n  return\nend subroutine cregen_rmsdalign\n\n!=============================================!\n! write the time tag and degeneracy file\n!=============================================!\nsubroutine cregen_bonusfiles(ng,degen)\n  use crest_parameters, only: wp, bohr\n  use crest_data\n  implicit none\n  integer :: ng\n  integer :: degen(3,ng)\n  integer :: i,ich\n\n  !--- how many rotamers per conformer\n  open (newunit=ich,file='cre_degen')\n  write (ich,'(3x,i0)') ng\n  do i = 1,ng\n    write (ich,'(3x,i0,2x,i0)') i,degen(1,i)\n  end do\n  close (ich)\n\n  return\nend subroutine cregen_bonusfiles\n\n!=========================================================================================!\n!=========================================================================================!\n!  CREGEN PRINTOUTS\n!=========================================================================================!\n!=========================================================================================!\nsubroutine cregen_setthreads(ch,env,pr)\n  use crest_parameters \n  use crest_data\n  implicit none\n  type(systemdata) :: env\n  integer :: ch\n  logical :: pr\n  integer :: TID,OMP_GET_NUM_THREADS,OMP_GET_THREAD_NUM,nproc\n!---- setting the threads for OMP parallel usage\n  if (env%autothreads) then\n    call ompautoset(env%threads,4,env%omp,env%MAXRUN,0) !mode=4 --> Program intern Threads max\n!$OMP PARALLEL PRIVATE(TID)\n    TID = OMP_GET_THREAD_NUM()\n    IF (TID .EQ. 0 .and. pr) THEN\n      nproc = OMP_GET_NUM_THREADS()\n      write (ch,*) '============================='\n      write (ch,*) ' # threads =',nproc\n      write (ch,*) '============================='\n    END IF\n!$OMP END PARALLEL\n  end if\n  return\nend subroutine cregen_setthreads\n\nsubroutine cregen_pr1(ch,env,nat,nall,rthr,bthr,pthr,ewin)\n  use crest_parameters\n  use crest_data\n  implicit none\n  integer :: ch\n  type(systemdata) :: env\n  integer :: nat\n  integer :: nall\n  real(wp) :: rthr,bthr,pthr,ewin\n  logical :: substruc\n  substruc = (nat .ne. env%rednat .and. env%subRMSD)\n  write (ch,'('' number of atoms                :'',3x,i0)') nat\n  if (substruc) then\n    write (ch,'('' atoms included in RMSD         :'',3x,i0)') env%rednat\n  end if\n  write (ch,'('' number of points on xyz files  :'',3x,i0)') nall\n  write (ch,'('' RMSD threshold                 :'',f9.4)') rthr\n  write (ch,'('' Bconst threshold               :'',f9.4)') bthr\n  write (ch,'('' population threshold           :'',f9.4)') pthr\n  if (ewin < 9999.9_wp) then\n    write (ch,'('' conformer energy window  /kcal :'',f9.4)') ewin\n  else\n    write (ch,'('' conformer energy window  /kcal :'',6x,a)') '+∞'\n  end if\n\n  return\nend subroutine cregen_pr1\n\nsubroutine enso_duplicates(env,nall,double)\n  use crest_parameters\n  use crest_data\n  implicit none\n  type(systemdata) :: env\n  integer :: nall\n  integer :: double(nall)\n  integer :: i,j,ich\n\n  if (.not. env%ENSO .or. .not. env%confgo) return\n\n  j = sum(double)\n  open (newunit=ich,file='cregen.enso')\n  if (j .gt. 0) then\n    do i = 1,nall\n      if (double(i) .gt. 0) then\n        write (ich,*) i,double(i)\n      end if\n    end do\n  else\n    write (ich,*) \"ALL UNIQUE\"\n  end if\n\n  return\nend subroutine enso_duplicates\n\nsubroutine create_anmr_dummy(nat)\n  implicit none\n  integer :: nat\n  integer :: i,ich\n\n  open (newunit=ich,file='anmr_nucinfo')\n  write (ich,*) nat\n  do i = 1,nat\n    write (ich,'(3x,i0,3x,i0)') i,1\n    write (ich,'(3x,i0)') i\n  end do\n  do i = 1,nat\n    write (ich,*) i,1\n    write (ich,'(i5)') i\n  end do\n  close (ich)\n  return\nend subroutine create_anmr_dummy\n\nsubroutine cregen_pr2(ch,env,nall,comments,ng,degen,er)\n  use crest_parameters\n  use crest_data\n  use strucrd\n  use iomod,only:touch\n  implicit none\n  integer :: ch\n  type(systemdata) :: env\n  integer :: nall\n  character(len=*) :: comments(nall)\n  integer :: ng\n  integer :: degen(3,ng)\n  real(wp) :: er(nall)\n  integer :: ich,chref\n  integer :: i,j,k\n  real(wp),allocatable :: erel(:),egrp(:)\n  real(wp),allocatable :: p(:),pg(:)\n  real(wp) :: eref,T\n  character(len=40),allocatable :: origin(:)\n  integer :: a,b\n  logical :: ex\n  real(wp) :: A0,eav,g,s,ss,beta,elow\n\n  allocate (origin(nall),erel(nall),p(nall))\n  eref = grepenergy(comments(1))\n  env%elowest = eref\n  do i = 1,nall\n    er(i) = grepenergy(comments(i))\n    erel(i) = (er(i) - eref) * autokcal\n    if (env%trackorigin) then\n      call getorigin(comments(i),origin(i))\n    else\n      origin(i) = ''\n    end if\n  end do\n  T = env%tboltz\n  call boltz(nall,T,erel,p)\n  allocate (pg(ng),source=0.0_wp)\n  do i = 1,ng\n    a = degen(2,i)\n    b = degen(3,i)\n    do j = a,b\n      pg(i) = pg(i) + p(j)\n    end do\n  end do\n\n  !-- really long energy list\n  !write(ch,*)'  Erel/kcal     Etot      weight/tot conformer  set degen    origin'\n  write (ch,'(7x,a,8x,a,1x,a,2x,a,5x,a,3x,a,5x,a)') 'Erel/kcal','Etot', &\n  &    'weight/tot','conformer','set','degen','origin'\n  if (env%entropic .and. ng > 50000) then\n    write (ch,'(1x,a)') '<skipped due to lenght and written to seperate file>'\n    chref = ch\n    open (newunit=ch,file='crest.conformerlist')\n  end if\n  k = 0\n  do i = 1,ng\n    k = k + 1\n    a = degen(2,i)\n    b = degen(3,i)\n    write (ch,'(i8,f8.3,1x,3f11.5,2i8,5x,a)') &\n  & k,erel(a),er(a),p(a),pg(i),i,degen(1,i),trim(origin(a))\n    if (.not. env%entropic) then\n      do j = a + 1,b\n        k = k + 1\n        write (ch,'(i8,f8.3,1x,2f11.5,32x,a)') &\n    &   k,erel(j),er(j),p(j),trim(origin(j))\n      end do\n    end if\n  end do\n  if (env%entropic .and. ng > 50000) then\n    close (ch)\n    ch = chref\n  end if\n\n  !-- file for the '-compare' mode\n  if (env%compareens) then\n    open (newunit=ich,file='.cretrack')\n    write (ich,'(5x,i0)') ng\n    do i = 1,ng\n      write (ich,'(1x,i8,1x,i7,1x,i7)') i,degen(2,i),degen(3,i)\n    end do\n    close (ich)\n  end if\n\n  !-- some ensemble data, entropy and G (including all structures)\n  A0 = 0\n  eav = 0\n  do i = 1,nall\n    A0 = A0 + p(i) * log(p(i) + 1.d-12)\n    eav = eav + p(i) * erel(i)\n  end do\n  beta = 1.0d0 / (T * 8.314510 / 4.184 / 1000.+1.d-14)\n  g = (1.0d0 / beta) * A0\n  s = -1000.0d0 * 4.184 * g / T\n  ss = -1000.0d0 * g / T\n\n  write (ch,'(''T /K                                  :'', F9.2)') T\n  write (ch,'(''E lowest                              :'',f12.5)') eref\n  !---- elow printout in between routines\n  if (.not. env%confgo) then\n    write (*,'(1x,''E lowest :'',f12.5)') eref\n  end if\n  if (env%QCG) then\n    write (ch,'(''ensemble average energy (kcal)        :'', F14.8)') eav\n    write (ch,'(''ensemble entropy (cal/mol K)          :'',F14.8)') ss\n    write (ch,'(''ensemble free energy (kcal/mol)       : '',F14.8)') g\n  else\n    write (ch,'(''ensemble average energy (kcal)        :'', F9.3)') eav\n    write (ch,'(''ensemble entropy (J/mol K, cal/mol K) :'',2F9.3)') s,ss\n    write (ch,'(''ensemble free energy (kcal/mol)       : '',F8.3)') g\n  end if\n  write (ch,'(''population of lowest in %             : '',F8.3)') pg(1) * 100.d0\n\n  !-- some ensemble data, entropy and G (including only unique conformers)\n  allocate (egrp(ng),source=0.0_wp)\n  do i = 1,ng\n    a = degen(2,i)\n    egrp(i) = (er(a) - eref) * autokcal\n  end do\n  call boltz(ng,T,egrp,pg)\n  A0 = 0\n  do i = 1,ng\n    A0 = A0 + pg(i) * log(pg(i) + 1.d-12)\n  end do\n  deallocate (egrp)\n  beta = 1.0d0 / (T * 8.314510 / 4.184 / 1000.+1.d-14)\n  g = (1.0d0 / beta) * A0\n  ss = -1000.0d0 * g / T\n  env%emtd%sapprox = ss  ! save for entropy mode\n\n  !-- MF-MD-GC legacy option\n  if ((env%crestver .eq. 1) .and. (.not. env%confgo)) then\n    inquire (file='.tmpxtbmodef',exist=ex)\n    if (ex) then\n      open (unit=66,file='.tmpxtbmodef')\n      read (66,*) i\n      read (66,*) elow\n      close (66)\n    else\n      elow = er(1)\n    end if\n    if ((elow - eref) * autokcal .lt. -0.2) then\n      write (ch,*) '...............................................'\n      write (ch,*) 'WARNING: new (best) energy less than that from '\n      write (ch,*) 'WARNING: preceding Hessian calculation:  '\n      write (ch,*) 'Improved by ',elow - eref,' Eh or ', (elow - eref) * autokcal,'kcal'\n      write (ch,*) '...............................................'\n      call touch('LOWER_FOUND')\n    end if\n  end if\n\n  deallocate (pg)\n  deallocate (p,erel,origin)\n  return\nend subroutine cregen_pr2\n\nsubroutine cregen_econf_list(ch,nall,er,ng,degen)\n  use crest_parameters\n  implicit none\n  integer :: nall\n  real(wp) :: er(nall)\n  integer :: ng\n  integer :: degen(3,ng)\n  integer :: ch,ich2,i,j\n  real(wp) :: eref,ewrt\n\n  write (ch,*) 'number of unique conformers for further calc ',ng\n  write (ch,*) 'list of relative energies saved as \"crest.energies\"'\n  open (newunit=ich2,file='crest.energies')\n  eref = er(1)\n  do i = 1,ng\n    j = degen(2,i)\n    ewrt = er(j) - eref\n    ewrt = ewrt * autokcal\n    write (ich2,'(2x,i0,2x,f12.3)') i,ewrt\n  end do\n  close (ich2)\n\n  return\nend subroutine cregen_econf_list\n\nsubroutine cregen_pr3(ch,infile,nall,comments)\n  use crest_parameters\n  use strucrd\n  implicit none\n  integer :: ch\n  character(len=*) :: infile\n  integer :: nall\n  character(len=*) :: comments(nall)\n  real(wp),allocatable :: er(:)\n  real(wp) :: dE\n  integer :: i\n  allocate (er(nall))\n\n  do i = 1,nall\n    er(i) = grepenergy(comments(i))\n  end do\n\n  write (ch,*)\n  write (ch,'(a)') '==================================================='\n  write (ch,'(a)') '============= ordered structure list =============='\n  write (ch,'(a)') '==================================================='\n  write (ch,'(a,a,a)') ' written to file <',trim(infile),'>'\n  write (ch,*)\n  write (ch,'(''   structure    ΔE(kcal/mol)    Etot(Eh)'')')\n  do i = 1,nall\n    dE = (er(i) - er(1)) * autokcal\n    write (ch,'(i10,3x,F12.2,2x,F14.6)') i,dE,er(i)\n  end do\n  write (ch,*)\n\n  deallocate (er)\n  return\nend subroutine cregen_pr3\n\nsubroutine cregen_pr4(ch,infile,nall,group)\n  use crest_parameters\n  use strucrd\n  implicit none\n  integer :: ch\n  character(len=*) :: infile\n  integer :: nall\n  integer :: group(0:nall)\n  integer :: i,ich\n  integer :: maxgroup\n  !write(ch,*) group(1:nall)\n  maxgroup = group(0)\n  write (ch,'(1x,i0,a,i0,a,a,a)') maxgroup,' unique groups for ', &\n  &    nall,' structures in file <',trim(infile),'>'\n\n  open (newunit=ich,file='.groups')\n  write (ich,'(5x,i0,3x,i0)') nall,maxgroup\n  do i = 1,nall\n    write (ich,'(2x,i10,2x,i10)') i,group(i)\n  end do\n  close (ich)\n  return\nend subroutine cregen_pr4\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/cregen.f90 b/src/cregen.f90
--- a/src/cregen.f90	
+++ b/src/cregen.f90	
@@ -33,6 +33,7 @@
 subroutine newcregen(env,quickset)
   use crest_parameters
   use crest_data
+  use crest_restartlog
   use strucrd
   implicit none
   type(systemdata) :: env      !> MAIN STORAGE OS SYSTEM DATA
@@ -41,7 +42,7 @@
   character(len=258) :: fname  !> input file
   character(len=258) :: oname  !> sorted output file
   character(len=258) :: cname  !> unique structure file
-  !>--- ensemble arguments
+!>--- ensemble arguments
   integer :: nat                      !> number of atoms
   integer :: nall                     !> number of structures
   integer,allocatable  :: at(:)       !> atom numbers
@@ -49,16 +50,16 @@
   character(len=128),allocatable :: comments(:)
   character(len=128),allocatable :: comref(:)
   real(wp),allocatable :: er(:)       !> energies
-  !>--- dummy ensemble arguments
+!>--- dummy ensemble arguments
   integer :: nallref
   integer :: nallnew
   real(wp),allocatable :: xyzref(:,:,:)
-  !>--- sorting arguments
+!>--- sorting arguments
   integer,allocatable :: gref(:),group(:)
   integer :: ng
   integer,allocatable :: degen(:,:)
 
-  !>--- float data
+!>--- float data
   real(wp) :: ewin
   real(wp) :: rthr
   real(wp) :: bthr
@@ -68,7 +69,7 @@
   real(wp) :: T
   real(wp) :: couthr
 
-  !>--- boolean data
+!>--- boolean data
   logical :: checkbroken
   logical :: topocheck
   logical :: checkez
@@ -82,10 +83,13 @@
   logical :: anal
   logical :: saveelow = .true.
 
-  !--- printout directions
-  integer :: prch  !the main printout channel
+!>--- printout directions
+  integer :: prch  !> the main printout channel
   logical :: pr1,pr2,pr3,pr4
 
+!>--- restart skip & tracking
+  if(trackrestart(env)) return
+
 !====================================================================!
 ! S E T T I N G S
 !====================================================================!
@@ -95,37 +99,39 @@
     simpleset = 0
   end if
 
-  !-- determine filenames and output channel
+!>-- determine filenames and output channel
   call cregen_files(env,fname,oname,cname,simpleset,prch)
-  !-- determine which printouts are required
+!>-- determine which printouts are required
   call cregen_prout(env,simpleset,pr1,pr2,pr3,pr4)
-  !-- determine which subroutines are required
+!>-- determine which subroutines are required
   call cregen_director(env,simpleset,checkbroken,sorte,sortRMSD,sortRMSD2, &
   &  repairord,newfile,conffile,bonusfiles,anal,topocheck,checkez)
 
-!--- DATA SECTION
+!>--- DATA SECTION
   call cregen_filldata1(env,ewin,rthr,ethr,bthr,athr,pthr,T,couthr)
   call cregen_filldata2(simpleset,ewin)
 
-!--- setting the threads for OMP parallel usage
+!>--- setting the threads for OMP parallel usage
   call cregen_setthreads(prch,env,.false.)
 
 !=====================================================================!
 
-!--- read in the ensemble parameters
+!>--- read in the ensemble parameters
   call rdensembleparam(fname,nat,nallref)
 
-!--- print a summary about the ensemble and thresholds
+!>--- print a summary about the ensemble and thresholds
   if (pr1) call cregen_pr1(prch,env,nat,nallref,rthr,bthr,pthr,ewin)
 
-!--- allocate space and read in the ensemble
+!>--- allocate space and read in the ensemble
   allocate (at(nat),comments(nallref),xyz(3,nat,nallref))
   call rdensemble(fname,nat,nallref,at,xyz,comments)
+!>--- track ensemble for restart
+  call trackensemble(fname,nat,nallref,at,xyz,comments) 
 
-!--- check if the ensemble contains broken structures? i.e., fusion or dissociation
+!>--- check if the ensemble contains broken structures? i.e., fusion or dissociation
   if (checkbroken) then
     call discardbroken(prch,env,nat,nallref,at,xyz,comments,nall)
-    !--- if structures were discarded, resize xyz
+!>--- if structures were discarded, resize xyz
     if (nall .lt. nallref) then
       xyzref = xyz(:,:,1:nall)
       call move_alloc(xyzref,xyz)
@@ -136,12 +142,12 @@
     nall = nallref
   end if
 
-!--- compare neighbourlists to sort out chemically transformed structures
+!>--- compare neighbourlists to sort out chemically transformed structures
   if (topocheck) then
     call cregen_topocheck(prch,env,checkez,nat,nall,at,xyz,comments,nallnew)
-    !--- if structures were discarded, resize xyz
+!>--- if structures were discarded, resize xyz
     if (nallnew .lt. nall) then
-      !-- special fallback if all are discared
+!>-- special fallback if all are discared
       if (nallnew == 0) then
         call rdcoord('coord',nat,at,xyz(:,:,1))
         xyz = xyz * bohr
@@ -159,10 +165,10 @@
     write (prch,'('' number of reliable points      :'',i6)') nall
   end if
 
-!--- sort the ensemble by its energies and make a cut (EWIN)
+!>--- sort the ensemble by its energies and make a cut (EWIN)
   if (sorte) then
     call cregen_esort(prch,nat,nall,xyz,comments,nallnew,ewin)
-    !--- if structures were discarded, resize xyz
+    !>--- if structures were discarded, resize xyz
     if (nallnew .lt. nall) then
       nall = nallnew
       xyzref = xyz(:,:,1:nall)
@@ -172,11 +178,11 @@
     end if
   end if
 
-!--- do the rotational constants and RMSD check
+!>--- do the rotational constants and RMSD check
   if (sortRMSD) then
     allocate (group(0:nall))
     call cregen_CRE(prch,env,nat,nall,at,xyz,comments,nallnew,group)
-    !--- if structures were discarded, resize xyz
+!>--- if structures were discarded, resize xyz
     if (nallnew .lt. nall) then
       nall = nallnew
       xyzref = xyz(:,:,1:nall)
@@ -188,11 +194,11 @@
       call move_alloc(gref,group)
       nall = nallnew
     end if
-    !--- repair the order
+!>--- repair the order
     if (repairord) then
       call cregen_repairorder(nat,nall,xyz,comments,group)
     end if
-    !--- get group info to degen
+!>--- get group info to degen
     ng = group(0)
     allocate (degen(3,ng))
     call cregen_groupinfo(nall,ng,group,degen)
@@ -202,48 +208,50 @@
     call cregen_CRE_2(prch,env,nat,nall,at,xyz,comments,nallnew,group)
   end if
 
-!--- align all structures to the first structure using the RMSD
+!>--- align all structures to the first structure using the RMSD
   call cregen_rmsdalign(nat,nall,at,xyz)
 
-!--- write new file with ALL remaining structures
+!>--- write new file with ALL remaining structures
   if (newfile) then
     call cregen_file_wr(env,oname,nat,nall,at,xyz,comments)
+!>--- track ensemble for restart
+    call trackensemble(oname,nat,nall,at,xyz,comments)
   end if
-!--- write a file only containing the conformers.
+!>--- write a file only containing the conformers.
   if (conffile) then
     call cregen_conffile(env,cname,nat,nall,at,xyz,comments,ng,degen)
   end if
   if (saveelow) then
     env%elowest = grepenergy(comments(1))
-    !-- and update reference geometry (in Bohrs!)
+!>-- and update reference geometry (in Bohrs!)
     env%ref%xyz = xyz(:,:,1) / bohr
   end if
 
-!--- additional files for entropy mode
+!>--- additional files for entropy mode
   if (bonusfiles) then
     call cregen_bonusfiles(ng,degen)
   end if
 
-!--- several printouts
+!>--- several printouts
   if (pr2) then
     allocate (er(nall))
     call cregen_pr2(prch,env,nall,comments,ng,degen,er)
     call cregen_econf_list(prch,nall,er,ng,degen)
     deallocate (er)
   end if
-  if (pr3) then !alternative to pr2
+  if (pr3) then !> alternative to pr2
     call cregen_pr3(prch,oname,nall,comments)
   end if
-  if (pr4) then !group dara printout
+  if (pr4) then !> group dara printout
     call cregen_pr4(prch,fname,nall,group)
   end if
 
-!--- analyze nuclear equivalencies, e.g. for NMR and Entropy
+!>--- analyze nuclear equivalencies, e.g. for NMR and Entropy
   if (anal) then
     call cregen_EQUAL(prch,nat,nall,at,xyz,group,athr,.not. env%entropic)
   end if
 
-!--- deallocate data
+!>--- deallocate data
   if (prch .ne. stdout) then
     close (prch)
   end if
@@ -268,6 +276,7 @@
   use crest_parameters
   use crest_data
   use iomod
+  use utilities
   implicit none
   type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
   character(len=*) :: fname
@@ -277,11 +286,11 @@
   integer,intent(out) :: iounit
   character(len=:),allocatable :: outfile
   logical :: ex
-  !--------------------------------------------------------------------
+  !>--------------------------------------------------------------------
   outfile = 'cregen.out.tmp'
   if (env%cgf(6)) outfile = 'tmp'
 
-  !-- the entire cregen output can be printed printed to a seperate file
+  !>-- the entire cregen output can be printed printed to a seperate file
   !   or to the terminal
   call remove(outfile)
   if (simpleset > 0) then
@@ -475,7 +484,7 @@
   implicit none
   type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
   real(wp),intent(out) :: ewin,rthr,ethr,bthr,athr,pthr,T,couthr
-  !--------------------------------------------------------------------
+  !>--------------------------------------------------------------------
   ewin = env%ewin          !ensemble energy window in kcal/mol
   rthr = env%rthr          ! RMSD thr in Ang
   ethr = env%ethr          ! E threshold in kcal
@@ -492,7 +501,7 @@
   implicit none
   integer,intent(in) :: simpleset
   real(wp),intent(out) :: ewin
-  !--------------------------------------------------------------------
+  !>--------------------------------------------------------------------
   if (simpleset == 6) then
     ewin = 100000
   end if
@@ -545,6 +554,7 @@
   use crest_parameters
   use crest_data
   use strucrd
+  use miscdata, only: rcov
   implicit none
   type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
   integer :: ch ! printout channel
@@ -558,7 +568,7 @@
   integer :: nat0
   real(wp),allocatable :: cref(:,:),c0(:,:),c1(:,:)
   integer,allocatable  :: at0(:),atdum(:)
-  real(wp),allocatable :: rcov(:),cn(:),bond(:,:)
+  real(wp),allocatable :: cn(:),bond(:,:)
   integer :: frag,frag0
   real(wp) :: erj
   integer :: j
@@ -570,10 +580,6 @@
   !>--- if we don't wish to include all atoms:
   substruc = (nat .ne. env%rednat .and. env%subRMSD)
 
-  !>--- settings
-  allocate (rcov(94))
-  call setrcov(rcov)
-
   !>--- read the reference structure
   allocate (cref(3,nat),atdum(nat))
   call rdcoord('coord',nat,atdum,cref)
@@ -657,7 +663,7 @@
   if(allocated(at0)) deallocate(at0)
   if(allocated(c0)) deallocate(c0)
   if(allocated(cref)) deallocate(cref)
-  if(allocated(rcov)) deallocate(rcov)
+  ! if(allocated(rcov)) deallocate(rcov)
   return
 end subroutine discardbroken
 
@@ -670,6 +676,8 @@
   use crest_parameters
   use crest_data
   use strucrd
+  use miscdata, only: rcov
+  use utilities
   implicit none
   type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
   integer,intent(in) :: ch ! printout channel
@@ -683,7 +691,7 @@
   integer,allocatable :: order(:),orderref(:)
   real(wp),allocatable :: cref(:,:),c1(:,:)
   integer,allocatable  :: atdum(:)
-  real(wp),allocatable :: rcov(:),cn(:),bond(:,:)
+  real(wp),allocatable :: cn(:),bond(:,:)
   integer,allocatable :: toporef(:)
   integer,allocatable :: topo(:)
   logical,allocatable :: neighmat(:,:)
@@ -696,15 +704,11 @@
   real(wp),allocatable :: ezdihed(:)
   real(wp) :: winkeldiff
 
-  !--- settings
-  allocate (rcov(94))
-  call setrcov(rcov)
-
-  !--- read the reference structure
+  !>--- read the reference structure
   allocate (cref(3,nat),atdum(nat))
   call rdcoord('coord',nat,atdum,cref)
 
-  !--- get the reference topology matrix (bonds)
+  !>--- get the reference topology matrix (bonds)
   ntopo = nat * (nat + 1) / 2
   allocate (toporef(ntopo),topo(ntopo))
   allocate (neighmat(nat,nat),source=.false.)
@@ -723,7 +727,7 @@
 
   nbonds = sum(toporef)
   write (ch,'('' # bonds in reference structure :'',i6)') nbonds
-  !--- if required, check for C=C bonds (based only on structure!)
+  !>--- if required, check for C=C bonds (based only on structure!)
   if (checkez) then
     cref = cref * bohr
     call nezcc(nat,atdum,cref,cn,ntopo,toporef,ncc)
@@ -741,13 +745,13 @@
 
   allocate (order(nall),orderref(nall))
   allocate (c1(3,nat))
-  !--- loop over the structures
+  !>--- loop over the structures
   ccfail = 0
   newnall = 0
   llan = nall
   do j = 1,nall
     c1(1:3,1:nat) = xyz(1:3,1:nat,j) / bohr
-    !--- generate topo and compare
+    !>--- generate topo and compare
     discard = .false.
     cn = 0.0d0
     bond = 0.0d0
@@ -766,7 +770,7 @@
         exit
       end if
     end do
-    !--- get E/Z info of C=C, discard isomers
+    !>--- get E/Z info of C=C, discard isomers
     if (checkez .and. .not. discard .and. ncc > 0) then
       c1 = c1 * bohr
       call ezccdihed(nat,c1,ncc,ezat,ezdihed)
@@ -782,7 +786,7 @@
     end if
 
     if (discard) then
-      !-- move broken structures to the end of the matrix
+      !>-- move broken structures to the end of the matrix
       orderref(j) = llan
       llan = llan - 1
       !write(ch,*) 'removing structure',j
@@ -792,7 +796,7 @@
     end if
   end do
 
-  !--- sort the xyz array (only if structures have been discarded)
+  !>--- sort the xyz array (only if structures have been discarded)
   if (newnall .lt. nall) then
     order = orderref
     call xyzqsort(nat,nall,xyz,c1,order,1,nall)
@@ -801,13 +805,15 @@
 
     llan = nall - newnall
     write (ch,'('' number of topology mismatches  :'',i6)') llan
+    !>--- report the removals during a run
+    if(ch.ne.stdout)then
+    write (stdout,'("CREGEN> number of topology-based structure removals: ",i0)') llan
+    endif
     if (checkez .and. ccfail > 0) then
       write (ch,'(''  => discared due to E/Z isom.  :'',i6)') ccfail
     end if
   end if
-  !--- otherwise the ensemble is ok
-
-  !write(ch,'('' number of reliable points      :'',i6)')newnall
+  !>--- otherwise the ensemble is ok
 
   deallocate (c1)
   deallocate (orderref,order)
@@ -818,7 +824,7 @@
   deallocate (neighmat)
   deallocate (topo,toporef)
   deallocate (atdum)
-  deallocate (cref,rcov)
+  deallocate (cref)
   return
 
 contains
@@ -836,7 +842,7 @@
     integer,intent(out) :: ncc
     real(wp) :: dist
     integer :: l
-    integer :: ci,cj,lin
+    integer :: ci,cj
     real(wp),parameter :: distcc = 1.384_wp
     ncc = 0
     do ci = 1,nat
@@ -873,7 +879,7 @@
     integer,intent(out) :: ezat(4,ncc)
     real(wp) :: dist
     integer :: i,j,k,l
-    integer :: ci,cj,lin
+    integer :: ci,cj
     real(wp),parameter :: distcc = 1.384_wp
     if (ncc < 1) return
     k = 0
@@ -892,7 +898,7 @@
             k = k + 1
             ezat(2,k) = ci
             ezat(3,k) = cj
-            !-- get a neighbour for ci
+            !>-- get a neighbour for ci
             do i = 1,nat
               if (i == cj .or. i == ci) cycle
               l = lin(ci,i)
@@ -901,7 +907,7 @@
                 exit
               end if
             end do
-            !-- get a neighbour for cj
+            !>-- get a neighbour for cj
             do j = 1,nat
               if (j == cj .or. j == ci) cycle
               l = lin(cj,j)
@@ -936,7 +942,7 @@
       b = ezat(2,i)
       c = ezat(3,i)
       d = ezat(4,i)
-      call DIHED(xyz,a,b,c,d,winkel) !-- from intmodes.f
+      call DIHED(xyz,a,b,c,d,winkel) !>-- from intmodes.f
       winkel = abs(winkel * (180.0_wp / pi))
       if (winkel > 180.0_wp) then
         winkel = 360.0_wp - winkel
@@ -985,15 +991,15 @@
     orderref(i) = i
     order(i) = i
   end do
-  !-- sort the energies and obtain the order
+  !>-- sort the energies and obtain the order
   call qsort(energies,1,nall,orderref)
-  !-- after the sorting orderref contains information:
+  !>-- after the sorting orderref contains information:
   !   before the sorting element "i" WAS at position "orderref(i)"
   !   but to use it as a mask, we need to invert it,
   !   so that it is: element "i" IS NOW at position "orderref(i)"
   call maskinvert(nall,orderref)
 
-  !-- sort structures and comments based on the order
+  !>-- sort structures and comments based on the order
   order = orderref
   allocate (c0(3,nat))
   call xyzqsort(nat,nall,xyz,c0,order,1,nall)
@@ -1002,7 +1008,7 @@
 
   call stringqsort(nall,comments,1,nall,order)
 
-  !-- determine cut-off of energies
+  !>-- determine cut-off of energies
   emax = maxval(energies(:),1)
   de = (emax - energies(1)) * autokcal
   if (de .gt. ewin) then
@@ -1046,6 +1052,7 @@
   use strucrd
   use ls_rmsd
   use axis_module
+  use utilities
   implicit none
   type(systemdata) :: env
   integer,intent(in) :: ch
@@ -1079,7 +1086,6 @@
   real(wp) :: rdum,dr,rdum2
   real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:),ydum(:) !dummy tensors
   integer(id) :: klong
-  integer(id) :: linr  !this is a function
   integer(id),allocatable :: rmap1(:)
   integer,allocatable :: rmap2(:)
   logical :: l1,l2,l3
@@ -1124,20 +1130,18 @@
 
 !>--- transform the coordinates to CMA and get rot.constants
   do i = 1,nall
-    call axis(nat,at,xyz(:,:,i)) !-- all coordinates to CMA
+    call axis(nat,at,xyz(:,:,i)) !>-- all coordinates to CMA
     if (substruc) then
       call maskedxyz(nat,nat0,xyz(:,:,i),c1,at,at0,includeRMSD)
     else
       c1(:,:) = xyz(:,:,i)
     end if
-    call axis(nat0,at0,c1,rot(1:3,i),bdum)  !-- B0 in MHz
+    call axis(nat0,at0,c1,rot(1:3,i),bdum)  !>-- B0 in MHz
   end do
 
 !>--- Calculate an artificial Coulomb energy used to compare structures
-!    !--- settings
+!    !>--- settings
 !    allocate(ecoul(nall), source=0.0_wp)
-!    allocate(rcov(94))
-!    call setrcov(rcov)
 !    allocate(bond(nat,nat),cn(nat), source=0.0_wp)
 !    allocate(cref(3,nat),source=0.0_wp)
 !    allocate(maskheavy(nat), source=0)
@@ -1196,7 +1200,8 @@
   allocate (gdum(3,3),Udum(3,3),xdum(3),ydum(3))
   !>-- begin calculation of RMSDs
   klong = 0
-  write (*,'(1x,a)') 'running RMSDs...'
+  write (stdout,'(a)',advance='no') 'CREGEN> running RMSDs ...'
+  flush(stdout) 
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!
   if (.not. substruc) then !regular case, all atoms included in RMSD
     if (.not. heavy) then    !really, the regular case
@@ -1281,12 +1286,12 @@
 !$OMP END PARALLEL
     end do
   end if
-  write (*,'(1x,a)') 'done.'
+  write (stdout,'(1x,a)') 'done.'
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!
 !>-- Now, with the RMSDs and rotational constants we can kick out duplicates
   do i = 1,nall
     do j = 1,i - 1
-      !-- only check for structures in energy range
+      !>-- only check for structures in energy range
       de = (er(i) - er(j)) * autokcal
       if (de .lt. ethr) then
         klong = linr(rmap1(i),rmap2(i),j)
@@ -1296,7 +1301,7 @@
       end if
       !>-- very small RMSD --> same structure
       if (dr .lt. rthr) then
-        double(i) = j !-- "i" is the same structure as "j"
+        double(i) = j !>-- "i" is the same structure as "j"
         !>-- slightly larger RMSD, but same rot. constants --> same structure
       elseif (dr .lt. 2.0_wp * rthr) then
         l1 = equalrotaniso(i,j,nall,rot,0.5d0 * bthr,env%bthrmax,env%bthrshift)
@@ -1362,20 +1367,20 @@
     end do
   end do
 !>-- check energy, rot. const. and nuclear permutation
-  double = 0 !-- re-use "double"
+  double = 0 !>-- re-use "double"
   SORTI: do i = 1,nallout
     SORTJ: do j = 1,i - 1
-      !-- energy difference
+      !>-- energy difference
       de = (er(i) - er(j)) * autokcal
       l3 = double(j) .eq. 0
       if (.not. l3) cycle
       if (abs(de) .lt. ethr) then
-        !-- rotational constant difference
+        !>-- rotational constant difference
         l1 = equalrotaniso(i,j,nall,rot,bthr,env%bthrmax,env%bthrshift)
-        !-- nuclear permutation
+        !>-- nuclear permutation
         l2 = 2.0d0 * abs(enuc(i) - enuc(j)) / (enuc(i) + enuc(j)) .lt. 1.d-3
         if (l1 .and. l2 .and. l3) then
-          double(i) = j   !-- "i" is a rotamer of "j"
+          double(i) = j   !>-- "i" is a rotamer of "j"
           call backtrack(double,i,k)
           cycle SORTI
         end if
@@ -1394,7 +1399,7 @@
       group(i) = group(j)
     end if
   end do
-  group(0) = k !-- total number of groups
+  group(0) = k !>-- total number of groups
 
   deallocate (enuc,c1,double)
   deallocate (order,orderref)
@@ -1465,7 +1470,7 @@
       ecoulomb = ecoulomb + dum
     end do
   end do
-  !-- normalization to the number of included(!) atoms
+  !>-- normalization to the number of included(!) atoms
   dum = float(sum(atommask))
   ecoulomb = ecoulomb / (dum**natexp)
   ecoulomb = ecoulomb * 627.5095
@@ -1492,6 +1497,7 @@
   use strucrd
   use ls_rmsd
   use axis_module
+  use utilities
   implicit none
   type(systemdata) :: env
   integer,intent(in) :: ch
@@ -1523,7 +1529,6 @@
   real(wp) :: rdum,dr,rdum2
   real(wp),allocatable :: gdum(:,:),Udum(:,:),xdum(:),ydum(:) !> dummy tensors
   integer(id) :: klong
-  integer(id) :: lina  !> this is a function
   integer(id),allocatable :: rmap1(:)
   integer,allocatable :: rmap2(:)
   logical :: l1,l2,l3
@@ -1552,23 +1557,21 @@
     orderref(i) = i
   end do
 
-!--- get dummy structure memory space
+!>--- get dummy structure memory space
   allocate (c0(3,nat),c1(3,nat),at0(nat))
   at0 = at
   nat0 = nat
 
-!--- transform the coordinates to CMA and get rot.constants
+!>--- transform the coordinates to CMA and get rot.constants
   do i = 1,nall
-    call axis(nat,at,xyz(:,:,i)) !-- all coordinates to CMA
+    call axis(nat,at,xyz(:,:,i)) !>-- all coordinates to CMA
     c1(:,:) = xyz(:,:,i)
-    call axis(nat0,at0,c1,rot(1:3,i),bdum)  !-- B0 in MHz
+    call axis(nat0,at0,c1,rot(1:3,i),bdum)  !>-- B0 in MHz
   end do
 
-!--- Calculate an artificial Coulomb energy used to compare structures
-  !--- settings
+!>--- Calculate an artificial Coulomb energy used to compare structures
+  !>--- settings
 !    allocate(ecoul(nall), source=0.0_wp)
-!    allocate(rcov(94))
-!    call setrcov(rcov)
 !    allocate(bond(nat,nat),cn(nat), source=0.0_wp)
 !    allocate(cref(3,nat),source=0.0_wp)
 !    allocate(maskheavy(nat), source=0)
@@ -1583,10 +1586,10 @@
 !    deallocate(maskheavy)
 !    deallocate(cref,cn,bond,rcov)
 
-!--- RMSD part
+!>--- RMSD part
   allocate (double(nall),source=0)
   !========================================================!
-  !-- crucial point: rmat is huge. VERY huge, potentially.
+  !>-- crucial point: rmat is huge. VERY huge, potentially.
   !                  use only for small ensembles!
   klong = nall
   klong = klong * (nall + 1)
@@ -1594,9 +1597,10 @@
   !write(*,*) nall,klong
   allocate (rmat(klong),source=0.0_sp)
   allocate (gdum(3,3),Udum(3,3),xdum(3),ydum(3))
-  !-- begin calculation of RMSDs
+  !>-- begin calculation of RMSDs
   klong = 0
-  write (*,'(1x,a)') 'running RMSDs...'
+  write (stdout,'(a)',advance='no') 'CREGEN> running RMSDs ...'
+  flush(stdout)
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!
   if (.not. heavy) then    !really, the regular case
     do i = 1,nall
@@ -1656,12 +1660,12 @@
     deallocate (maskheavy,c1h,c0h)
   end if
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!
-  write (*,'(1x,a)') 'done.'
+  write (stdout,'(1x,a)') 'done.'
   !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!
-!-- Now, with the RMSDs and rotational constants we can kick out duplicates
+!>-- Now, with the RMSDs and rotational constants we can kick out duplicates
   do i = 1,nall
     do j = 1,i - 1
-      !-- only check for structures in energy range
+      !>-- only check for structures in energy range
       de = (er(i) - er(j)) * autokcal
       if (de .lt. ethr) then
         !klong= linr(rmap1(i),rmap2(i),j)
@@ -1670,28 +1674,28 @@
       else
         cycle
       end if
-      !-- very small RMSD --> same structure
+      !>-- very small RMSD --> same structure
       if (dr .lt. rthr) then
-        double(i) = j !-- "i" is the same structure as "j"
-        !-- slightly larger RMSD, but same rot. constants --> same structure
+        double(i) = j !>-- "i" is the same structure as "j"
+        !>-- slightly larger RMSD, but same rot. constants --> same structure
       elseif (dr .lt. 2.0_wp * rthr) then
         l1 = equalrotaniso(i,j,nall,rot,0.5d0 * bthr,env%bthrmax,env%bthrshift)
         if (l1) then
-          double(i) = j  !-- "i" is the same structure as "j"
+          double(i) = j  !>-- "i" is the same structure as "j"
         end if
       end if
     end do
-    !-- find the original reference. k is a dummy variable
+    !>-- find the original reference. k is a dummy variable
     call backtrack(double,i,k)
   end do
   deallocate (c0,c1,at0)
   deallocate (ydum,xdum,Udum,gdum)
   deallocate (rmat)
 
-  !-- for ENSO write a file with duplicate info (if required)
+  !>-- for ENSO write a file with duplicate info (if required)
   call enso_duplicates(env,nall,double)
 
-!-- count how many duplicates we have found
+!>-- count how many duplicates we have found
   allocate (mask(nall))
   mask(:) = double(:) .ne. 0
   k = count(mask,1)
@@ -1700,7 +1704,7 @@
   write (ch,'(1x,a,i10)') 'number of doubles removed by rot/RMSD:',k
   !write(ch,*)'total number unique points remaining :',nallout
 
-!-- finally, determine conformer groups and their rotamers
+!>-- finally, determine conformer groups and their rotamers
   allocate (c1(3,nat))
   allocate (enuc(nall))
   do k = 1,nall
@@ -1715,28 +1719,28 @@
       end do
     end do
   end do
-!-- check energy, rot. const. and nuclear permutation
-  !double=0 !-- re-use "double"  !in this version we do not overwrite
+!>-- check energy, rot. const. and nuclear permutation
+  !double=0 !>-- re-use "double"  !in this version we do not overwrite
   SORTI: do i = 1,nall
     SORTJ: do j = 1,i - 1
-      !-- energy difference
+      !>-- energy difference
       de = (er(i) - er(j)) * autokcal
       l3 = double(j) .eq. 0
       if (.not. l3) cycle
       if (abs(de) .lt. ethr) then
-        !-- rotational constant difference
+        !>-- rotational constant difference
         l1 = equalrotaniso(i,j,nall,rot,bthr,env%bthrmax,env%bthrshift)
-        !-- nuclear permutation
+        !>-- nuclear permutation
         l2 = 2.0d0 * abs(enuc(i) - enuc(j)) / (enuc(i) + enuc(j)) .lt. 1.d-3
         if (l1 .and. l2 .and. l3) then
-          double(i) = j   !-- "i" is a rotamer of "j"
+          double(i) = j   !>-- "i" is a rotamer of "j"
           call backtrack(double,i,k)
           cycle SORTI
         end if
       end if
     end do SORTJ
   end do SORTI
-!-- assign conformer groups
+!>-- assign conformer groups
   k = 0
   group = 0
   do i = 1,nall
@@ -1748,7 +1752,7 @@
       group(i) = group(j)
     end if
   end do
-  group(0) = k !-- total number of groups
+  group(0) = k !>-- total number of groups
   write (ch,'(1x,a,i10)') 'number of removed rotamers           :', (nallout - k)
   nallout = k
   write (ch,'(1x,a,i10)') 'total number unique points remaining :',nallout
@@ -1802,6 +1806,8 @@
   use crest_parameters, id => dp
   use crest_data
   use strucrd
+  use miscdata, only: rcov
+  use utilities
   implicit none
   integer,intent(in) :: ch
   integer,intent(in) :: nat
@@ -1814,10 +1820,9 @@
   real(wp),allocatable :: cdum(:,:)
   integer :: ng,n
   integer :: i,j,k,l
-  integer :: lin
   logical :: ex
 
-  !--- arrays and variable for the analysis
+  !>--- arrays and variable for the analysis
   integer :: gmax
   integer,allocatable :: glist(:,:)
   integer :: current
@@ -1832,17 +1837,16 @@
   real(wp),allocatable :: tmp2(:)
   integer :: m,m1,m2,s1,s2,iat,j1,k2
 
-  !-- further NMR-mode related data
+  !>-- further NMR-mode related data
   integer,allocatable :: nmract(:)
   integer,allocatable :: elist(:,:),flist(:,:)
   integer,allocatable :: jnd(:)
   real(wp),allocatable :: sd(:,:),jfake(:),cn(:)
-  real(wp),allocatable :: rcov(:)
 
   character(len=:),allocatable :: atmp
   integer :: ig,ir,irr,nr
 
-!--- variable declarations
+!>--- variable declarations
   n = nat       !other variable name for number of atoms
   ng = group(0) !number of different groups (conformers)
   gmax = 0        !max number of
@@ -1865,10 +1869,10 @@
     glist(0,i) = k !number of members in group i
   end do
 
-!---distance neighbor list
+!>---distance neighbor list
   allocate (cdum(3,nat))
 
-!--- set up the "pair" array --> how many bonds are between two nuclei?
+!>--- set up the "pair" array --> how many bonds are between two nuclei?
   allocate (pair(n * (n + 1) / 2),metric(n,n),vis(n),pre(n),nb(200,n))
   cdum(1:3,1:n) = xyz(1:3,1:n,1) / bohr
   call neighdist(n,at,cdum,nb,metric)
@@ -1876,7 +1880,7 @@
   pair = 0
   do i = 1,n - 1
     do j = i + 1,n
-!---the shortest bond path
+!>---the shortest bond path
       current = j
       dum = shortest_distance(n,i,j,nb,metric,vis,pre)
       k = 0
@@ -1892,10 +1896,10 @@
   allocate (tmp2(n),relat(0:n,n))
   allocate (equiv(0:n,n,0:nall),dist(n,n,nall))
   equiv = 0
-!-- (costly) symmetry analyis of all rotamers for NMR. this is complicated stuff also
+!>-- (costly) symmetry analyis of all rotamers for NMR. this is complicated stuff also
 !   and the end of the program where this is completed...
   do i = 1,nall
-    call distance(n,xyz(1,1,i),dist(1,1,i))   ! distance matrix
+    call distance(n,xyz(:,:,i),dist(:,:,i))   ! distance matrix
     do j = 1,n
       do k = 1,n
         tmp2(k) = dist(k,j,i) * dble(at(k))  ! the distance of j to all atoms * Z to distinguish
@@ -1923,14 +1927,14 @@
     equiv(0:n,1:n,i) = relat(0:n,1:n)
   end do
   deallocate (dist)
-!-- symmetrize result i.e. if iat is in list of jat, jat must be in list of iat
+!>-- symmetrize result i.e. if iat is in list of jat, jat must be in list of iat
 !   done again at the end of this part
   do i = 1,ng
     do j1 = 1,n
       m1 = equiv(0,j1,i)
       do k = 1,m1
         iat = equiv(k,j1,i)
-!--            is atom j1 in the list of atom iat?
+!>--            is atom j1 in the list of atom iat?
         ex = .false.
         m2 = equiv(0,iat,i)
         do k2 = 1,m2
@@ -1944,7 +1948,7 @@
     end do
   end do
 
-!-- inlcude equivalence info from the other conformers as well i.e.
+!>-- inlcude equivalence info from the other conformers as well i.e.
 !   assume that all conformers have the same chemical equivalencies
 !   the result is put into equiv(:,:,0)
   equiv(0:n,1:n,0) = equiv(0:n,1:n,1)
@@ -1966,7 +1970,7 @@
     end do JLOOP
   end do ILOOP
 
-!--- NMR part and writeout
+!>--- NMR part and writeout
   !get NMR-active nuclei
   allocate (nmract(86))
   call cregen_nmract(ch,nmract)
@@ -1995,7 +1999,7 @@
       elist(1:n,k) = elist(1:n,k) + elist(1:n,i)
     end do
   end do
-!---  prepare write out
+!>---  prepare write out
   do i = 1,n
     k = 1
     equiv(1,i,ig) = i
@@ -2058,7 +2062,7 @@
       end do
     end do
   end do
-!---  symmetrize
+!>---  symmetrize
   do i = 1,n
     k = 1
     equiv(1,i,ig) = i
@@ -2077,7 +2081,7 @@
       elist(1:n,k) = elist(1:n,k) + elist(1:n,i)
     end do
   end do
-!---  prepare write out
+!>---  prepare write out
   do i = 1,n
     k = 1
     equiv(1,i,ig) = i
@@ -2116,8 +2120,6 @@
 !ccccccccccccccccccccc
   if (rotfil) then
     allocate (jfake(n * (n + 1) / 2),sd(n,n),cn(n))
-    allocate (rcov(94))
-    call setrcov(rcov)
     atmp = 'anmr_rotamer'
     open (unit=112,file=atmp,form='unformatted')
     !open(unit=112,file=fname)
@@ -2128,7 +2130,7 @@
       write (112) nr
       do ir = 1,nr
         irr = glist(ir,ig)
-        call distance(n,xyz(1,1,irr),sd)   ! distance matrix
+        call distance(n,xyz(:,:,irr),sd)   ! distance matrix
         cdum(1:3,1:n) = xyz(1:3,1:n,irr)
         call ncoord(n,rcov,at,cdum,cn,500.0d0)
         do i = 1,n - 1
@@ -2143,7 +2145,7 @@
       end do
     end do
     close (112)
-    deallocate (rcov,cn)
+    deallocate (cn)
     deallocate (sd,jfake)
   end if
 
@@ -2160,9 +2162,10 @@
   return
 end subroutine cregen_EQUAL
 
-!-- util to fill nmract array
+!>-- util to fill nmract array
 subroutine cregen_nmract(ch,nmract)
   use crest_parameters
+  use utilities
   implicit none
   integer :: nmract(86)
   character(len=:),allocatable :: atmp
@@ -2172,17 +2175,17 @@
   integer :: ch,ich2
 
   nmract = 0 !reset
-  !--- get NMR active nuclei
+  !>--- get NMR active nuclei
   atmp = '.anmrrc'  ! <--- name of the .anmrrc written by ENSO
   call getanmrrc(atmp,fail)
-  if (fail) then  !--- there is no .anmrrc from ENSO
+  if (fail) then  !>--- there is no .anmrrc from ENSO
     !write(ch,*)'NMR mode.'
     nmract = 0       ! all nuclei inactive
     nmract(1) = 1  ! H active
     !nmract(6) = 1  ! C active
     nmract(9) = 1  ! F active
     nmract(15) = 1  ! P active
-  else          !--- there IS a .anmrrc, and it is used.
+  else          !>--- there IS a .anmrrc, and it is used.
     write (ch,*) 'NMR mode. Reading <',trim(atmp),'> for atomic NMR data'
     open (newunit=ich2,file=atmp)
     read (ich2,'(a)') atmp
@@ -2216,6 +2219,7 @@
   use crest_parameters, id => dp 
   use crest_data
   use strucrd
+  use utilities
   implicit none
   integer,intent(in) :: nat
   integer,intent(in) :: nall
@@ -2231,33 +2235,16 @@
   integer :: ng,tmax
   integer :: i,j,k,l
 
-  !-- check if timetag info is present?
+  !>-- check if timetag info is present?
   ttag = .false.
-  !if(env%entropic)then
-  !  call getorigin(comments(1),atmp)
-  !  if(atmp(1:1)=='t') then
-  !   ttag=.true.
-  !   allocate(timetag(nall))
-  !   do i=1,nall
-  !     call getorigin(comments(i),atmp)
-  !     if(atmp(1:1)=='t')then !should work only with timetag flag
-  !      atmp=atmp(2:) !cut the "t"
-  !      read(atmp,*)timetag(i)
-  !     else
-  !      timetag(i)=1
-  !     endif
-  !   enddo
-  !   tmax=maxval(timetag,1)
-  !  endif
-  !endif
 
   ng = group(0)
   allocate (order(nall),orderref(nall))
-  !-- determine new order
+  !>-- determine new order
   k = 0
   if (ttag) then
     do i = 1,ng
-      do l = 1,tmax  !-- with timetag info
+      do l = 1,tmax  !>-- with timetag info
         do j = 1,nall
           if (group(j) .eq. i .and. timetag(j) .eq. l) then
             k = k + 1
@@ -2269,7 +2256,7 @@
     end do
   else
     do i = 1,ng
-      do j = 1,nall !-- without timetag info
+      do j = 1,nall !>-- without timetag info
         if (group(j) .eq. i) then
           k = k + 1
           orderref(k) = j
@@ -2279,7 +2266,7 @@
     end do
   end if
 
-  !-- sort xyz and comments
+  !>-- sort xyz and comments
   group(1:nall) = order(1:nall)
   order = orderref
   allocate (cdum(3,nat))
@@ -2391,6 +2378,7 @@
   use crest_parameters, only: wp
   use crest_data
   use strucrd
+  use utilities,only: boltz
   implicit none
   type(systemdata) :: env
   character(len=*) :: fname
@@ -2444,6 +2432,7 @@
   use crest_data
   use strucrd
   use iomod
+  use utilities
   implicit none
   type(systemdata) :: env
   character(len=*) :: cname
@@ -2569,7 +2558,7 @@
   integer :: degen(3,ng)
   integer :: i,ich
 
-  !--- how many rotamers per conformer
+  !>--- how many rotamers per conformer
   open (newunit=ich,file='cre_degen')
   write (ich,'(3x,i0)') ng
   do i = 1,ng
@@ -2593,7 +2582,7 @@
   integer :: ch
   logical :: pr
   integer :: TID,OMP_GET_NUM_THREADS,OMP_GET_THREAD_NUM,nproc
-!---- setting the threads for OMP parallel usage
+!>---- setting the threads for OMP parallel usage
   if (env%autothreads) then
     call ompautoset(env%threads,4,env%omp,env%MAXRUN,0) !mode=4 --> Program intern Threads max
 !$OMP PARALLEL PRIVATE(TID)
@@ -2687,6 +2676,7 @@
   use crest_data
   use strucrd
   use iomod,only:touch
+  use utilities, only: boltz
   implicit none
   integer :: ch
   type(systemdata) :: env
@@ -2728,7 +2718,7 @@
     end do
   end do
 
-  !-- really long energy list
+  !>-- really long energy list
   !write(ch,*)'  Erel/kcal     Etot      weight/tot conformer  set degen    origin'
   write (ch,'(7x,a,8x,a,1x,a,2x,a,5x,a,3x,a,5x,a)') 'Erel/kcal','Etot', &
   &    'weight/tot','conformer','set','degen','origin'
@@ -2757,7 +2747,7 @@
     ch = chref
   end if
 
-  !-- file for the '-compare' mode
+  !>-- file for the '-compare' mode
   if (env%compareens) then
     open (newunit=ich,file='.cretrack')
     write (ich,'(5x,i0)') ng
@@ -2767,7 +2757,7 @@
     close (ich)
   end if
 
-  !-- some ensemble data, entropy and G (including all structures)
+  !>-- some ensemble data, entropy and G (including all structures)
   A0 = 0
   eav = 0
   do i = 1,nall
@@ -2781,9 +2771,9 @@
 
   write (ch,'(''T /K                                  :'', F9.2)') T
   write (ch,'(''E lowest                              :'',f12.5)') eref
-  !---- elow printout in between routines
+  !>---- elow printout in between routines
   if (.not. env%confgo) then
-    write (*,'(1x,''E lowest :'',f12.5)') eref
+    write (stdout,'("CREGEN> E lowest :",f12.5)') eref
   end if
   if (env%QCG) then
     write (ch,'(''ensemble average energy (kcal)        :'', F14.8)') eav
@@ -2796,7 +2786,7 @@
   end if
   write (ch,'(''population of lowest in %             : '',F8.3)') pg(1) * 100.d0
 
-  !-- some ensemble data, entropy and G (including only unique conformers)
+  !>-- some ensemble data, entropy and G (including only unique conformers)
   allocate (egrp(ng),source=0.0_wp)
   do i = 1,ng
     a = degen(2,i)
@@ -2813,7 +2803,7 @@
   ss = -1000.0d0 * g / T
   env%emtd%sapprox = ss  ! save for entropy mode
 
-  !-- MF-MD-GC legacy option
+  !>-- MF-MD-GC legacy option
   if ((env%crestver .eq. 1) .and. (.not. env%confgo)) then
     inquire (file='.tmpxtbmodef',exist=ex)
     if (ex) then
Index: src/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\n\nadd_subdirectory(\"parsing\")\nadd_subdirectory(\"optimize\")\nadd_subdirectory(\"calculator\")\nadd_subdirectory(\"algos\")\nadd_subdirectory(\"dynamics\")\nadd_subdirectory(\"qcg\")\nadd_subdirectory(\"qmhelpers\")\nadd_subdirectory(\"graphs\")\nadd_subdirectory(\"rigidconf\")\nadd_subdirectory(\"discretize\")\nadd_subdirectory(\"entropy\")\nadd_subdirectory(\"legacy_algos\")\n\n\nset(dir \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\nlist(APPEND srcs\n  \"${dir}/atmasses.f90\"\n  \"${dir}/axis_module.f90\"\n  \"${dir}/biasmerge.f90\"\n  \"${dir}/bondconstraint.f90\"\n  \"${dir}/ccegen.f90\"\n  \"${dir}/choose_settings.f90\"\n  \"${dir}/classes.f90\"\n  \"${dir}/cleanup.f90\"\n  \"${dir}/compress.f90\"\n  \"${dir}/confparse.f90\"\n  \"${dir}/constraining.f90\"\n  \"${dir}/cregen.f90\"\n  \"${dir}/crest_pars.f90\"\n  \"${dir}/data.f90\"\n  \"${dir}/ensemblecomp.f90\"\n  \"${dir}/eval_timer.f90\"\n  \"${dir}/filemod.f90\"\n  \"${dir}/flexi.F90\"\n  \"${dir}/freqmasses.f90\"\n  \"${dir}/geo.f90\"\n  \"${dir}/identifiers.f90\"\n  \"${dir}/internals.f90\"\n  \"${dir}/internals2.f90\"\n  \"${dir}/io.f\"\n  \"${dir}/iomod.F90\"\n  \"${dir}/legacy_wrappers.f90\"\n  \"${dir}/ls_rmsd.f90\"\n  \"${dir}/marqfit.f90\"\n  \"${dir}/minitools.f90\"\n  \"${dir}/msmod.f90\"\n  \"${dir}/msreact.f90\"\n  \"${dir}/ncigeo.f90\"\n  \"${dir}/neighbor.f\"\n  \"${dir}/ompmklset.F90\"\n  \"${dir}/printouts.f90\"\n  \"${dir}/prmat.f90\"\n  \"${dir}/progressbar.f90\"\n  \"${dir}/propcalc.f90\"\n  \"${dir}/quicksort.f90\"\n  \"${dir}/readl.f90\"\n  \"${dir}/rotcompare.f90\"\n  \"${dir}/scratch.f90\"\n  \"${dir}/sdfio.f90\"\n  \"${dir}/select.f90\"\n  \"${dir}/signal.c\"\n  \"${dir}/sigterm.f90\"\n  \"${dir}/sortens.f90\"\n  \"${dir}/spline.f90\"\n  \"${dir}/strucreader.f90\"\n  \"${dir}/symmetry2.f90\"\n  \"${dir}/symmetry_i.c\"\n  \"${dir}/testmol.f90\"\n  \"${dir}/timer.f90\"\n  \"${dir}/trackorigin.f90\"\n  \"${dir}/utilities.f\"\n  \"${dir}/zdata.f90\"\n  \"${dir}/zsort.f90\"\n  \"${dir}/ztopology.f90\"\n)\n\nlist(APPEND prog\n  \"${dir}/crest_main.f90\"\n)\n\nset(srcs ${srcs} PARENT_SCOPE)\nset(prog ${prog} PARENT_SCOPE)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
--- a/src/CMakeLists.txt	
+++ b/src/CMakeLists.txt	
@@ -42,10 +42,8 @@
   "${dir}/cleanup.f90"
   "${dir}/compress.f90"
   "${dir}/confparse.f90"
-  "${dir}/constraining.f90"
   "${dir}/cregen.f90"
   "${dir}/crest_pars.f90"
-  "${dir}/data.f90"
   "${dir}/ensemblecomp.f90"
   "${dir}/eval_timer.f90"
   "${dir}/filemod.f90"
@@ -55,16 +53,15 @@
   "${dir}/identifiers.f90"
   "${dir}/internals.f90"
   "${dir}/internals2.f90"
-  "${dir}/io.f"
   "${dir}/iomod.F90"
   "${dir}/legacy_wrappers.f90"
   "${dir}/ls_rmsd.f90"
   "${dir}/marqfit.f90"
   "${dir}/minitools.f90"
+  "${dir}/miscdata.f90"
   "${dir}/msmod.f90"
   "${dir}/msreact.f90"
   "${dir}/ncigeo.f90"
-  "${dir}/neighbor.f"
   "${dir}/ompmklset.F90"
   "${dir}/printouts.f90"
   "${dir}/prmat.f90"
@@ -72,6 +69,7 @@
   "${dir}/propcalc.f90"
   "${dir}/quicksort.f90"
   "${dir}/readl.f90"
+  "${dir}/restartlog.f90"
   "${dir}/rotcompare.f90"
   "${dir}/scratch.f90"
   "${dir}/sdfio.f90"
@@ -86,9 +84,9 @@
   "${dir}/testmol.f90"
   "${dir}/timer.f90"
   "${dir}/trackorigin.f90"
-  "${dir}/utilities.f"
+  "${dir}/utilmod.f90"
+  "${dir}/wallsetup.f90"
   "${dir}/zdata.f90"
-  "${dir}/zsort.f90"
   "${dir}/ztopology.f90"
 )
 
Index: src/scratch.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!===================================================================================================!\n!c scratch dir handling\n!===================================================================================================!\nsubroutine scrdir(env)\n      use iso_fortran_env, wp => real64\n      use crest_data\n      use iomod\n\n      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n\n      integer :: ich,io\n\n      if(len_trim(env%scratchdir).lt.1)then\n         call command('mktemp -d > tmpconf 2>/dev/null', io)\n         open(newunit=ich,file='tmpconf')\n         read(ich,'(a)',iostat=io) env%scratchdir\n         if(io < 0 ) then   ! if mktemp failed and tmpconf is empty\n            env%scratchdir=''\n            return\n         endif\n         close(ich,status='delete')\n      endif\n\n      write(*,'(a,a)') 'Using scratch directory: ',trim((env%scratchdir))\n\n      io = makedir(trim(env%scratchdir))\n\n      if (env%crestver .eq. crest_solv) then\n         call copy('solute',trim(env%scratchdir)//'/'//'solute')\n         call copy('solvent',trim(env%scratchdir)//'/'//'solvent')\n      else\n         call copy('coord',trim(env%scratchdir)//'/'//'coord')\n      end if\n      call copy('.CHRG',trim(env%scratchdir)//'/'//'.CHRG')\n      call copy('.UHF',trim(env%scratchdir)//'/'//'.UHF')\n      call copy(env%fixfile,trim(env%scratchdir)//'/'//trim(env%fixfile))\n      call copy(env%ensemblename,trim(env%scratchdir)//'/'//trim(env%ensemblename))\n      call copy(env%constraints,trim(env%scratchdir)//'/'//trim(env%constraints))\n      call copy(trim(env%fixfile),trim(env%scratchdir)//'/'//trim(env%fixfile))\n\n      io = sylnk(trim(env%scratchdir),'./scratch')\n\n      call chdir(trim(env%scratchdir))\n\nend subroutine scrdir\n\nsubroutine scrend(env)\n      use iso_fortran_env, wp => real64\n      use crest_data\n      use iomod\n\n      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA\n      character(len=1024) :: crefi,crefi2\n      logical :: ex\n\n      if(len_trim(env%scratchdir).lt.1)then\n         return\n      endif\n\n      call copy(trim(env%scratchdir)//'/'//'coord','coord')\n      call copy(trim(env%scratchdir)//'/'//conformerfile,conformerfile)\n      call checkname_xyz(trim(env%scratchdir)//'/'//crefile,crefi,crefi2)\n      call copy(trim(crefi),crefile//'.xyz')\n\n      inquire(file=trim(env%scratchdir)//'/'//conformerfilebase//'.sdf',exist=ex)\n      if(ex)then\n        call copy(trim(env%scratchdir)//'/'//conformerfilebase//'.sdf',conformerfilebase//'.sdf')\n      endif\n\n      inquire(file=trim(env%scratchdir)//'/'//ensemblefile,exist=ex)\n      if(ex)then\n        call copy(trim(env%scratchdir)//'/'//ensemblefile,ensemblefile)\n      endif\n\n      call command('cp -r '//trim(env%scratchdir)//'/* ./')\n\n      if(.not.env%keepScratch)then\n      call rmrf(env%scratchdir)\n      endif\n \n      return \nend subroutine scrend\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/scratch.f90 b/src/scratch.f90
--- a/src/scratch.f90	
+++ b/src/scratch.f90	
@@ -17,85 +17,69 @@
 ! along with crest.  If not, see <https://www.gnu.org/licenses/>.
 !================================================================================!
 
-!===================================================================================================!
-!c scratch dir handling
-!===================================================================================================!
+!> scratch directory handling (for simplicity just use shell commands)
+
+!=========================================================================================!
 subroutine scrdir(env)
-      use iso_fortran_env, wp => real64
-      use crest_data
-      use iomod
-
-      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
-
-      integer :: ich,io
+  use crest_parameters
+  use crest_data
+  use iomod
+  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
+  integer :: ich,io
 
-      if(len_trim(env%scratchdir).lt.1)then
-         call command('mktemp -d > tmpconf 2>/dev/null', io)
-         open(newunit=ich,file='tmpconf')
-         read(ich,'(a)',iostat=io) env%scratchdir
-         if(io < 0 ) then   ! if mktemp failed and tmpconf is empty
-            env%scratchdir=''
-            return
-         endif
-         close(ich,status='delete')
-      endif
+  if (len_trim(env%scratchdir) .lt. 1) then
+    call command('mktemp -d > tmpconf 2>/dev/null',io)
+    open (newunit=ich,file='tmpconf')
+    read (ich,'(a)',iostat=io) env%scratchdir
+    if (io < 0) then   ! if mktemp failed and tmpconf is empty
+      env%scratchdir = ''
+      error stop 'Failed to create scratch directory!'
+      return
+    end if
+    close (ich,status='delete')
+  end if
 
-      write(*,'(a,a)') 'Using scratch directory: ',trim((env%scratchdir))
-
-      io = makedir(trim(env%scratchdir))
+  write (stdout,'(a,a)') 'Home directory          : ',trim(env%homedir)
+  write (stdout,'(a,a)') 'Using scratch directory : ',trim((env%scratchdir))
+  io = makedir(trim(env%scratchdir))
 
-      if (env%crestver .eq. crest_solv) then
-         call copy('solute',trim(env%scratchdir)//'/'//'solute')
-         call copy('solvent',trim(env%scratchdir)//'/'//'solvent')
-      else
-         call copy('coord',trim(env%scratchdir)//'/'//'coord')
-      end if
-      call copy('.CHRG',trim(env%scratchdir)//'/'//'.CHRG')
-      call copy('.UHF',trim(env%scratchdir)//'/'//'.UHF')
-      call copy(env%fixfile,trim(env%scratchdir)//'/'//trim(env%fixfile))
-      call copy(env%ensemblename,trim(env%scratchdir)//'/'//trim(env%ensemblename))
-      call copy(env%constraints,trim(env%scratchdir)//'/'//trim(env%constraints))
-      call copy(trim(env%fixfile),trim(env%scratchdir)//'/'//trim(env%fixfile))
+  call copy('.CHRG',trim(env%scratchdir)//'/'//'.CHRG')
+  call copy('.UHF',trim(env%scratchdir)//'/'//'.UHF')
+
+  write(stdout,'(a)',advance='no') 'Copying data to scratch directory ...'
+  flush(stdout)
+  call command('scp -r ./* '//trim(env%scratchdir)//'/') 
+  write(stdout,*) 'done.'
 
-      io = sylnk(trim(env%scratchdir),'./scratch')
+
 
-      call chdir(trim(env%scratchdir))
+  call chdir(trim(env%scratchdir))
 
 end subroutine scrdir
 
 subroutine scrend(env)
-      use iso_fortran_env, wp => real64
-      use crest_data
-      use iomod
-
-      type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
-      character(len=1024) :: crefi,crefi2
-      logical :: ex
+  use crest_parameters
+  use crest_data
+  use iomod
+  type(systemdata) :: env    ! MAIN STORAGE OS SYSTEM DATA
+  character(len=1024) :: crefi,crefi2
+  logical :: ex
 
-      if(len_trim(env%scratchdir).lt.1)then
-         return
-      endif
+  if (len_trim(env%scratchdir) .lt. 1) then
+    return
+  end if
 
-      call copy(trim(env%scratchdir)//'/'//'coord','coord')
-      call copy(trim(env%scratchdir)//'/'//conformerfile,conformerfile)
-      call checkname_xyz(trim(env%scratchdir)//'/'//crefile,crefi,crefi2)
-      call copy(trim(crefi),crefile//'.xyz')
-
-      inquire(file=trim(env%scratchdir)//'/'//conformerfilebase//'.sdf',exist=ex)
-      if(ex)then
-        call copy(trim(env%scratchdir)//'/'//conformerfilebase//'.sdf',conformerfilebase//'.sdf')
-      endif
-
-      inquire(file=trim(env%scratchdir)//'/'//ensemblefile,exist=ex)
-      if(ex)then
-        call copy(trim(env%scratchdir)//'/'//ensemblefile,ensemblefile)
-      endif
-
-      call command('cp -r '//trim(env%scratchdir)//'/* ./')
+  write(stdout,'(/,a)',advance='no') 'Retrieving data from scratch directory ...'
+  flush(stdout) 
+  call command('scp -r '//trim(env%scratchdir)//'/* '//trim(env%homedir)//'/')
+  write(stdout,*) 'done.'
 
-      if(.not.env%keepScratch)then
-      call rmrf(env%scratchdir)
-      endif
- 
-      return 
+  if (.not.env%keepScratch) then
+    write(stdout,'(a)',advance='no') 'Removing scratch directory ...'
+    flush(stdout)
+    call rmrf(env%scratchdir)
+    write(stdout,*) 'done.'
+  end if
+
+  return
 end subroutine scrend
Index: src/ncigeo.f90
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>!================================================================================!\n! This file is part of crest.\n!\n! Copyright (C) 2018-2020 Philipp Pracht\n!\n! crest is free software: you can redistribute it and/or modify it under\n! the terms of the GNU Lesser General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! crest is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU Lesser General Public License for more details.\n!\n! You should have received a copy of the GNU Lesser General Public License\n! along with crest.  If not, see <https://www.gnu.org/licenses/>.\n!================================================================================!\n\n!========================================================================================!\n! calculate settings for an elipsoid wall potential\n!========================================================================================!\nsubroutine wallpot(env)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use strucrd,only:rdnat,rdcoord,wrc0\n  use axis_module\n  implicit none\n  type(systemdata) :: env\n\n  integer :: nat\n  integer,allocatable  :: at(:)\n  real(wp),allocatable :: xyz(:,:)\n  real(wp) :: eaxr(3),rabc(3)\n  real(wp) :: rmax\n  real(wp) :: sola,vtot\n  real(wp) :: r,roff,boxr\n  real(wp) :: pshape\n  real(wp) :: volsum\n  real(wp) :: natfac,erffac,erfscal\n  logical :: pr = .false.\n\n  real(wp),parameter :: pi43 = 3.1415926540_wp * (4.0_wp / 3.0_wp)\n  real(wp),parameter :: pi = 3.1415926540_wp\n  real(wp),parameter :: third = 1.0_wp / 3.0_wp\n\n  allocate (env%cts%pots(10))\n  env%cts%pots = ''\n  !env%cts%NCI = env%NCI\n  env%cts%NCI = .true.\n\n  pshape = 1.0d0\n\n  nat = env%nat\n  eaxr = 0.0d0\n\n!--- read in coord\n  allocate (xyz(3,nat),at(nat))\n  call rdcoord('coord',nat,at,xyz)\n\n!--- CMA trafo\n  call axis(pr,nat,at,xyz,eaxr)\n  sola = sqrt(1.0d0 + (abs(eaxr(1) - eaxr(3))) / (abs(eaxr(1) + eaxr(2) + eaxr(3)) / 3.0d0))\n  call getmaxdist(nat,xyz,at,rmax)\n  vtot = volsum(nat,at) !--- volume as sum of speherical atoms (crude approximation)\n\n!--- calculate ellipsoid\n  roff = sola * vtot / 1000.0d0\n  boxr = ((sola * vtot) / pi43)**third + roff + rmax * 0.5_wp\n  r = (boxr**3 / (eaxr(1) * eaxr(2) * eaxr(3)))**third  ! volume of ellipsoid = volume of sphere\n  rabc = eaxr**pshape / sum((eaxr(1:3))**pshape)\n\n  !> scale pot size by number of atoms\n  !> pure empirics\n  natfac = 0.08_wp * nat - 0.08_wp * 50.0_wp\n  erffac = erf(natfac) * 0.25_wp\n  erfscal = 1.0_wp - erffac\n  !> erfscal is ~ 1.25 for systems <<50 atoms\n  !> erfscal is ~ 0.75 for systems >>50 atoms\n  rabc = eaxr * r * env%potscal * erfscal * 1.5_wp\n\n!--- write CMA transformed coord file\n  call wrc0('coord',env%nat,at,xyz)\n  call dummypot(rabc,xyz,at,env%nat)\n\n  deallocate (at,xyz)\n\n  write (env%cts%pots(1),'(\"$wall\")')\n  write (env%cts%pots(2),'(2x,\"potential=polynomial\")')\n  write (env%cts%pots(3),'(2x,\"ellipsoid:\",1x,3(g0,\",\",1x),\"all\")') rabc\n\n  return\nend subroutine wallpot\n!============================================================================\n! only calculate the ellipsoide wall potential\n!============================================================================\nsubroutine wallpot_calc(nat,at,xyz,rabc)\n  use iso_fortran_env,wp => real64\n  use axis_module\n  implicit none\n  integer,intent(in)     :: nat\n  integer,intent(inout)  :: at(nat)\n  real(wp),intent(inout) :: xyz(3,nat)\n  real(wp),intent(out)   :: rabc(3)     !potential ellipsoide-axis\n  real(wp) :: eaxr(3)\n  real(wp) :: rmax\n  real(wp) :: sola,vtot\n  real(wp) :: r,roff,boxr\n  real(wp) :: pshape\n  real(wp) :: volsum\n  real(wp) :: natfac,erffac,erfscal\n  logical :: pr = .false.\n  real(wp),parameter :: pi43 = 3.1415926540_wp * (4.0_wp / 3.0_wp)\n  real(wp),parameter :: pi = 3.1415926540_wp\n  real(wp),parameter :: third = 1.0_wp / 3.0_wp\n  rabc = 0.0d0\n  pshape = 1.0d0\n  eaxr = 0.0d0\n\n!--- CMA trafo\n  call axis(pr,nat,at,xyz,eaxr)\n  sola = sqrt(1.0d0 + (eaxr(1) - eaxr(3)) / ((eaxr(1) + eaxr(2) + eaxr(3)) / 3.0d0))\n  call getmaxdist(nat,xyz,at,rmax)\n  vtot = volsum(nat,at) !--- volume as sum of spherical atoms (crude approximation)\n!--- calculate ellipsoid\n  roff = sola * vtot / 1000.0d0\n  boxr = ((sola * vtot) / pi43)**third + roff + rmax * 0.5\n  r = (boxr**3 / (eaxr(1) * eaxr(2) * eaxr(3)))**third  ! volume of ellipsoid = volume of sphere\n  rabc = eaxr**pshape / sum((eaxr(1:3))**pshape)\n!--- scale pot size by number of atoms\n  natfac = 0.08_wp * nat - 0.08_wp * 50.0_wp\n  erffac = erf(natfac) * 0.25_wp\n  erfscal = 1.0_wp - erffac\n\n  rabc = eaxr * r * erfscal * 1.5_wp\n  return\nend subroutine wallpot_calc\n\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine getmaxdist(n,xyz,at,dist)\n  use iso_fortran_env,wp => real64\n  implicit none\n  integer :: n\n  integer :: at(n)\n  integer :: i\n  real(wp) :: xyz(3,n)\n  real(wp) :: dist\n  real(wp) :: dum\n  real(wp),allocatable :: rcov(:)\n\n  allocate (rcov(94))\n  call setrcov(rcov)\n  dist = 0.0d0\n\n  do i = 1,n\n    dum = sqrt(xyz(1,i)**2 + xyz(2,i)**2 + xyz(3,i)**2)\n    dum = dum + rcov(at(i))\n    if (dum .gt. dist) dist = dum\n  end do\n\n  deallocate (rcov)\n\nend subroutine getmaxdist\n\n!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n!c\n!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nsubroutine dummypot(ellips,xyz,at,nat)\n  use iso_fortran_env,wp => real64\n  use crest_data\n  use strucrd,only:i2e\n  implicit none\n\n  integer :: i\n  integer :: nat,ich\n  integer :: at(nat)\n\n  real(wp) :: xyz(3,nat)\n  real(wp) :: r,dum\n  real(wp) :: ellips(3)\n\n  real(wp) :: point(3)\n\n!---- ellipsoide has to statisfy x²/a² + y²/b² + z²/c² = 1\n\n  call init_random_seed()\n  open (file='wall.coord',newunit=ich)\n  write (ich,'(a)') \"$coord\"\n\n  do i = 1,nat\n    write (ich,'(3F24.12,5x,a2)') xyz(1:3,i),i2e(at(i))\n  end do\n\n  point = 0.0d0\n  do i = 1,100\n    call random_number(r)\n    point(1) = r * ellips(1)\n    do\n      call random_number(r)\n      point(2) = r * ellips(2)\n      dum = (point(1)**2 / ellips(1)**2)  &\n      &    + (point(2)**2 / ellips(2)**2)\n      if (dum .lt. 1.0d0) exit\n    end do\n    dum = 1.0d0 - (point(1)**2 / ellips(1)**2) - (point(2)**2 / ellips(2)**2)\n    dum = dum * ellips(3)**2\n\n    point(3) = sqrt(dum)\n\n    write (ich,'(3F24.12,5x,a2)') point(1:3),'he'\n    write (ich,'(3F24.12,5x,a2)') - 1 * point(1:3),'he'\n    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),point(2),point(3),'he'\n    write (ich,'(3F24.12,5x,a2)') point(1),-1 * point(2),point(3),'he'\n    write (ich,'(3F24.12,5x,a2)') point(1),point(2),-1 * point(3),'he'\n    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),-1 * point(2),point(3),'he'\n    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),point(2),-1 * point(3),'he'\n    write (ich,'(3F24.12,5x,a2)') point(1),-1 * point(2),-1 * point(3),'he'\n  end do\n\n  write (ich,'(a)') \"$end\"\n  close (ich)\nend subroutine dummypot\n\nSUBROUTINE init_random_seed()\n  INTEGER :: i,n,clock\n  INTEGER,DIMENSION(:),ALLOCATABLE :: seed\n\n  CALL RANDOM_SEED(size=n)\n  ALLOCATE (seed(n))\n\n  CALL SYSTEM_CLOCK(COUNT=clock)\n\n  seed = clock + 37 * (/(i - 1,i=1,n)/)\n  CALL RANDOM_SEED(PUT=seed)\n\n  DEALLOCATE (seed)\nEND SUBROUTINE\n\n!---- set up  a box around the molecule. the return value is the box volume\nfunction getbox(n,xyz,box)\n  use iso_fortran_env,wp => real64\n  implicit none\n  real(wp) :: getbox\n  integer,intent(in)  :: n\n  real(wp),intent(in) :: xyz(3,n)\n  real(wp),intent(out) :: box(3,3)\n  integer :: i\n  box = 0.0_wp\n  getbox = 1.0_wp\n  do i = 1,3 !i are the X,Y,Z axis\n    box(i,1) = maxval(xyz(i,:))\n    box(i,2) = minval(xyz(i,:))\n    box(i,3) = abs(box(i,1) - box(i,2)) !side length\n    getbox = getbox * box(i,3)          !to volume\n  end do\n  return\nend function getbox\n!---- set up  a box around the molecule. the return value is the box volume\nfunction getbox2(n,xyz,at,box)\n  use iso_fortran_env,wp => real64\n  implicit none\n  real(wp) :: getbox2\n  integer,intent(in)  :: n\n  real(wp),intent(in) :: xyz(3,n)\n  real(wp),intent(out) :: box(3,3)\n  integer,intent(in) :: at(n)\n  integer :: i\n  real(wp),allocatable :: rcov(:),rat(:)\n  real(wp) :: rcovmax\n  allocate (rcov(94),rat(n))\n  call setrcov(rcov)\n  do i = 1,n\n    rat(i) = rcov(at(i))\n  end do\n  rcovmax = maxval(rat)\n  box = 0.0_wp\n  getbox2 = 1.0_wp\n  do i = 1,3 !i are the X,Y,Z axis\n    box(i,1) = maxval(xyz(i,:))\n    box(i,2) = minval(xyz(i,:))\n    box(i,3) = abs(box(i,1) - box(i,2)) !side length\n    if (box(i,3) .lt. 1d-6) then\n      box(i,1) = rcovmax\n      box(i,2) = -rcovmax\n      box(i,3) = rcovmax * 2.0_wp\n    end if\n    getbox2 = getbox2 * box(i,3)          !to volume\n  end do\n  deallocate (rat,rcov)\n  return\nend function getbox2\n\n!---- get the volume simply as a sum of spherical atom volumes (crude approximation)\nfunction volsum(n,at)\n  use iso_fortran_env,wp => real64\n  implicit none\n  real(wp) :: volsum\n  integer,intent(in)  :: n\n  integer,intent(in) :: at(n)\n  integer :: i\n  real(wp),allocatable :: rcov(:)\n  real(wp) :: r\n  allocate (rcov(94))\n  !--- D3 radii in Bohr\n  rcov = (/ &\n   &  2.18230009,1.73469996,3.49559999,3.09820008,3.21600008, &\n   &  2.91030002,2.62249994,2.48169994,2.29959989,2.13739991, &\n   &  3.70819998,3.48390007,4.01060009,3.79169989,3.50169992, &\n   &  3.31069994,3.10459995,2.91479993,4.24109983,4.10349989, &\n   &  3.89030004,3.76419997,3.72110009,3.44140005,3.54620004, &\n   &  3.44210005,3.43269992,3.34619999,3.30080009,3.23090005, &\n   &  3.95790005,3.86190009,3.66249990,3.52679992,3.36619997, &\n   &  3.20959997,4.61759996,4.47639990,4.21960020,4.05970001, &\n   &  3.85960007,3.75430012,3.56900001,3.46230006,3.39750004, &\n   &  3.35249996,3.33080006,3.46199989,4.26230001,4.18739986, &\n   &  4.01499987,3.89010000,3.73799992,3.58890009,5.05670023, &\n   &  5.18139982,4.62610006,4.62010002,4.57019997,4.52710009, &\n   &  4.48960018,4.45149994,4.42339993,4.12430000,4.24270010, &\n   &  4.15409994,4.27939987,4.24499989,4.22079992,4.19859982, &\n   &  4.01300001,4.24499989,4.09800005,3.98550010,3.89549994, &\n   &  3.74900007,3.44560003,3.35249996,3.25640011,3.35990000, &\n   &  4.31269979,4.27640009,4.11749983,4.00540018,3.86439991, &\n   &  3.72160006,5.07959986,4.92939997,4.70429993,4.42519999, &\n   &  4.45940018,4.39569998,4.35389996,4.43410015/)\n  volsum = 0.0_wp\n  do i = 1,n\n    r = rcov(at(i))\n    volsum = volsum + (4.0_wp / 3.0_wp) * (3.14159265359_wp * r**3)\n  end do\n  deallocate (rcov)\n  return\nend function volsum\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ncigeo.f90 b/src/ncigeo.f90
--- a/src/ncigeo.f90	
+++ b/src/ncigeo.f90	
@@ -21,10 +21,12 @@
 ! calculate settings for an elipsoid wall potential
 !========================================================================================!
 subroutine wallpot(env)
-  use iso_fortran_env,wp => real64
+  use crest_parameters
   use crest_data
-  use strucrd,only:rdnat,rdcoord,wrc0
+  use strucrd,only:rdnat,rdcoord,wrc0,coord
   use axis_module
+  use crest_calculator
+  use wall_setup
   implicit none
   type(systemdata) :: env
 
@@ -40,296 +42,41 @@
   real(wp) :: natfac,erffac,erfscal
   logical :: pr = .false.
 
-  real(wp),parameter :: pi43 = 3.1415926540_wp * (4.0_wp / 3.0_wp)
-  real(wp),parameter :: pi = 3.1415926540_wp
+  type(coord) :: mol
+  type(constraint) :: constr
+  logical,allocatable :: atms(:)
+
+  real(wp),parameter :: pi43 = pi * (4.0_wp / 3.0_wp)
   real(wp),parameter :: third = 1.0_wp / 3.0_wp
-
+  real(wp),parameter :: kdefault = 1.0_wp  !> xtb version doesn't use k
+  real(wp),parameter :: alphadefault = 30.0_wp !> polynomial default in xtb
+!=========================================================!
   allocate (env%cts%pots(10))
   env%cts%pots = ''
-  !env%cts%NCI = env%NCI
   env%cts%NCI = .true.
 
-  pshape = 1.0d0
-
-  nat = env%nat
-  eaxr = 0.0d0
+!>--- read in coord
+  call env%ref%to(mol)
 
-!--- read in coord
-  allocate (xyz(3,nat),at(nat))
-  call rdcoord('coord',nat,at,xyz)
+!>--- calculate the surrounding ellipsoid
+  call wallpot_core(mol,rabc, potscal=env%potscal) 
 
-!--- CMA trafo
-  call axis(pr,nat,at,xyz,eaxr)
-  sola = sqrt(1.0d0 + (abs(eaxr(1) - eaxr(3))) / (abs(eaxr(1) + eaxr(2) + eaxr(3)) / 3.0d0))
-  call getmaxdist(nat,xyz,at,rmax)
-  vtot = volsum(nat,at) !--- volume as sum of speherical atoms (crude approximation)
+!>--- write CMA transformed coord file
+  call wrc0('coord',env%nat,mol%at,mol%xyz)
+  call wall_dummypot(rabc,mol%xyz,mol%at,mol%nat)
 
-!--- calculate ellipsoid
-  roff = sola * vtot / 1000.0d0
-  boxr = ((sola * vtot) / pi43)**third + roff + rmax * 0.5_wp
-  r = (boxr**3 / (eaxr(1) * eaxr(2) * eaxr(3)))**third  ! volume of ellipsoid = volume of sphere
-  rabc = eaxr**pshape / sum((eaxr(1:3))**pshape)
-
-  !> scale pot size by number of atoms
-  !> pure empirics
-  natfac = 0.08_wp * nat - 0.08_wp * 50.0_wp
-  erffac = erf(natfac) * 0.25_wp
-  erfscal = 1.0_wp - erffac
-  !> erfscal is ~ 1.25 for systems <<50 atoms
-  !> erfscal is ~ 0.75 for systems >>50 atoms
-  rabc = eaxr * r * env%potscal * erfscal * 1.5_wp
-
-!--- write CMA transformed coord file
-  call wrc0('coord',env%nat,at,xyz)
-  call dummypot(rabc,xyz,at,env%nat)
-
-  deallocate (at,xyz)
-
+!>--- constraint in legacy framework
   write (env%cts%pots(1),'("$wall")')
   write (env%cts%pots(2),'(2x,"potential=polynomial")')
   write (env%cts%pots(3),'(2x,"ellipsoid:",1x,3(g0,",",1x),"all")') rabc
 
+!>--- add constraint in calculator framwork
+  if(.not.env%legacy)then
+    allocate(atms(mol%nat), source=.true.) !> all atoms
+    call constr%ellipsoid( mol%nat, atms,rabc, kdefault,alphadefault,.false.)
+    deallocate(atms)
+    !call constr%print(stdout)
+    call env%calc%add(constr)
+  endif
   return
 end subroutine wallpot
-!============================================================================
-! only calculate the ellipsoide wall potential
-!============================================================================
-subroutine wallpot_calc(nat,at,xyz,rabc)
-  use iso_fortran_env,wp => real64
-  use axis_module
-  implicit none
-  integer,intent(in)     :: nat
-  integer,intent(inout)  :: at(nat)
-  real(wp),intent(inout) :: xyz(3,nat)
-  real(wp),intent(out)   :: rabc(3)     !potential ellipsoide-axis
-  real(wp) :: eaxr(3)
-  real(wp) :: rmax
-  real(wp) :: sola,vtot
-  real(wp) :: r,roff,boxr
-  real(wp) :: pshape
-  real(wp) :: volsum
-  real(wp) :: natfac,erffac,erfscal
-  logical :: pr = .false.
-  real(wp),parameter :: pi43 = 3.1415926540_wp * (4.0_wp / 3.0_wp)
-  real(wp),parameter :: pi = 3.1415926540_wp
-  real(wp),parameter :: third = 1.0_wp / 3.0_wp
-  rabc = 0.0d0
-  pshape = 1.0d0
-  eaxr = 0.0d0
-
-!--- CMA trafo
-  call axis(pr,nat,at,xyz,eaxr)
-  sola = sqrt(1.0d0 + (eaxr(1) - eaxr(3)) / ((eaxr(1) + eaxr(2) + eaxr(3)) / 3.0d0))
-  call getmaxdist(nat,xyz,at,rmax)
-  vtot = volsum(nat,at) !--- volume as sum of spherical atoms (crude approximation)
-!--- calculate ellipsoid
-  roff = sola * vtot / 1000.0d0
-  boxr = ((sola * vtot) / pi43)**third + roff + rmax * 0.5
-  r = (boxr**3 / (eaxr(1) * eaxr(2) * eaxr(3)))**third  ! volume of ellipsoid = volume of sphere
-  rabc = eaxr**pshape / sum((eaxr(1:3))**pshape)
-!--- scale pot size by number of atoms
-  natfac = 0.08_wp * nat - 0.08_wp * 50.0_wp
-  erffac = erf(natfac) * 0.25_wp
-  erfscal = 1.0_wp - erffac
-
-  rabc = eaxr * r * erfscal * 1.5_wp
-  return
-end subroutine wallpot_calc
-
-!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-!c
-!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-subroutine getmaxdist(n,xyz,at,dist)
-  use iso_fortran_env,wp => real64
-  implicit none
-  integer :: n
-  integer :: at(n)
-  integer :: i
-  real(wp) :: xyz(3,n)
-  real(wp) :: dist
-  real(wp) :: dum
-  real(wp),allocatable :: rcov(:)
-
-  allocate (rcov(94))
-  call setrcov(rcov)
-  dist = 0.0d0
-
-  do i = 1,n
-    dum = sqrt(xyz(1,i)**2 + xyz(2,i)**2 + xyz(3,i)**2)
-    dum = dum + rcov(at(i))
-    if (dum .gt. dist) dist = dum
-  end do
-
-  deallocate (rcov)
-
-end subroutine getmaxdist
-
-!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-!c
-!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-subroutine dummypot(ellips,xyz,at,nat)
-  use iso_fortran_env,wp => real64
-  use crest_data
-  use strucrd,only:i2e
-  implicit none
-
-  integer :: i
-  integer :: nat,ich
-  integer :: at(nat)
-
-  real(wp) :: xyz(3,nat)
-  real(wp) :: r,dum
-  real(wp) :: ellips(3)
-
-  real(wp) :: point(3)
-
-!---- ellipsoide has to statisfy x²/a² + y²/b² + z²/c² = 1
-
-  call init_random_seed()
-  open (file='wall.coord',newunit=ich)
-  write (ich,'(a)') "$coord"
-
-  do i = 1,nat
-    write (ich,'(3F24.12,5x,a2)') xyz(1:3,i),i2e(at(i))
-  end do
-
-  point = 0.0d0
-  do i = 1,100
-    call random_number(r)
-    point(1) = r * ellips(1)
-    do
-      call random_number(r)
-      point(2) = r * ellips(2)
-      dum = (point(1)**2 / ellips(1)**2)  &
-      &    + (point(2)**2 / ellips(2)**2)
-      if (dum .lt. 1.0d0) exit
-    end do
-    dum = 1.0d0 - (point(1)**2 / ellips(1)**2) - (point(2)**2 / ellips(2)**2)
-    dum = dum * ellips(3)**2
-
-    point(3) = sqrt(dum)
-
-    write (ich,'(3F24.12,5x,a2)') point(1:3),'he'
-    write (ich,'(3F24.12,5x,a2)') - 1 * point(1:3),'he'
-    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),point(2),point(3),'he'
-    write (ich,'(3F24.12,5x,a2)') point(1),-1 * point(2),point(3),'he'
-    write (ich,'(3F24.12,5x,a2)') point(1),point(2),-1 * point(3),'he'
-    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),-1 * point(2),point(3),'he'
-    write (ich,'(3F24.12,5x,a2)') - 1 * point(1),point(2),-1 * point(3),'he'
-    write (ich,'(3F24.12,5x,a2)') point(1),-1 * point(2),-1 * point(3),'he'
-  end do
-
-  write (ich,'(a)') "$end"
-  close (ich)
-end subroutine dummypot
-
-SUBROUTINE init_random_seed()
-  INTEGER :: i,n,clock
-  INTEGER,DIMENSION(:),ALLOCATABLE :: seed
-
-  CALL RANDOM_SEED(size=n)
-  ALLOCATE (seed(n))
-
-  CALL SYSTEM_CLOCK(COUNT=clock)
-
-  seed = clock + 37 * (/(i - 1,i=1,n)/)
-  CALL RANDOM_SEED(PUT=seed)
-
-  DEALLOCATE (seed)
-END SUBROUTINE
-
-!---- set up  a box around the molecule. the return value is the box volume
-function getbox(n,xyz,box)
-  use iso_fortran_env,wp => real64
-  implicit none
-  real(wp) :: getbox
-  integer,intent(in)  :: n
-  real(wp),intent(in) :: xyz(3,n)
-  real(wp),intent(out) :: box(3,3)
-  integer :: i
-  box = 0.0_wp
-  getbox = 1.0_wp
-  do i = 1,3 !i are the X,Y,Z axis
-    box(i,1) = maxval(xyz(i,:))
-    box(i,2) = minval(xyz(i,:))
-    box(i,3) = abs(box(i,1) - box(i,2)) !side length
-    getbox = getbox * box(i,3)          !to volume
-  end do
-  return
-end function getbox
-!---- set up  a box around the molecule. the return value is the box volume
-function getbox2(n,xyz,at,box)
-  use iso_fortran_env,wp => real64
-  implicit none
-  real(wp) :: getbox2
-  integer,intent(in)  :: n
-  real(wp),intent(in) :: xyz(3,n)
-  real(wp),intent(out) :: box(3,3)
-  integer,intent(in) :: at(n)
-  integer :: i
-  real(wp),allocatable :: rcov(:),rat(:)
-  real(wp) :: rcovmax
-  allocate (rcov(94),rat(n))
-  call setrcov(rcov)
-  do i = 1,n
-    rat(i) = rcov(at(i))
-  end do
-  rcovmax = maxval(rat)
-  box = 0.0_wp
-  getbox2 = 1.0_wp
-  do i = 1,3 !i are the X,Y,Z axis
-    box(i,1) = maxval(xyz(i,:))
-    box(i,2) = minval(xyz(i,:))
-    box(i,3) = abs(box(i,1) - box(i,2)) !side length
-    if (box(i,3) .lt. 1d-6) then
-      box(i,1) = rcovmax
-      box(i,2) = -rcovmax
-      box(i,3) = rcovmax * 2.0_wp
-    end if
-    getbox2 = getbox2 * box(i,3)          !to volume
-  end do
-  deallocate (rat,rcov)
-  return
-end function getbox2
-
-!---- get the volume simply as a sum of spherical atom volumes (crude approximation)
-function volsum(n,at)
-  use iso_fortran_env,wp => real64
-  implicit none
-  real(wp) :: volsum
-  integer,intent(in)  :: n
-  integer,intent(in) :: at(n)
-  integer :: i
-  real(wp),allocatable :: rcov(:)
-  real(wp) :: r
-  allocate (rcov(94))
-  !--- D3 radii in Bohr
-  rcov = (/ &
-   &  2.18230009,1.73469996,3.49559999,3.09820008,3.21600008, &
-   &  2.91030002,2.62249994,2.48169994,2.29959989,2.13739991, &
-   &  3.70819998,3.48390007,4.01060009,3.79169989,3.50169992, &
-   &  3.31069994,3.10459995,2.91479993,4.24109983,4.10349989, &
-   &  3.89030004,3.76419997,3.72110009,3.44140005,3.54620004, &
-   &  3.44210005,3.43269992,3.34619999,3.30080009,3.23090005, &
-   &  3.95790005,3.86190009,3.66249990,3.52679992,3.36619997, &
-   &  3.20959997,4.61759996,4.47639990,4.21960020,4.05970001, &
-   &  3.85960007,3.75430012,3.56900001,3.46230006,3.39750004, &
-   &  3.35249996,3.33080006,3.46199989,4.26230001,4.18739986, &
-   &  4.01499987,3.89010000,3.73799992,3.58890009,5.05670023, &
-   &  5.18139982,4.62610006,4.62010002,4.57019997,4.52710009, &
-   &  4.48960018,4.45149994,4.42339993,4.12430000,4.24270010, &
-   &  4.15409994,4.27939987,4.24499989,4.22079992,4.19859982, &
-   &  4.01300001,4.24499989,4.09800005,3.98550010,3.89549994, &
-   &  3.74900007,3.44560003,3.35249996,3.25640011,3.35990000, &
-   &  4.31269979,4.27640009,4.11749983,4.00540018,3.86439991, &
-   &  3.72160006,5.07959986,4.92939997,4.70429993,4.42519999, &
-   &  4.45940018,4.39569998,4.35389996,4.43410015/)
-  volsum = 0.0_wp
-  do i = 1,n
-    r = rcov(at(i))
-    volsum = volsum + (4.0_wp / 3.0_wp) * (3.14159265359_wp * r**3)
-  end do
-  deallocate (rcov)
-  return
-end function volsum
-
Index: subprojects/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## Using CREST subprojects\n\nNewer versions of CREST use external projects:\n\n| Library | Description | Build Option | git submodule |\n| ------- | ----------- | ------------ | :-----------: |\n| [`toml-f`](https://github.com/toml-f/toml-f) | A TOML parser for Fortran | `-DWITH_TOMLF=true` (default) | :white_check_mark: |\n| [`gfn0`](https://github.com/pprcht/gfn0) | A GFN0-xTB standalone library | `-DWITH_GFN0=true` (default) |  :white_check_mark:|\n| [`gfnff`](https://github.com/pprcht/gfnff) | A GFN-FF standalone library | `-DWITH_GFNFF=true` (default) | :white_check_mark: |\n| [`tblite`](https://github.com/tblite/tblite) | A lightweight implementation of the GFN1 and GFN2-xTB Hamiltonians | `-DWITH_TBLITE=true` | :x: |\n\nBoth `cmake` and `meson` should be **able to handle the download automatically** (with meson being a little bit better at this). The build option can be specified in the respective setup step.\n\nHowever, some projects are also set up as `git` submodules (see table) if you want to download the most current commits by hand.\nTo do so, in the CREST main directory use\n```bash\ngit submodule init\ngit submodule update\n```\nwhich should download all the subprojects.\n\nTo update the submodule sources from the respective remote branches\n```bash\ngit submodule update --remote\n```\ncan be used.\n\n---\n\n### `tblite` additional information\nThe [`tblite`](https://github.com/tblite/tblite) subproject is an important exception.\nIt is **not** set up as a `git` submodule, but it could still be downloaded manually.\nTo do so, while in the CREST main directory, use the usual\n```bash\ngit clone https://github.com/tblite/tblite.git subprojects/tblite\n```\nto clone `tblite` to the correct place.\nHowever, to make the build work after downloading, some of the `meson` build instructions of `tblite` must be updated.\nWe have prepared a patch file for this located at [packagefiles/tblite/](./packagefile/tblite/)\nChange to the directory and apply the patches via\n```bash\ncd subprojects/tblite\ngit apply ../packagefile/tblite/tblite_patch.patch\n```\n\nNote that `meson` will download and apply the patch automatically *if you don't download `tblite` yourself*!\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/subprojects/README.md b/subprojects/README.md
--- a/subprojects/README.md	
+++ b/subprojects/README.md	
@@ -4,10 +4,14 @@
 
 | Library | Description | Build Option | git submodule |
 | ------- | ----------- | ------------ | :-----------: |
-| [`toml-f`](https://github.com/toml-f/toml-f) | A TOML parser for Fortran | `-DWITH_TOMLF=true` (default) | :white_check_mark: |
-| [`gfn0`](https://github.com/pprcht/gfn0) | A GFN0-xTB standalone library | `-DWITH_GFN0=true` (default) |  :white_check_mark:|
-| [`gfnff`](https://github.com/pprcht/gfnff) | A GFN-FF standalone library | `-DWITH_GFNFF=true` (default) | :white_check_mark: |
-| [`tblite`](https://github.com/tblite/tblite) | A lightweight implementation of the GFN1 and GFN2-xTB Hamiltonians | `-DWITH_TBLITE=true` | :x: |
+| [`toml-f`](https://github.com/toml-f/toml-f) | A TOML parser for Fortran | `-DWITH_TOMLF=true` (default) | ✅ |
+| [`gfn0`](https://github.com/pprcht/gfn0) | A GFN0-xTB standalone library | `-DWITH_GFN0=true` (default) | ✅ |
+| [`gfnff`](https://github.com/pprcht/gfnff) | A GFN-FF standalone library | `-DWITH_GFNFF=true` (default) | ✅ |
+| [`tblite`](https://github.com/tblite/tblite) | A lightweight implementation of the GFN1 and GFN2-xTB Hamiltonians | `-DWITH_TBLITE=true` (default) | ✅ |
+<!--
+| [`xhcff`](https://github.com/zellerf/xhcff) | Implementation of the XHCFF force field | `-DWITH_XHCFF=true` | ✅ |
+-->
+
 
 Both `cmake` and `meson` should be **able to handle the download automatically** (with meson being a little bit better at this). The build option can be specified in the respective setup step.
 
@@ -17,7 +21,7 @@
 git submodule init
 git submodule update
 ```
-which should download all the subprojects.
+which should check out all the subprojects.
 
 To update the submodule sources from the respective remote branches
 ```bash
@@ -25,22 +29,3 @@
 ```
 can be used.
 
----
-
-### `tblite` additional information
-The [`tblite`](https://github.com/tblite/tblite) subproject is an important exception.
-It is **not** set up as a `git` submodule, but it could still be downloaded manually.
-To do so, while in the CREST main directory, use the usual
-```bash
-git clone https://github.com/tblite/tblite.git subprojects/tblite
-```
-to clone `tblite` to the correct place.
-However, to make the build work after downloading, some of the `meson` build instructions of `tblite` must be updated.
-We have prepared a patch file for this located at [packagefiles/tblite/](./packagefile/tblite/)
-Change to the directory and apply the patches via
-```bash
-cd subprojects/tblite
-git apply ../packagefile/tblite/tblite_patch.patch
-```
-
-Note that `meson` will download and apply the patch automatically *if you don't download `tblite` yourself*!
Index: meson.build
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\nproject(\n  'crest',\n  'fortran', 'c',\n  version: '3.0dev',\n  license: 'LGPL-3.0-or-later',\n  meson_version: '>=0.63',\n  default_options: [\n    'buildtype=release',\n    'default_library=static',\n    'c_link_args=-static',\n    'fortran_link_args=-static',\n  ],\n)\ninstall = not (meson.is_subproject() and get_option('default_library') == 'static')\n\n\n# =================================== #\n## General configuration information ##\n# =================================== #\nexe_deps = []\nsubdir('config')\n\n# create the metadata file with the configured data\nconfigure_file(\n  input: files('assets/template/metadata.f90'),\n  output: 'crest_metadata.fh',\n  configuration : config,\n)\n\n\n# Documentation\n#subdir('docs')\n\n# Collect source of the project\nprog = []\nsrcs = []\nsubdir('src')\n\n\n# Create library target\ncrest_lib = library(\n  meson.project_name(),\n  sources: srcs,\n  dependencies: exe_deps,\n#  include_directories: include_directories('include'),\n)\n\n# Export as dependency\ncrest_inc = crest_lib.private_dir_include()\ncrest_dep = declare_dependency(\n  link_with: crest_lib,\n  include_directories: crest_inc,\n  dependencies: exe_deps,\n)\n\n\n# Create executable target\ncrest_exe = executable(\n  meson.project_name(),\n  sources: prog,\n  dependencies: crest_dep,\n  install: install,\n  link_language: 'fortran',\n)\n\n\n\n# add the testsuite separate meson.build \n#subdir('testsuite') #has to be filled with tests, not availabel yet\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/meson.build b/meson.build
--- a/meson.build	
+++ b/meson.build	
@@ -21,7 +21,7 @@
   license: 'LGPL-3.0-or-later',
   meson_version: '>=0.63',
   default_options: [
-    'buildtype=release',
+    'buildtype=debugoptimized',
     'default_library=static',
     'c_link_args=-static',
     'fortran_link_args=-static',
Index: subprojects/tblite.wrap
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[wrap-git]\ndirectory = tblite\nurl = https://github.com/tblite/tblite\nrevision = head\ndiff_files = tblite/tblite_patch.patch\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/subprojects/tblite.wrap b/subprojects/tblite.wrap
--- a/subprojects/tblite.wrap	
+++ b/subprojects/tblite.wrap	
@@ -2,4 +2,3 @@
 directory = tblite
 url = https://github.com/tblite/tblite
 revision = head
-diff_files = tblite/tblite_patch.patch
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Conformer-Rotamer Ensemble Sampling Tool\n\n[![Latest Version](https://img.shields.io/github/v/release/crest-lab/crest)](https://github.com/crest-lab/crest/releases/latest)\n[![DOI](https://img.shields.io/badge/DOI-10.1039%2Fc9cp06869d%20-blue)](http://dx.doi.org/10.1039/c9cp06869d)\n![example workflow](https://github.com/crest-lab/crest/actions/workflows/build.yml/badge.svg)\n[![License: LGPL v3](https://img.shields.io/badge/License-LGPL_v3-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0)\n\n\nThis is the offical repository of the CREST program developed by the Grimme group in Bonn.\n\nCREST is an extension to the [`xtb`](https://github.com/grimme-lab/xtb) program.\nIt functions as an IO based OMP scheduler (*i.e.*, calculations are\nperformed by the `xtb` program) and tool for the creation and analysation of\nstructure ensembles.\n\n<div align=\"center\">\n<img src=\"./assets/crest.png\" alt=\"CREST\" width=\"200\">\n</div>\n\n\n## Documentation\n\nThe CREST documentation with installation instructions and application examples is hosted at <https://crest-lab.github.io/crest-docs/>.\n\n\n---\n\n## Installation quick guide\n\nFor any installation make sure that you have correctly installed and sourced the [`xtb`](https://github.com/grimme-lab/xtb) program before attempting any calculations with CREST.\n\nThere are multiple possible ways of installing CREST. \nFor building the program from source we recommend the Intel `ifort` and `icc` compilers (tested with the 2021 version).\n\nDetailed build instructions can be found at <https://crest-lab.github.io/crest-docs/page/installation>.\n\nFor builds with subprojects see [here](./subprojects/README.md).\n\n\n### Precompiled binaries\n\nTo use the statically linked binaries (Intel compilers)\nthat can be found at the [release page](https://github.com/crest-lab/crest/releases),\nof this repository.\nThe most recent program version is automatically build (`meson`/`ifort`) from the main branch and can be found at the [continous release page](https://github.com/crest-lab/crest/releases/tag/latest).\nSimply unpack the binary and add it to your *PATH* variable.\n```bash\nunzip crest.zip\n```\nor\n```bash\ntar -xf crest-latest.tar.xz\n```\nThe program should be directly executable.\n\n### Tested builds\nWorking and tested builds of CREST (mostly on Ubuntu 20.04 LTS):\n\n| Build System | Compiler | Linear Algebra Backend | Build type     | Status     |\n|--------------|----------|------------------------|:--------------:|:----------:|\n| CMake | GNU (gcc 10.3.0)  | [OpenBLAS](https://github.com/xianyi/OpenBLAS) (with OpenMP) | dynamic | :white_check_mark: |\n| CMake | GNU (gcc 10.3.0)  |  [MKL shared (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | dynamic | :white_check_mark:\n| Meson | [Intel (`ifort`/`icc` 2021.9.0)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html)   | [MKL static (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | static  | :white_check_mark: |\n| Meson | [Intel (`ifort` 2021.9.0/`icx` 2023.1.0)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html)   | [MKL static (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | static  | :white_check_mark: |\n\n\n\nSome basic build instructions can be found in the following dropdown tabs:\n\n<details open>\n<summary><h4><code>meson</code> build</h4></summary>\n<!-- blank line to recover markdown format-->\n\nFor the setup an configuration of meson see also the [meson setup](https://github.com/grimme-lab/xtb/blob/master/meson/README.adoc) page hosted at the `xtb` repository.\nThe chain of commands to build CREST with meson is:\n\n```bash\nexport FC=ifort CC=icc\nmeson setup _build --prefix=$PWD/_dist\nmeson install -C _build\n```\n\nThe `meson` build of CREST is mainly focused on and tested with the Intel `ifort`/`icc` compilers.\nWhen attempting to build with `gfortran` and `gcc`, add `-Dla_backend=mkl` to the meson setup command. Compatibility with the GNU compilers might be limited, however.\n\nBy default the `meson` build will create a **statically** linked binary.\n</details>\n\n<details>\n<summary><h4><code>cmake</code> build</h4></summary>\n<!-- blank line to recover markdown format-->\n\nFor the setup of CMake see also the [CMake setup](https://github.com/grimme-lab/xtb/blob/master/cmake/README.adoc) page hosted at the `xtb` repository.\nBuilding CREST with CMake works with the following chain of commands:\n```bash\nexport FC=gfortran CC=gcc\ncmake -B _build -DCMAKE_BUILD_TYPE=Release\n```\nand then to build the CREST binary\n```bash\nmake -C _build\n```\n\nThe CMake build of CREST is focused on and tested with the GNU `gfortran`/`gcc` compilers. The Intel compilers could technically be used as well, but in our experience \n\nBy default the `cmake` build will create a **dynamically** linked binary.\n</details>\n\n<details>\n<summary><h4>Conda build</h4></summary>\n<!-- blank line to recover markdown format-->\n\nA [conda-forge](https://github.com/conda-forge) feedstock is maintained at <https://github.com/conda-forge/crest-feedstock>.\n\nInstalling CREST from the `conda-forge` channel can be achieved by adding `conda-forge` to your channels with:\n\n```\nconda config --add channels conda-forge\nconda config --set channel_priority strict\n```\n\nOnce the `conda-forge` channel has been enabled, CREST can be installed with `conda`:\n\n```\nconda install crest\n```\n\nThe confa-forge distribution is based on a CMake/`gfortran` build. \n</details>\n\n\n---\n\n## Citations\n\n1. P. Pracht, F. Bohle, S. Grimme, *Phys. Chem. Chem. Phys.*, **2020**, 22, 7169-7192.\n  DOI: [10.1039/C9CP06869D](https://dx.doi.org/10.1039/C9CP06869D)\n\n2. S. Grimme, *J. Chem. Theory Comput.*, **2019**, 155, 2847-2862.\n  DOI: [10.1021/acs.jctc.9b00143](https://dx.doi.org/10.1021/acs.jctc.9b00143)\n\n3. P. Pracht, S. Grimme, *Chem. Sci.*, **2021**, 12, 6551-6568.\n  DOI: [10.1039/d1sc00621e](https://dx.doi.org/10.1039/d1sc00621e)\n\n4. P. Pracht, C.A. Bauer, S. Grimme, *J. Comput. Chem.*, **2017**, *38*, 2618-2631. \n  DOI: [10.1002/jcc.24922](https://dx.doi.org/10.1002/jcc.24922)\n\n5. S. Spicher, C. Plett, P. Pracht, A. Hansen, S. Grimme,  *J. Chem. Theory Comput.*, **2022**,\n  *18*, 3174-3189. DOI: [10.1021/acs.jctc.2c00239](https://dx.doi.org/10.1021/acs.jctc.2c00239)\n\n6. P. Pracht, C. Bannwarth, *J. Chem. Theory Comput.*, **2022**, *18 (10)*, 6370-6385. DOI: [10.1021/acs.jctc.2c00578](https://dx.doi.org/10.1021/acs.jctc.2c00578)\n\n## License\n\nCREST is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\nCREST is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose. See the GNU Lesser General Public License for more details.\n\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in CREST by you, as defined in the GNU Lesser General Public license, shall be licensed as above, without any additional terms or conditions\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	
+++ b/README.md	
@@ -34,7 +34,11 @@
 
 Detailed build instructions can be found at <https://crest-lab.github.io/crest-docs/page/installation>.
 
-For builds with subprojects see [here](./subprojects/README.md).
+
+
+
+
+
 
 
 ### Precompiled binaries
@@ -58,12 +62,19 @@
 
 | Build System | Compiler | Linear Algebra Backend | Build type     | Status     |
 |--------------|----------|------------------------|:--------------:|:----------:|
-| CMake | GNU (gcc 10.3.0)  | [OpenBLAS](https://github.com/xianyi/OpenBLAS) (with OpenMP) | dynamic | :white_check_mark: |
-| CMake | GNU (gcc 10.3.0)  |  [MKL shared (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | dynamic | :white_check_mark:
-| Meson | [Intel (`ifort`/`icc` 2021.9.0)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html)   | [MKL static (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | static  | :white_check_mark: |
-| Meson | [Intel (`ifort` 2021.9.0/`icx` 2023.1.0)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html)   | [MKL static (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | static  | :white_check_mark: |
+| CMake | GNU (gcc 10.3.0)  | [OpenBLAS](https://github.com/xianyi/OpenBLAS) (with OpenMP) | dynamic | ✅ |
+| CMake | GNU (gcc 10.3.0)  |  [MKL shared (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | dynamic | ✅ |
+| Meson | [Intel (`ifort`/`icc` 2021.9.0)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html)   | [MKL static (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | static  | ✅ |
+| Meson | [Intel (`ifort` 2021.9.0/`icx` 2023.1.0)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html)   | [MKL static (oneAPI 2023.1)](https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html) | static  | ✅ |
 
 
+
+Generally, subprojects should be initialized for the *default* build options, which can be done by 
+```bash
+git submodule init
+git submodule update
+```
+For more information about builds including subprojects see [here](./subprojects/README.md).
 
 Some basic build instructions can be found in the following dropdown tabs:
 
Index: subprojects/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*/\njson-fortran-8.2.5.wrap\ndftd4.wrap\nmstore.wrap\nmulticharge.wrap\ns-dftd3.wrap\ntest-drive.wrap\nmctc-lib.wrap\nxhcff\n\n!gfn0\n!toml-f\n!gfnff\n\n!packagefiles\n!packagefiles/tblite\n!packagefiles/tblite/rm_app_test.patch\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/subprojects/.gitignore b/subprojects/.gitignore
--- a/subprojects/.gitignore	
+++ b/subprojects/.gitignore	
@@ -7,10 +7,12 @@
 test-drive.wrap
 mctc-lib.wrap
 xhcff
+lwoniom
 
 !gfn0
 !toml-f
 !gfnff
+!tblite
 
 !packagefiles
 !packagefiles/tblite
Index: meson_options.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is part of crest.\n# SPDX-Identifier: LGPL-3.0-or-later\n#\n# crest is free software: you can redistribute it and/or modify it under\n# the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# crest is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with crest.  If not, see <https://www.gnu.org/licenses/>.\n\noption(\n  'la_backend',\n  type: 'combo',\n  value: 'mkl-static',\n  yield: true,\n  choices: ['mkl', 'mkl-rt', 'mkl-static', 'openblas', 'netlib', 'custom','none'],\n  description: 'Linear algebra backend for program.',\n)\noption(\n  'custom_libraries',\n  type: 'array',\n  value: [],\n  description: 'libraries to load for custom linear algebra backend',\n)\noption(\n  'openmp',\n  type: 'boolean',\n  value: true,\n  yield: true,\n  description: 'use OpenMP parallelisation',\n)\noption(\n  'WITH_TBLITE',\n  type: 'boolean',\n  value: false,\n  description: 'build with tblite integration',\n)\noption(\n  'WITH_GFN0',\n  type: 'boolean',\n  value: true,\n  description: 'build with GFN0-xTB integration',\n)\noption(\n  'WITH_GFNFF',\n  type: 'boolean',\n  value: true,\n  description: 'build with GFN-FF integration',\n)\noption(\n  'WITH_TOMLF',\n  type: 'boolean',\n  value: true,\n  description: 'build with toml-f integration',\n)\noption(\n  'WITH_XHCFF',\n  type: 'boolean',\n  value: false,\n  description: 'build with XHCFF integration',\n)\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/meson_options.txt b/meson_options.txt
--- a/meson_options.txt	
+++ b/meson_options.txt	
@@ -38,7 +38,7 @@
 option(
   'WITH_TBLITE',
   type: 'boolean',
-  value: false,
+  value: true,
   description: 'build with tblite integration',
 )
 option(
@@ -66,4 +66,10 @@
   description: 'build with XHCFF integration',
 )
 
+option(
+  'WITH_LWONIOM',
+  type: 'boolean',
+  value: false,
+  description: 'build with lwONIOM integration',
+)
 
